{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar _fields = require(\"./fields\");\n\nvar _decorators = require(\"./decorators\");\n\nvar _misc = require(\"./misc\");\n\nvar _features = require(\"./features\");\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst version = _package.default.version.split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\n\nconst versionKey = \"@babel/plugin-class-features/version\";\n\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions\n}) {\n  return {\n    name,\n    manipulateOptions,\n\n    pre() {\n      (0, _features.enableFeature)(this.file, feature, loose);\n\n      if (!this.file.get(versionKey) || this.file.get(versionKey) < version) {\n        this.file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, state) {\n        if (this.file.get(versionKey) !== version) return;\n        (0, _features.verifyUsedFeatures)(path, this.file);\n        const loose = (0, _features.isLoose)(this.file, feature);\n        let constructor;\n        let isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          (0, _features.verifyUsedFeatures)(path, this.file);\n\n          if (path.node.computed) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.node.kind === \"get\") {\n              if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(getName).add(name);\n            } else if (path.node.kind === \"set\") {\n              if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(setName).add(name);\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n\n            if (path.isProperty() || path.isPrivate()) {\n              props.push(path);\n            }\n          }\n\n          if (!isDecorated) isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        }\n\n        if (!props.length && !isDecorated) return;\n        let ref;\n\n        if (path.isClassExpression() || !path.node.id) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = path.node.id;\n        }\n\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, loose, state);\n        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, loose, state);\n        let keysNodes, staticNodes, instanceNodes, wrapClass;\n\n        if (isDecorated) {\n          staticNodes = keysNodes = [];\n          ({\n            instanceNodes,\n            wrapClass\n          } = (0, _decorators.buildDecoratedClass)(ref, path, elements, this.file));\n        } else {\n          keysNodes = (0, _misc.extractComputedKeys)(ref, path, computedPaths, this.file);\n          ({\n            staticNodes,\n            instanceNodes,\n            wrapClass\n          } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, loose));\n        }\n\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            if (isDecorated) return;\n\n            for (const prop of props) {\n              if (prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n\n        path = wrapClass(path);\n        path.insertBefore([...privateNamesNodes, ...keysNodes]);\n        path.insertAfter(staticNodes);\n      },\n\n      PrivateName(path) {\n        if (this.file.get(versionKey) !== version) return;\n        throw path.buildCodeFrameError(`Unknown PrivateName \"${path}\"`);\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (this.file.get(versionKey) !== version) return;\n        const decl = path.get(\"declaration\");\n\n        if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n          if (decl.node.id) {\n            (0, _helperSplitExportDeclaration.default)(path);\n          } else {\n            decl.node.type = \"ClassExpression\";\n          }\n        }\n      }\n\n    }\n  };\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"],"names":["Object","defineProperty","exports","value","createClassFeaturePlugin","enumerable","get","_misc","injectInitialization","_features","FEATURES","_helperFunctionName","_interopRequireDefault","require","_helperSplitExportDeclaration","_fields","_decorators","_package","obj","__esModule","default","version","split","reduce","v","x","versionKey","name","feature","loose","manipulateOptions","pre","enableFeature","file","set","visitor","Class","path","state","verifyUsedFeatures","isLoose","constructor","isDecorated","hasOwnDecorators","node","props","elements","computedPaths","privateNames","Set","body","computed","push","isPrivate","key","id","getName","setName","kind","has","buildCodeFrameError","add","isClassMethod","isProperty","length","ref","isClassExpression","scope","generateUidIdentifier","privateNamesMap","buildPrivateNamesMap","privateNamesNodes","buildPrivateNamesNodes","transformPrivateNamesUsage","keysNodes","staticNodes","instanceNodes","wrapClass","buildDecoratedClass","extractComputedKeys","buildFieldsInitNodes","superClass","referenceVisitor","prop","static","traverse","insertBefore","insertAfter","PrivateName","ExportDefaultDeclaration","decl","isClassDeclaration","hasDecorators","type"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar _fields = require(\"./fields\");\n\nvar _decorators = require(\"./decorators\");\n\nvar _misc = require(\"./misc\");\n\nvar _features = require(\"./features\");\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst version = _package.default.version.split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\n\nconst versionKey = \"@babel/plugin-class-features/version\";\n\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions\n}) {\n  return {\n    name,\n    manipulateOptions,\n\n    pre() {\n      (0, _features.enableFeature)(this.file, feature, loose);\n\n      if (!this.file.get(versionKey) || this.file.get(versionKey) < version) {\n        this.file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, state) {\n        if (this.file.get(versionKey) !== version) return;\n        (0, _features.verifyUsedFeatures)(path, this.file);\n        const loose = (0, _features.isLoose)(this.file, feature);\n        let constructor;\n        let isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          (0, _features.verifyUsedFeatures)(path, this.file);\n\n          if (path.node.computed) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.node.kind === \"get\") {\n              if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(getName).add(name);\n            } else if (path.node.kind === \"set\") {\n              if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(setName).add(name);\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n\n            if (path.isProperty() || path.isPrivate()) {\n              props.push(path);\n            }\n          }\n\n          if (!isDecorated) isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        }\n\n        if (!props.length && !isDecorated) return;\n        let ref;\n\n        if (path.isClassExpression() || !path.node.id) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = path.node.id;\n        }\n\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, loose, state);\n        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, loose, state);\n        let keysNodes, staticNodes, instanceNodes, wrapClass;\n\n        if (isDecorated) {\n          staticNodes = keysNodes = [];\n          ({\n            instanceNodes,\n            wrapClass\n          } = (0, _decorators.buildDecoratedClass)(ref, path, elements, this.file));\n        } else {\n          keysNodes = (0, _misc.extractComputedKeys)(ref, path, computedPaths, this.file);\n          ({\n            staticNodes,\n            instanceNodes,\n            wrapClass\n          } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, loose));\n        }\n\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            if (isDecorated) return;\n\n            for (const prop of props) {\n              if (prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n\n        path = wrapClass(path);\n        path.insertBefore([...privateNamesNodes, ...keysNodes]);\n        path.insertAfter(staticNodes);\n      },\n\n      PrivateName(path) {\n        if (this.file.get(versionKey) !== version) return;\n        throw path.buildCodeFrameError(`Unknown PrivateName \"${path}\"`);\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (this.file.get(versionKey) !== version) return;\n        const decl = path.get(\"declaration\");\n\n        if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n          if (decl.node.id) {\n            (0, _helperSplitExportDeclaration.default)(path);\n          } else {\n            decl.node.type = \"ClassExpression\";\n          }\n        }\n      }\n\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}