{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar ts = _interopRequireWildcard(require(\"./typescript\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    const isPrivate = prop.isPrivate();\n    const isMethod = !prop.isProperty();\n    const isInstance = !prop.node.static;\n\n    if (isPrivate) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: !isInstance,\n        method: isMethod\n      };\n\n      if (prop.node.kind === \"get\") {\n        update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n      } else if (prop.node.kind === \"set\") {\n        update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n      } else if (prop.node.kind === \"method\") {\n        update.methodId = prop.scope.generateUidIdentifier(name);\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, loose, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    if (loose) {\n      initNodes.push(_core.template.statement.ast`\n          var ${id} = ${state.addHelper(\"classPrivateFieldLooseKey\")}(\"${name}\")\n        `);\n    } else if (isMethod && !isStatic) {\n      if (isAccessor) {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n      } else {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakSet();`);\n      }\n    } else if (!isStatic) {\n      initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n    }\n  }\n\n  return initNodes;\n}\n\nfunction privateNameVisitorFactory(visitor) {\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      if (!redeclared.length) {\n        return;\n      }\n\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n\n  });\n\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor]);\n\n  return privateNameVisitor;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath);\n  }\n\n});\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!path.get(\"left\").isPrivateName()) return;\n    const {\n      loose,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    if (loose) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${id})\n      `);\n      return;\n    }\n\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(_core.template.expression.ast`${id}.has(${right})`);\n  }\n\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodSet\"), []);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id\n    } = privateNamesMap.get(name);\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: object,\n      PROP: privateNamesMap.get(name).id\n    });\n  },\n\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = loose ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    loose\n  });\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`${id}.set(${ref}, {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ${value},\n  })`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${id.name} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${id} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n\n  return _core.template.statement.ast`${id}.add(${ref})`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, loose = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n\n  const methodValue = _core.types.functionExpression(methodId, params, body, generator, async);\n\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(getId, methodValue)]);\n  }\n\n  if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(setId, methodValue)]);\n  }\n\n  if (isStatic && !loose) {\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.functionExpression(id, params, body, generator, async))]);\n  }\n\n  return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(methodId, methodValue)]);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nfunction replaceThisContext(path, ref, superRef, file, loose) {\n  const state = {\n    classRef: ref,\n    needsClassRef: false\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    isLoose: loose,\n    superRef,\n    file,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {\n  const staticNodes = [];\n  const instanceNodes = [];\n  let needsClassRef = false;\n\n  for (const prop of props) {\n    ts.assertFieldTransformed(prop);\n    const isStatic = prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n\n    if (isStatic || isMethod && isPrivate) {\n      const replaced = replaceThisContext(prop, ref, superRef, state, loose);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStatic && isPrivate && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n        break;\n\n      case isStatic && isPublic && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && loose:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !loose:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isMethod && loose:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPrivate && isMethod && !loose:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPublic && isField && loose:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !loose:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"],"names":["Object","defineProperty","exports","value","buildPrivateNamesMap","buildPrivateNamesNodes","transformPrivateNamesUsage","buildFieldsInitNodes","_core","require","_helperReplaceSupers","_interopRequireWildcard","_helperMemberExpressionToFunctions","_interopRequireDefault","_helperOptimiseCallExpression","ts","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","props","privateNamesMap","Map","prop","isPrivate","isMethod","isProperty","isInstance","node","static","name","id","update","scope","generateUidIdentifier","method","kind","getId","setId","methodId","loose","state","initNodes","isStatic","isAccessor","push","template","statement","ast","addHelper","privateNameVisitorFactory","visitor","privateNameVisitor","assign","Class","path","body","visiblePrivateNames","redeclared","delete","length","traverse","nestedVisitor","skipKey","visitors","merge","environmentVisitor","PrivateName","parentPath","isMemberExpression","property","isOptionalMemberExpression","includes","handle","privateInVisitor","BinaryExpression","operator","left","right","isPrivateName","replaceWith","expression","classRef","privateNameHandlerSpec","memoise","member","count","object","memo","maybeGenerateMemoised","memoiser","receiver","types","cloneNode","file","helperName","callExpression","boundGet","memberExpression","identifier","destructureSet","args","optionalCall","privateNameHandlerLoose","BASE","REF","PROP","simpleSet","optionalCallExpression","ref","size","handler","buildPrivateFieldInitLoose","buildUndefinedNode","buildPrivateInstanceFieldInitSpec","buildPrivateStaticFieldInitSpec","privateName","initAdded","buildPrivateMethodInitLoose","buildPrivateInstanceMethodInitSpec","buildPublicFieldInitLoose","computed","expressionStatement","assignmentExpression","isLiteral","buildPublicFieldInitSpec","stringLiteral","buildPrivateStaticMethodInitLoose","buildPrivateMethodDeclaration","getterDeclared","setterDeclared","params","generator","async","methodValue","functionExpression","isGetter","isSetter","variableDeclaration","variableDeclarator","thisContextVisitor","ThisExpression","needsClassRef","replaceThisContext","superRef","replacer","methodPath","isLoose","getObjectRef","replace","staticNodes","instanceNodes","assertFieldTransformed","isPublic","isField","replaced","thisExpression","unshift","Error","filter","Boolean","wrapClass","remove","isClassExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar ts = _interopRequireWildcard(require(\"./typescript\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    const isPrivate = prop.isPrivate();\n    const isMethod = !prop.isProperty();\n    const isInstance = !prop.node.static;\n\n    if (isPrivate) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: !isInstance,\n        method: isMethod\n      };\n\n      if (prop.node.kind === \"get\") {\n        update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n      } else if (prop.node.kind === \"set\") {\n        update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n      } else if (prop.node.kind === \"method\") {\n        update.methodId = prop.scope.generateUidIdentifier(name);\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, loose, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    if (loose) {\n      initNodes.push(_core.template.statement.ast`\n          var ${id} = ${state.addHelper(\"classPrivateFieldLooseKey\")}(\"${name}\")\n        `);\n    } else if (isMethod && !isStatic) {\n      if (isAccessor) {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n      } else {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakSet();`);\n      }\n    } else if (!isStatic) {\n      initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n    }\n  }\n\n  return initNodes;\n}\n\nfunction privateNameVisitorFactory(visitor) {\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      if (!redeclared.length) {\n        return;\n      }\n\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n\n  });\n\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor]);\n\n  return privateNameVisitor;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath);\n  }\n\n});\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!path.get(\"left\").isPrivateName()) return;\n    const {\n      loose,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    if (loose) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${id})\n      `);\n      return;\n    }\n\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(_core.template.expression.ast`${id}.has(${right})`);\n  }\n\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodSet\"), []);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id\n    } = privateNamesMap.get(name);\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: object,\n      PROP: privateNamesMap.get(name).id\n    });\n  },\n\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = loose ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    loose\n  });\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`${id}.set(${ref}, {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ${value},\n  })`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${id.name} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${id} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n\n  return _core.template.statement.ast`${id}.add(${ref})`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, loose = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n\n  const methodValue = _core.types.functionExpression(methodId, params, body, generator, async);\n\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(getId, methodValue)]);\n  }\n\n  if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(setId, methodValue)]);\n  }\n\n  if (isStatic && !loose) {\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.functionExpression(id, params, body, generator, async))]);\n  }\n\n  return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(methodId, methodValue)]);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nfunction replaceThisContext(path, ref, superRef, file, loose) {\n  const state = {\n    classRef: ref,\n    needsClassRef: false\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    isLoose: loose,\n    superRef,\n    file,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {\n  const staticNodes = [];\n  const instanceNodes = [];\n  let needsClassRef = false;\n\n  for (const prop of props) {\n    ts.assertFieldTransformed(prop);\n    const isStatic = prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n\n    if (isStatic || isMethod && isPrivate) {\n      const replaced = replaceThisContext(prop, ref, superRef, state, loose);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStatic && isPrivate && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n        break;\n\n      case isStatic && isPublic && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && loose:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !loose:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isMethod && loose:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPrivate && isMethod && !loose:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPublic && isField && loose:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !loose:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}"]},"metadata":{},"sourceType":"script"}