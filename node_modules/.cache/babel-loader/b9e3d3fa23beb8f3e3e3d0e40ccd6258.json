{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasOwnDecorators = hasOwnDecorators;\nexports.hasDecorators = hasDecorators;\nexports.buildDecoratedClass = buildDecoratedClass;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireDefault(require(\"@babel/helper-replace-supers\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction hasOwnDecorators(node) {\n  return !!(node.decorators && node.decorators.length);\n}\n\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\n\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\n\nfunction takeDecorators(node) {\n  let result;\n\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n\n  node.decorators = undefined;\n  return result;\n}\n\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\n\nfunction extractElementDescriptor(classRef, superRef, path) {\n  const {\n    node,\n    scope\n  } = path;\n  const isMethod = path.isClassMethod();\n\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n\n  new _helperReplaceSupers.default({\n    methodPath: path,\n    methodNode: node,\n    objectRef: classRef,\n    isStatic: node.static,\n    superRef,\n    scope,\n    file: this\n  }, true).replace();\n  const properties = [prop(\"kind\", _core.types.stringLiteral(isMethod ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n\n  if (isMethod) {\n    const id = node.computed ? null : node.key;\n\n    _core.types.toExpression(node);\n\n    properties.push(prop(\"value\", (0, _helperFunctionName.default)({\n      node,\n      id,\n      scope\n    }) || node));\n  } else if (node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file) {\n  try {\n    return file.addHelper(\"decorate\");\n  } catch (err) {\n    if (err.code === \"BABEL_HELPER_UNKNOWN\") {\n      err.message += \"\\n  '@babel/plugin-transform-decorators' in non-legacy mode\" + \" requires '@babel/core' version ^7.0.2 and you appear to be using\" + \" an older version.\";\n    }\n\n    throw err;\n  }\n}\n\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract).map(extractElementDescriptor.bind(file, node.id, superId)));\n\n  let replacement = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? superId : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n  let classPathDesc = \"arguments.1.body.body.0\";\n\n  if (!isStrict) {\n    replacement.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n\n  if (isDeclaration) {\n    replacement = _core.template.ast`let ${ref} = ${replacement}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [_core.template.statement.ast`${initializeId}(this)`],\n\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n\n  };\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"],"names":["Object","defineProperty","exports","value","hasOwnDecorators","hasDecorators","buildDecoratedClass","_core","require","_helperReplaceSupers","_interopRequireDefault","_helperFunctionName","obj","__esModule","default","node","decorators","length","body","some","prop","key","types","objectProperty","identifier","method","objectMethod","blockStatement","takeDecorators","result","arrayExpression","map","decorator","expression","undefined","getKey","computed","isIdentifier","stringLiteral","name","String","extractElementDescriptor","classRef","superRef","path","scope","isMethod","isClassMethod","isPrivate","buildCodeFrameError","methodPath","methodNode","objectRef","isStatic","static","file","replace","properties","kind","booleanLiteral","filter","Boolean","id","toExpression","push","template","statements","ast","buildUndefinedNode","remove","objectExpression","addDecorateHelper","addHelper","err","code","message","ref","elements","initializeId","generateUidIdentifier","isDeclaration","isStrict","isInStrictMode","superClass","type","cloneNode","superId","generateUidIdentifierBasedOnNode","classDecorators","definitions","element","abstract","bind","replacement","nullLiteral","classPathDesc","arguments","directives","directive","directiveLiteral","instanceNodes","statement","wrapClass","replaceWith","get"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasOwnDecorators = hasOwnDecorators;\nexports.hasDecorators = hasDecorators;\nexports.buildDecoratedClass = buildDecoratedClass;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireDefault(require(\"@babel/helper-replace-supers\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasOwnDecorators(node) {\n  return !!(node.decorators && node.decorators.length);\n}\n\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\n\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\n\nfunction takeDecorators(node) {\n  let result;\n\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n\n  node.decorators = undefined;\n  return result;\n}\n\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\n\nfunction extractElementDescriptor(classRef, superRef, path) {\n  const {\n    node,\n    scope\n  } = path;\n  const isMethod = path.isClassMethod();\n\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n\n  new _helperReplaceSupers.default({\n    methodPath: path,\n    methodNode: node,\n    objectRef: classRef,\n    isStatic: node.static,\n    superRef,\n    scope,\n    file: this\n  }, true).replace();\n  const properties = [prop(\"kind\", _core.types.stringLiteral(isMethod ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n\n  if (isMethod) {\n    const id = node.computed ? null : node.key;\n\n    _core.types.toExpression(node);\n\n    properties.push(prop(\"value\", (0, _helperFunctionName.default)({\n      node,\n      id,\n      scope\n    }) || node));\n  } else if (node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file) {\n  try {\n    return file.addHelper(\"decorate\");\n  } catch (err) {\n    if (err.code === \"BABEL_HELPER_UNKNOWN\") {\n      err.message += \"\\n  '@babel/plugin-transform-decorators' in non-legacy mode\" + \" requires '@babel/core' version ^7.0.2 and you appear to be using\" + \" an older version.\";\n    }\n\n    throw err;\n  }\n}\n\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract).map(extractElementDescriptor.bind(file, node.id, superId)));\n\n  let replacement = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? superId : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n  let classPathDesc = \"arguments.1.body.body.0\";\n\n  if (!isStrict) {\n    replacement.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n\n  if (isDeclaration) {\n    replacement = _core.template.ast`let ${ref} = ${replacement}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [_core.template.statement.ast`${initializeId}(this)`],\n\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n\n  };\n}"]},"metadata":{},"sourceType":"script"}