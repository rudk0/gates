{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = replaceShorthandObjectMethod;\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\n\n\nfunction replaceShorthandObjectMethod(path) {\n  var t = util.getTypes();\n\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  } // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n\n\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  } // this function only replaces generators.\n\n\n  if (!path.node.generator) {\n    return path;\n  }\n\n  var parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  });\n  var functionExpression = t.functionExpression(null, // id\n  parameters, // params\n  t.cloneDeep(path.node.body), // body\n  path.node.generator, path.node.async);\n  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), // key\n  functionExpression, //value\n  path.node.computed, // computed\n  false // shorthand\n  )); // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n\n  return path.get(\"value\");\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/regenerator-transform/lib/replaceShorthandObjectMethod.js"],"names":["_interopRequireWildcard","require","exports","__esModule","replaceShorthandObjectMethod","util","path","t","getTypes","node","isFunction","Error","isObjectMethod","generator","parameters","params","map","param","cloneDeep","functionExpression","body","async","replaceWithOrRemove","objectProperty","key","computed","get"],"mappings":"AAAA;;AAEA,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAAD,CAArC;;AAEAC,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,4BAArB;;AAEA,IAAIC,IAAI,GAAGL,uBAAuB,CAACC,OAAO,CAAC,QAAD,CAAR,CAAlC;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,4BAAT,CAAsCE,IAAtC,EAA4C;AAC1C,MAAIC,CAAC,GAAGF,IAAI,CAACG,QAAL,EAAR;;AAEA,MAAI,CAACF,IAAI,CAACG,IAAN,IAAc,CAACF,CAAC,CAACG,UAAF,CAAaJ,IAAI,CAACG,IAAlB,CAAnB,EAA4C;AAC1C,UAAM,IAAIE,KAAJ,CAAU,6EAAV,CAAN;AACD,GALyC,CAKxC;AACF;;;AAGA,MAAI,CAACJ,CAAC,CAACK,cAAF,CAAiBN,IAAI,CAACG,IAAtB,CAAL,EAAkC;AAChC,WAAOH,IAAP;AACD,GAXyC,CAWxC;;;AAGF,MAAI,CAACA,IAAI,CAACG,IAAL,CAAUI,SAAf,EAA0B;AACxB,WAAOP,IAAP;AACD;;AAED,MAAIQ,UAAU,GAAGR,IAAI,CAACG,IAAL,CAAUM,MAAV,CAAiBC,GAAjB,CAAqB,UAAUC,KAAV,EAAiB;AACrD,WAAOV,CAAC,CAACW,SAAF,CAAYD,KAAZ,CAAP;AACD,GAFgB,CAAjB;AAGA,MAAIE,kBAAkB,GAAGZ,CAAC,CAACY,kBAAF,CAAqB,IAArB,EAA2B;AACpDL,EAAAA,UADyB,EACb;AACZP,EAAAA,CAAC,CAACW,SAAF,CAAYZ,IAAI,CAACG,IAAL,CAAUW,IAAtB,CAFyB,EAEI;AAC7Bd,EAAAA,IAAI,CAACG,IAAL,CAAUI,SAHe,EAGJP,IAAI,CAACG,IAAL,CAAUY,KAHN,CAAzB;AAIAhB,EAAAA,IAAI,CAACiB,mBAAL,CAAyBhB,IAAzB,EAA+BC,CAAC,CAACgB,cAAF,CAAiBhB,CAAC,CAACW,SAAF,CAAYZ,IAAI,CAACG,IAAL,CAAUe,GAAtB,CAAjB,EAA6C;AAC5EL,EAAAA,kBAD+B,EACX;AACpBb,EAAAA,IAAI,CAACG,IAAL,CAAUgB,QAFqB,EAEX;AACpB,OAH+B,CAGzB;AAHyB,GAA/B,EAzB0C,CA6BtC;AACJ;AACA;AACA;;AAEA,SAAOnB,IAAI,CAACoB,GAAL,CAAS,OAAT,CAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = replaceShorthandObjectMethod;\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\nfunction replaceShorthandObjectMethod(path) {\n  var t = util.getTypes();\n\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  } // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n\n\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  } // this function only replaces generators.\n\n\n  if (!path.node.generator) {\n    return path;\n  }\n\n  var parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  });\n  var functionExpression = t.functionExpression(null, // id\n  parameters, // params\n  t.cloneDeep(path.node.body), // body\n  path.node.generator, path.node.async);\n  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), // key\n  functionExpression, //value\n  path.node.computed, // computed\n  false // shorthand\n  )); // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n\n  return path.get(\"value\");\n}"]},"metadata":{},"sourceType":"script"}