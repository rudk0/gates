{"ast":null,"code":"import { extname, sep, resolve, posix } from 'path';\nimport pm from 'picomatch';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n  let result = `${filename}`;\n  if (!extname(filename)) result += ext;\n  return result;\n};\n\nfunction walk(ast, {\n  enter,\n  leave\n}) {\n  return visit(ast, null, enter, leave);\n}\n\nlet should_skip = false;\nlet should_remove = false;\nlet replacement = null;\nconst context = {\n  skip: () => should_skip = true,\n  remove: () => should_remove = true,\n  replace: node => replacement = node\n};\n\nfunction replace(parent, prop, index, node) {\n  if (parent) {\n    if (index !== null) {\n      parent[prop][index] = node;\n    } else {\n      parent[prop] = node;\n    }\n  }\n}\n\nfunction remove(parent, prop, index) {\n  if (parent) {\n    if (index !== null) {\n      parent[prop].splice(index, 1);\n    } else {\n      delete parent[prop];\n    }\n  }\n}\n\nfunction visit(node, parent, enter, leave, prop, index) {\n  if (node) {\n    if (enter) {\n      const _should_skip = should_skip;\n      const _should_remove = should_remove;\n      const _replacement = replacement;\n      should_skip = false;\n      should_remove = false;\n      replacement = null;\n      enter.call(context, node, parent, prop, index);\n\n      if (replacement) {\n        node = replacement;\n        replace(parent, prop, index, node);\n      }\n\n      if (should_remove) {\n        remove(parent, prop, index);\n      }\n\n      const skipped = should_skip;\n      const removed = should_remove;\n      should_skip = _should_skip;\n      should_remove = _should_remove;\n      replacement = _replacement;\n      if (skipped) return node;\n      if (removed) return null;\n    }\n\n    for (const key in node) {\n      const value = node[key];\n\n      if (typeof value !== 'object') {\n        continue;\n      } else if (Array.isArray(value)) {\n        for (let j = 0, k = 0; j < value.length; j += 1, k += 1) {\n          if (value[j] !== null && typeof value[j].type === 'string') {\n            if (!visit(value[j], node, enter, leave, key, k)) {\n              // removed\n              j--;\n            }\n          }\n        }\n      } else if (value !== null && typeof value.type === 'string') {\n        visit(value, node, enter, leave, key, null);\n      }\n    }\n\n    if (leave) {\n      const _replacement = replacement;\n      const _should_remove = should_remove;\n      replacement = null;\n      should_remove = false;\n      leave.call(context, node, parent, prop, index);\n\n      if (replacement) {\n        node = replacement;\n        replace(parent, prop, index, node);\n      }\n\n      if (should_remove) {\n        remove(parent, prop, index);\n      }\n\n      const removed = should_remove;\n      replacement = _replacement;\n      should_remove = _should_remove;\n      if (removed) return null;\n    }\n  }\n\n  return node;\n}\n\nconst extractors = {\n  ArrayPattern(names, param) {\n    for (const element of param.elements) {\n      if (element) extractors[element.type](names, element);\n    }\n  },\n\n  AssignmentPattern(names, param) {\n    extractors[param.left.type](names, param.left);\n  },\n\n  Identifier(names, param) {\n    names.push(param.name);\n  },\n\n  MemberExpression() {},\n\n  ObjectPattern(names, param) {\n    for (const prop of param.properties) {\n      // @ts-ignore Typescript reports that this is not a valid type\n      if (prop.type === 'RestElement') {\n        extractors.RestElement(names, prop);\n      } else {\n        extractors[prop.value.type](names, prop.value);\n      }\n    }\n  },\n\n  RestElement(names, param) {\n    extractors[param.argument.type](names, param.argument);\n  }\n\n};\n\nconst extractAssignedNames = function extractAssignedNames(param) {\n  const names = [];\n  extractors[param.type](names, param);\n  return names;\n};\n\nconst blockDeclarations = {\n  const: true,\n  let: true\n};\n\nclass Scope {\n  constructor(options = {}) {\n    this.parent = options.parent;\n    this.isBlockScope = !!options.block;\n    this.declarations = Object.create(null);\n\n    if (options.params) {\n      options.params.forEach(param => {\n        extractAssignedNames(param).forEach(name => {\n          this.declarations[name] = true;\n        });\n      });\n    }\n  }\n\n  addDeclaration(node, isBlockDeclaration, isVar) {\n    if (!isBlockDeclaration && this.isBlockScope) {\n      // it's a `var` or function node, and this\n      // is a block scope, so we need to go up\n      this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n    } else if (node.id) {\n      extractAssignedNames(node.id).forEach(name => {\n        this.declarations[name] = true;\n      });\n    }\n  }\n\n  contains(name) {\n    return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n  }\n\n}\n\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n  let scope = new Scope();\n  walk(ast, {\n    enter(n, parent) {\n      const node = n; // function foo () {...}\n      // class Foo {...}\n\n      if (/(Function|Class)Declaration/.test(node.type)) {\n        scope.addDeclaration(node, false, false);\n      } // var foo = 1\n\n\n      if (node.type === 'VariableDeclaration') {\n        const {\n          kind\n        } = node;\n        const isBlockDeclaration = blockDeclarations[kind]; // don't add const/let declarations in the body of a for loop #113\n\n        const parentType = parent ? parent.type : '';\n\n        if (!(isBlockDeclaration && /ForOfStatement/.test(parentType))) {\n          node.declarations.forEach(declaration => {\n            scope.addDeclaration(declaration, isBlockDeclaration, true);\n          });\n        }\n      }\n\n      let newScope; // create new function scope\n\n      if (/Function/.test(node.type)) {\n        const func = node;\n        newScope = new Scope({\n          parent: scope,\n          block: false,\n          params: func.params\n        }); // named function expressions - the name is considered\n        // part of the function's scope\n\n        if (func.type === 'FunctionExpression' && func.id) {\n          newScope.addDeclaration(func, false, false);\n        }\n      } // create new block scope\n\n\n      if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n        newScope = new Scope({\n          parent: scope,\n          block: true\n        });\n      } // catch clause has its own block scope\n\n\n      if (node.type === 'CatchClause') {\n        newScope = new Scope({\n          parent: scope,\n          params: node.param ? [node.param] : [],\n          block: true\n        });\n      }\n\n      if (newScope) {\n        Object.defineProperty(node, propertyName, {\n          value: newScope,\n          configurable: true\n        });\n        scope = newScope;\n      }\n    },\n\n    leave(n) {\n      const node = n;\n      if (node[propertyName]) scope = scope.parent;\n    }\n\n  });\n  return scope;\n}; // Helper since Typescript can't detect readonly arrays with Array.isArray\n\n\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\n\nfunction ensureArray(thing) {\n  if (isArray(thing)) return thing;\n  if (thing == null) return [];\n  return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n  if (resolutionBase === false) {\n    return id;\n  } // resolve('') is valid and will default to process.cwd()\n\n\n  const basePath = resolve(resolutionBase || '').split(sep).join('/') // escape all possible (posix + win) path characters that might interfere with regex\n  .replace(/[-^$*+?.()|[\\]{}]/g, '\\\\$&'); // Note that we use posix.join because:\n  // 1. the basePath has been normalized to use /\n  // 2. the incoming glob (id) matcher, also uses /\n  // otherwise Node will force backslash (\\) on windows\n\n  return posix.join(basePath, id);\n}\n\nconst createFilter = function createFilter(include, exclude, options) {\n  const resolutionBase = options && options.resolve;\n\n  const getMatcher = id => id instanceof RegExp ? id : {\n    test: what => {\n      // this refactor is a tad overly verbose but makes for easy debugging\n      const pattern = getMatcherString(id, resolutionBase);\n      const fn = pm(pattern, {\n        dot: true\n      });\n      const result = fn(what);\n      return result;\n    }\n  };\n\n  const includeMatchers = ensureArray(include).map(getMatcher);\n  const excludeMatchers = ensureArray(exclude).map(getMatcher);\n  return function result(id) {\n    if (typeof id !== 'string') return false;\n    if (/\\0/.test(id)) return false;\n    const pathId = id.split(sep).join('/');\n\n    for (let i = 0; i < excludeMatchers.length; ++i) {\n      const matcher = excludeMatchers[i];\n      if (matcher.test(pathId)) return false;\n    }\n\n    for (let i = 0; i < includeMatchers.length; ++i) {\n      const matcher = includeMatchers[i];\n      if (matcher.test(pathId)) return true;\n    }\n\n    return !includeMatchers.length;\n  };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\n\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n  let identifier = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, '_');\n\n  if (/\\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {\n    identifier = `_${identifier}`;\n  }\n\n  return identifier || '_';\n};\n\nfunction stringify(obj) {\n  return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, char => `\\\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);\n}\n\nfunction serializeArray(arr, indent, baseIndent) {\n  let output = '[';\n  const separator = indent ? `\\n${baseIndent}${indent}` : '';\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = arr[i];\n    output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n  }\n\n  return `${output}${indent ? `\\n${baseIndent}` : ''}]`;\n}\n\nfunction serializeObject(obj, indent, baseIndent) {\n  let output = '{';\n  const separator = indent ? `\\n${baseIndent}${indent}` : '';\n  const entries = Object.entries(obj);\n\n  for (let i = 0; i < entries.length; i++) {\n    const [key, value] = entries[i];\n    const stringKey = makeLegalIdentifier(key) === key ? key : stringify(key);\n    output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(value, indent, baseIndent + indent)}`;\n  }\n\n  return `${output}${indent ? `\\n${baseIndent}` : ''}}`;\n}\n\nfunction serialize(obj, indent, baseIndent) {\n  if (obj === Infinity) return 'Infinity';\n  if (obj === -Infinity) return '-Infinity';\n  if (obj === 0 && 1 / obj === -Infinity) return '-0';\n  if (obj instanceof Date) return `new Date(${obj.getTime()})`;\n  if (obj instanceof RegExp) return obj.toString();\n  if (obj !== obj) return 'NaN'; // eslint-disable-line no-self-compare\n\n  if (Array.isArray(obj)) return serializeArray(obj, indent, baseIndent);\n  if (obj === null) return 'null';\n  if (typeof obj === 'object') return serializeObject(obj, indent, baseIndent);\n  return stringify(obj);\n}\n\nconst dataToEsm = function dataToEsm(data, options = {}) {\n  const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n\n  const _ = options.compact ? '' : ' ';\n\n  const n = options.compact ? '' : '\\n';\n  const declarationType = options.preferConst ? 'const' : 'var';\n\n  if (options.namedExports === false || typeof data !== 'object' || Array.isArray(data) || data instanceof Date || data instanceof RegExp || data === null) {\n    const code = serialize(data, options.compact ? null : t, '');\n    const magic = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape\n\n    return `export default${magic}${code};`;\n  }\n\n  let namedExportCode = '';\n  const defaultExportRows = [];\n\n  for (const [key, value] of Object.entries(data)) {\n    if (key === makeLegalIdentifier(key)) {\n      if (options.objectShorthand) defaultExportRows.push(key);else defaultExportRows.push(`${key}:${_}${key}`);\n      namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;\n    } else {\n      defaultExportRows.push(`${stringify(key)}:${_}${serialize(value, options.compact ? null : t, '')}`);\n    }\n  }\n\n  return `${namedExportCode}export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;\n}; // TODO: remove this in next major\n\n\nvar index = {\n  addExtension,\n  attachScopes,\n  createFilter,\n  dataToEsm,\n  extractAssignedNames,\n  makeLegalIdentifier\n};\nexport default index;\nexport { addExtension, attachScopes, createFilter, dataToEsm, extractAssignedNames, makeLegalIdentifier };","map":{"version":3,"sources":["/home/agatha/open/node_modules/@rollup/pluginutils/dist/es/index.js"],"names":["extname","sep","resolve","posix","pm","addExtension","filename","ext","result","walk","ast","enter","leave","visit","should_skip","should_remove","replacement","context","skip","remove","replace","node","parent","prop","index","splice","_should_skip","_should_remove","_replacement","call","skipped","removed","key","value","Array","isArray","j","k","length","type","extractors","ArrayPattern","names","param","element","elements","AssignmentPattern","left","Identifier","push","name","MemberExpression","ObjectPattern","properties","RestElement","argument","extractAssignedNames","blockDeclarations","const","let","Scope","constructor","options","isBlockScope","block","declarations","Object","create","params","forEach","addDeclaration","isBlockDeclaration","isVar","id","contains","attachScopes","propertyName","scope","n","test","kind","parentType","declaration","newScope","func","defineProperty","configurable","arg","ensureArray","thing","getMatcherString","resolutionBase","basePath","split","join","createFilter","include","exclude","getMatcher","RegExp","what","pattern","fn","dot","includeMatchers","map","excludeMatchers","pathId","i","matcher","reservedWords","builtins","forbiddenIdentifiers","Set","add","makeLegalIdentifier","str","identifier","_","letter","toUpperCase","has","stringify","obj","JSON","char","charCodeAt","toString","slice","serializeArray","arr","indent","baseIndent","output","separator","serialize","serializeObject","entries","stringKey","Infinity","Date","getTime","dataToEsm","data","t","compact","declarationType","preferConst","namedExports","code","magic","namedExportCode","defaultExportRows","objectShorthand"],"mappings":"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","sourcesContent":["import { extname, sep, resolve, posix } from 'path';\nimport pm from 'picomatch';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n    let result = `${filename}`;\n    if (!extname(filename))\n        result += ext;\n    return result;\n};\n\nfunction walk(ast, { enter, leave }) {\n\treturn visit(ast, null, enter, leave);\n}\n\nlet should_skip = false;\nlet should_remove = false;\nlet replacement = null;\nconst context = {\n\tskip: () => should_skip = true,\n\tremove: () => should_remove = true,\n\treplace: (node) => replacement = node\n};\n\nfunction replace(parent, prop, index, node) {\n\tif (parent) {\n\t\tif (index !== null) {\n\t\t\tparent[prop][index] = node;\n\t\t} else {\n\t\t\tparent[prop] = node;\n\t\t}\n\t}\n}\n\nfunction remove(parent, prop, index) {\n\tif (parent) {\n\t\tif (index !== null) {\n\t\t\tparent[prop].splice(index, 1);\n\t\t} else {\n\t\t\tdelete parent[prop];\n\t\t}\n\t}\n}\n\nfunction visit(\n\tnode,\n\tparent,\n\tenter,\n\tleave,\n\tprop,\n\tindex\n) {\n\tif (node) {\n\t\tif (enter) {\n\t\t\tconst _should_skip = should_skip;\n\t\t\tconst _should_remove = should_remove;\n\t\t\tconst _replacement = replacement;\n\t\t\tshould_skip = false;\n\t\t\tshould_remove = false;\n\t\t\treplacement = null;\n\n\t\t\tenter.call(context, node, parent, prop, index);\n\n\t\t\tif (replacement) {\n\t\t\t\tnode = replacement;\n\t\t\t\treplace(parent, prop, index, node);\n\t\t\t}\n\n\t\t\tif (should_remove) {\n\t\t\t\tremove(parent, prop, index);\n\t\t\t}\n\n\t\t\tconst skipped = should_skip;\n\t\t\tconst removed = should_remove;\n\n\t\t\tshould_skip = _should_skip;\n\t\t\tshould_remove = _should_remove;\n\t\t\treplacement = _replacement;\n\n\t\t\tif (skipped) return node;\n\t\t\tif (removed) return null;\n\t\t}\n\n\t\tfor (const key in node) {\n\t\t\tconst value = (node )[key];\n\n\t\t\tif (typeof value !== 'object') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (Array.isArray(value)) {\n\t\t\t\tfor (let j = 0, k = 0; j < value.length; j += 1, k += 1) {\n\t\t\t\t\tif (value[j] !== null && typeof value[j].type === 'string') {\n\t\t\t\t\t\tif (!visit(value[j], node, enter, leave, key, k)) {\n\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (value !== null && typeof value.type === 'string') {\n\t\t\t\tvisit(value, node, enter, leave, key, null);\n\t\t\t}\n\t\t}\n\n\t\tif (leave) {\n\t\t\tconst _replacement = replacement;\n\t\t\tconst _should_remove = should_remove;\n\t\t\treplacement = null;\n\t\t\tshould_remove = false;\n\n\t\t\tleave.call(context, node, parent, prop, index);\n\n\t\t\tif (replacement) {\n\t\t\t\tnode = replacement;\n\t\t\t\treplace(parent, prop, index, node);\n\t\t\t}\n\n\t\t\tif (should_remove) {\n\t\t\t\tremove(parent, prop, index);\n\t\t\t}\n\n\t\t\tconst removed = should_remove;\n\n\t\t\treplacement = _replacement;\n\t\t\tshould_remove = _should_remove;\n\n\t\t\tif (removed) return null;\n\t\t}\n\t}\n\n\treturn node;\n}\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            // @ts-ignore Typescript reports that this is not a valid type\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\nconst blockDeclarations = {\n    const: true,\n    let: true\n};\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent;\n        this.isBlockScope = !!options.block;\n        this.declarations = Object.create(null);\n        if (options.params) {\n            options.params.forEach((param) => {\n                extractAssignedNames(param).forEach((name) => {\n                    this.declarations[name] = true;\n                });\n            });\n        }\n    }\n    addDeclaration(node, isBlockDeclaration, isVar) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n            // it's a `var` or function node, and this\n            // is a block scope, so we need to go up\n            this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n        }\n        else if (node.id) {\n            extractAssignedNames(node.id).forEach((name) => {\n                this.declarations[name] = true;\n            });\n        }\n    }\n    contains(name) {\n        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n    }\n}\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n    let scope = new Scope();\n    walk(ast, {\n        enter(n, parent) {\n            const node = n;\n            // function foo () {...}\n            // class Foo {...}\n            if (/(Function|Class)Declaration/.test(node.type)) {\n                scope.addDeclaration(node, false, false);\n            }\n            // var foo = 1\n            if (node.type === 'VariableDeclaration') {\n                const { kind } = node;\n                const isBlockDeclaration = blockDeclarations[kind];\n                // don't add const/let declarations in the body of a for loop #113\n                const parentType = parent ? parent.type : '';\n                if (!(isBlockDeclaration && /ForOfStatement/.test(parentType))) {\n                    node.declarations.forEach((declaration) => {\n                        scope.addDeclaration(declaration, isBlockDeclaration, true);\n                    });\n                }\n            }\n            let newScope;\n            // create new function scope\n            if (/Function/.test(node.type)) {\n                const func = node;\n                newScope = new Scope({\n                    parent: scope,\n                    block: false,\n                    params: func.params\n                });\n                // named function expressions - the name is considered\n                // part of the function's scope\n                if (func.type === 'FunctionExpression' && func.id) {\n                    newScope.addDeclaration(func, false, false);\n                }\n            }\n            // create new block scope\n            if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // catch clause has its own block scope\n            if (node.type === 'CatchClause') {\n                newScope = new Scope({\n                    parent: scope,\n                    params: node.param ? [node.param] : [],\n                    block: true\n                });\n            }\n            if (newScope) {\n                Object.defineProperty(node, propertyName, {\n                    value: newScope,\n                    configurable: true\n                });\n                scope = newScope;\n            }\n        },\n        leave(n) {\n            const node = n;\n            if (node[propertyName])\n                scope = scope.parent;\n        }\n    });\n    return scope;\n};\n\n// Helper since Typescript can't detect readonly arrays with Array.isArray\nfunction isArray(arg) {\n    return Array.isArray(arg);\n}\nfunction ensureArray(thing) {\n    if (isArray(thing))\n        return thing;\n    if (thing == null)\n        return [];\n    return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false) {\n        return id;\n    }\n    // resolve('') is valid and will default to process.cwd()\n    const basePath = resolve(resolutionBase || '')\n        .split(sep)\n        .join('/')\n        // escape all possible (posix + win) path characters that might interfere with regex\n        .replace(/[-^$*+?.()|[\\]{}]/g, '\\\\$&');\n    // Note that we use posix.join because:\n    // 1. the basePath has been normalized to use /\n    // 2. the incoming glob (id) matcher, also uses /\n    // otherwise Node will force backslash (\\) on windows\n    return posix.join(basePath, id);\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => id instanceof RegExp\n        ? id\n        : {\n            test: (what) => {\n                // this refactor is a tad overly verbose but makes for easy debugging\n                const pattern = getMatcherString(id, resolutionBase);\n                const fn = pm(pattern, { dot: true });\n                const result = fn(what);\n                return result;\n            }\n        };\n    const includeMatchers = ensureArray(include).map(getMatcher);\n    const excludeMatchers = ensureArray(exclude).map(getMatcher);\n    return function result(id) {\n        if (typeof id !== 'string')\n            return false;\n        if (/\\0/.test(id))\n            return false;\n        const pathId = id.split(sep).join('/');\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(pathId))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(pathId))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n    let identifier = str\n        .replace(/-(\\w)/g, (_, letter) => letter.toUpperCase())\n        .replace(/[^$_a-zA-Z0-9]/g, '_');\n    if (/\\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {\n        identifier = `_${identifier}`;\n    }\n    return identifier || '_';\n};\n\nfunction stringify(obj) {\n    return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, (char) => `\\\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);\n}\nfunction serializeArray(arr, indent, baseIndent) {\n    let output = '[';\n    const separator = indent ? `\\n${baseIndent}${indent}` : '';\n    for (let i = 0; i < arr.length; i++) {\n        const key = arr[i];\n        output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n    }\n    return `${output}${indent ? `\\n${baseIndent}` : ''}]`;\n}\nfunction serializeObject(obj, indent, baseIndent) {\n    let output = '{';\n    const separator = indent ? `\\n${baseIndent}${indent}` : '';\n    const entries = Object.entries(obj);\n    for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i];\n        const stringKey = makeLegalIdentifier(key) === key ? key : stringify(key);\n        output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(value, indent, baseIndent + indent)}`;\n    }\n    return `${output}${indent ? `\\n${baseIndent}` : ''}}`;\n}\nfunction serialize(obj, indent, baseIndent) {\n    if (obj === Infinity)\n        return 'Infinity';\n    if (obj === -Infinity)\n        return '-Infinity';\n    if (obj === 0 && 1 / obj === -Infinity)\n        return '-0';\n    if (obj instanceof Date)\n        return `new Date(${obj.getTime()})`;\n    if (obj instanceof RegExp)\n        return obj.toString();\n    if (obj !== obj)\n        return 'NaN'; // eslint-disable-line no-self-compare\n    if (Array.isArray(obj))\n        return serializeArray(obj, indent, baseIndent);\n    if (obj === null)\n        return 'null';\n    if (typeof obj === 'object')\n        return serializeObject(obj, indent, baseIndent);\n    return stringify(obj);\n}\nconst dataToEsm = function dataToEsm(data, options = {}) {\n    const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const declarationType = options.preferConst ? 'const' : 'var';\n    if (options.namedExports === false ||\n        typeof data !== 'object' ||\n        Array.isArray(data) ||\n        data instanceof Date ||\n        data instanceof RegExp ||\n        data === null) {\n        const code = serialize(data, options.compact ? null : t, '');\n        const magic = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape\n        return `export default${magic}${code};`;\n    }\n    let namedExportCode = '';\n    const defaultExportRows = [];\n    for (const [key, value] of Object.entries(data)) {\n        if (key === makeLegalIdentifier(key)) {\n            if (options.objectShorthand)\n                defaultExportRows.push(key);\n            else\n                defaultExportRows.push(`${key}:${_}${key}`);\n            namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;\n        }\n        else {\n            defaultExportRows.push(`${stringify(key)}:${_}${serialize(value, options.compact ? null : t, '')}`);\n        }\n    }\n    return `${namedExportCode}export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;\n};\n\n// TODO: remove this in next major\nvar index = {\n    addExtension,\n    attachScopes,\n    createFilter,\n    dataToEsm,\n    extractAssignedNames,\n    makeLegalIdentifier\n};\n\nexport default index;\nexport { addExtension, attachScopes, createFilter, dataToEsm, extractAssignedNames, makeLegalIdentifier };\n"]},"metadata":{},"sourceType":"module"}