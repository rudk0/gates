{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.injectInitialization = injectInitialization;\nexports.extractComputedKeys = extractComputedKeys;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nconst findBareSupers = _core.traverse.visitors.merge([{\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path) {\n    if (this.scope.hasOwnBinding(path.node.name)) {\n      this.scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n\n};\n\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ\n};\n\nfunction injectInitialization(path, constructor, nodes, renamer) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n\n    for (const bareSuper of bareSupers) {\n      bareSuper.insertAfter(nodes);\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\nfunction extractComputedKeys(ref, path, computedPaths, file) {\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file\n  };\n\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);\n      path.scope.push({\n        id: ident,\n        kind: \"let\"\n      });\n      declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), computedNode.key)));\n      computedNode.key = _core.types.cloneNode(ident);\n    }\n  }\n\n  return declarations;\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"],"names":["Object","defineProperty","exports","value","injectInitialization","extractComputedKeys","_core","require","_helperReplaceSupers","findBareSupers","traverse","visitors","merge","Super","path","node","parentPath","isCallExpression","callee","push","environmentVisitor","referenceVisitor","skip","ReferencedIdentifier","scope","hasOwnBinding","name","rename","handleClassTDZ","state","classBinding","getBinding","classNameTDZError","file","addHelper","throwNode","types","callExpression","stringLiteral","replaceWith","sequenceExpression","classFieldDefinitionEvaluationTDZVisitor","constructor","nodes","renamer","length","isDerived","superClass","newConstructor","classMethod","identifier","blockStatement","params","restElement","body","template","statement","ast","get","unshiftContainer","bareSupers","bareSuper","insertAfter","ref","computedPaths","declarations","id","computedPath","computedKey","isReferencedIdentifier","computedNode","isConstantExpression","ident","generateUidIdentifierBasedOnNode","key","kind","expressionStatement","assignmentExpression","cloneNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.injectInitialization = injectInitialization;\nexports.extractComputedKeys = extractComputedKeys;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nconst findBareSupers = _core.traverse.visitors.merge([{\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path) {\n    if (this.scope.hasOwnBinding(path.node.name)) {\n      this.scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n\n};\n\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ\n};\n\nfunction injectInitialization(path, constructor, nodes, renamer) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n\n    for (const bareSuper of bareSupers) {\n      bareSuper.insertAfter(nodes);\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\nfunction extractComputedKeys(ref, path, computedPaths, file) {\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file\n  };\n\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);\n      path.scope.push({\n        id: ident,\n        kind: \"let\"\n      });\n      declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), computedNode.key)));\n      computedNode.key = _core.types.cloneNode(ident);\n    }\n  }\n\n  return declarations;\n}"]},"metadata":{},"sourceType":"script"}