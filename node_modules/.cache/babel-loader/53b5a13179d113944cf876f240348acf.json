{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformClass;\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar defineMap = _interopRequireWildcard(require(\"@babel/helper-define-map\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nvar _inlineCreateSuperHelpers = _interopRequireDefault(require(\"./inline-createSuper-helpers\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction buildConstructor(classRef, constructorBody, node) {\n  const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);\n\n  _core.types.inherits(func, node);\n\n  return func;\n}\n\nfunction transformClass(path, file, builtinClasses, isLoose) {\n  const classState = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: undefined,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n    instancePropBody: [],\n    instancePropRefs: {},\n    staticPropBody: [],\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    protoAlias: null,\n    isLoose: false,\n    hasInstanceDescriptors: false,\n    hasStaticDescriptors: false,\n    instanceMutatorMap: {},\n    staticMutatorMap: {}\n  };\n\n  const setState = newState => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = _core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    }\n\n  }]);\n\n  function pushToMap(node, enumerable, kind = \"value\", scope) {\n    let mutatorMap;\n\n    if (node.static) {\n      setState({\n        hasStaticDescriptors: true\n      });\n      mutatorMap = classState.staticMutatorMap;\n    } else {\n      setState({\n        hasInstanceDescriptors: true\n      });\n      mutatorMap = classState.instanceMutatorMap;\n    }\n\n    const map = defineMap.push(mutatorMap, node, kind, classState.file, scope);\n\n    if (enumerable) {\n      map.enumerable = _core.types.booleanLiteral(true);\n    }\n\n    return map;\n  }\n\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n\n    for (const path of paths) {\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n\n    if (hasConstructor) return;\n    let params, body;\n\n    if (classState.isDerived) {\n      const constructor = _core.template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      `;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = _core.types.blockStatement([]);\n    }\n\n    classState.path.get(\"body\").unshiftContainer(\"body\", _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), params, body));\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const {\n        constructorBody,\n        userConstructor,\n        construct\n      } = classState;\n      constructorBody.body = constructorBody.body.concat(userConstructor.body.body);\n\n      _core.types.inherits(construct, userConstructor);\n\n      _core.types.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\"Method has decorators, put the decorator plugin before the classes one.\");\n      }\n\n      if (_core.types.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n        const replaceSupers = new _helperReplaceSupers.default({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          isLoose: classState.isLoose,\n          file: classState.file\n        });\n        replaceSupers.replace();\n        const superReturns = [];\n        path.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {\n          ReturnStatement(path) {\n            if (!path.getFunctionParent().isArrowFunctionExpression()) {\n              superReturns.push(path);\n            }\n          }\n\n        }]));\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function clearDescriptors() {\n    setState({\n      hasInstanceDescriptors: false,\n      hasStaticDescriptors: false,\n      instanceMutatorMap: {},\n      staticMutatorMap: {}\n    });\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n    const {\n      body\n    } = classState;\n    let instanceProps;\n    let staticProps;\n\n    if (classState.hasInstanceDescriptors) {\n      instanceProps = defineMap.toClassObject(classState.instanceMutatorMap);\n    }\n\n    if (classState.hasStaticDescriptors) {\n      staticProps = defineMap.toClassObject(classState.staticMutatorMap);\n    }\n\n    if (instanceProps || staticProps) {\n      if (instanceProps) {\n        instanceProps = defineMap.toComputedObjectFromClass(instanceProps);\n      }\n\n      if (staticProps) {\n        staticProps = defineMap.toComputedObjectFromClass(staticProps);\n      }\n\n      let args = [_core.types.cloneNode(classState.classRef), _core.types.nullLiteral(), _core.types.nullLiteral()];\n      if (instanceProps) args[1] = instanceProps;\n      if (staticProps) args[2] = staticProps;\n      let lastNonNullIndex = 0;\n\n      for (let i = 0; i < args.length; i++) {\n        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n\n      args = args.slice(0, lastNonNullIndex + 1);\n      body.push(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(\"createClass\"), args)));\n    }\n\n    clearDescriptors();\n  }\n\n  function wrapSuperCall(bareSuper, superRef, thisRef, body) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (classState.isLoose) {\n      bareSuperNode.arguments.unshift(_core.types.thisExpression());\n\n      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {\n        name: \"arguments\"\n      })) {\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"apply\"));\n      } else {\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"call\"));\n      }\n\n      call = _core.types.logicalExpression(\"||\", bareSuperNode, _core.types.thisExpression());\n    } else {\n      call = (0, _helperOptimiseCallExpression.default)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments);\n    }\n\n    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {\n      if (classState.superThises.length) {\n        call = _core.types.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(_core.types.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n\n      thisRef = () => _core.types.cloneNode(ref);\n\n      return ref;\n    };\n\n    for (const thisPath of classState.superThises) {\n      const {\n        node,\n        parentPath\n      } = thisPath;\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]));\n    }\n\n    const bareSupers = new Set();\n    path.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {\n      Super(path) {\n        const {\n          node,\n          parentPath\n        } = path;\n\n        if (parentPath.isCallExpression({\n          callee: node\n        })) {\n          bareSupers.add(parentPath);\n        }\n      }\n\n    }]));\n    let guaranteedSuperBeforeFinish = !!bareSupers.size;\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          if (parentPath === path) {\n            return true;\n          }\n\n          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = returnArg => {\n        const thisExpr = _core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]);\n\n        return returnArg ? _core.types.logicalExpression(\"||\", returnArg, thisExpr) : thisExpr;\n      };\n    } else {\n      wrapReturn = returnArg => _core.types.callExpression(classState.file.addHelper(\"possibleConstructorReturn\"), [thisRef()].concat(returnArg || []));\n    }\n\n    const bodyPaths = body.get(\"body\");\n\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\"body\", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath.get(\"argument\").replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  function pushMethod(node, path) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    pushToMap(node, false, null, scope);\n  }\n\n  function processMethod(node, scope) {\n    if (classState.isLoose && !node.decorators) {\n      let {\n        classRef\n      } = classState;\n\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n\n      const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));\n\n      let func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);\n\n      _core.types.inherits(func, node);\n\n      const key = _core.types.toComputedKey(node, node.key);\n\n      if (_core.types.isStringLiteral(key)) {\n        func = (0, _helperFunctionName.default)({\n          node: func,\n          id: key,\n          scope\n        });\n      }\n\n      const expr = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", methodName, func));\n\n      _core.types.inheritsComments(expr, node);\n\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({\n        protoAlias: classState.scope.generateUidIdentifier(\"proto\")\n      });\n\n      const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier(\"prototype\"));\n\n      const protoDeclaration = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  function pushConstructor(superReturns, method, path) {\n    if (path.scope.hasOwnBinding(classState.classRef.name)) {\n      path.scope.rename(classState.classRef.name);\n    }\n\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns\n    });\n    const {\n      construct\n    } = classState;\n\n    _core.types.inheritsComments(construct, method);\n\n    construct.params = method.params;\n\n    _core.types.inherits(construct.body, method.body);\n\n    construct.body.directives = method.body.directives;\n    pushConstructorToBody();\n  }\n\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    classState.body.push(classState.construct);\n    pushInheritsToBody();\n  }\n\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n    setState({\n      pushedInherits: true,\n      superFnId\n    });\n\n    if (!classState.isLoose) {\n      classState.body.unshift(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(superFnId, _core.types.callExpression((0, _inlineCreateSuperHelpers.default)(classState.file), [_core.types.cloneNode(classState.classRef)]))]));\n    }\n\n    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? \"inheritsLoose\" : \"inherits\"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));\n  }\n\n  function setupClosureParamsArgs() {\n    const {\n      superName\n    } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = _core.types.cloneNode(superName);\n\n      if (classState.extendsNative) {\n        arg = _core.types.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [arg]);\n        (0, _helperAnnotateAsPure.default)(arg);\n      }\n\n      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);\n      closureParams.push(param);\n      closureArgs.push(arg);\n      setState({\n        superName: _core.types.cloneNode(param)\n      });\n    }\n\n    return {\n      closureParams,\n      closureArgs\n    };\n  }\n\n  function classTransformer(path, file, builtinClasses, isLoose) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose\n    });\n    setState({\n      classId: classState.node.id,\n      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: _core.types.blockStatement([])\n    });\n    setState({\n      extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)\n    });\n    const {\n      classRef,\n      node,\n      constructorBody\n    } = classState;\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node)\n    });\n    let {\n      body\n    } = classState;\n    const {\n      closureParams,\n      closureArgs\n    } = setupClosureParamsArgs();\n    buildBody();\n\n    if (!classState.isLoose) {\n      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(\"classCallCheck\"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));\n    }\n\n    body = body.concat(classState.staticPropBody.map(fn => fn(_core.types.cloneNode(classState.classRef))));\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        if (!_core.types.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly ? body[0].body.directives : [];\n\n    if (!isStrict) {\n      directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      return _core.types.toExpression(body[0]);\n    }\n\n    body.push(_core.types.returnStatement(_core.types.cloneNode(classState.classRef)));\n\n    const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));\n\n    return _core.types.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-classes/lib/transformClass.js"],"names":["Object","defineProperty","exports","value","default","transformClass","_helperFunctionName","_interopRequireDefault","require","_helperReplaceSupers","_interopRequireWildcard","_helperOptimiseCallExpression","defineMap","_core","_helperAnnotateAsPure","_inlineCreateSuperHelpers","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","buildConstructor","classRef","constructorBody","node","func","types","functionDeclaration","cloneNode","inherits","path","file","builtinClasses","isLoose","classState","parent","undefined","scope","classId","superFnId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","instancePropBody","instancePropRefs","staticPropBody","body","superThises","pushedConstructor","pushedInherits","protoAlias","hasInstanceDescriptors","hasStaticDescriptors","instanceMutatorMap","staticMutatorMap","setState","newState","assign","findThisesVisitor","traverse","visitors","merge","environmentVisitor","ThisExpression","push","pushToMap","enumerable","kind","mutatorMap","static","map","booleanLiteral","maybeCreateConstructor","paths","equals","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","concat","pushDescriptors","classBodyPaths","isClassProperty","buildCodeFrameError","decorators","isClassMethod","isConstructor","replaceSupers","methodPath","objectRef","superRef","replace","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","pushMethod","clearDescriptors","pushInheritsToBody","instanceProps","staticProps","toClassObject","toComputedObjectFromClass","args","nullLiteral","lastNonNullIndex","i","length","isNullLiteral","slice","expressionStatement","callExpression","addHelper","wrapSuperCall","bareSuper","thisRef","bareSuperNode","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","parentPath","isExpressionStatement","container","assignmentExpression","replaceWith","returnStatement","ref","generateDeclaredUidIdentifier","thisPath","isMemberExpression","object","bareSupers","Set","Super","isCallExpression","add","guaranteedSuperBeforeFinish","size","find","isLoop","isConditional","wrapReturn","returnArg","thisExpr","bodyPaths","pop","isReturnStatement","pushContainer","returnPath","processMethod","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","generator","async","toComputedKey","isStringLiteral","id","expr","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","hasOwnBinding","rename","directives","pushConstructorToBody","setupClosureParamsArgs","closureParams","closureArgs","arg","param","generateUidIdentifierBasedOnNode","classTransformer","superClass","hasBinding","fn","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","toExpression","arrowFunctionExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transformClass;\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar defineMap = _interopRequireWildcard(require(\"@babel/helper-define-map\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nvar _inlineCreateSuperHelpers = _interopRequireDefault(require(\"./inline-createSuper-helpers\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction buildConstructor(classRef, constructorBody, node) {\n  const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);\n\n  _core.types.inherits(func, node);\n\n  return func;\n}\n\nfunction transformClass(path, file, builtinClasses, isLoose) {\n  const classState = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: undefined,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n    instancePropBody: [],\n    instancePropRefs: {},\n    staticPropBody: [],\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    protoAlias: null,\n    isLoose: false,\n    hasInstanceDescriptors: false,\n    hasStaticDescriptors: false,\n    instanceMutatorMap: {},\n    staticMutatorMap: {}\n  };\n\n  const setState = newState => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = _core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    }\n\n  }]);\n\n  function pushToMap(node, enumerable, kind = \"value\", scope) {\n    let mutatorMap;\n\n    if (node.static) {\n      setState({\n        hasStaticDescriptors: true\n      });\n      mutatorMap = classState.staticMutatorMap;\n    } else {\n      setState({\n        hasInstanceDescriptors: true\n      });\n      mutatorMap = classState.instanceMutatorMap;\n    }\n\n    const map = defineMap.push(mutatorMap, node, kind, classState.file, scope);\n\n    if (enumerable) {\n      map.enumerable = _core.types.booleanLiteral(true);\n    }\n\n    return map;\n  }\n\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n\n    for (const path of paths) {\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n\n    if (hasConstructor) return;\n    let params, body;\n\n    if (classState.isDerived) {\n      const constructor = _core.template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      `;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = _core.types.blockStatement([]);\n    }\n\n    classState.path.get(\"body\").unshiftContainer(\"body\", _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), params, body));\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const {\n        constructorBody,\n        userConstructor,\n        construct\n      } = classState;\n      constructorBody.body = constructorBody.body.concat(userConstructor.body.body);\n\n      _core.types.inherits(construct, userConstructor);\n\n      _core.types.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\"Method has decorators, put the decorator plugin before the classes one.\");\n      }\n\n      if (_core.types.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n        const replaceSupers = new _helperReplaceSupers.default({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          isLoose: classState.isLoose,\n          file: classState.file\n        });\n        replaceSupers.replace();\n        const superReturns = [];\n        path.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {\n          ReturnStatement(path) {\n            if (!path.getFunctionParent().isArrowFunctionExpression()) {\n              superReturns.push(path);\n            }\n          }\n\n        }]));\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function clearDescriptors() {\n    setState({\n      hasInstanceDescriptors: false,\n      hasStaticDescriptors: false,\n      instanceMutatorMap: {},\n      staticMutatorMap: {}\n    });\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n    const {\n      body\n    } = classState;\n    let instanceProps;\n    let staticProps;\n\n    if (classState.hasInstanceDescriptors) {\n      instanceProps = defineMap.toClassObject(classState.instanceMutatorMap);\n    }\n\n    if (classState.hasStaticDescriptors) {\n      staticProps = defineMap.toClassObject(classState.staticMutatorMap);\n    }\n\n    if (instanceProps || staticProps) {\n      if (instanceProps) {\n        instanceProps = defineMap.toComputedObjectFromClass(instanceProps);\n      }\n\n      if (staticProps) {\n        staticProps = defineMap.toComputedObjectFromClass(staticProps);\n      }\n\n      let args = [_core.types.cloneNode(classState.classRef), _core.types.nullLiteral(), _core.types.nullLiteral()];\n      if (instanceProps) args[1] = instanceProps;\n      if (staticProps) args[2] = staticProps;\n      let lastNonNullIndex = 0;\n\n      for (let i = 0; i < args.length; i++) {\n        if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n\n      args = args.slice(0, lastNonNullIndex + 1);\n      body.push(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(\"createClass\"), args)));\n    }\n\n    clearDescriptors();\n  }\n\n  function wrapSuperCall(bareSuper, superRef, thisRef, body) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (classState.isLoose) {\n      bareSuperNode.arguments.unshift(_core.types.thisExpression());\n\n      if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {\n        name: \"arguments\"\n      })) {\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"apply\"));\n      } else {\n        bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier(\"call\"));\n      }\n\n      call = _core.types.logicalExpression(\"||\", bareSuperNode, _core.types.thisExpression());\n    } else {\n      call = (0, _helperOptimiseCallExpression.default)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments);\n    }\n\n    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {\n      if (classState.superThises.length) {\n        call = _core.types.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(_core.types.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n\n      thisRef = () => _core.types.cloneNode(ref);\n\n      return ref;\n    };\n\n    for (const thisPath of classState.superThises) {\n      const {\n        node,\n        parentPath\n      } = thisPath;\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]));\n    }\n\n    const bareSupers = new Set();\n    path.traverse(_core.traverse.visitors.merge([_helperReplaceSupers.environmentVisitor, {\n      Super(path) {\n        const {\n          node,\n          parentPath\n        } = path;\n\n        if (parentPath.isCallExpression({\n          callee: node\n        })) {\n          bareSupers.add(parentPath);\n        }\n      }\n\n    }]));\n    let guaranteedSuperBeforeFinish = !!bareSupers.size;\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          if (parentPath === path) {\n            return true;\n          }\n\n          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = returnArg => {\n        const thisExpr = _core.types.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [thisRef()]);\n\n        return returnArg ? _core.types.logicalExpression(\"||\", returnArg, thisExpr) : thisExpr;\n      };\n    } else {\n      wrapReturn = returnArg => _core.types.callExpression(classState.file.addHelper(\"possibleConstructorReturn\"), [thisRef()].concat(returnArg || []));\n    }\n\n    const bodyPaths = body.get(\"body\");\n\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\"body\", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath.get(\"argument\").replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  function pushMethod(node, path) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    pushToMap(node, false, null, scope);\n  }\n\n  function processMethod(node, scope) {\n    if (classState.isLoose && !node.decorators) {\n      let {\n        classRef\n      } = classState;\n\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n\n      const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));\n\n      let func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);\n\n      _core.types.inherits(func, node);\n\n      const key = _core.types.toComputedKey(node, node.key);\n\n      if (_core.types.isStringLiteral(key)) {\n        func = (0, _helperFunctionName.default)({\n          node: func,\n          id: key,\n          scope\n        });\n      }\n\n      const expr = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", methodName, func));\n\n      _core.types.inheritsComments(expr, node);\n\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({\n        protoAlias: classState.scope.generateUidIdentifier(\"proto\")\n      });\n\n      const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier(\"prototype\"));\n\n      const protoDeclaration = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(classState.protoAlias, classProto)]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  function pushConstructor(superReturns, method, path) {\n    if (path.scope.hasOwnBinding(classState.classRef.name)) {\n      path.scope.rename(classState.classRef.name);\n    }\n\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns\n    });\n    const {\n      construct\n    } = classState;\n\n    _core.types.inheritsComments(construct, method);\n\n    construct.params = method.params;\n\n    _core.types.inherits(construct.body, method.body);\n\n    construct.body.directives = method.body.directives;\n    pushConstructorToBody();\n  }\n\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    classState.body.push(classState.construct);\n    pushInheritsToBody();\n  }\n\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n    setState({\n      pushedInherits: true,\n      superFnId\n    });\n\n    if (!classState.isLoose) {\n      classState.body.unshift(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(superFnId, _core.types.callExpression((0, _inlineCreateSuperHelpers.default)(classState.file), [_core.types.cloneNode(classState.classRef)]))]));\n    }\n\n    classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? \"inheritsLoose\" : \"inherits\"), [_core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName)])));\n  }\n\n  function setupClosureParamsArgs() {\n    const {\n      superName\n    } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = _core.types.cloneNode(superName);\n\n      if (classState.extendsNative) {\n        arg = _core.types.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [arg]);\n        (0, _helperAnnotateAsPure.default)(arg);\n      }\n\n      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);\n      closureParams.push(param);\n      closureArgs.push(arg);\n      setState({\n        superName: _core.types.cloneNode(param)\n      });\n    }\n\n    return {\n      closureParams,\n      closureArgs\n    };\n  }\n\n  function classTransformer(path, file, builtinClasses, isLoose) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose\n    });\n    setState({\n      classId: classState.node.id,\n      classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: _core.types.blockStatement([])\n    });\n    setState({\n      extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)\n    });\n    const {\n      classRef,\n      node,\n      constructorBody\n    } = classState;\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node)\n    });\n    let {\n      body\n    } = classState;\n    const {\n      closureParams,\n      closureArgs\n    } = setupClosureParamsArgs();\n    buildBody();\n\n    if (!classState.isLoose) {\n      constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(\"classCallCheck\"), [_core.types.thisExpression(), _core.types.cloneNode(classState.classRef)])));\n    }\n\n    body = body.concat(classState.staticPropBody.map(fn => fn(_core.types.cloneNode(classState.classRef))));\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        if (!_core.types.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly ? body[0].body.directives : [];\n\n    if (!isStrict) {\n      directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      return _core.types.toExpression(body[0]);\n    }\n\n    body.push(_core.types.returnStatement(_core.types.cloneNode(classState.classRef)));\n\n    const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));\n\n    return _core.types.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}"]},"metadata":{},"sourceType":"script"}