{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst errors = require('./errors');\n\nconst escapeRegExp = require('./escape-regexp');\n\nmodule.exports = modifyURLPrefix => {\n  if (!modifyURLPrefix || typeof modifyURLPrefix !== 'object' || Array.isArray(modifyURLPrefix)) {\n    throw new Error(errors['modify-url-prefix-bad-prefixes']);\n  } // If there are no entries in modifyURLPrefix, just return an identity\n  // function as a shortcut.\n\n\n  if (Object.keys(modifyURLPrefix).length === 0) {\n    return entry => entry;\n  }\n\n  Object.keys(modifyURLPrefix).forEach(key => {\n    if (typeof modifyURLPrefix[key] !== 'string') {\n      throw new Error(errors['modify-url-prefix-bad-prefixes']);\n    }\n  }); // Escape the user input so it's safe to use in a regex.\n\n  const safeModifyURLPrefixes = Object.keys(modifyURLPrefix).map(escapeRegExp); // Join all the `modifyURLPrefix` keys so a single regex can be used.\n\n  const prefixMatchesStrings = safeModifyURLPrefixes.join('|'); // Add `^` to the front the prefix matches so it only matches the start of\n  // a string.\n\n  const modifyRegex = new RegExp(`^(${prefixMatchesStrings})`);\n  return originalManifest => {\n    const manifest = originalManifest.map(entry => {\n      if (typeof entry.url !== 'string') {\n        throw new Error(errors['manifest-entry-bad-url']);\n      }\n\n      entry.url = entry.url.replace(modifyRegex, match => {\n        return modifyURLPrefix[match];\n      });\n      return entry;\n    });\n    return {\n      manifest\n    };\n  };\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/lib/modify-url-prefix-transform.js"],"names":["errors","require","escapeRegExp","module","exports","modifyURLPrefix","Array","isArray","Error","Object","keys","length","entry","forEach","key","safeModifyURLPrefixes","map","prefixMatchesStrings","join","modifyRegex","RegExp","originalManifest","manifest","url","replace","match"],"mappings":"AAAA;AAEA;;;;;;;;AAOA,MAAMA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AAEA,MAAMC,YAAY,GAAGD,OAAO,CAAC,iBAAD,CAA5B;;AAEAE,MAAM,CAACC,OAAP,GAAiBC,eAAe,IAAI;AAClC,MAAI,CAACA,eAAD,IAAoB,OAAOA,eAAP,KAA2B,QAA/C,IAA2DC,KAAK,CAACC,OAAN,CAAcF,eAAd,CAA/D,EAA+F;AAC7F,UAAM,IAAIG,KAAJ,CAAUR,MAAM,CAAC,gCAAD,CAAhB,CAAN;AACD,GAHiC,CAGhC;AACF;;;AAGA,MAAIS,MAAM,CAACC,IAAP,CAAYL,eAAZ,EAA6BM,MAA7B,KAAwC,CAA5C,EAA+C;AAC7C,WAAOC,KAAK,IAAIA,KAAhB;AACD;;AAEDH,EAAAA,MAAM,CAACC,IAAP,CAAYL,eAAZ,EAA6BQ,OAA7B,CAAqCC,GAAG,IAAI;AAC1C,QAAI,OAAOT,eAAe,CAACS,GAAD,CAAtB,KAAgC,QAApC,EAA8C;AAC5C,YAAM,IAAIN,KAAJ,CAAUR,MAAM,CAAC,gCAAD,CAAhB,CAAN;AACD;AACF,GAJD,EAXkC,CAe9B;;AAEJ,QAAMe,qBAAqB,GAAGN,MAAM,CAACC,IAAP,CAAYL,eAAZ,EAA6BW,GAA7B,CAAiCd,YAAjC,CAA9B,CAjBkC,CAiB4C;;AAE9E,QAAMe,oBAAoB,GAAGF,qBAAqB,CAACG,IAAtB,CAA2B,GAA3B,CAA7B,CAnBkC,CAmB4B;AAC9D;;AAEA,QAAMC,WAAW,GAAG,IAAIC,MAAJ,CAAY,KAAIH,oBAAqB,GAArC,CAApB;AACA,SAAOI,gBAAgB,IAAI;AACzB,UAAMC,QAAQ,GAAGD,gBAAgB,CAACL,GAAjB,CAAqBJ,KAAK,IAAI;AAC7C,UAAI,OAAOA,KAAK,CAACW,GAAb,KAAqB,QAAzB,EAAmC;AACjC,cAAM,IAAIf,KAAJ,CAAUR,MAAM,CAAC,wBAAD,CAAhB,CAAN;AACD;;AAEDY,MAAAA,KAAK,CAACW,GAAN,GAAYX,KAAK,CAACW,GAAN,CAAUC,OAAV,CAAkBL,WAAlB,EAA+BM,KAAK,IAAI;AAClD,eAAOpB,eAAe,CAACoB,KAAD,CAAtB;AACD,OAFW,CAAZ;AAGA,aAAOb,KAAP;AACD,KATgB,CAAjB;AAUA,WAAO;AACLU,MAAAA;AADK,KAAP;AAGD,GAdD;AAeD,CAtCD","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst errors = require('./errors');\n\nconst escapeRegExp = require('./escape-regexp');\n\nmodule.exports = modifyURLPrefix => {\n  if (!modifyURLPrefix || typeof modifyURLPrefix !== 'object' || Array.isArray(modifyURLPrefix)) {\n    throw new Error(errors['modify-url-prefix-bad-prefixes']);\n  } // If there are no entries in modifyURLPrefix, just return an identity\n  // function as a shortcut.\n\n\n  if (Object.keys(modifyURLPrefix).length === 0) {\n    return entry => entry;\n  }\n\n  Object.keys(modifyURLPrefix).forEach(key => {\n    if (typeof modifyURLPrefix[key] !== 'string') {\n      throw new Error(errors['modify-url-prefix-bad-prefixes']);\n    }\n  }); // Escape the user input so it's safe to use in a regex.\n\n  const safeModifyURLPrefixes = Object.keys(modifyURLPrefix).map(escapeRegExp); // Join all the `modifyURLPrefix` keys so a single regex can be used.\n\n  const prefixMatchesStrings = safeModifyURLPrefixes.join('|'); // Add `^` to the front the prefix matches so it only matches the start of\n  // a string.\n\n  const modifyRegex = new RegExp(`^(${prefixMatchesStrings})`);\n  return originalManifest => {\n    const manifest = originalManifest.map(entry => {\n      if (typeof entry.url !== 'string') {\n        throw new Error(errors['manifest-entry-bad-url']);\n      }\n\n      entry.url = entry.url.replace(modifyRegex, match => {\n        return modifyURLPrefix[match];\n      });\n      return entry;\n    });\n    return {\n      manifest\n    };\n  };\n};"]},"metadata":{},"sourceType":"script"}