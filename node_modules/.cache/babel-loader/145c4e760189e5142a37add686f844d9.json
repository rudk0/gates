{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxOptionalChaining = _interopRequireDefault(require(\"@babel/plugin-syntax-optional-chaining\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n\n  function isSimpleMemberExpression(expression) {\n    return _core.types.isIdentifier(expression) || _core.types.isSuper(expression) || _core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n  }\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: _pluginSyntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const {\n          scope\n        } = path;\n        let maybeParenthesized = path;\n        const parentPath = path.findParent(p => {\n          if (!p.isParenthesizedExpression()) return true;\n          maybeParenthesized = p;\n        });\n        let isDeleteOperation = false;\n        const parentIsCall = parentPath.isCallExpression({\n          callee: maybeParenthesized.node\n        }) && path.isOptionalMemberExpression();\n        const optionals = [];\n        let optionalPath = path;\n\n        while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression() || optionalPath.isParenthesizedExpression() || optionalPath.isTSNonNullExpression()) {\n          const {\n            node\n          } = optionalPath;\n\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = optionalPath.get(\"object\");\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = optionalPath.get(\"callee\");\n          } else {\n            optionalPath = optionalPath.get(\"expression\");\n          }\n        }\n\n        let replacementPath = path;\n\n        if (parentPath.isUnaryExpression({\n          operator: \"delete\"\n        })) {\n          replacementPath = parentPath;\n          isDeleteOperation = true;\n        }\n\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = _core.types.isCallExpression(node);\n\n          const replaceKey = isCall ? \"callee\" : \"object\";\n          const chain = node[replaceKey];\n          let ref;\n          let check;\n\n          if (loose && isCall && isSimpleMemberExpression(chain)) {\n            check = ref = chain;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n\n            if (ref) {\n              check = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), chain);\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chain;\n            }\n          }\n\n          if (isCall && _core.types.isMemberExpression(chain)) {\n            if (loose && isSimpleMemberExpression(chain)) {\n              node.callee = chain;\n            } else {\n              const {\n                object\n              } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n\n              if (context) {\n                chain.object = _core.types.assignmentExpression(\"=\", context, object);\n              } else if (_core.types.isSuper(object)) {\n                context = _core.types.thisExpression();\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(_core.types.cloneNode(context));\n              node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"call\"));\n            }\n          }\n\n          let replacement = replacementPath.node;\n\n          if (i === 0 && parentIsCall) {\n            var _baseRef;\n\n            const {\n              object\n            } = replacement;\n            let baseRef;\n\n            if (!loose || !isSimpleMemberExpression(object)) {\n              baseRef = scope.maybeGenerateMemoised(object);\n\n              if (baseRef) {\n                replacement.object = _core.types.assignmentExpression(\"=\", baseRef, object);\n              }\n            }\n\n            replacement = _core.types.callExpression(_core.types.memberExpression(replacement, _core.types.identifier(\"bind\")), [_core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n          }\n\n          replacementPath.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"==\", _core.types.cloneNode(check), _core.types.nullLiteral()) : _core.types.logicalExpression(\"||\", _core.types.binaryExpression(\"===\", _core.types.cloneNode(check), _core.types.nullLiteral()), _core.types.binaryExpression(\"===\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? _core.types.booleanLiteral(true) : scope.buildUndefinedNode(), replacement));\n          replacementPath = replacementPath.get(\"alternate\");\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxOptionalChaining","_interopRequireDefault","_core","obj","__esModule","_default","declare","api","options","assertVersion","loose","isSimpleMemberExpression","expression","types","isIdentifier","isSuper","isMemberExpression","computed","object","name","inherits","visitor","path","scope","maybeParenthesized","parentPath","findParent","p","isParenthesizedExpression","isDeleteOperation","parentIsCall","isCallExpression","callee","node","isOptionalMemberExpression","optionals","optionalPath","isOptionalCallExpression","isTSNonNullExpression","optional","push","type","get","replacementPath","isUnaryExpression","operator","i","length","isCall","replaceKey","chain","ref","check","maybeGenerateMemoised","assignmentExpression","cloneNode","context","thisExpression","arguments","unshift","memberExpression","identifier","replacement","_baseRef","baseRef","callExpression","replaceWith","conditionalExpression","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","booleanLiteral"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxOptionalChaining = _interopRequireDefault(require(\"@babel/plugin-syntax-optional-chaining\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n\n  function isSimpleMemberExpression(expression) {\n    return _core.types.isIdentifier(expression) || _core.types.isSuper(expression) || _core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n  }\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: _pluginSyntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const {\n          scope\n        } = path;\n        let maybeParenthesized = path;\n        const parentPath = path.findParent(p => {\n          if (!p.isParenthesizedExpression()) return true;\n          maybeParenthesized = p;\n        });\n        let isDeleteOperation = false;\n        const parentIsCall = parentPath.isCallExpression({\n          callee: maybeParenthesized.node\n        }) && path.isOptionalMemberExpression();\n        const optionals = [];\n        let optionalPath = path;\n\n        while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression() || optionalPath.isParenthesizedExpression() || optionalPath.isTSNonNullExpression()) {\n          const {\n            node\n          } = optionalPath;\n\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = optionalPath.get(\"object\");\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = optionalPath.get(\"callee\");\n          } else {\n            optionalPath = optionalPath.get(\"expression\");\n          }\n        }\n\n        let replacementPath = path;\n\n        if (parentPath.isUnaryExpression({\n          operator: \"delete\"\n        })) {\n          replacementPath = parentPath;\n          isDeleteOperation = true;\n        }\n\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = _core.types.isCallExpression(node);\n\n          const replaceKey = isCall ? \"callee\" : \"object\";\n          const chain = node[replaceKey];\n          let ref;\n          let check;\n\n          if (loose && isCall && isSimpleMemberExpression(chain)) {\n            check = ref = chain;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n\n            if (ref) {\n              check = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), chain);\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chain;\n            }\n          }\n\n          if (isCall && _core.types.isMemberExpression(chain)) {\n            if (loose && isSimpleMemberExpression(chain)) {\n              node.callee = chain;\n            } else {\n              const {\n                object\n              } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n\n              if (context) {\n                chain.object = _core.types.assignmentExpression(\"=\", context, object);\n              } else if (_core.types.isSuper(object)) {\n                context = _core.types.thisExpression();\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(_core.types.cloneNode(context));\n              node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"call\"));\n            }\n          }\n\n          let replacement = replacementPath.node;\n\n          if (i === 0 && parentIsCall) {\n            var _baseRef;\n\n            const {\n              object\n            } = replacement;\n            let baseRef;\n\n            if (!loose || !isSimpleMemberExpression(object)) {\n              baseRef = scope.maybeGenerateMemoised(object);\n\n              if (baseRef) {\n                replacement.object = _core.types.assignmentExpression(\"=\", baseRef, object);\n              }\n            }\n\n            replacement = _core.types.callExpression(_core.types.memberExpression(replacement, _core.types.identifier(\"bind\")), [_core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n          }\n\n          replacementPath.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"==\", _core.types.cloneNode(check), _core.types.nullLiteral()) : _core.types.logicalExpression(\"||\", _core.types.binaryExpression(\"===\", _core.types.cloneNode(check), _core.types.nullLiteral()), _core.types.binaryExpression(\"===\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? _core.types.booleanLiteral(true) : scope.buildUndefinedNode(), replacement));\n          replacementPath = replacementPath.get(\"alternate\");\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}