{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\n\nvar _regexpuCore = _interopRequireDefault(require(\"regexpu-core\"));\n\nvar _features = require(\"./features\");\n\nvar _util = require(\"./util\");\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperRegex = require(\"@babel/helper-regex\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst version = _package.default.version.split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\n\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nfunction createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {}\n}) {\n  return {\n    name,\n\n    pre() {\n      var _file$get;\n\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime = true\n      } = options;\n\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n\n      if (!runtime) {\n        file.set(_features.runtimeKey, false);\n      }\n\n      if (!file.has(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2;\n\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node, features);\n\n        if (regexpuOptions === null) {\n          return;\n        }\n\n        const namedCaptureGroups = {};\n\n        if (regexpuOptions.namedGroup) {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            namedCaptureGroups[name] = index;\n          };\n        }\n\n        node.pattern = (0, _regexpuCore.default)(node.pattern, node.flags, regexpuOptions);\n\n        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {\n          (0, _helperRegex.pullFlag)(node, \"u\");\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag)) {\n          (0, _helperRegex.pullFlag)(node, \"s\");\n        }\n      }\n\n    }\n  };\n}\n\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js"],"names":["Object","defineProperty","exports","value","createRegExpFeaturePlugin","_regexpuCore","_interopRequireDefault","require","_features","_util","_package","_core","_helperRegex","_helperAnnotateAsPure","obj","__esModule","default","version","split","reduce","v","x","versionKey","name","feature","options","pre","_file$get","file","features","get","featuresKey","newFeatures","enableFeature","FEATURES","useUnicodeFlag","runtime","unicodeFlag","set","runtimeKey","has","visitor","RegExpLiteral","path","_file$get2","node","regexpuOptions","generateRegexpuOptions","namedCaptureGroups","namedGroup","onNamedGroup","index","pattern","flags","keys","length","isRegExpTest","call","types","callExpression","addHelper","valueToNode","replaceWith","hasFeature","pullFlag","dotAllFlag","parentPath","isMemberExpression","object","computed","isIdentifier"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\n\nvar _regexpuCore = _interopRequireDefault(require(\"regexpu-core\"));\n\nvar _features = require(\"./features\");\n\nvar _util = require(\"./util\");\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperRegex = require(\"@babel/helper-regex\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst version = _package.default.version.split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\n\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nfunction createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {}\n}) {\n  return {\n    name,\n\n    pre() {\n      var _file$get;\n\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime = true\n      } = options;\n\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n\n      if (!runtime) {\n        file.set(_features.runtimeKey, false);\n      }\n\n      if (!file.has(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2;\n\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node, features);\n\n        if (regexpuOptions === null) {\n          return;\n        }\n\n        const namedCaptureGroups = {};\n\n        if (regexpuOptions.namedGroup) {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            namedCaptureGroups[name] = index;\n          };\n        }\n\n        node.pattern = (0, _regexpuCore.default)(node.pattern, node.flags, regexpuOptions);\n\n        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {\n          (0, _helperRegex.pullFlag)(node, \"u\");\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag)) {\n          (0, _helperRegex.pullFlag)(node, \"s\");\n        }\n      }\n\n    }\n  };\n}\n\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}"]},"metadata":{},"sourceType":"script"}