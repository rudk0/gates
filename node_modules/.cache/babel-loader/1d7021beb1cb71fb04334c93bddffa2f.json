{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst ol = require('common-tags').oneLine;\n\nconst errors = require('./errors');\n\nconst stringifyWithoutComments = require('./stringify-without-comments');\n/**\n * Given a set of options that configures runtime caching behavior, convert it\n * to the equivalent Workbox method calls.\n *\n * @param {ModuleRegistry} moduleRegistry\n * @param {Object} options See\n *        https://developers.google.com/web/tools/workbox/modules/workbox-build#generateSW-runtimeCaching\n * @return {string} A JSON string representing the equivalent options.\n *\n * @private\n */\n\n\nfunction getOptionsString(moduleRegistry, options = {}) {\n  let plugins = [];\n\n  if (options.plugins) {\n    // Using libs because JSON.stringify won't handle functions.\n    plugins = options.plugins.map(stringifyWithoutComments);\n    delete options.plugins;\n  } // Pull handler-specific config from the options object, since they are\n  // not directly used to construct a plugin instance. If set, need to be\n  // passed as options to the handler constructor instead.\n\n\n  const handlerOptionKeys = ['cacheName', 'networkTimeoutSeconds', 'fetchOptions', 'matchOptions'];\n  const handlerOptions = {};\n\n  for (const key of handlerOptionKeys) {\n    if (key in options) {\n      handlerOptions[key] = options[key];\n      delete options[key];\n    }\n  }\n\n  for (const [pluginName, pluginConfig] of Object.entries(options)) {\n    // Ensure that we have some valid configuration to pass to the plugin.\n    if (Object.keys(pluginConfig).length === 0) {\n      continue;\n    }\n\n    let pluginCode;\n\n    switch (pluginName) {\n      case 'backgroundSync':\n        {\n          const name = pluginConfig.name;\n          const plugin = moduleRegistry.use('workbox-background-sync', 'BackgroundSyncPlugin');\n          pluginCode = `new ${plugin}(${JSON.stringify(name)}`;\n\n          if ('options' in pluginConfig) {\n            pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;\n          }\n\n          pluginCode += `)`;\n          break;\n        }\n\n      case 'broadcastUpdate':\n        {\n          const channelName = pluginConfig.channelName;\n          const opts = Object.assign({\n            channelName\n          }, pluginConfig.options);\n          const plugin = moduleRegistry.use('workbox-broadcast-update', 'BroadcastUpdatePlugin');\n          pluginCode = `new ${plugin}(${stringifyWithoutComments(opts)})`;\n          break;\n        }\n\n      case 'cacheableResponse':\n        {\n          const plugin = moduleRegistry.use('workbox-cacheable-response', 'CacheableResponsePlugin');\n          pluginCode = `new ${plugin}(${stringifyWithoutComments(pluginConfig)})`;\n          break;\n        }\n\n      case 'expiration':\n        {\n          const plugin = moduleRegistry.use('workbox-expiration', 'ExpirationPlugin');\n          pluginCode = `new ${plugin}(${stringifyWithoutComments(pluginConfig)})`;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(errors['bad-runtime-caching-config'] + pluginName);\n        }\n    }\n\n    plugins.push(pluginCode);\n  }\n\n  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {\n    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);\n    return ol`{\n      ${optionsString ? optionsString + ',' : ''}\n      plugins: [${plugins.join(', ')}]\n    }`;\n  } else {\n    return '';\n  }\n}\n\nmodule.exports = (moduleRegistry, runtimeCaching) => {\n  return runtimeCaching.map(entry => {\n    const method = entry.method || 'GET';\n\n    if (!entry.urlPattern) {\n      throw new Error(errors['urlPattern-is-required']);\n    }\n\n    if (!entry.handler) {\n      throw new Error(errors['handler-is-required']);\n    } // This validation logic is a bit too gnarly for joi, so it's manually\n    // implemented here.\n\n\n    if (entry.options && entry.options.networkTimeoutSeconds && entry.handler !== 'NetworkFirst') {\n      throw new Error(errors['invalid-network-timeout-seconds']);\n    } // urlPattern might be a string, a RegExp object, or a function.\n    // If it's a string, it needs to be quoted.\n\n\n    const matcher = typeof entry.urlPattern === 'string' ? JSON.stringify(entry.urlPattern) : entry.urlPattern;\n    const registerRoute = moduleRegistry.use('workbox-routing', 'registerRoute');\n\n    if (typeof entry.handler === 'string') {\n      const optionsString = getOptionsString(moduleRegistry, entry.options);\n      const handler = moduleRegistry.use('workbox-strategies', entry.handler);\n      const strategyString = `new ${handler}(${optionsString})`;\n      return `${registerRoute}(${matcher}, ${strategyString}, '${method}');\\n`;\n    } else if (typeof entry.handler === 'function') {\n      return `${registerRoute}(${matcher}, ${entry.handler}, '${method}');\\n`;\n    }\n  }).filter(entry => Boolean(entry)); // Remove undefined map() return values.\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/lib/runtime-caching-converter.js"],"names":["ol","require","oneLine","errors","stringifyWithoutComments","getOptionsString","moduleRegistry","options","plugins","map","handlerOptionKeys","handlerOptions","key","pluginName","pluginConfig","Object","entries","keys","length","pluginCode","name","plugin","use","JSON","stringify","channelName","opts","assign","Error","push","optionsString","slice","join","module","exports","runtimeCaching","entry","method","urlPattern","handler","networkTimeoutSeconds","matcher","registerRoute","strategyString","filter","Boolean"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst ol = require('common-tags').oneLine;\n\nconst errors = require('./errors');\n\nconst stringifyWithoutComments = require('./stringify-without-comments');\n/**\n * Given a set of options that configures runtime caching behavior, convert it\n * to the equivalent Workbox method calls.\n *\n * @param {ModuleRegistry} moduleRegistry\n * @param {Object} options See\n *        https://developers.google.com/web/tools/workbox/modules/workbox-build#generateSW-runtimeCaching\n * @return {string} A JSON string representing the equivalent options.\n *\n * @private\n */\n\n\nfunction getOptionsString(moduleRegistry, options = {}) {\n  let plugins = [];\n\n  if (options.plugins) {\n    // Using libs because JSON.stringify won't handle functions.\n    plugins = options.plugins.map(stringifyWithoutComments);\n    delete options.plugins;\n  } // Pull handler-specific config from the options object, since they are\n  // not directly used to construct a plugin instance. If set, need to be\n  // passed as options to the handler constructor instead.\n\n\n  const handlerOptionKeys = ['cacheName', 'networkTimeoutSeconds', 'fetchOptions', 'matchOptions'];\n  const handlerOptions = {};\n\n  for (const key of handlerOptionKeys) {\n    if (key in options) {\n      handlerOptions[key] = options[key];\n      delete options[key];\n    }\n  }\n\n  for (const [pluginName, pluginConfig] of Object.entries(options)) {\n    // Ensure that we have some valid configuration to pass to the plugin.\n    if (Object.keys(pluginConfig).length === 0) {\n      continue;\n    }\n\n    let pluginCode;\n\n    switch (pluginName) {\n      case 'backgroundSync':\n        {\n          const name = pluginConfig.name;\n          const plugin = moduleRegistry.use('workbox-background-sync', 'BackgroundSyncPlugin');\n          pluginCode = `new ${plugin}(${JSON.stringify(name)}`;\n\n          if ('options' in pluginConfig) {\n            pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;\n          }\n\n          pluginCode += `)`;\n          break;\n        }\n\n      case 'broadcastUpdate':\n        {\n          const channelName = pluginConfig.channelName;\n          const opts = Object.assign({\n            channelName\n          }, pluginConfig.options);\n          const plugin = moduleRegistry.use('workbox-broadcast-update', 'BroadcastUpdatePlugin');\n          pluginCode = `new ${plugin}(${stringifyWithoutComments(opts)})`;\n          break;\n        }\n\n      case 'cacheableResponse':\n        {\n          const plugin = moduleRegistry.use('workbox-cacheable-response', 'CacheableResponsePlugin');\n          pluginCode = `new ${plugin}(${stringifyWithoutComments(pluginConfig)})`;\n          break;\n        }\n\n      case 'expiration':\n        {\n          const plugin = moduleRegistry.use('workbox-expiration', 'ExpirationPlugin');\n          pluginCode = `new ${plugin}(${stringifyWithoutComments(pluginConfig)})`;\n          break;\n        }\n\n      default:\n        {\n          throw new Error(errors['bad-runtime-caching-config'] + pluginName);\n        }\n    }\n\n    plugins.push(pluginCode);\n  }\n\n  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {\n    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);\n    return ol`{\n      ${optionsString ? optionsString + ',' : ''}\n      plugins: [${plugins.join(', ')}]\n    }`;\n  } else {\n    return '';\n  }\n}\n\nmodule.exports = (moduleRegistry, runtimeCaching) => {\n  return runtimeCaching.map(entry => {\n    const method = entry.method || 'GET';\n\n    if (!entry.urlPattern) {\n      throw new Error(errors['urlPattern-is-required']);\n    }\n\n    if (!entry.handler) {\n      throw new Error(errors['handler-is-required']);\n    } // This validation logic is a bit too gnarly for joi, so it's manually\n    // implemented here.\n\n\n    if (entry.options && entry.options.networkTimeoutSeconds && entry.handler !== 'NetworkFirst') {\n      throw new Error(errors['invalid-network-timeout-seconds']);\n    } // urlPattern might be a string, a RegExp object, or a function.\n    // If it's a string, it needs to be quoted.\n\n\n    const matcher = typeof entry.urlPattern === 'string' ? JSON.stringify(entry.urlPattern) : entry.urlPattern;\n    const registerRoute = moduleRegistry.use('workbox-routing', 'registerRoute');\n\n    if (typeof entry.handler === 'string') {\n      const optionsString = getOptionsString(moduleRegistry, entry.options);\n      const handler = moduleRegistry.use('workbox-strategies', entry.handler);\n      const strategyString = `new ${handler}(${optionsString})`;\n      return `${registerRoute}(${matcher}, ${strategyString}, '${method}');\\n`;\n    } else if (typeof entry.handler === 'function') {\n      return `${registerRoute}(${matcher}, ${entry.handler}, '${method}');\\n`;\n    }\n  }).filter(entry => Boolean(entry)); // Remove undefined map() return values.\n};"]},"metadata":{},"sourceType":"script"}