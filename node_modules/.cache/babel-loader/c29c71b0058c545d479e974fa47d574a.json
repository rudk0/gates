{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addCreateSuperHelper;\n\nvar _core = require(\"@babel/core\");\n\nconst helperIDs = new WeakMap();\n\nfunction addCreateSuperHelper(file) {\n  if (helperIDs.has(file)) {\n    return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));\n  }\n\n  try {\n    return file.addHelper(\"createSuper\");\n  } catch (_unused) {}\n\n  const id = file.scope.generateUidIdentifier(\"createSuper\");\n  helperIDs.set(file, id);\n  const fn = helper({\n    CREATE_SUPER: id,\n    GET_PROTOTYPE_OF: file.addHelper(\"getPrototypeOf\"),\n    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper(\"possibleConstructorReturn\")\n  });\n  file.path.unshiftContainer(\"body\", [fn]);\n  file.scope.registerDeclaration(file.path.get(\"body.0\"));\n  return _core.types.cloneNode(id);\n}\n\nconst helper = _core.template.statement`\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n`;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-classes/lib/inline-createSuper-helpers.js"],"names":["Object","defineProperty","exports","value","default","addCreateSuperHelper","_core","require","helperIDs","WeakMap","file","has","types","cloneNode","clone","get","addHelper","_unused","id","scope","generateUidIdentifier","set","fn","helper","CREATE_SUPER","GET_PROTOTYPE_OF","POSSIBLE_CONSTRUCTOR_RETURN","path","unshiftContainer","registerDeclaration","template","statement"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,oBAAlB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,aAAD,CAAnB;;AAEA,MAAMC,SAAS,GAAG,IAAIC,OAAJ,EAAlB;;AAEA,SAASJ,oBAAT,CAA8BK,IAA9B,EAAoC;AAClC,MAAIF,SAAS,CAACG,GAAV,CAAcD,IAAd,CAAJ,EAAyB;AACvB,WAAO,CAACJ,KAAK,CAACM,KAAN,CAAYC,SAAZ,IAAyBP,KAAK,CAACM,KAAN,CAAYE,KAAtC,EAA6CN,SAAS,CAACO,GAAV,CAAcL,IAAd,CAA7C,CAAP;AACD;;AAED,MAAI;AACF,WAAOA,IAAI,CAACM,SAAL,CAAe,aAAf,CAAP;AACD,GAFD,CAEE,OAAOC,OAAP,EAAgB,CAAE;;AAEpB,QAAMC,EAAE,GAAGR,IAAI,CAACS,KAAL,CAAWC,qBAAX,CAAiC,aAAjC,CAAX;AACAZ,EAAAA,SAAS,CAACa,GAAV,CAAcX,IAAd,EAAoBQ,EAApB;AACA,QAAMI,EAAE,GAAGC,MAAM,CAAC;AAChBC,IAAAA,YAAY,EAAEN,EADE;AAEhBO,IAAAA,gBAAgB,EAAEf,IAAI,CAACM,SAAL,CAAe,gBAAf,CAFF;AAGhBU,IAAAA,2BAA2B,EAAEhB,IAAI,CAACM,SAAL,CAAe,2BAAf;AAHb,GAAD,CAAjB;AAKAN,EAAAA,IAAI,CAACiB,IAAL,CAAUC,gBAAV,CAA2B,MAA3B,EAAmC,CAACN,EAAD,CAAnC;AACAZ,EAAAA,IAAI,CAACS,KAAL,CAAWU,mBAAX,CAA+BnB,IAAI,CAACiB,IAAL,CAAUZ,GAAV,CAAc,QAAd,CAA/B;AACA,SAAOT,KAAK,CAACM,KAAN,CAAYC,SAAZ,CAAsBK,EAAtB,CAAP;AACD;;AAED,MAAMK,MAAM,GAAGjB,KAAK,CAACwB,QAAN,CAAeC,SAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAxC","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = addCreateSuperHelper;\n\nvar _core = require(\"@babel/core\");\n\nconst helperIDs = new WeakMap();\n\nfunction addCreateSuperHelper(file) {\n  if (helperIDs.has(file)) {\n    return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));\n  }\n\n  try {\n    return file.addHelper(\"createSuper\");\n  } catch (_unused) {}\n\n  const id = file.scope.generateUidIdentifier(\"createSuper\");\n  helperIDs.set(file, id);\n  const fn = helper({\n    CREATE_SUPER: id,\n    GET_PROTOTYPE_OF: file.addHelper(\"getPrototypeOf\"),\n    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper(\"possibleConstructorReturn\")\n  });\n  file.path.unshiftContainer(\"body\", [fn]);\n  file.scope.registerDeclaration(file.path.get(\"body.0\"));\n  return _core.types.cloneNode(id);\n}\n\nconst helper = _core.template.statement`\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n`;"]},"metadata":{},"sourceType":"script"}