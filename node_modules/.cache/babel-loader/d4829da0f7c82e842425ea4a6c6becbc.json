{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose,\n    allowArrayLike\n  } = options;\n\n  function getSpreadLiteral(spread, scope) {\n    if (loose && !_core.types.isIdentifier(spread.argument, {\n      name: \"arguments\"\n    })) {\n      return spread.argument;\n    } else {\n      return scope.toArray(spread.argument, true, allowArrayLike);\n    }\n  }\n\n  function hasSpread(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (_core.types.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function push(_props, nodes) {\n    if (!_props.length) return _props;\n    nodes.push(_core.types.arrayExpression(_props));\n    return [];\n  }\n\n  function build(props, scope) {\n    const nodes = [];\n    let _props = [];\n\n    for (const prop of props) {\n      if (_core.types.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        nodes.push(getSpreadLiteral(prop, scope));\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n    visitor: {\n      ArrayExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n        const nodes = build(elements, scope);\n        let first = nodes[0];\n\n        if (nodes.length === 1 && first !== elements[0].argument) {\n          path.replaceWith(first);\n          return;\n        }\n\n        if (!_core.types.isArrayExpression(first)) {\n          first = _core.types.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n      },\n\n      CallExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const args = node.arguments;\n        if (!hasSpread(args)) return;\n        const calleePath = path.get(\"callee\");\n        if (calleePath.isSuper()) return;\n        let contextLiteral = scope.buildUndefinedNode();\n        node.arguments = [];\n        let nodes;\n\n        if (args.length === 1 && args[0].argument.name === \"arguments\") {\n          nodes = [args[0].argument];\n        } else {\n          nodes = build(args, scope);\n        }\n\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = node.callee;\n\n        if (calleePath.isMemberExpression()) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n\n          if (temp) {\n            callee.object = _core.types.assignmentExpression(\"=\", temp, callee.object);\n            contextLiteral = temp;\n          } else {\n            contextLiteral = _core.types.cloneNode(callee.object);\n          }\n\n          _core.types.appendToMemberExpression(callee, _core.types.identifier(\"apply\"));\n        } else {\n          node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"apply\"));\n        }\n\n        if (_core.types.isSuper(contextLiteral)) {\n          contextLiteral = _core.types.thisExpression();\n        }\n\n        node.arguments.unshift(_core.types.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        let args = node.arguments;\n        if (!hasSpread(args)) return;\n        const nodes = build(args, scope);\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes);\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(_core.types.callExpression(path.hub.addHelper(\"construct\"), [node.callee, args]));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-spread/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","options","assertVersion","loose","allowArrayLike","getSpreadLiteral","spread","scope","types","isIdentifier","argument","name","toArray","hasSpread","nodes","i","length","isSpreadElement","push","_props","arrayExpression","build","props","prop","visitor","ArrayExpression","path","node","elements","first","replaceWith","isArrayExpression","shift","callExpression","memberExpression","identifier","CallExpression","args","arguments","calleePath","get","isSuper","contextLiteral","buildUndefinedNode","callee","isMemberExpression","temp","maybeGenerateMemoised","object","assignmentExpression","cloneNode","appendToMemberExpression","thisExpression","unshift","NewExpression","hub","addHelper"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose,\n    allowArrayLike\n  } = options;\n\n  function getSpreadLiteral(spread, scope) {\n    if (loose && !_core.types.isIdentifier(spread.argument, {\n      name: \"arguments\"\n    })) {\n      return spread.argument;\n    } else {\n      return scope.toArray(spread.argument, true, allowArrayLike);\n    }\n  }\n\n  function hasSpread(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (_core.types.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function push(_props, nodes) {\n    if (!_props.length) return _props;\n    nodes.push(_core.types.arrayExpression(_props));\n    return [];\n  }\n\n  function build(props, scope) {\n    const nodes = [];\n    let _props = [];\n\n    for (const prop of props) {\n      if (_core.types.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        nodes.push(getSpreadLiteral(prop, scope));\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n    visitor: {\n      ArrayExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n        const nodes = build(elements, scope);\n        let first = nodes[0];\n\n        if (nodes.length === 1 && first !== elements[0].argument) {\n          path.replaceWith(first);\n          return;\n        }\n\n        if (!_core.types.isArrayExpression(first)) {\n          first = _core.types.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n      },\n\n      CallExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const args = node.arguments;\n        if (!hasSpread(args)) return;\n        const calleePath = path.get(\"callee\");\n        if (calleePath.isSuper()) return;\n        let contextLiteral = scope.buildUndefinedNode();\n        node.arguments = [];\n        let nodes;\n\n        if (args.length === 1 && args[0].argument.name === \"arguments\") {\n          nodes = [args[0].argument];\n        } else {\n          nodes = build(args, scope);\n        }\n\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = node.callee;\n\n        if (calleePath.isMemberExpression()) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n\n          if (temp) {\n            callee.object = _core.types.assignmentExpression(\"=\", temp, callee.object);\n            contextLiteral = temp;\n          } else {\n            contextLiteral = _core.types.cloneNode(callee.object);\n          }\n\n          _core.types.appendToMemberExpression(callee, _core.types.identifier(\"apply\"));\n        } else {\n          node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"apply\"));\n        }\n\n        if (_core.types.isSuper(contextLiteral)) {\n          contextLiteral = _core.types.thisExpression();\n        }\n\n        node.arguments.unshift(_core.types.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        let args = node.arguments;\n        if (!hasSpread(args)) return;\n        const nodes = build(args, scope);\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes);\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(_core.types.callExpression(path.hub.addHelper(\"construct\"), [node.callee, args]));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}