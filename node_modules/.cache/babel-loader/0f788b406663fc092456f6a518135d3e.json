{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  const surrogate = /[\\ud800-\\udfff]/g;\n  const unicodeEscape = /(\\\\+)u\\{([0-9a-fA-F]+)\\}/g;\n\n  function escape(code) {\n    let str = code.toString(16);\n\n    while (str.length < 4) str = \"0\" + str;\n\n    return \"\\\\u\" + str;\n  }\n\n  function replacer(match, backslashes, code) {\n    if (backslashes.length % 2 === 0) {\n      return match;\n    }\n\n    const char = String.fromCodePoint(parseInt(code, 16));\n    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));\n    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));\n  }\n\n  function replaceUnicodeEscapes(str) {\n    return str.replace(unicodeEscape, replacer);\n  }\n\n  function getUnicodeEscape(str) {\n    let match;\n\n    while (match = unicodeEscape.exec(str)) {\n      if (match[1].length % 2 === 0) continue;\n      unicodeEscape.lastIndex = 0;\n      return match[0];\n    }\n\n    return null;\n  }\n\n  return {\n    name: \"transform-unicode-escapes\",\n    visitor: {\n      Identifier(path) {\n        const {\n          node,\n          key\n        } = path;\n        const {\n          name\n        } = node;\n        const replaced = name.replace(surrogate, c => {\n          return `_u${c.charCodeAt(0).toString(16)}`;\n        });\n        if (name === replaced) return;\n\n        const str = _core.types.inherits(_core.types.stringLiteral(name), node);\n\n        if (key === \"key\") {\n          path.replaceWith(str);\n          return;\n        }\n\n        const {\n          parentPath,\n          scope\n        } = path;\n\n        if (parentPath.isMemberExpression({\n          property: node\n        }) || parentPath.isOptionalMemberExpression({\n          property: node\n        })) {\n          parentPath.node.computed = true;\n          path.replaceWith(str);\n          return;\n        }\n\n        const binding = scope.getBinding(name);\n\n        if (binding) {\n          scope.rename(name, scope.generateUid(replaced));\n          return;\n        }\n\n        throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);\n      },\n\n      \"StringLiteral|DirectiveLiteral\"(path) {\n        const {\n          node\n        } = path;\n        const {\n          extra\n        } = node;\n        if (extra == null ? void 0 : extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);\n      },\n\n      TemplateElement(path) {\n        const {\n          node,\n          parentPath\n        } = path;\n        const {\n          value\n        } = node;\n        const firstEscape = getUnicodeEscape(value.raw);\n        if (!firstEscape) return;\n        const grandParent = parentPath.parentPath;\n\n        if (grandParent.isTaggedTemplateExpression()) {\n          throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);\n        }\n\n        value.raw = replaceUnicodeEscapes(value.raw);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-unicode-escapes/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","assertVersion","surrogate","unicodeEscape","escape","code","str","toString","length","replacer","match","backslashes","char","String","fromCodePoint","parseInt","escaped","slice","charCodeAt","replaceUnicodeEscapes","replace","getUnicodeEscape","exec","lastIndex","name","visitor","Identifier","path","node","key","replaced","c","types","inherits","stringLiteral","replaceWith","parentPath","scope","isMemberExpression","property","isOptionalMemberExpression","computed","binding","getBinding","rename","generateUid","buildCodeFrameError","extra","raw","TemplateElement","firstEscape","grandParent","isTaggedTemplateExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  const surrogate = /[\\ud800-\\udfff]/g;\n  const unicodeEscape = /(\\\\+)u\\{([0-9a-fA-F]+)\\}/g;\n\n  function escape(code) {\n    let str = code.toString(16);\n\n    while (str.length < 4) str = \"0\" + str;\n\n    return \"\\\\u\" + str;\n  }\n\n  function replacer(match, backslashes, code) {\n    if (backslashes.length % 2 === 0) {\n      return match;\n    }\n\n    const char = String.fromCodePoint(parseInt(code, 16));\n    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));\n    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));\n  }\n\n  function replaceUnicodeEscapes(str) {\n    return str.replace(unicodeEscape, replacer);\n  }\n\n  function getUnicodeEscape(str) {\n    let match;\n\n    while (match = unicodeEscape.exec(str)) {\n      if (match[1].length % 2 === 0) continue;\n      unicodeEscape.lastIndex = 0;\n      return match[0];\n    }\n\n    return null;\n  }\n\n  return {\n    name: \"transform-unicode-escapes\",\n    visitor: {\n      Identifier(path) {\n        const {\n          node,\n          key\n        } = path;\n        const {\n          name\n        } = node;\n        const replaced = name.replace(surrogate, c => {\n          return `_u${c.charCodeAt(0).toString(16)}`;\n        });\n        if (name === replaced) return;\n\n        const str = _core.types.inherits(_core.types.stringLiteral(name), node);\n\n        if (key === \"key\") {\n          path.replaceWith(str);\n          return;\n        }\n\n        const {\n          parentPath,\n          scope\n        } = path;\n\n        if (parentPath.isMemberExpression({\n          property: node\n        }) || parentPath.isOptionalMemberExpression({\n          property: node\n        })) {\n          parentPath.node.computed = true;\n          path.replaceWith(str);\n          return;\n        }\n\n        const binding = scope.getBinding(name);\n\n        if (binding) {\n          scope.rename(name, scope.generateUid(replaced));\n          return;\n        }\n\n        throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);\n      },\n\n      \"StringLiteral|DirectiveLiteral\"(path) {\n        const {\n          node\n        } = path;\n        const {\n          extra\n        } = node;\n        if (extra == null ? void 0 : extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);\n      },\n\n      TemplateElement(path) {\n        const {\n          node,\n          parentPath\n        } = path;\n        const {\n          value\n        } = node;\n        const firstEscape = getUnicodeEscape(value.raw);\n        if (!firstEscape) return;\n        const grandParent = parentPath.parentPath;\n\n        if (grandParent.isTaggedTemplateExpression()) {\n          throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);\n        }\n\n        value.raw = replaceUnicodeEscapes(value.raw);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}