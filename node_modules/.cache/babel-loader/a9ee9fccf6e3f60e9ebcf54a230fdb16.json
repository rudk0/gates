{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst maximumSizeTransform = require('./maximum-size-transform');\n\nconst modifyURLPrefixTranform = require('./modify-url-prefix-transform');\n\nconst noRevisionForURLsMatchingTransform = require('./no-revision-for-urls-matching-transform');\n/**\n * A `ManifestTransform` function can be used to modify the modify the `url` or\n * `revision` properties of some or all of the\n * {@link module:workbox-build#ManifestEntry|ManifestEntries} in the manifest.\n *\n * Deleting the `revision` property of an entry will cause\n * the corresponding `url` to be precached without cache-busting parameters\n * applied, which is to say, it implies that the URL itself contains\n * proper versioning info. If the `revision` property is present, it must be\n * set to a string.\n *\n * @example <caption>A transformation that prepended the origin of a CDN for any\n * URL starting with '/assets/' could be implemented as:</caption>\n *\n * const cdnTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const cdnOrigin = 'https://example.com';\n *     if (entry.url.startsWith('/assets/')) {\n *       entry.url = cdnOrigin + entry.url;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @example <caption>A transformation that removes the revision field when the\n * URL contains an 8-character hash surrounded by '.', indicating that it\n * already contains revision information:</caption>\n *\n * const removeRevisionTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const hashRegExp = /\\.\\w{8}\\./;\n *     if (entry.url.match(hashRegExp)) {\n *       delete entry.revision;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @callback ManifestTransform\n * @param {Array<module:workbox-build.ManifestEntry>} manifestEntries The full\n * array of entries, prior to the current transformation.\n * @return {module:workbox-build.ManifestTransformResult}\n * The array of entries with the transformation applied, and optionally, any\n * warnings that should be reported back to the build tool.\n *\n * @memberof module:workbox-build\n */\n\n\nmodule.exports = ({\n  dontCacheBustURLsMatching,\n  fileDetails,\n  manifestTransforms,\n  maximumFileSizeToCacheInBytes,\n  modifyURLPrefix\n}) => {\n  let allWarnings = []; // Take the array of fileDetail objects and convert it into an array of\n  // {url, revision, size} objects, with \\ replaced with /.\n\n  const normalizedManifest = fileDetails.map(fileDetails => {\n    return {\n      url: fileDetails.file.replace(/\\\\/g, '/'),\n      revision: fileDetails.hash,\n      size: fileDetails.size\n    };\n  });\n  let transformsToApply = [];\n\n  if (maximumFileSizeToCacheInBytes) {\n    transformsToApply.push(maximumSizeTransform(maximumFileSizeToCacheInBytes));\n  }\n\n  if (modifyURLPrefix) {\n    transformsToApply.push(modifyURLPrefixTranform(modifyURLPrefix));\n  }\n\n  if (dontCacheBustURLsMatching) {\n    transformsToApply.push(noRevisionForURLsMatchingTransform(dontCacheBustURLsMatching));\n  } // Any additional manifestTransforms that were passed will be applied last.\n\n\n  transformsToApply = transformsToApply.concat(manifestTransforms || []);\n  let transformedManifest = normalizedManifest;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = transformsToApply[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const transform = _step.value;\n\n      const _transform = transform(transformedManifest),\n            manifest = _transform.manifest,\n            warnings = _transform.warnings;\n\n      transformedManifest = manifest;\n      allWarnings = allWarnings.concat(warnings || []);\n    } // Generate some metadata about the manifest before we clear out the size\n    // properties from each entry.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  const count = transformedManifest.length;\n  let size = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = transformedManifest[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      const manifestEntry = _step2.value;\n      size += manifestEntry.size;\n      delete manifestEntry.size;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    count,\n    size,\n    manifestEntries: transformedManifest,\n    warnings: allWarnings\n  };\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/lib/filter-files.js"],"names":["maximumSizeTransform","require","modifyURLPrefixTranform","noRevisionForURLsMatchingTransform","module","exports","dontCacheBustURLsMatching","fileDetails","manifestTransforms","maximumFileSizeToCacheInBytes","modifyURLPrefix","allWarnings","normalizedManifest","map","url","file","replace","revision","hash","size","transformsToApply","push","concat","transformedManifest","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","transform","value","_transform","manifest","warnings","err","return","count","length","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","manifestEntry","manifestEntries"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst maximumSizeTransform = require('./maximum-size-transform');\n\nconst modifyURLPrefixTranform = require('./modify-url-prefix-transform');\n\nconst noRevisionForURLsMatchingTransform = require('./no-revision-for-urls-matching-transform');\n/**\n * A `ManifestTransform` function can be used to modify the modify the `url` or\n * `revision` properties of some or all of the\n * {@link module:workbox-build#ManifestEntry|ManifestEntries} in the manifest.\n *\n * Deleting the `revision` property of an entry will cause\n * the corresponding `url` to be precached without cache-busting parameters\n * applied, which is to say, it implies that the URL itself contains\n * proper versioning info. If the `revision` property is present, it must be\n * set to a string.\n *\n * @example <caption>A transformation that prepended the origin of a CDN for any\n * URL starting with '/assets/' could be implemented as:</caption>\n *\n * const cdnTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const cdnOrigin = 'https://example.com';\n *     if (entry.url.startsWith('/assets/')) {\n *       entry.url = cdnOrigin + entry.url;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @example <caption>A transformation that removes the revision field when the\n * URL contains an 8-character hash surrounded by '.', indicating that it\n * already contains revision information:</caption>\n *\n * const removeRevisionTransform = (manifestEntries) => {\n *   const manifest = manifestEntries.map(entry => {\n *     const hashRegExp = /\\.\\w{8}\\./;\n *     if (entry.url.match(hashRegExp)) {\n *       delete entry.revision;\n *     }\n *     return entry;\n *   });\n *   return {manifest, warnings: []};\n * };\n *\n * @callback ManifestTransform\n * @param {Array<module:workbox-build.ManifestEntry>} manifestEntries The full\n * array of entries, prior to the current transformation.\n * @return {module:workbox-build.ManifestTransformResult}\n * The array of entries with the transformation applied, and optionally, any\n * warnings that should be reported back to the build tool.\n *\n * @memberof module:workbox-build\n */\n\n\nmodule.exports = ({\n  dontCacheBustURLsMatching,\n  fileDetails,\n  manifestTransforms,\n  maximumFileSizeToCacheInBytes,\n  modifyURLPrefix\n}) => {\n  let allWarnings = []; // Take the array of fileDetail objects and convert it into an array of\n  // {url, revision, size} objects, with \\ replaced with /.\n\n  const normalizedManifest = fileDetails.map(fileDetails => {\n    return {\n      url: fileDetails.file.replace(/\\\\/g, '/'),\n      revision: fileDetails.hash,\n      size: fileDetails.size\n    };\n  });\n  let transformsToApply = [];\n\n  if (maximumFileSizeToCacheInBytes) {\n    transformsToApply.push(maximumSizeTransform(maximumFileSizeToCacheInBytes));\n  }\n\n  if (modifyURLPrefix) {\n    transformsToApply.push(modifyURLPrefixTranform(modifyURLPrefix));\n  }\n\n  if (dontCacheBustURLsMatching) {\n    transformsToApply.push(noRevisionForURLsMatchingTransform(dontCacheBustURLsMatching));\n  } // Any additional manifestTransforms that were passed will be applied last.\n\n\n  transformsToApply = transformsToApply.concat(manifestTransforms || []);\n  let transformedManifest = normalizedManifest;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = transformsToApply[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const transform = _step.value;\n\n      const _transform = transform(transformedManifest),\n            manifest = _transform.manifest,\n            warnings = _transform.warnings;\n\n      transformedManifest = manifest;\n      allWarnings = allWarnings.concat(warnings || []);\n    } // Generate some metadata about the manifest before we clear out the size\n    // properties from each entry.\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  const count = transformedManifest.length;\n  let size = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = transformedManifest[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      const manifestEntry = _step2.value;\n      size += manifestEntry.size;\n      delete manifestEntry.size;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    count,\n    size,\n    manifestEntries: transformedManifest,\n    warnings: allWarnings\n  };\n};"]},"metadata":{},"sourceType":"script"}