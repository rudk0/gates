{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose\n  } = options;\n  const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;\n  const buildMutatorMapAssign = (0, _core.template)(`\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  `);\n\n  function getValue(prop) {\n    if (_core.types.isObjectProperty(prop)) {\n      return prop.value;\n    } else if (_core.types.isObjectMethod(prop)) {\n      return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);\n    }\n  }\n\n  function pushAssign(objId, prop, body) {\n    if (prop.kind === \"get\" && prop.kind === \"set\") {\n      pushMutatorDefine(objId, prop, body);\n    } else {\n      body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));\n    }\n  }\n\n  function pushMutatorDefine({\n    body,\n    getMutatorId,\n    scope\n  }, prop) {\n    let key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;\n    const maybeMemoise = scope.maybeGenerateMemoised(key);\n\n    if (maybeMemoise) {\n      body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", maybeMemoise, key)));\n      key = maybeMemoise;\n    }\n\n    body.push(...buildMutatorMapAssign({\n      MUTATOR_MAP_REF: getMutatorId(),\n      KEY: _core.types.cloneNode(key),\n      VALUE: getValue(prop),\n      KIND: _core.types.identifier(prop.kind)\n    }));\n  }\n\n  function pushComputedPropsLoose(info) {\n    for (const prop of info.computedProps) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        pushMutatorDefine(info, prop);\n      } else {\n        pushAssign(_core.types.cloneNode(info.objId), prop, info.body);\n      }\n    }\n  }\n\n  function pushComputedPropsSpec(info) {\n    const {\n      objId,\n      body,\n      computedProps,\n      state\n    } = info;\n\n    for (const prop of computedProps) {\n      const key = _core.types.toComputedKey(prop);\n\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        pushMutatorDefine(info, prop);\n      } else if (_core.types.isStringLiteral(key, {\n        value: \"__proto__\"\n      })) {\n        pushAssign(objId, prop, body);\n      } else {\n        if (computedProps.length === 1) {\n          return _core.types.callExpression(state.addHelper(\"defineProperty\"), [info.initPropExpression, key, getValue(prop)]);\n        } else {\n          body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [_core.types.cloneNode(objId), key, getValue(prop)])));\n        }\n      }\n    }\n  }\n\n  return {\n    name: \"transform-computed-properties\",\n    visitor: {\n      ObjectExpression: {\n        exit(path, state) {\n          const {\n            node,\n            parent,\n            scope\n          } = path;\n          let hasComputed = false;\n\n          for (const prop of node.properties) {\n            hasComputed = prop.computed === true;\n            if (hasComputed) break;\n          }\n\n          if (!hasComputed) return;\n          const initProps = [];\n          const computedProps = [];\n          let foundComputed = false;\n\n          for (const prop of node.properties) {\n            if (prop.computed) {\n              foundComputed = true;\n            }\n\n            if (foundComputed) {\n              computedProps.push(prop);\n            } else {\n              initProps.push(prop);\n            }\n          }\n\n          const objId = scope.generateUidIdentifierBasedOnNode(parent);\n\n          const initPropExpression = _core.types.objectExpression(initProps);\n\n          const body = [];\n          body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(objId, initPropExpression)]));\n          let mutatorRef;\n\n          const getMutatorId = function () {\n            if (!mutatorRef) {\n              mutatorRef = scope.generateUidIdentifier(\"mutatorMap\");\n              body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(mutatorRef, _core.types.objectExpression([]))]));\n            }\n\n            return _core.types.cloneNode(mutatorRef);\n          };\n\n          const single = pushComputedProps({\n            scope,\n            objId,\n            body,\n            computedProps,\n            initPropExpression,\n            getMutatorId,\n            state\n          });\n\n          if (mutatorRef) {\n            body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineEnumerableProperties\"), [_core.types.cloneNode(objId), _core.types.cloneNode(mutatorRef)])));\n          }\n\n          if (single) {\n            path.replaceWith(single);\n          } else {\n            body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));\n            path.replaceWithMultiple(body);\n          }\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-computed-properties/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","options","assertVersion","loose","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","buildMutatorMapAssign","template","getValue","prop","types","isObjectProperty","isObjectMethod","functionExpression","params","body","generator","async","pushAssign","objId","kind","pushMutatorDefine","push","expressionStatement","assignmentExpression","memberExpression","cloneNode","key","computed","isLiteral","getMutatorId","scope","isIdentifier","stringLiteral","name","maybeMemoise","maybeGenerateMemoised","MUTATOR_MAP_REF","KEY","VALUE","KIND","identifier","info","computedProps","state","toComputedKey","isStringLiteral","length","callExpression","addHelper","initPropExpression","visitor","ObjectExpression","exit","path","node","parent","hasComputed","properties","initProps","foundComputed","generateUidIdentifierBasedOnNode","objectExpression","variableDeclaration","variableDeclarator","mutatorRef","generateUidIdentifier","single","replaceWith","replaceWithMultiple"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose\n  } = options;\n  const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;\n  const buildMutatorMapAssign = (0, _core.template)(`\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  `);\n\n  function getValue(prop) {\n    if (_core.types.isObjectProperty(prop)) {\n      return prop.value;\n    } else if (_core.types.isObjectMethod(prop)) {\n      return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);\n    }\n  }\n\n  function pushAssign(objId, prop, body) {\n    if (prop.kind === \"get\" && prop.kind === \"set\") {\n      pushMutatorDefine(objId, prop, body);\n    } else {\n      body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));\n    }\n  }\n\n  function pushMutatorDefine({\n    body,\n    getMutatorId,\n    scope\n  }, prop) {\n    let key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;\n    const maybeMemoise = scope.maybeGenerateMemoised(key);\n\n    if (maybeMemoise) {\n      body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", maybeMemoise, key)));\n      key = maybeMemoise;\n    }\n\n    body.push(...buildMutatorMapAssign({\n      MUTATOR_MAP_REF: getMutatorId(),\n      KEY: _core.types.cloneNode(key),\n      VALUE: getValue(prop),\n      KIND: _core.types.identifier(prop.kind)\n    }));\n  }\n\n  function pushComputedPropsLoose(info) {\n    for (const prop of info.computedProps) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        pushMutatorDefine(info, prop);\n      } else {\n        pushAssign(_core.types.cloneNode(info.objId), prop, info.body);\n      }\n    }\n  }\n\n  function pushComputedPropsSpec(info) {\n    const {\n      objId,\n      body,\n      computedProps,\n      state\n    } = info;\n\n    for (const prop of computedProps) {\n      const key = _core.types.toComputedKey(prop);\n\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        pushMutatorDefine(info, prop);\n      } else if (_core.types.isStringLiteral(key, {\n        value: \"__proto__\"\n      })) {\n        pushAssign(objId, prop, body);\n      } else {\n        if (computedProps.length === 1) {\n          return _core.types.callExpression(state.addHelper(\"defineProperty\"), [info.initPropExpression, key, getValue(prop)]);\n        } else {\n          body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [_core.types.cloneNode(objId), key, getValue(prop)])));\n        }\n      }\n    }\n  }\n\n  return {\n    name: \"transform-computed-properties\",\n    visitor: {\n      ObjectExpression: {\n        exit(path, state) {\n          const {\n            node,\n            parent,\n            scope\n          } = path;\n          let hasComputed = false;\n\n          for (const prop of node.properties) {\n            hasComputed = prop.computed === true;\n            if (hasComputed) break;\n          }\n\n          if (!hasComputed) return;\n          const initProps = [];\n          const computedProps = [];\n          let foundComputed = false;\n\n          for (const prop of node.properties) {\n            if (prop.computed) {\n              foundComputed = true;\n            }\n\n            if (foundComputed) {\n              computedProps.push(prop);\n            } else {\n              initProps.push(prop);\n            }\n          }\n\n          const objId = scope.generateUidIdentifierBasedOnNode(parent);\n\n          const initPropExpression = _core.types.objectExpression(initProps);\n\n          const body = [];\n          body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(objId, initPropExpression)]));\n          let mutatorRef;\n\n          const getMutatorId = function () {\n            if (!mutatorRef) {\n              mutatorRef = scope.generateUidIdentifier(\"mutatorMap\");\n              body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(mutatorRef, _core.types.objectExpression([]))]));\n            }\n\n            return _core.types.cloneNode(mutatorRef);\n          };\n\n          const single = pushComputedProps({\n            scope,\n            objId,\n            body,\n            computedProps,\n            initPropExpression,\n            getMutatorId,\n            state\n          });\n\n          if (mutatorRef) {\n            body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineEnumerableProperties\"), [_core.types.cloneNode(objId), _core.types.cloneNode(mutatorRef)])));\n          }\n\n          if (single) {\n            path.replaceWith(single);\n          } else {\n            body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));\n            path.replaceWithMultiple(body);\n          }\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}