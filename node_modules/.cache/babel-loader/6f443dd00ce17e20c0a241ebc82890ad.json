{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst assert = require('assert');\n\nconst fse = require('fs-extra');\n\nconst sourceMapURL = require('source-map-url');\n\nconst stringify = require('fast-json-stable-stringify');\n\nconst upath = require('upath');\n\nconst errors = require('./lib/errors');\n\nconst escapeRegexp = require('./lib/escape-regexp');\n\nconst getFileManifestEntries = require('./lib/get-file-manifest-entries');\n\nconst injectManifestSchema = require('./options/schema/inject-manifest');\n\nconst rebasePath = require('./lib/rebase-path');\n\nconst replaceAndUpdateSourceMap = require('./lib/replace-and-update-source-map');\n\nconst validate = require('./lib/validate-options'); // eslint-disable-next-line jsdoc/newline-after-description\n\n/**\n * This method creates a list of URLs to precache, referred to as a \"precache\n * manifest\", based on the options you provide.\n *\n * The manifest is injected into the `swSrc` file, and the placeholder string\n * `injectionPoint` determines where in the file the manifest should go.\n *\n * The final service worker file, with the manifest injected, is written to\n * disk at `swDest`.\n *\n * @param {Object} config The configuration to use.\n *\n * @param {string} config.globDirectory The local directory you wish to match\n * `globPatterns` against. The path is relative to the current directory.\n *\n * @param {string} config.swDest The path and filename of the service worker file\n * that will be created by the build process, relative to the current working\n * directory. It must end in '.js'.\n *\n * @param {string} config.swSrc The path and filename of the service worker file\n * that will be read during the build process, relative to the current working\n * directory.\n *\n * @param {Array<module:workbox-build.ManifestEntry>} [config.additionalManifestEntries]\n * A list of entries to be precached, in addition to any entries that are\n * generated as part of the build configuration.\n *\n * @param {RegExp} [config.dontCacheBustURLsMatching] Assets that match this will be\n * assumed to be uniquely versioned via their URL, and exempted from the normal\n * HTTP cache-busting that's done when populating the precache. While not\n * required, it's recommended that if your existing build process already\n * inserts a `[hash]` value into each filename, you provide a RegExp that will\n * detect that, as it will reduce the bandwidth consumed when precaching.\n *\n * @param {boolean} [config.globFollow=true] Determines whether or not symlinks\n * are followed when generating the precache manifest. For more information, see\n * the definition of `follow` in the `glob`\n * [documentation](https://github.com/isaacs/node-glob#options).\n *\n * @param {Array<string>} [config.globIgnores=['node_modules/**']]\n * A set of patterns matching files to always exclude when generating the\n * precache manifest. For more information, see the definition of `ignore` in the `glob`\n * [documentation](https://github.com/isaacs/node-glob#options).\n *\n * @param {Array<string>} [config.globPatterns=['**.{js,css,html}']]\n * Files matching any of these patterns will be included in the precache\n * manifest. For more information, see the\n * [`glob` primer](https://github.com/isaacs/node-glob#glob-primer).\n *\n * @param {boolean} [config.globStrict=true] If true, an error reading a directory when\n * generating a precache manifest will cause the build to fail. If false, the\n * problematic directory will be skipped. For more information, see the\n * definition of `strict` in the `glob`\n * [documentation](https://github.com/isaacs/node-glob#options).\n *\n * @param  {string} [config.injectionPoint='self.__WB_MANIFEST'] The string to\n * find inside of the `swSrc` file. Once found, it will be replaced by the\n * generated precache manifest.\n *\n * @param {Array<module:workbox-build.ManifestTransform>} [config.manifestTransforms] One or more\n * functions which will be applied sequentially against the generated manifest.\n * If `modifyURLPrefix` or `dontCacheBustURLsMatching` are also specified, their\n * corresponding transformations will be applied first.\n *\n * @param {number} [config.maximumFileSizeToCacheInBytes=2097152] This value can be\n * used to determine the maximum size of files that will be precached. This\n * prevents you from inadvertently precaching very large files that might have\n * accidentally matched one of your patterns.\n *\n * @param {string} [config.mode='production'] If set to 'production', then an\n * optimized service worker bundle that excludes debugging info will be\n * produced. If not explicitly configured here, the `process.env.NODE_ENV` value\n * will be used, and failing that, it will fall back to `'production'`.\n *\n * @param {object<string, string>} [config.modifyURLPrefix] A mapping of prefixes\n * that, if present in an entry in the precache manifest, will be replaced with\n * the corresponding value. This can be used to, for example, remove or add a\n * path prefix from a manifest entry if your web hosting setup doesn't match\n * your local filesystem setup. As an alternative with more flexibility, you can\n * use the `manifestTransforms` option and provide a function that modifies the\n * entries in the manifest using whatever logic you provide.\n *\n * @param {Object} [config.templatedURLs] If a URL is rendered based on some\n * server-side logic, its contents may depend on multiple files or on some other\n * unique string value. The keys in this object are server-rendered URLs. If the\n * values are an array of strings, they will be interpreted as `glob` patterns,\n * and the contents of any files matching the patterns will be used to uniquely\n * version the URL. If used with a single string, it will be interpreted as\n * unique versioning information that you've generated for a given URL.\n *\n * @return {Promise<{count: number, filePaths: Array<string>, size: number, warnings: Array<string>}>}\n * A promise that resolves once the service worker and related files\n * (indicated by `filePaths`) has been written to `swDest`. The `size` property\n * contains the aggregate size of all the precached entries, in bytes, and the\n * `count` property contains the total number of precached entries. Any\n * non-fatal warning messages will be returned via `warnings`.\n *\n * @memberof module:workbox-build\n */\n\n\nasync function injectManifest(config) {\n  const options = validate(config, injectManifestSchema); // Make sure we leave swSrc and swDest out of the precache manifest.\n\n  for (const file of [options.swSrc, options.swDest]) {\n    options.globIgnores.push(rebasePath({\n      file,\n      baseDirectory: options.globDirectory\n    }));\n  }\n\n  const globalRegexp = new RegExp(escapeRegexp(options.injectionPoint), 'g');\n  const {\n    count,\n    size,\n    manifestEntries,\n    warnings\n  } = await getFileManifestEntries(options);\n  let swFileContents;\n\n  try {\n    swFileContents = await fse.readFile(options.swSrc, 'utf8');\n  } catch (error) {\n    throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n  }\n\n  const injectionResults = swFileContents.match(globalRegexp);\n\n  if (!injectionResults) {\n    // See https://github.com/GoogleChrome/workbox/issues/2230\n    if (upath.resolve(options.swSrc) === upath.resolve(options.swDest)) {\n      throw new Error(errors['same-src-and-dest'] + ' ' + options.injectionPoint);\n    }\n\n    throw new Error(errors['injection-point-not-found'] + ' ' + options.injectionPoint);\n  }\n\n  assert(injectionResults.length === 1, errors['multiple-injection-points'] + options.injectionPoint);\n  const manifestString = stringify(manifestEntries);\n  const filesToWrite = {};\n  const url = sourceMapURL.getFrom(swFileContents); // If our swSrc file contains a sourcemap, we would invalidate that\n  // mapping if we just replaced injectionPoint with the stringified manifest.\n  // Instead, we need to update the swDest contents as well as the sourcemap\n  // at the same time.\n  // See https://github.com/GoogleChrome/workbox/issues/2235\n\n  if (url) {\n    const sourcemapSrcPath = upath.resolve(upath.dirname(options.swSrc), url);\n    const sourcemapDestPath = upath.resolve(upath.dirname(options.swDest), url);\n    let originalMap;\n\n    try {\n      originalMap = await fse.readJSON(sourcemapSrcPath, 'utf8');\n    } catch (error) {\n      throw new Error(`${errors['cant-find-sourcemap']} ${error.message}`);\n    }\n\n    const {\n      map,\n      source\n    } = await replaceAndUpdateSourceMap({\n      originalMap,\n      jsFilename: upath.basename(options.swDest),\n      originalSource: swFileContents,\n      replaceString: manifestString,\n      searchString: options.injectionPoint\n    });\n    filesToWrite[options.swDest] = source;\n    filesToWrite[sourcemapDestPath] = map;\n  } else {\n    // If there's no sourcemap associated with swSrc, a simple string\n    // replacement will suffice.\n    filesToWrite[options.swDest] = swFileContents.replace(globalRegexp, manifestString);\n  }\n\n  for (const [file, contents] of Object.entries(filesToWrite)) {\n    try {\n      await fse.mkdirp(upath.dirname(file));\n    } catch (error) {\n      throw new Error(errors['unable-to-make-injection-directory'] + ` '${error.message}'`);\n    }\n\n    await fse.writeFile(file, contents);\n  }\n\n  return {\n    count,\n    size,\n    warnings,\n    // Use upath.resolve() to make all the paths absolute.\n    filePaths: Object.keys(filesToWrite).map(f => upath.resolve(f))\n  };\n}\n\nmodule.exports = injectManifest;","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/inject-manifest.js"],"names":["assert","require","fse","sourceMapURL","stringify","upath","errors","escapeRegexp","getFileManifestEntries","injectManifestSchema","rebasePath","replaceAndUpdateSourceMap","validate","injectManifest","config","options","file","swSrc","swDest","globIgnores","push","baseDirectory","globDirectory","globalRegexp","RegExp","injectionPoint","count","size","manifestEntries","warnings","swFileContents","readFile","error","Error","message","injectionResults","match","resolve","length","manifestString","filesToWrite","url","getFrom","sourcemapSrcPath","dirname","sourcemapDestPath","originalMap","readJSON","map","source","jsFilename","basename","originalSource","replaceString","searchString","replace","contents","Object","entries","mkdirp","writeFile","filePaths","keys","f","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst assert = require('assert');\n\nconst fse = require('fs-extra');\n\nconst sourceMapURL = require('source-map-url');\n\nconst stringify = require('fast-json-stable-stringify');\n\nconst upath = require('upath');\n\nconst errors = require('./lib/errors');\n\nconst escapeRegexp = require('./lib/escape-regexp');\n\nconst getFileManifestEntries = require('./lib/get-file-manifest-entries');\n\nconst injectManifestSchema = require('./options/schema/inject-manifest');\n\nconst rebasePath = require('./lib/rebase-path');\n\nconst replaceAndUpdateSourceMap = require('./lib/replace-and-update-source-map');\n\nconst validate = require('./lib/validate-options'); // eslint-disable-next-line jsdoc/newline-after-description\n\n/**\n * This method creates a list of URLs to precache, referred to as a \"precache\n * manifest\", based on the options you provide.\n *\n * The manifest is injected into the `swSrc` file, and the placeholder string\n * `injectionPoint` determines where in the file the manifest should go.\n *\n * The final service worker file, with the manifest injected, is written to\n * disk at `swDest`.\n *\n * @param {Object} config The configuration to use.\n *\n * @param {string} config.globDirectory The local directory you wish to match\n * `globPatterns` against. The path is relative to the current directory.\n *\n * @param {string} config.swDest The path and filename of the service worker file\n * that will be created by the build process, relative to the current working\n * directory. It must end in '.js'.\n *\n * @param {string} config.swSrc The path and filename of the service worker file\n * that will be read during the build process, relative to the current working\n * directory.\n *\n * @param {Array<module:workbox-build.ManifestEntry>} [config.additionalManifestEntries]\n * A list of entries to be precached, in addition to any entries that are\n * generated as part of the build configuration.\n *\n * @param {RegExp} [config.dontCacheBustURLsMatching] Assets that match this will be\n * assumed to be uniquely versioned via their URL, and exempted from the normal\n * HTTP cache-busting that's done when populating the precache. While not\n * required, it's recommended that if your existing build process already\n * inserts a `[hash]` value into each filename, you provide a RegExp that will\n * detect that, as it will reduce the bandwidth consumed when precaching.\n *\n * @param {boolean} [config.globFollow=true] Determines whether or not symlinks\n * are followed when generating the precache manifest. For more information, see\n * the definition of `follow` in the `glob`\n * [documentation](https://github.com/isaacs/node-glob#options).\n *\n * @param {Array<string>} [config.globIgnores=['node_modules/**']]\n * A set of patterns matching files to always exclude when generating the\n * precache manifest. For more information, see the definition of `ignore` in the `glob`\n * [documentation](https://github.com/isaacs/node-glob#options).\n *\n * @param {Array<string>} [config.globPatterns=['**.{js,css,html}']]\n * Files matching any of these patterns will be included in the precache\n * manifest. For more information, see the\n * [`glob` primer](https://github.com/isaacs/node-glob#glob-primer).\n *\n * @param {boolean} [config.globStrict=true] If true, an error reading a directory when\n * generating a precache manifest will cause the build to fail. If false, the\n * problematic directory will be skipped. For more information, see the\n * definition of `strict` in the `glob`\n * [documentation](https://github.com/isaacs/node-glob#options).\n *\n * @param  {string} [config.injectionPoint='self.__WB_MANIFEST'] The string to\n * find inside of the `swSrc` file. Once found, it will be replaced by the\n * generated precache manifest.\n *\n * @param {Array<module:workbox-build.ManifestTransform>} [config.manifestTransforms] One or more\n * functions which will be applied sequentially against the generated manifest.\n * If `modifyURLPrefix` or `dontCacheBustURLsMatching` are also specified, their\n * corresponding transformations will be applied first.\n *\n * @param {number} [config.maximumFileSizeToCacheInBytes=2097152] This value can be\n * used to determine the maximum size of files that will be precached. This\n * prevents you from inadvertently precaching very large files that might have\n * accidentally matched one of your patterns.\n *\n * @param {string} [config.mode='production'] If set to 'production', then an\n * optimized service worker bundle that excludes debugging info will be\n * produced. If not explicitly configured here, the `process.env.NODE_ENV` value\n * will be used, and failing that, it will fall back to `'production'`.\n *\n * @param {object<string, string>} [config.modifyURLPrefix] A mapping of prefixes\n * that, if present in an entry in the precache manifest, will be replaced with\n * the corresponding value. This can be used to, for example, remove or add a\n * path prefix from a manifest entry if your web hosting setup doesn't match\n * your local filesystem setup. As an alternative with more flexibility, you can\n * use the `manifestTransforms` option and provide a function that modifies the\n * entries in the manifest using whatever logic you provide.\n *\n * @param {Object} [config.templatedURLs] If a URL is rendered based on some\n * server-side logic, its contents may depend on multiple files or on some other\n * unique string value. The keys in this object are server-rendered URLs. If the\n * values are an array of strings, they will be interpreted as `glob` patterns,\n * and the contents of any files matching the patterns will be used to uniquely\n * version the URL. If used with a single string, it will be interpreted as\n * unique versioning information that you've generated for a given URL.\n *\n * @return {Promise<{count: number, filePaths: Array<string>, size: number, warnings: Array<string>}>}\n * A promise that resolves once the service worker and related files\n * (indicated by `filePaths`) has been written to `swDest`. The `size` property\n * contains the aggregate size of all the precached entries, in bytes, and the\n * `count` property contains the total number of precached entries. Any\n * non-fatal warning messages will be returned via `warnings`.\n *\n * @memberof module:workbox-build\n */\n\n\nasync function injectManifest(config) {\n  const options = validate(config, injectManifestSchema); // Make sure we leave swSrc and swDest out of the precache manifest.\n\n  for (const file of [options.swSrc, options.swDest]) {\n    options.globIgnores.push(rebasePath({\n      file,\n      baseDirectory: options.globDirectory\n    }));\n  }\n\n  const globalRegexp = new RegExp(escapeRegexp(options.injectionPoint), 'g');\n  const {\n    count,\n    size,\n    manifestEntries,\n    warnings\n  } = await getFileManifestEntries(options);\n  let swFileContents;\n\n  try {\n    swFileContents = await fse.readFile(options.swSrc, 'utf8');\n  } catch (error) {\n    throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n  }\n\n  const injectionResults = swFileContents.match(globalRegexp);\n\n  if (!injectionResults) {\n    // See https://github.com/GoogleChrome/workbox/issues/2230\n    if (upath.resolve(options.swSrc) === upath.resolve(options.swDest)) {\n      throw new Error(errors['same-src-and-dest'] + ' ' + options.injectionPoint);\n    }\n\n    throw new Error(errors['injection-point-not-found'] + ' ' + options.injectionPoint);\n  }\n\n  assert(injectionResults.length === 1, errors['multiple-injection-points'] + options.injectionPoint);\n  const manifestString = stringify(manifestEntries);\n  const filesToWrite = {};\n  const url = sourceMapURL.getFrom(swFileContents); // If our swSrc file contains a sourcemap, we would invalidate that\n  // mapping if we just replaced injectionPoint with the stringified manifest.\n  // Instead, we need to update the swDest contents as well as the sourcemap\n  // at the same time.\n  // See https://github.com/GoogleChrome/workbox/issues/2235\n\n  if (url) {\n    const sourcemapSrcPath = upath.resolve(upath.dirname(options.swSrc), url);\n    const sourcemapDestPath = upath.resolve(upath.dirname(options.swDest), url);\n    let originalMap;\n\n    try {\n      originalMap = await fse.readJSON(sourcemapSrcPath, 'utf8');\n    } catch (error) {\n      throw new Error(`${errors['cant-find-sourcemap']} ${error.message}`);\n    }\n\n    const {\n      map,\n      source\n    } = await replaceAndUpdateSourceMap({\n      originalMap,\n      jsFilename: upath.basename(options.swDest),\n      originalSource: swFileContents,\n      replaceString: manifestString,\n      searchString: options.injectionPoint\n    });\n    filesToWrite[options.swDest] = source;\n    filesToWrite[sourcemapDestPath] = map;\n  } else {\n    // If there's no sourcemap associated with swSrc, a simple string\n    // replacement will suffice.\n    filesToWrite[options.swDest] = swFileContents.replace(globalRegexp, manifestString);\n  }\n\n  for (const [file, contents] of Object.entries(filesToWrite)) {\n    try {\n      await fse.mkdirp(upath.dirname(file));\n    } catch (error) {\n      throw new Error(errors['unable-to-make-injection-directory'] + ` '${error.message}'`);\n    }\n\n    await fse.writeFile(file, contents);\n  }\n\n  return {\n    count,\n    size,\n    warnings,\n    // Use upath.resolve() to make all the paths absolute.\n    filePaths: Object.keys(filesToWrite).map(f => upath.resolve(f))\n  };\n}\n\nmodule.exports = injectManifest;"]},"metadata":{},"sourceType":"script"}