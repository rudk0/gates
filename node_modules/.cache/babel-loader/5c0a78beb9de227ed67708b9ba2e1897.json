{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nvar errors = require('./errors');\n/**\n * Escaping user input to be treated as a literal string within a regular\n * expression can be accomplished by simple replacement.\n *\n * From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n *\n * @private\n * @param  {string} string The string to be used as part of a regular\n *                         expression\n * @return {string}        A string that is safe to use in a regular\n *                         expression.\n *\n * @private\n */\n\n\nvar escapeRegExp = function escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\n\nmodule.exports = function (modifyURLPrefix) {\n  if (!modifyURLPrefix || typeof modifyURLPrefix !== 'object' || Array.isArray(modifyURLPrefix)) {\n    throw new Error(errors['modify-url-prefix-bad-prefixes']);\n  } // If there are no entries in modifyURLPrefix, just return an identity\n  // function as a shortcut.\n\n\n  if (Object.keys(modifyURLPrefix).length === 0) {\n    return function (entry) {\n      return entry;\n    };\n  }\n\n  Object.keys(modifyURLPrefix).forEach(function (key) {\n    if (typeof modifyURLPrefix[key] !== 'string') {\n      throw new Error(errors['modify-url-prefix-bad-prefixes']);\n    }\n  }); // Escape the user input so it's safe to use in a regex.\n\n  var safeModifyURLPrefixes = Object.keys(modifyURLPrefix).map(escapeRegExp); // Join all the `modifyURLPrefix` keys so a single regex can be used.\n\n  var prefixMatchesStrings = safeModifyURLPrefixes.join('|'); // Add `^` to the front the prefix matches so it only matches the start of\n  // a string.\n\n  var modifyRegex = new RegExp(\"^(\".concat(prefixMatchesStrings, \")\"));\n  return function (originalManifest) {\n    var manifest = originalManifest.map(function (entry) {\n      if (typeof entry.url !== 'string') {\n        throw new Error(errors['manifest-entry-bad-url']);\n      }\n\n      entry.url = entry.url.replace(modifyRegex, function (match) {\n        return modifyURLPrefix[match];\n      });\n      return entry;\n    });\n    return {\n      manifest: manifest\n    };\n  };\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/lib/modify-url-prefix-transform.js"],"names":["errors","require","escapeRegExp","string","replace","module","exports","modifyURLPrefix","Array","isArray","Error","Object","keys","length","entry","forEach","key","safeModifyURLPrefixes","map","prefixMatchesStrings","join","modifyRegex","RegExp","originalManifest","manifest","url","match"],"mappings":"AAAA;AAEA;;;;;;;;AAOA,IAAMA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAtB;AACA;;;;;;;;;;;;;;;;AAgBA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAAC,MAAM,EAAI;AAC7B,SAAOA,MAAM,CAACC,OAAP,CAAe,qBAAf,EAAsC,MAAtC,CAAP;AACD,CAFD;;AAIAC,MAAM,CAACC,OAAP,GAAiB,UAAAC,eAAe,EAAI;AAClC,MAAI,CAACA,eAAD,IAAoB,OAAOA,eAAP,KAA2B,QAA/C,IAA2DC,KAAK,CAACC,OAAN,CAAcF,eAAd,CAA/D,EAA+F;AAC7F,UAAM,IAAIG,KAAJ,CAAUV,MAAM,CAAC,gCAAD,CAAhB,CAAN;AACD,GAHiC,CAGhC;AACF;;;AAGA,MAAIW,MAAM,CAACC,IAAP,CAAYL,eAAZ,EAA6BM,MAA7B,KAAwC,CAA5C,EAA+C;AAC7C,WAAO,UAAAC,KAAK;AAAA,aAAIA,KAAJ;AAAA,KAAZ;AACD;;AAEDH,EAAAA,MAAM,CAACC,IAAP,CAAYL,eAAZ,EAA6BQ,OAA7B,CAAqC,UAAAC,GAAG,EAAI;AAC1C,QAAI,OAAOT,eAAe,CAACS,GAAD,CAAtB,KAAgC,QAApC,EAA8C;AAC5C,YAAM,IAAIN,KAAJ,CAAUV,MAAM,CAAC,gCAAD,CAAhB,CAAN;AACD;AACF,GAJD,EAXkC,CAe9B;;AAEJ,MAAMiB,qBAAqB,GAAGN,MAAM,CAACC,IAAP,CAAYL,eAAZ,EAA6BW,GAA7B,CAAiChB,YAAjC,CAA9B,CAjBkC,CAiB4C;;AAE9E,MAAMiB,oBAAoB,GAAGF,qBAAqB,CAACG,IAAtB,CAA2B,GAA3B,CAA7B,CAnBkC,CAmB4B;AAC9D;;AAEA,MAAMC,WAAW,GAAG,IAAIC,MAAJ,aAAgBH,oBAAhB,OAApB;AACA,SAAO,UAAAI,gBAAgB,EAAI;AACzB,QAAMC,QAAQ,GAAGD,gBAAgB,CAACL,GAAjB,CAAqB,UAAAJ,KAAK,EAAI;AAC7C,UAAI,OAAOA,KAAK,CAACW,GAAb,KAAqB,QAAzB,EAAmC;AACjC,cAAM,IAAIf,KAAJ,CAAUV,MAAM,CAAC,wBAAD,CAAhB,CAAN;AACD;;AAEDc,MAAAA,KAAK,CAACW,GAAN,GAAYX,KAAK,CAACW,GAAN,CAAUrB,OAAV,CAAkBiB,WAAlB,EAA+B,UAAAK,KAAK,EAAI;AAClD,eAAOnB,eAAe,CAACmB,KAAD,CAAtB;AACD,OAFW,CAAZ;AAGA,aAAOZ,KAAP;AACD,KATgB,CAAjB;AAUA,WAAO;AACLU,MAAAA,QAAQ,EAARA;AADK,KAAP;AAGD,GAdD;AAeD,CAtCD","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst errors = require('./errors');\n/**\n * Escaping user input to be treated as a literal string within a regular\n * expression can be accomplished by simple replacement.\n *\n * From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n *\n * @private\n * @param  {string} string The string to be used as part of a regular\n *                         expression\n * @return {string}        A string that is safe to use in a regular\n *                         expression.\n *\n * @private\n */\n\n\nconst escapeRegExp = string => {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\n\nmodule.exports = modifyURLPrefix => {\n  if (!modifyURLPrefix || typeof modifyURLPrefix !== 'object' || Array.isArray(modifyURLPrefix)) {\n    throw new Error(errors['modify-url-prefix-bad-prefixes']);\n  } // If there are no entries in modifyURLPrefix, just return an identity\n  // function as a shortcut.\n\n\n  if (Object.keys(modifyURLPrefix).length === 0) {\n    return entry => entry;\n  }\n\n  Object.keys(modifyURLPrefix).forEach(key => {\n    if (typeof modifyURLPrefix[key] !== 'string') {\n      throw new Error(errors['modify-url-prefix-bad-prefixes']);\n    }\n  }); // Escape the user input so it's safe to use in a regex.\n\n  const safeModifyURLPrefixes = Object.keys(modifyURLPrefix).map(escapeRegExp); // Join all the `modifyURLPrefix` keys so a single regex can be used.\n\n  const prefixMatchesStrings = safeModifyURLPrefixes.join('|'); // Add `^` to the front the prefix matches so it only matches the start of\n  // a string.\n\n  const modifyRegex = new RegExp(`^(${prefixMatchesStrings})`);\n  return originalManifest => {\n    const manifest = originalManifest.map(entry => {\n      if (typeof entry.url !== 'string') {\n        throw new Error(errors['manifest-entry-bad-url']);\n      }\n\n      entry.url = entry.url.replace(modifyRegex, match => {\n        return modifyURLPrefix[match];\n      });\n      return entry;\n    });\n    return {\n      manifest\n    };\n  };\n};"]},"metadata":{},"sourceType":"script"}