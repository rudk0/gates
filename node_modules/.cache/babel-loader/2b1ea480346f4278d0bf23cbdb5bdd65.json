{"ast":null,"code":"/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {\n  readFileSync\n} = require(\"fs\");\n\nconst {\n  join\n} = require(\"path\");\n\nconst ejs = require(\"ejs\");\n\nconst MagicString = require(\"magic-string\");\n\nconst defaultOpts = {\n  // A string containing the EJS template for the amd loader. If `undefined`,\n  // OMT will use `loader.ejs`.\n  loader: readFileSync(join(__dirname, \"/loader.ejs\"), \"utf8\"),\n  // Use `fetch()` + `eval()` to load dependencies instead of `<script>` tags\n  // and `importScripts()`. _This is not CSP compliant, but is required if you\n  // want to use dynamic imports in ServiceWorker_.\n  useEval: false,\n  // A RegExp to find `new Workers()` calls. The second capture group _must_\n  // capture the provided file name without the quotes.\n  workerRegexp: /new Worker\\(([\"'])(.+?)\\1(,[^)]+)?\\)/g,\n  // Function name to use instead of AMD’s `define`.\n  amdFunctionName: \"define\",\n  // A function that determines whether the loader code should be prepended to a\n  // certain chunk. Should return true if the load is supposed to be prepended.\n  prependLoader: (chunk, workerFiles) => chunk.isEntry || workerFiles.includes(chunk.facadeModuleId),\n  // The scheme used when importing workers as a URL.\n  urlLoaderScheme: \"omt\"\n};\n\nmodule.exports = function (opts = {}) {\n  opts = Object.assign({}, defaultOpts, opts);\n  opts.loader = ejs.render(opts.loader, opts);\n  const urlLoaderPrefix = opts.urlLoaderScheme + \":\";\n  let workerFiles;\n  let isEsmOutput = false;\n  return {\n    name: \"off-main-thread\",\n\n    async buildStart(options) {\n      workerFiles = [];\n    },\n\n    outputOptions({\n      format\n    }) {\n      if (format === \"esm\" || format === \"es\") {\n        this.warn('Very few browsers support ES modules in Workers. If you want to your code to run in all browsers, set `output.format = \"amd\";`'); // In ESM, we never prepend a loader.\n\n        isEsmOutput = true;\n      } else if (format !== \"amd\") {\n        this.error(`\\`output.format\\` must either be \"amd\" or \"esm\", got \"${format}\"`);\n      }\n    },\n\n    async resolveId(id, importer) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n      const path = id.slice(urlLoaderPrefix.length);\n      const newId = (await this.resolve(path, importer)).id;\n      if (!newId) throw Error(`Cannot find module '${path}'`);\n      return urlLoaderPrefix + newId;\n    },\n\n    load(id) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n      const realId = id.slice(urlLoaderPrefix.length);\n      const chunkRef = this.emitFile({\n        id: realId,\n        type: \"chunk\"\n      });\n      return `export default import.meta.ROLLUP_FILE_URL_${chunkRef};`;\n    },\n\n    async transform(code, id) {\n      // Copy the regexp as they are stateful and this hook is async.\n      const workerRegexp = new RegExp(opts.workerRegexp.source, opts.workerRegexp.flags);\n\n      if (!workerRegexp.test(code)) {\n        return;\n      }\n\n      const ms = new MagicString(code); // Reset the regexp\n\n      workerRegexp.lastIndex = 0;\n\n      while (true) {\n        const match = workerRegexp.exec(code);\n\n        if (!match) {\n          break;\n        }\n\n        const workerFile = match[2];\n        let optionsObject = {}; // Parse the optional options object\n\n        if (match[3] && match[3].length > 0) {\n          // FIXME: ooooof!\n          optionsObject = new Function(`return ${match[3].slice(1)};`)();\n        }\n\n        if (!isEsmOutput) {\n          delete optionsObject.type;\n        }\n\n        if (!new RegExp(\"^.*/\").test(workerFile)) {\n          this.warn(`Paths passed to the Worker constructor must be relative or absolute, i.e. start with /, ./ or ../ (just like dynamic import!). Ignoring \"${workerFile}\".`);\n          continue;\n        }\n\n        const resolvedWorkerFile = (await this.resolve(workerFile, id)).id;\n        workerFiles.push(resolvedWorkerFile);\n        const chunkRefId = this.emitFile({\n          id: resolvedWorkerFile,\n          type: \"chunk\"\n        });\n        const workerParametersStartIndex = match.index + \"new Worker(\".length;\n        const workerParametersEndIndex = match.index + match[0].length - \")\".length;\n        ms.overwrite(workerParametersStartIndex, workerParametersEndIndex, `import.meta.ROLLUP_FILE_URL_${chunkRefId}, ${JSON.stringify(optionsObject)}`);\n      }\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({\n          hires: true\n        })\n      };\n    },\n\n    resolveFileUrl(chunk) {\n      return `\"./${chunk.fileName}\"`;\n    },\n\n    renderChunk(code, chunk, outputOptions) {\n      // We don’t need to do any loader processing when targeting ESM format.\n      if (isEsmOutput) {\n        return;\n      }\n\n      if (outputOptions.banner && outputOptions.banner.length > 0) {\n        this.error(\"OMT currently doesn’t work with `banner`. Feel free to submit a PR at https://github.com/surma/rollup-plugin-off-main-thread\");\n        return;\n      }\n\n      const ms = new MagicString(code); // Mangle define() call\n\n      const id = `./${chunk.fileName}`;\n      ms.remove(0, \"define(\".length); // If the module does not have any dependencies, it’s technically okay\n      // to skip the dependency array. But our minimal loader expects it, so\n      // we add it back in.\n\n      if (!code.startsWith(\"define([\")) {\n        ms.prepend(\"[],\");\n      }\n\n      ms.prepend(`${opts.amdFunctionName}(\"${id}\",`); // Prepend loader if it’s an entry point or a worker file\n\n      if (opts.prependLoader(chunk, workerFiles)) {\n        ms.prepend(opts.loader);\n      }\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({\n          hires: true\n        })\n      };\n    }\n\n  };\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/@surma/rollup-plugin-off-main-thread/index.js"],"names":["readFileSync","require","join","ejs","MagicString","defaultOpts","loader","__dirname","useEval","workerRegexp","amdFunctionName","prependLoader","chunk","workerFiles","isEntry","includes","facadeModuleId","urlLoaderScheme","module","exports","opts","Object","assign","render","urlLoaderPrefix","isEsmOutput","name","buildStart","options","outputOptions","format","warn","error","resolveId","id","importer","startsWith","path","slice","length","newId","resolve","Error","load","realId","chunkRef","emitFile","type","transform","code","RegExp","source","flags","test","ms","lastIndex","match","exec","workerFile","optionsObject","Function","resolvedWorkerFile","push","chunkRefId","workerParametersStartIndex","index","workerParametersEndIndex","overwrite","JSON","stringify","toString","map","generateMap","hires","resolveFileUrl","fileName","renderChunk","banner","remove","prepend"],"mappings":"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","sourcesContent":["/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { readFileSync } = require(\"fs\");\nconst { join } = require(\"path\");\nconst ejs = require(\"ejs\");\nconst MagicString = require(\"magic-string\");\n\nconst defaultOpts = {\n  // A string containing the EJS template for the amd loader. If `undefined`,\n  // OMT will use `loader.ejs`.\n  loader: readFileSync(join(__dirname, \"/loader.ejs\"), \"utf8\"),\n  // Use `fetch()` + `eval()` to load dependencies instead of `<script>` tags\n  // and `importScripts()`. _This is not CSP compliant, but is required if you\n  // want to use dynamic imports in ServiceWorker_.\n  useEval: false,\n  // A RegExp to find `new Workers()` calls. The second capture group _must_\n  // capture the provided file name without the quotes.\n  workerRegexp: /new Worker\\(([\"'])(.+?)\\1(,[^)]+)?\\)/g,\n  // Function name to use instead of AMD’s `define`.\n  amdFunctionName: \"define\",\n  // A function that determines whether the loader code should be prepended to a\n  // certain chunk. Should return true if the load is supposed to be prepended.\n  prependLoader: (chunk, workerFiles) =>\n    chunk.isEntry || workerFiles.includes(chunk.facadeModuleId),\n  // The scheme used when importing workers as a URL.\n  urlLoaderScheme: \"omt\"\n};\n\nmodule.exports = function(opts = {}) {\n  opts = Object.assign({}, defaultOpts, opts);\n\n  opts.loader = ejs.render(opts.loader, opts);\n\n  const urlLoaderPrefix = opts.urlLoaderScheme + \":\";\n\n  let workerFiles;\n  let isEsmOutput = false;\n  return {\n    name: \"off-main-thread\",\n\n    async buildStart(options) {\n      workerFiles = [];\n    },\n\n    outputOptions({ format }) {\n      if (format === \"esm\" || format === \"es\") {\n        this.warn(\n          'Very few browsers support ES modules in Workers. If you want to your code to run in all browsers, set `output.format = \"amd\";`'\n        );\n        // In ESM, we never prepend a loader.\n        isEsmOutput = true;\n      } else if (format !== \"amd\") {\n        this.error(\n          `\\`output.format\\` must either be \"amd\" or \"esm\", got \"${format}\"`\n        );\n      }\n    },\n\n    async resolveId(id, importer) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n\n      const path = id.slice(urlLoaderPrefix.length);\n      const newId = (await this.resolve(path, importer)).id;\n\n      if (!newId) throw Error(`Cannot find module '${path}'`);\n\n      return urlLoaderPrefix + newId;\n    },\n\n    load(id) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n\n      const realId = id.slice(urlLoaderPrefix.length);\n      const chunkRef = this.emitFile({ id: realId, type: \"chunk\" });\n      return `export default import.meta.ROLLUP_FILE_URL_${chunkRef};`;\n    },\n\n    async transform(code, id) {\n      // Copy the regexp as they are stateful and this hook is async.\n      const workerRegexp = new RegExp(\n        opts.workerRegexp.source,\n        opts.workerRegexp.flags\n      );\n      if (!workerRegexp.test(code)) {\n        return;\n      }\n\n      const ms = new MagicString(code);\n      // Reset the regexp\n      workerRegexp.lastIndex = 0;\n      while (true) {\n        const match = workerRegexp.exec(code);\n        if (!match) {\n          break;\n        }\n\n        const workerFile = match[2];\n        let optionsObject = {};\n        // Parse the optional options object\n        if (match[3] && match[3].length > 0) {\n          // FIXME: ooooof!\n          optionsObject = new Function(`return ${match[3].slice(1)};`)();\n        }\n        if (!isEsmOutput) {\n          delete optionsObject.type;\n        }\n\n        if (!new RegExp(\"^.*/\").test(workerFile)) {\n          this.warn(\n            `Paths passed to the Worker constructor must be relative or absolute, i.e. start with /, ./ or ../ (just like dynamic import!). Ignoring \"${workerFile}\".`\n          );\n          continue;\n        }\n\n        const resolvedWorkerFile = (await this.resolve(workerFile, id)).id;\n        workerFiles.push(resolvedWorkerFile);\n        const chunkRefId = this.emitFile({\n          id: resolvedWorkerFile,\n          type: \"chunk\"\n        });\n\n        const workerParametersStartIndex = match.index + \"new Worker(\".length;\n        const workerParametersEndIndex =\n          match.index + match[0].length - \")\".length;\n\n        ms.overwrite(\n          workerParametersStartIndex,\n          workerParametersEndIndex,\n          `import.meta.ROLLUP_FILE_URL_${chunkRefId}, ${JSON.stringify(\n            optionsObject\n          )}`\n        );\n      }\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({ hires: true })\n      };\n    },\n\n    resolveFileUrl(chunk) {\n      return `\"./${chunk.fileName}\"`;\n    },\n\n    renderChunk(code, chunk, outputOptions) {\n      // We don’t need to do any loader processing when targeting ESM format.\n      if (isEsmOutput) {\n        return;\n      }\n      if (outputOptions.banner && outputOptions.banner.length > 0) {\n        this.error(\n          \"OMT currently doesn’t work with `banner`. Feel free to submit a PR at https://github.com/surma/rollup-plugin-off-main-thread\"\n        );\n        return;\n      }\n      const ms = new MagicString(code);\n\n      // Mangle define() call\n      const id = `./${chunk.fileName}`;\n      ms.remove(0, \"define(\".length);\n      // If the module does not have any dependencies, it’s technically okay\n      // to skip the dependency array. But our minimal loader expects it, so\n      // we add it back in.\n      if (!code.startsWith(\"define([\")) {\n        ms.prepend(\"[],\");\n      }\n      ms.prepend(`${opts.amdFunctionName}(\"${id}\",`);\n\n      // Prepend loader if it’s an entry point or a worker file\n      if (opts.prependLoader(chunk, workerFiles)) {\n        ms.prepend(opts.loader);\n      }\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({ hires: true })\n      };\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}