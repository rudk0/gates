{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Hoek = require('@hapi/hoek');\n\nvar Any = require('../any');\n\nvar Cast = require('../../cast');\n\nvar Ref = require('../../ref');\n\nvar internals = {};\n\ninternals.Alternatives = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'alternatives';\n\n    _this._invalids.remove(null);\n\n    _this._inner.matches = [];\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.try.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var errors = [];\n      var il = this._inner.matches.length;\n      var baseType = this._baseType;\n\n      for (var i = 0; i < il; ++i) {\n        var item = this._inner.matches[i];\n\n        if (!item.schema) {\n          var schema = item.peek || item.is;\n          var input = item.is ? item.ref(state.reference || state.parent, options) : value;\n\n          var failed = schema._validate(input, null, options, state.parent).errors;\n\n          if (failed) {\n            if (item.otherwise) {\n              return item.otherwise._validate(value, state, options);\n            }\n          } else if (item.then) {\n            return item.then._validate(value, state, options);\n          }\n\n          if (i === il - 1 && baseType) {\n            return baseType._validate(value, state, options);\n          }\n\n          continue;\n        }\n\n        var result = item.schema._validate(value, state, options);\n\n        if (!result.errors) {\n          // Found a valid match\n          return result;\n        }\n\n        errors.push.apply(errors, _toConsumableArray(result.errors));\n      }\n\n      if (errors.length) {\n        return {\n          errors: this.createError('alternatives.child', {\n            reason: errors\n          }, state, options)\n        };\n      }\n\n      return {\n        errors: this.createError('alternatives.base', null, state, options)\n      };\n    }\n  }, {\n    key: \"try\",\n    value: function _try() {\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n\n      schemas = Hoek.flatten(schemas);\n      Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n      var obj = this.clone();\n\n      for (var i = 0; i < schemas.length; ++i) {\n        var cast = Cast.schema(this._currentJoi, schemas[i]);\n\n        if (cast._refs.length) {\n          var _obj$_refs;\n\n          (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(cast._refs));\n        }\n\n        obj._inner.matches.push({\n          schema: cast\n        });\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"when\",\n    value: function when(condition, options) {\n      var schemaCondition = false;\n      Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n      Hoek.assert(options, 'Missing options');\n      Hoek.assert(typeof options === 'object', 'Invalid options');\n\n      if (schemaCondition) {\n        Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n      } else {\n        Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n      }\n\n      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n      var obj = this.clone();\n      var is;\n\n      if (!schemaCondition) {\n        is = Cast.schema(this._currentJoi, options.is);\n\n        if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n          // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n          is = is.required();\n        }\n      }\n\n      var item = {\n        ref: schemaCondition ? null : Cast.ref(condition),\n        peek: schemaCondition ? condition : null,\n        is: is,\n        then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n        otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n      };\n\n      if (obj._baseType) {\n        item.then = item.then && obj._baseType.concat(item.then);\n        item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n      }\n\n      if (!schemaCondition) {\n        var _obj$_refs2;\n\n        Ref.push(obj._refs, item.ref);\n\n        (_obj$_refs2 = obj._refs).push.apply(_obj$_refs2, _toConsumableArray(item.is._refs));\n      }\n\n      if (item.then && item.then._refs.length) {\n        var _obj$_refs3;\n\n        (_obj$_refs3 = obj._refs).push.apply(_obj$_refs3, _toConsumableArray(item.then._refs));\n      }\n\n      if (item.otherwise && item.otherwise._refs.length) {\n        var _obj$_refs4;\n\n        (_obj$_refs4 = obj._refs).push.apply(_obj$_refs4, _toConsumableArray(item.otherwise._refs));\n      }\n\n      obj._inner.matches.push(item);\n\n      return obj;\n    }\n  }, {\n    key: \"label\",\n    value: function label(name) {\n      var obj = _get(_getPrototypeOf(_class.prototype), \"label\", this).call(this, name);\n\n      obj._inner.matches = obj._inner.matches.map(function (match) {\n        if (match.schema) {\n          return {\n            schema: match.schema.label(name)\n          };\n        }\n\n        match = Object.assign({}, match);\n\n        if (match.then) {\n          match.then = match.then.label(name);\n        }\n\n        if (match.otherwise) {\n          match.otherwise = match.otherwise.label(name);\n        }\n\n        return match;\n      });\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      var alternatives = [];\n\n      for (var i = 0; i < this._inner.matches.length; ++i) {\n        var item = this._inner.matches[i];\n\n        if (item.schema) {\n          // try()\n          alternatives.push(item.schema.describe());\n        } else {\n          // when()\n          var when = item.is ? {\n            ref: item.ref.toString(),\n            is: item.is.describe()\n          } : {\n            peek: item.peek.describe()\n          };\n\n          if (item.then) {\n            when.then = item.then.describe();\n          }\n\n          if (item.otherwise) {\n            when.otherwise = item.otherwise.describe();\n          }\n\n          alternatives.push(when);\n        }\n      }\n\n      description.alternatives = alternatives;\n      return description;\n    }\n  }]);\n\n  return _class;\n}(Any);\n\nmodule.exports = new internals.Alternatives();","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/joi/lib/types/alternatives/index.js"],"names":["Hoek","require","Any","Cast","Ref","internals","Alternatives","_type","_invalids","remove","_inner","matches","length","try","value","state","options","errors","il","baseType","_baseType","i","item","schema","peek","is","input","ref","reference","parent","failed","_validate","otherwise","then","result","push","createError","reason","schemas","flatten","assert","obj","clone","cast","_currentJoi","_refs","condition","schemaCondition","isRef","hasOwnProperty","undefined","required","concat","name","map","match","label","Object","assign","description","alternatives","describe","when","toString","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\n\n\nconst internals = {};\n\n\ninternals.Alternatives = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'alternatives';\n        this._invalids.remove(null);\n        this._inner.matches = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.try(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        const errors = [];\n        const il = this._inner.matches.length;\n        const baseType = this._baseType;\n\n        for (let i = 0; i < il; ++i) {\n            const item = this._inner.matches[i];\n            if (!item.schema) {\n                const schema = item.peek || item.is;\n                const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n                const failed = schema._validate(input, null, options, state.parent).errors;\n\n                if (failed) {\n                    if (item.otherwise) {\n                        return item.otherwise._validate(value, state, options);\n                    }\n                }\n                else if (item.then) {\n                    return item.then._validate(value, state, options);\n                }\n\n                if (i === (il - 1) && baseType) {\n                    return baseType._validate(value, state, options);\n                }\n\n                continue;\n            }\n\n            const result = item.schema._validate(value, state, options);\n            if (!result.errors) {     // Found a valid match\n                return result;\n            }\n\n            errors.push(...result.errors);\n        }\n\n        if (errors.length) {\n            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };\n        }\n\n        return { errors: this.createError('alternatives.base', null, state, options) };\n    }\n\n    try(...schemas) {\n\n        schemas = Hoek.flatten(schemas);\n        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\n        const obj = this.clone();\n\n        for (let i = 0; i < schemas.length; ++i) {\n            const cast = Cast.schema(this._currentJoi, schemas[i]);\n            if (cast._refs.length) {\n                obj._refs.push(...cast._refs);\n            }\n\n            obj._inner.matches.push({ schema: cast });\n        }\n\n        return obj;\n    }\n\n    when(condition, options) {\n\n        let schemaCondition = false;\n        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n        Hoek.assert(options, 'Missing options');\n        Hoek.assert(typeof options === 'object', 'Invalid options');\n        if (schemaCondition) {\n            Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n        }\n        else {\n            Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n        }\n\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const obj = this.clone();\n        let is;\n        if (!schemaCondition) {\n            is = Cast.schema(this._currentJoi, options.is);\n\n            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n\n                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n                is = is.required();\n            }\n        }\n\n        const item = {\n            ref: schemaCondition ? null : Cast.ref(condition),\n            peek: schemaCondition ? condition : null,\n            is,\n            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n        };\n\n        if (obj._baseType) {\n\n            item.then = item.then && obj._baseType.concat(item.then);\n            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n        }\n\n        if (!schemaCondition) {\n            Ref.push(obj._refs, item.ref);\n            obj._refs.push(...item.is._refs);\n        }\n\n        if (item.then && item.then._refs.length) {\n            obj._refs.push(...item.then._refs);\n        }\n\n        if (item.otherwise && item.otherwise._refs.length) {\n            obj._refs.push(...item.otherwise._refs);\n        }\n\n        obj._inner.matches.push(item);\n\n        return obj;\n    }\n\n    label(name) {\n\n        const obj = super.label(name);\n        obj._inner.matches = obj._inner.matches.map((match) => {\n\n            if (match.schema) {\n                return { schema: match.schema.label(name) };\n            }\n\n            match = Object.assign({}, match);\n            if (match.then) {\n                match.then = match.then.label(name);\n            }\n\n            if (match.otherwise) {\n                match.otherwise = match.otherwise.label(name);\n            }\n\n            return match;\n        });\n        return obj;\n    }\n\n    describe() {\n\n        const description = super.describe();\n        const alternatives = [];\n        for (let i = 0; i < this._inner.matches.length; ++i) {\n            const item = this._inner.matches[i];\n            if (item.schema) {\n\n                // try()\n\n                alternatives.push(item.schema.describe());\n            }\n            else {\n\n                // when()\n\n                const when = item.is ? {\n                    ref: item.ref.toString(),\n                    is: item.is.describe()\n                } : {\n                    peek: item.peek.describe()\n                };\n\n                if (item.then) {\n                    when.then = item.then.describe();\n                }\n\n                if (item.otherwise) {\n                    when.otherwise = item.otherwise.describe();\n                }\n\n                alternatives.push(when);\n            }\n        }\n\n        description.alternatives = alternatives;\n        return description;\n    }\n\n};\n\n\nmodule.exports = new internals.Alternatives();\n"]},"metadata":{},"sourceType":"script"}