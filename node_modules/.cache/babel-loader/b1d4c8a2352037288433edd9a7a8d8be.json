{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionParams;\n\nvar _core = require(\"@babel/core\");\n\nconst buildDefaultParam = (0, _core.template)(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\nconst buildLooseDefaultParam = (0, _core.template)(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\nconst buildLooseDestructuredDefaultParam = (0, _core.template)(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\nconst buildSafeArgumentsAccess = (0, _core.template)(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\nconst iifeVisitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      name\n    } = node;\n\n    if (name === \"eval\" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {\n      state.needsOuterBinding = true;\n      path.stop();\n    }\n  },\n\n  \"TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration\": path => path.skip()\n};\n\nfunction convertFunctionParams(path, loose, shouldTransformParam, replaceRestElement) {\n  const params = path.get(\"params\");\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n  const {\n    node,\n    scope\n  } = path;\n  const state = {\n    stop: false,\n    needsOuterBinding: false,\n    scope\n  };\n  const body = [];\n  const shadowedParams = new Set();\n\n  for (const param of params) {\n    for (const name of Object.keys(param.getBindingIdentifiers())) {\n      var _scope$bindings$name;\n\n      const constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;\n\n      if (constantViolations) {\n        for (const redeclarator of constantViolations) {\n          const node = redeclarator.node;\n\n          switch (node.type) {\n            case \"VariableDeclarator\":\n              {\n                if (node.init === null) {\n                  const declaration = redeclarator.parentPath;\n\n                  if (!declaration.parentPath.isFor() || declaration.parentPath.get(\"body\") === declaration) {\n                    redeclarator.remove();\n                    break;\n                  }\n                }\n\n                shadowedParams.add(name);\n                break;\n              }\n\n            case \"FunctionDeclaration\":\n              shadowedParams.add(name);\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n\n  let firstOptionalIndex = null;\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n\n    const transformedRestNodes = [];\n\n    if (replaceRestElement) {\n      replaceRestElement(param.parentPath, param, transformedRestNodes);\n    }\n\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n\n    if (paramIsAssignmentPattern && (loose || node.kind === \"set\")) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const undefinedNode = scope.buildUndefinedNode();\n\n      if (left.isIdentifier()) {\n        body.push(buildLooseDefaultParam({\n          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),\n          DEFAULT_VALUE: right.node,\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(buildLooseDestructuredDefaultParam({\n          ASSIGNMENT_IDENTIFIER: left.node,\n          DEFAULT_VALUE: right.node,\n          PARAMETER_NAME: _core.types.cloneNode(paramName),\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: _core.types.numericLiteral(i)\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n\n      const defNode = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(param.node, uid)]);\n\n      body.push(defNode);\n      param.replaceWith(_core.types.cloneNode(uid));\n    }\n\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n\n  path.ensureBlock();\n\n  if (state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push(buildScopeIIFE(shadowedParams, path.get(\"body\").node));\n    path.set(\"body\", _core.types.blockStatement(body));\n    const bodyPath = path.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\"argument.callee\");\n    arrowPath.arrowFunctionToExpression();\n    arrowPath.node.generator = path.node.generator;\n    arrowPath.node.async = path.node.async;\n    path.node.generator = false;\n  } else {\n    path.get(\"body\").unshiftContainer(\"body\", body);\n  }\n\n  return true;\n}\n\nfunction buildScopeIIFE(shadowedParams, body) {\n  const args = [];\n  const params = [];\n\n  for (const name of shadowedParams) {\n    args.push(_core.types.identifier(name));\n    params.push(_core.types.identifier(name));\n  }\n\n  return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), params));\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-parameters/lib/params.js"],"names":["Object","defineProperty","exports","value","default","convertFunctionParams","_core","require","buildDefaultParam","template","buildLooseDefaultParam","buildLooseDestructuredDefaultParam","buildSafeArgumentsAccess","iifeVisitor","path","state","scope","node","name","getBinding","parent","hasOwnBinding","needsOuterBinding","stop","skip","loose","shouldTransformParam","replaceRestElement","params","get","isSimpleParameterList","every","param","isIdentifier","body","shadowedParams","Set","keys","getBindingIdentifiers","_scope$bindings$name","constantViolations","bindings","redeclarator","type","init","declaration","parentPath","isFor","remove","add","size","traverse","firstOptionalIndex","i","length","transformedRestNodes","paramIsAssignmentPattern","isAssignmentPattern","kind","left","right","undefinedNode","buildUndefinedNode","push","ASSIGNMENT_IDENTIFIER","types","cloneNode","DEFAULT_VALUE","UNDEFINED","replaceWith","isObjectPattern","isArrayPattern","paramName","generateUidIdentifier","PARAMETER_NAME","defNode","VARIABLE_NAME","ARGUMENT_KEY","numericLiteral","uid","variableDeclaration","variableDeclarator","transformedNode","slice","ensureBlock","buildScopeIIFE","set","blockStatement","bodyPath","arrowPath","arrowFunctionToExpression","generator","async","unshiftContainer","args","identifier","returnStatement","callExpression","arrowFunctionExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionParams;\n\nvar _core = require(\"@babel/core\");\n\nconst buildDefaultParam = (0, _core.template)(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\nconst buildLooseDefaultParam = (0, _core.template)(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\nconst buildLooseDestructuredDefaultParam = (0, _core.template)(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\nconst buildSafeArgumentsAccess = (0, _core.template)(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\nconst iifeVisitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      name\n    } = node;\n\n    if (name === \"eval\" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {\n      state.needsOuterBinding = true;\n      path.stop();\n    }\n  },\n\n  \"TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration\": path => path.skip()\n};\n\nfunction convertFunctionParams(path, loose, shouldTransformParam, replaceRestElement) {\n  const params = path.get(\"params\");\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n  const {\n    node,\n    scope\n  } = path;\n  const state = {\n    stop: false,\n    needsOuterBinding: false,\n    scope\n  };\n  const body = [];\n  const shadowedParams = new Set();\n\n  for (const param of params) {\n    for (const name of Object.keys(param.getBindingIdentifiers())) {\n      var _scope$bindings$name;\n\n      const constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;\n\n      if (constantViolations) {\n        for (const redeclarator of constantViolations) {\n          const node = redeclarator.node;\n\n          switch (node.type) {\n            case \"VariableDeclarator\":\n              {\n                if (node.init === null) {\n                  const declaration = redeclarator.parentPath;\n\n                  if (!declaration.parentPath.isFor() || declaration.parentPath.get(\"body\") === declaration) {\n                    redeclarator.remove();\n                    break;\n                  }\n                }\n\n                shadowedParams.add(name);\n                break;\n              }\n\n            case \"FunctionDeclaration\":\n              shadowedParams.add(name);\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n\n  let firstOptionalIndex = null;\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n\n    const transformedRestNodes = [];\n\n    if (replaceRestElement) {\n      replaceRestElement(param.parentPath, param, transformedRestNodes);\n    }\n\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n\n    if (paramIsAssignmentPattern && (loose || node.kind === \"set\")) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const undefinedNode = scope.buildUndefinedNode();\n\n      if (left.isIdentifier()) {\n        body.push(buildLooseDefaultParam({\n          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),\n          DEFAULT_VALUE: right.node,\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(buildLooseDestructuredDefaultParam({\n          ASSIGNMENT_IDENTIFIER: left.node,\n          DEFAULT_VALUE: right.node,\n          PARAMETER_NAME: _core.types.cloneNode(paramName),\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: _core.types.numericLiteral(i)\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n\n      const defNode = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(param.node, uid)]);\n\n      body.push(defNode);\n      param.replaceWith(_core.types.cloneNode(uid));\n    }\n\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n\n  path.ensureBlock();\n\n  if (state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push(buildScopeIIFE(shadowedParams, path.get(\"body\").node));\n    path.set(\"body\", _core.types.blockStatement(body));\n    const bodyPath = path.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\"argument.callee\");\n    arrowPath.arrowFunctionToExpression();\n    arrowPath.node.generator = path.node.generator;\n    arrowPath.node.async = path.node.async;\n    path.node.generator = false;\n  } else {\n    path.get(\"body\").unshiftContainer(\"body\", body);\n  }\n\n  return true;\n}\n\nfunction buildScopeIIFE(shadowedParams, body) {\n  const args = [];\n  const params = [];\n\n  for (const name of shadowedParams) {\n    args.push(_core.types.identifier(name));\n    params.push(_core.types.identifier(name));\n  }\n\n  return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), params));\n}"]},"metadata":{},"sourceType":"script"}