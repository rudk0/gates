{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst assert = require('assert');\n\nconst fse = require('fs-extra');\n\nconst path = require('path');\n\nconst checkForDeprecatedOptions = require('../lib/check-for-deprecated-options');\n\nconst defaults = require('./options/defaults');\n\nconst errors = require('../lib/errors');\n\nconst getFileManifestEntries = require('../lib/get-file-manifest-entries');\n\nconst injectManifestSchema = require('./options/inject-manifest-schema');\n\nconst validate = require('./options/validate');\n/**\n * This method creates a list of URLs to precache, referred to as a \"precache\n * manifest\", based on the options you provide.\n *\n * The manifest is injected into the `swSrc` file, and the regular expression\n * `injectionPointRegexp` determines where in the file the manifest should go.\n *\n * The final service worker file, with the manifest injected, is written to\n * disk at `swDest`.\n *\n * @param {Object} config Please refer to the\n * [configuration guide](https://developers.google.com/web/tools/workbox/modules/workbox-build#full_injectmanifest_config).\n * @return {Promise<{count: number, size: number, warnings: Array<string>}>}\n * A promise that resolves once the service worker file has been written to\n * `swDest`. The `size` property contains the aggregate size of all the\n * precached entries, in bytes, and the `count` property contains the total\n * number of precached entries. Any non-fatal warning messages will be returned\n * via `warnings`.\n *\n * @memberof module:workbox-build\n */\n\n\nfunction injectManifest(_x) {\n  return _injectManifest.apply(this, arguments);\n}\n\nfunction _injectManifest() {\n  _injectManifest = (0, _asyncToGenerator2.default)(function* (config) {\n    // This check needs to be done before validation, since the deprecated options\n    // will be renamed.\n    const deprecationWarnings = checkForDeprecatedOptions(config);\n    const options = validate(config, injectManifestSchema);\n\n    if (path.normalize(config.swSrc) === path.normalize(config.swDest)) {\n      throw new Error(errors['same-src-and-dest']);\n    }\n\n    const globalRegexp = new RegExp(options.injectionPointRegexp, 'g');\n\n    const _ref = yield getFileManifestEntries(options),\n          count = _ref.count,\n          size = _ref.size,\n          manifestEntries = _ref.manifestEntries,\n          warnings = _ref.warnings;\n\n    let swFileContents;\n\n    try {\n      swFileContents = yield fse.readFile(config.swSrc, 'utf8');\n    } catch (error) {\n      throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n    }\n\n    const injectionResults = swFileContents.match(globalRegexp);\n    assert(injectionResults, errors['injection-point-not-found'] + ( // Customize the error message when this happens:\n    // - If the default RegExp is used, then include the expected string that\n    //   matches as a hint to the developer.\n    // - If a custom RegExp is used, then just include the raw RegExp.\n    options.injectionPointRegexp === defaults.injectionPointRegexp ? 'workbox.precaching.precacheAndRoute([])' : options.injectionPointRegexp));\n    assert(injectionResults.length === 1, errors['multiple-injection-points'] + ` ${options.injectionPointRegexp}`);\n    const entriesString = JSON.stringify(manifestEntries, null, 2);\n    swFileContents = swFileContents.replace(globalRegexp, `$1${entriesString}$2`);\n\n    try {\n      yield fse.mkdirp(path.dirname(options.swDest));\n    } catch (error) {\n      throw new Error(errors['unable-to-make-injection-directory'] + ` '${error.message}'`);\n    }\n\n    yield fse.writeFile(config.swDest, swFileContents); // Add in any deprecation warnings.\n\n    warnings.push(...deprecationWarnings);\n    return {\n      count,\n      size,\n      warnings\n    };\n  });\n  return _injectManifest.apply(this, arguments);\n}\n\nmodule.exports = injectManifest;","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/entry-points/inject-manifest.js"],"names":["_interopRequireDefault","require","_asyncToGenerator2","assert","fse","path","checkForDeprecatedOptions","defaults","errors","getFileManifestEntries","injectManifestSchema","validate","injectManifest","_x","_injectManifest","apply","arguments","default","config","deprecationWarnings","options","normalize","swSrc","swDest","Error","globalRegexp","RegExp","injectionPointRegexp","_ref","count","size","manifestEntries","warnings","swFileContents","readFile","error","message","injectionResults","match","length","entriesString","JSON","stringify","replace","mkdirp","dirname","writeFile","push","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst assert = require('assert');\n\nconst fse = require('fs-extra');\n\nconst path = require('path');\n\nconst checkForDeprecatedOptions = require('../lib/check-for-deprecated-options');\n\nconst defaults = require('./options/defaults');\n\nconst errors = require('../lib/errors');\n\nconst getFileManifestEntries = require('../lib/get-file-manifest-entries');\n\nconst injectManifestSchema = require('./options/inject-manifest-schema');\n\nconst validate = require('./options/validate');\n/**\n * This method creates a list of URLs to precache, referred to as a \"precache\n * manifest\", based on the options you provide.\n *\n * The manifest is injected into the `swSrc` file, and the regular expression\n * `injectionPointRegexp` determines where in the file the manifest should go.\n *\n * The final service worker file, with the manifest injected, is written to\n * disk at `swDest`.\n *\n * @param {Object} config Please refer to the\n * [configuration guide](https://developers.google.com/web/tools/workbox/modules/workbox-build#full_injectmanifest_config).\n * @return {Promise<{count: number, size: number, warnings: Array<string>}>}\n * A promise that resolves once the service worker file has been written to\n * `swDest`. The `size` property contains the aggregate size of all the\n * precached entries, in bytes, and the `count` property contains the total\n * number of precached entries. Any non-fatal warning messages will be returned\n * via `warnings`.\n *\n * @memberof module:workbox-build\n */\n\n\nfunction injectManifest(_x) {\n  return _injectManifest.apply(this, arguments);\n}\n\nfunction _injectManifest() {\n  _injectManifest = (0, _asyncToGenerator2.default)(function* (config) {\n    // This check needs to be done before validation, since the deprecated options\n    // will be renamed.\n    const deprecationWarnings = checkForDeprecatedOptions(config);\n    const options = validate(config, injectManifestSchema);\n\n    if (path.normalize(config.swSrc) === path.normalize(config.swDest)) {\n      throw new Error(errors['same-src-and-dest']);\n    }\n\n    const globalRegexp = new RegExp(options.injectionPointRegexp, 'g');\n\n    const _ref = yield getFileManifestEntries(options),\n          count = _ref.count,\n          size = _ref.size,\n          manifestEntries = _ref.manifestEntries,\n          warnings = _ref.warnings;\n\n    let swFileContents;\n\n    try {\n      swFileContents = yield fse.readFile(config.swSrc, 'utf8');\n    } catch (error) {\n      throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n    }\n\n    const injectionResults = swFileContents.match(globalRegexp);\n    assert(injectionResults, errors['injection-point-not-found'] + ( // Customize the error message when this happens:\n    // - If the default RegExp is used, then include the expected string that\n    //   matches as a hint to the developer.\n    // - If a custom RegExp is used, then just include the raw RegExp.\n    options.injectionPointRegexp === defaults.injectionPointRegexp ? 'workbox.precaching.precacheAndRoute([])' : options.injectionPointRegexp));\n    assert(injectionResults.length === 1, errors['multiple-injection-points'] + ` ${options.injectionPointRegexp}`);\n    const entriesString = JSON.stringify(manifestEntries, null, 2);\n    swFileContents = swFileContents.replace(globalRegexp, `$1${entriesString}$2`);\n\n    try {\n      yield fse.mkdirp(path.dirname(options.swDest));\n    } catch (error) {\n      throw new Error(errors['unable-to-make-injection-directory'] + ` '${error.message}'`);\n    }\n\n    yield fse.writeFile(config.swDest, swFileContents); // Add in any deprecation warnings.\n\n    warnings.push(...deprecationWarnings);\n    return {\n      count,\n      size,\n      warnings\n    };\n  });\n  return _injectManifest.apply(this, arguments);\n}\n\nmodule.exports = injectManifest;"]},"metadata":{},"sourceType":"script"}