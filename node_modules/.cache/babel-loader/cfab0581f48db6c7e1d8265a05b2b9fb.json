{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Assert = require('@hapi/hoek/lib/assert');\n\nvar internals = {};\n\nmodule.exports = /*#__PURE__*/function () {\n  function Topo() {\n    _classCallCheck(this, Topo);\n\n    this._items = [];\n    this.nodes = [];\n  }\n\n  _createClass(Topo, [{\n    key: \"add\",\n    value: function add(nodes, options) {\n      options = options || {}; // Validate rules\n\n      var before = [].concat(options.before || []);\n      var after = [].concat(options.after || []);\n      var group = options.group || '?';\n      var sort = options.sort || 0; // Used for merging only\n\n      Assert(!before.includes(group), \"Item cannot come before itself: \".concat(group));\n      Assert(!before.includes('?'), 'Item cannot come before unassociated items');\n      Assert(!after.includes(group), \"Item cannot come after itself: \".concat(group));\n      Assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n      if (!Array.isArray(nodes)) {\n        nodes = [nodes];\n      }\n\n      var _iterator = _createForOfIteratorHelper(nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var node = _step.value;\n          var item = {\n            seq: this._items.length,\n            sort: sort,\n            before: before,\n            after: after,\n            group: group,\n            node: node\n          };\n\n          this._items.push(item);\n        } // Insert event\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var valid = this._sort();\n\n      Assert(valid, 'item', group !== '?' ? \"added into group \".concat(group) : '', 'created a dependencies error');\n      return this.nodes;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(others) {\n      if (!Array.isArray(others)) {\n        others = [others];\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(others),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var other = _step2.value;\n\n          if (other) {\n            var _iterator3 = _createForOfIteratorHelper(other._items),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var item = _step3.value;\n\n                this._items.push(Object.assign({}, item)); // Shallow cloned\n\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        } // Sort items\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._items.sort(internals.mergeSort);\n\n      for (var i = 0; i < this._items.length; ++i) {\n        this._items[i].seq = i;\n      }\n\n      var valid = this._sort();\n\n      Assert(valid, 'merge created a dependencies error');\n      return this.nodes;\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort() {\n      // Construct graph\n      var graph = {};\n      var graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n      var groups = Object.create(null);\n\n      var _iterator4 = _createForOfIteratorHelper(this._items),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var item = _step4.value;\n          var seq = item.seq; // Unique across all items\n\n          var _group2 = item.group; // Determine Groups\n\n          groups[_group2] = groups[_group2] || [];\n\n          groups[_group2].push(seq); // Build intermediary graph using 'before'\n\n\n          graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n          var _iterator8 = _createForOfIteratorHelper(item.after),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var after = _step8.value;\n              graphAfters[after] = graphAfters[after] || [];\n              graphAfters[after].push(seq);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        } // Expand intermediary graph\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      for (var node in graph) {\n        var expandedGroups = [];\n\n        for (var graphNodeItem in graph[node]) {\n          var group = graph[node][graphNodeItem];\n          groups[group] = groups[group] || [];\n          expandedGroups.push.apply(expandedGroups, _toConsumableArray(groups[group]));\n        }\n\n        graph[node] = expandedGroups;\n      } // Merge intermediary graph using graphAfters into final graph\n\n\n      for (var _group in graphAfters) {\n        if (groups[_group]) {\n          var _iterator5 = _createForOfIteratorHelper(groups[_group]),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _graph$_node;\n\n              var _node = _step5.value;\n\n              (_graph$_node = graph[_node]).push.apply(_graph$_node, _toConsumableArray(graphAfters[_group]));\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } // Compile ancestors\n\n\n      var ancestors = {};\n\n      for (var _node2 in graph) {\n        var children = graph[_node2];\n\n        var _iterator6 = _createForOfIteratorHelper(children),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var child = _step6.value;\n            ancestors[child] = ancestors[child] || [];\n            ancestors[child].push(_node2);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      } // Topo sort\n\n\n      var visited = {};\n      var sorted = [];\n\n      for (var i = 0; i < this._items.length; ++i) {\n        // Looping through item.seq values out of order\n        var next = i;\n\n        if (ancestors[i]) {\n          next = null;\n\n          for (var j = 0; j < this._items.length; ++j) {\n            // As above, these are item.seq values\n            if (visited[j] === true) {\n              continue;\n            }\n\n            if (!ancestors[j]) {\n              ancestors[j] = [];\n            }\n\n            var shouldSeeCount = ancestors[j].length;\n            var seenCount = 0;\n\n            for (var k = 0; k < shouldSeeCount; ++k) {\n              if (visited[ancestors[j][k]]) {\n                ++seenCount;\n              }\n            }\n\n            if (seenCount === shouldSeeCount) {\n              next = j;\n              break;\n            }\n          }\n        }\n\n        if (next !== null) {\n          visited[next] = true;\n          sorted.push(next);\n        }\n      }\n\n      if (sorted.length !== this._items.length) {\n        return false;\n      }\n\n      var seqIndex = {};\n\n      var _iterator7 = _createForOfIteratorHelper(this._items),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _item = _step7.value;\n          seqIndex[_item.seq] = _item;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this._items = [];\n      this.nodes = [];\n\n      for (var _i = 0, _sorted = sorted; _i < _sorted.length; _i++) {\n        var value = _sorted[_i];\n        var sortedItem = seqIndex[value];\n        this.nodes.push(sortedItem.node);\n\n        this._items.push(sortedItem);\n      }\n\n      return true;\n    }\n  }]);\n\n  return Topo;\n}();\n\ninternals.mergeSort = function (a, b) {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/topo/lib/index.js"],"names":["Assert","require","internals","module","exports","_items","nodes","options","before","concat","after","group","sort","includes","Array","isArray","node","item","seq","length","push","valid","_sort","others","other","Object","assign","mergeSort","i","graph","graphAfters","create","groups","expandedGroups","graphNodeItem","ancestors","children","child","visited","sorted","next","j","shouldSeeCount","seenCount","k","seqIndex","value","sortedItem","a","b"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Assert = require('@hapi/hoek/lib/assert');\r\n\r\n\r\nconst internals = {};\r\n\r\n\r\nmodule.exports = class Topo {\r\n\r\n    constructor() {\r\n\r\n        this._items = [];\r\n        this.nodes = [];\r\n    }\r\n\r\n    add(nodes, options) {\r\n\r\n        options = options || {};\r\n\r\n        // Validate rules\r\n\r\n        const before = [].concat(options.before || []);\r\n        const after = [].concat(options.after || []);\r\n        const group = options.group || '?';\r\n        const sort = options.sort || 0;                   // Used for merging only\r\n\r\n        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\r\n        Assert(!before.includes('?'), 'Item cannot come before unassociated items');\r\n        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\r\n        Assert(!after.includes('?'), 'Item cannot come after unassociated items');\r\n\r\n        if (!Array.isArray(nodes)) {\r\n            nodes = [nodes];\r\n        }\r\n\r\n        for (const node of nodes) {\r\n            const item = {\r\n                seq: this._items.length,\r\n                sort,\r\n                before,\r\n                after,\r\n                group,\r\n                node\r\n            };\r\n\r\n            this._items.push(item);\r\n        }\r\n\r\n        // Insert event\r\n\r\n        const valid = this._sort();\r\n        Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\r\n\r\n        return this.nodes;\r\n    }\r\n\r\n    merge(others) {\r\n\r\n        if (!Array.isArray(others)) {\r\n            others = [others];\r\n        }\r\n\r\n        for (const other of others) {\r\n            if (other) {\r\n                for (const item of other._items) {\r\n                    this._items.push(Object.assign({}, item));      // Shallow cloned\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sort items\r\n\r\n        this._items.sort(internals.mergeSort);\r\n        for (let i = 0; i < this._items.length; ++i) {\r\n            this._items[i].seq = i;\r\n        }\r\n\r\n        const valid = this._sort();\r\n        Assert(valid, 'merge created a dependencies error');\r\n\r\n        return this.nodes;\r\n    }\r\n\r\n    _sort() {\r\n\r\n        // Construct graph\r\n\r\n        const graph = {};\r\n        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives\r\n        const groups = Object.create(null);\r\n\r\n        for (const item of this._items) {\r\n            const seq = item.seq;                           // Unique across all items\r\n            const group = item.group;\r\n\r\n            // Determine Groups\r\n\r\n            groups[group] = groups[group] || [];\r\n            groups[group].push(seq);\r\n\r\n            // Build intermediary graph using 'before'\r\n\r\n            graph[seq] = item.before;\r\n\r\n            // Build second intermediary graph with 'after'\r\n\r\n            for (const after of item.after) {\r\n                graphAfters[after] = graphAfters[after] || [];\r\n                graphAfters[after].push(seq);\r\n            }\r\n        }\r\n\r\n        // Expand intermediary graph\r\n\r\n        for (const node in graph) {\r\n            const expandedGroups = [];\r\n\r\n            for (const graphNodeItem in graph[node]) {\r\n                const group = graph[node][graphNodeItem];\r\n                groups[group] = groups[group] || [];\r\n                expandedGroups.push(...groups[group]);\r\n            }\r\n\r\n            graph[node] = expandedGroups;\r\n        }\r\n\r\n        // Merge intermediary graph using graphAfters into final graph\r\n\r\n        for (const group in graphAfters) {\r\n            if (groups[group]) {\r\n                for (const node of groups[group]) {\r\n                    graph[node].push(...graphAfters[group]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile ancestors\r\n\r\n        const ancestors = {};\r\n        for (const node in graph) {\r\n            const children = graph[node];\r\n            for (const child of children) {\r\n                ancestors[child] = ancestors[child] || [];\r\n                ancestors[child].push(node);\r\n            }\r\n        }\r\n\r\n        // Topo sort\r\n\r\n        const visited = {};\r\n        const sorted = [];\r\n\r\n        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order\r\n            let next = i;\r\n\r\n            if (ancestors[i]) {\r\n                next = null;\r\n                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values\r\n                    if (visited[j] === true) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!ancestors[j]) {\r\n                        ancestors[j] = [];\r\n                    }\r\n\r\n                    const shouldSeeCount = ancestors[j].length;\r\n                    let seenCount = 0;\r\n                    for (let k = 0; k < shouldSeeCount; ++k) {\r\n                        if (visited[ancestors[j][k]]) {\r\n                            ++seenCount;\r\n                        }\r\n                    }\r\n\r\n                    if (seenCount === shouldSeeCount) {\r\n                        next = j;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (next !== null) {\r\n                visited[next] = true;\r\n                sorted.push(next);\r\n            }\r\n        }\r\n\r\n        if (sorted.length !== this._items.length) {\r\n            return false;\r\n        }\r\n\r\n        const seqIndex = {};\r\n        for (const item of this._items) {\r\n            seqIndex[item.seq] = item;\r\n        }\r\n\r\n        this._items = [];\r\n        this.nodes = [];\r\n\r\n        for (const value of sorted) {\r\n            const sortedItem = seqIndex[value];\r\n            this.nodes.push(sortedItem.node);\r\n            this._items.push(sortedItem);\r\n        }\r\n\r\n        return true;\r\n    }\r\n};\r\n\r\n\r\ninternals.mergeSort = (a, b) => {\r\n\r\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}