{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose\n  } = options;\n  let helperName = \"taggedTemplateLiteral\";\n  if (loose) helperName += \"Loose\";\n\n  function buildConcatCallExpressions(items) {\n    let avail = true;\n    return items.reduce(function (left, right) {\n      let canBeInserted = _core.types.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n\n      if (canBeInserted && _core.types.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n\n      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier(\"concat\")), [right]);\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const {\n          node\n        } = path;\n        const {\n          quasi\n        } = node;\n        const strings = [];\n        const raws = [];\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const {\n            raw,\n            cooked\n          } = elem.value;\n          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);\n          strings.push(value);\n          raws.push(_core.types.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            isStringsRawEqual = false;\n          }\n        }\n\n        const scope = path.scope.getProgramParent();\n        const templateObject = scope.generateUidIdentifier(\"templateObject\");\n        const helperId = this.addHelper(helperName);\n        const callExpressionInput = [_core.types.arrayExpression(strings)];\n\n        if (!isStringsRawEqual) {\n          callExpressionInput.push(_core.types.arrayExpression(raws));\n        }\n\n        const lazyLoad = _core.template.ast`\n          function ${templateObject}() {\n            const data = ${_core.types.callExpression(helperId, callExpressionInput)};\n            ${templateObject} = function() { return data };\n            return data;\n          } \n        `;\n        scope.path.unshiftContainer(\"body\", lazyLoad);\n        path.replaceWith(_core.types.callExpression(node.tag, [_core.types.callExpression(_core.types.cloneNode(templateObject), []), ...quasi.expressions]));\n      },\n\n      TemplateLiteral(path) {\n        const nodes = [];\n        const expressions = path.get(\"expressions\");\n        let index = 0;\n\n        for (const elem of path.node.quasis) {\n          if (elem.value.cooked) {\n            nodes.push(_core.types.stringLiteral(elem.value.cooked));\n          }\n\n          if (index < expressions.length) {\n            const expr = expressions[index++];\n            const node = expr.node;\n\n            if (!_core.types.isStringLiteral(node, {\n              value: \"\"\n            })) {\n              nodes.push(node);\n            }\n          }\n        }\n\n        const considerSecondNode = !loose || !_core.types.isStringLiteral(nodes[1]);\n\n        if (!_core.types.isStringLiteral(nodes[0]) && considerSecondNode) {\n          nodes.unshift(_core.types.stringLiteral(\"\"));\n        }\n\n        let root = nodes[0];\n\n        if (loose) {\n          for (let i = 1; i < nodes.length; i++) {\n            root = _core.types.binaryExpression(\"+\", root, nodes[i]);\n          }\n        } else if (nodes.length > 1) {\n          root = buildConcatCallExpressions(nodes);\n        }\n\n        path.replaceWith(root);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-template-literals/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","options","assertVersion","loose","helperName","buildConcatCallExpressions","items","avail","reduce","left","right","canBeInserted","types","isLiteral","isCallExpression","arguments","push","callExpression","memberExpression","identifier","name","visitor","TaggedTemplateExpression","path","node","quasi","strings","raws","isStringsRawEqual","elem","quasis","raw","cooked","scope","buildUndefinedNode","stringLiteral","getProgramParent","templateObject","generateUidIdentifier","helperId","addHelper","callExpressionInput","arrayExpression","lazyLoad","template","ast","unshiftContainer","replaceWith","tag","cloneNode","expressions","TemplateLiteral","nodes","get","index","length","expr","isStringLiteral","considerSecondNode","unshift","root","i","binaryExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose\n  } = options;\n  let helperName = \"taggedTemplateLiteral\";\n  if (loose) helperName += \"Loose\";\n\n  function buildConcatCallExpressions(items) {\n    let avail = true;\n    return items.reduce(function (left, right) {\n      let canBeInserted = _core.types.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n\n      if (canBeInserted && _core.types.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n\n      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier(\"concat\")), [right]);\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const {\n          node\n        } = path;\n        const {\n          quasi\n        } = node;\n        const strings = [];\n        const raws = [];\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const {\n            raw,\n            cooked\n          } = elem.value;\n          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);\n          strings.push(value);\n          raws.push(_core.types.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            isStringsRawEqual = false;\n          }\n        }\n\n        const scope = path.scope.getProgramParent();\n        const templateObject = scope.generateUidIdentifier(\"templateObject\");\n        const helperId = this.addHelper(helperName);\n        const callExpressionInput = [_core.types.arrayExpression(strings)];\n\n        if (!isStringsRawEqual) {\n          callExpressionInput.push(_core.types.arrayExpression(raws));\n        }\n\n        const lazyLoad = _core.template.ast`\n          function ${templateObject}() {\n            const data = ${_core.types.callExpression(helperId, callExpressionInput)};\n            ${templateObject} = function() { return data };\n            return data;\n          } \n        `;\n        scope.path.unshiftContainer(\"body\", lazyLoad);\n        path.replaceWith(_core.types.callExpression(node.tag, [_core.types.callExpression(_core.types.cloneNode(templateObject), []), ...quasi.expressions]));\n      },\n\n      TemplateLiteral(path) {\n        const nodes = [];\n        const expressions = path.get(\"expressions\");\n        let index = 0;\n\n        for (const elem of path.node.quasis) {\n          if (elem.value.cooked) {\n            nodes.push(_core.types.stringLiteral(elem.value.cooked));\n          }\n\n          if (index < expressions.length) {\n            const expr = expressions[index++];\n            const node = expr.node;\n\n            if (!_core.types.isStringLiteral(node, {\n              value: \"\"\n            })) {\n              nodes.push(node);\n            }\n          }\n        }\n\n        const considerSecondNode = !loose || !_core.types.isStringLiteral(nodes[1]);\n\n        if (!_core.types.isStringLiteral(nodes[0]) && considerSecondNode) {\n          nodes.unshift(_core.types.stringLiteral(\"\"));\n        }\n\n        let root = nodes[0];\n\n        if (loose) {\n          for (let i = 1; i < nodes.length; i++) {\n            root = _core.types.binaryExpression(\"+\", root, nodes[i]);\n          }\n        } else if (nodes.length > 1) {\n          root = buildConcatCallExpressions(nodes);\n        }\n\n        path.replaceWith(root);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}