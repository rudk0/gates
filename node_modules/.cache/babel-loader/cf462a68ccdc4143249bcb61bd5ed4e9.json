{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return {\n    name: \"transform-typeof-symbol\",\n    visitor: {\n      Scope({\n        scope\n      }) {\n        if (!scope.getBinding(\"Symbol\")) {\n          return;\n        }\n\n        scope.rename(\"Symbol\");\n      },\n\n      UnaryExpression(path) {\n        const {\n          node,\n          parent\n        } = path;\n        if (node.operator !== \"typeof\") return;\n\n        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {\n          const opposite = path.getOpposite();\n\n          if (opposite.isLiteral() && opposite.node.value !== \"symbol\" && opposite.node.value !== \"object\") {\n            return;\n          }\n        }\n\n        let isUnderHelper = path.findParent(path => {\n          if (path.isFunction()) {\n            var _path$get;\n\n            return ((_path$get = path.get(\"body.directives.0\")) == null ? void 0 : _path$get.node.value.value) === \"@babel/helpers - typeof\";\n          }\n        });\n        if (isUnderHelper) return;\n        const helper = this.addHelper(\"typeof\");\n        isUnderHelper = path.findParent(path => {\n          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;\n        });\n\n        if (isUnderHelper) {\n          return;\n        }\n\n        const call = _core.types.callExpression(helper, [node.argument]);\n\n        const arg = path.get(\"argument\");\n\n        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {\n          const unary = _core.types.unaryExpression(\"typeof\", _core.types.cloneNode(node.argument));\n\n          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression(\"===\", unary, _core.types.stringLiteral(\"undefined\")), _core.types.stringLiteral(\"undefined\"), call));\n        } else {\n          path.replaceWith(call);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-typeof-symbol/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","assertVersion","name","visitor","Scope","scope","getBinding","rename","UnaryExpression","path","node","parent","operator","parentPath","isBinaryExpression","types","EQUALITY_BINARY_OPERATORS","indexOf","opposite","getOpposite","isLiteral","isUnderHelper","findParent","isFunction","_path$get","get","helper","addHelper","isVariableDeclarator","id","isFunctionDeclaration","call","callExpression","argument","arg","isIdentifier","hasBinding","unary","unaryExpression","cloneNode","replaceWith","conditionalExpression","binaryExpression","stringLiteral"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return {\n    name: \"transform-typeof-symbol\",\n    visitor: {\n      Scope({\n        scope\n      }) {\n        if (!scope.getBinding(\"Symbol\")) {\n          return;\n        }\n\n        scope.rename(\"Symbol\");\n      },\n\n      UnaryExpression(path) {\n        const {\n          node,\n          parent\n        } = path;\n        if (node.operator !== \"typeof\") return;\n\n        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {\n          const opposite = path.getOpposite();\n\n          if (opposite.isLiteral() && opposite.node.value !== \"symbol\" && opposite.node.value !== \"object\") {\n            return;\n          }\n        }\n\n        let isUnderHelper = path.findParent(path => {\n          if (path.isFunction()) {\n            var _path$get;\n\n            return ((_path$get = path.get(\"body.directives.0\")) == null ? void 0 : _path$get.node.value.value) === \"@babel/helpers - typeof\";\n          }\n        });\n        if (isUnderHelper) return;\n        const helper = this.addHelper(\"typeof\");\n        isUnderHelper = path.findParent(path => {\n          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;\n        });\n\n        if (isUnderHelper) {\n          return;\n        }\n\n        const call = _core.types.callExpression(helper, [node.argument]);\n\n        const arg = path.get(\"argument\");\n\n        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {\n          const unary = _core.types.unaryExpression(\"typeof\", _core.types.cloneNode(node.argument));\n\n          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression(\"===\", unary, _core.types.stringLiteral(\"undefined\")), _core.types.stringLiteral(\"undefined\"), call));\n        } else {\n          path.replaceWith(call);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}