{"ast":null,"code":"export function walk(ast, {\n  enter,\n  leave\n}) {\n  visit(ast, null, enter, leave);\n}\nlet shouldSkip = false;\nconst context = {\n  skip: () => shouldSkip = true\n};\nexport const childKeys = {};\nconst toString = Object.prototype.toString;\n\nfunction isArray(thing) {\n  return toString.call(thing) === '[object Array]';\n}\n\nfunction visit(node, parent, enter, leave, prop, index) {\n  if (!node) return;\n\n  if (enter) {\n    const _shouldSkip = shouldSkip;\n    shouldSkip = false;\n    enter.call(context, node, parent, prop, index);\n    const skipped = shouldSkip;\n    shouldSkip = _shouldSkip;\n    if (skipped) return;\n  }\n\n  const keys = node.type && childKeys[node.type] || (childKeys[node.type] = Object.keys(node).filter(key => typeof node[key] === 'object'));\n\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    const value = node[key];\n\n    if (isArray(value)) {\n      for (let j = 0; j < value.length; j += 1) {\n        value[j] && value[j].type && visit(value[j], node, enter, leave, key, j);\n      }\n    } else if (value && value.type) {\n      visit(value, node, enter, leave, key, null);\n    }\n  }\n\n  if (leave) {\n    leave(node, parent, prop, index);\n  }\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/rollup-pluginutils/node_modules/estree-walker/src/estree-walker.js"],"names":["walk","ast","enter","leave","visit","shouldSkip","context","skip","childKeys","toString","Object","prototype","isArray","thing","call","node","parent","prop","index","_shouldSkip","skipped","keys","type","filter","key","i","length","value","j"],"mappings":"AAAA,OAAO,SAASA,IAAT,CAAcC,GAAd,EAAmB;AAAEC,EAAAA,KAAF;AAASC,EAAAA;AAAT,CAAnB,EAAqC;AAC3CC,EAAAA,KAAK,CAACH,GAAD,EAAM,IAAN,EAAYC,KAAZ,EAAmBC,KAAnB,CAAL;AACA;AAED,IAAIE,UAAU,GAAG,KAAjB;AACA,MAAMC,OAAO,GAAG;AAAEC,EAAAA,IAAI,EAAE,MAAMF,UAAU,GAAG;AAA3B,CAAhB;AAEA,OAAO,MAAMG,SAAS,GAAG,EAAlB;AAEP,MAAMC,QAAQ,GAAGC,MAAM,CAACC,SAAP,CAAiBF,QAAlC;;AAEA,SAASG,OAAT,CAAiBC,KAAjB,EAAwB;AACvB,SAAOJ,QAAQ,CAACK,IAAT,CAAcD,KAAd,MAAyB,gBAAhC;AACA;;AAED,SAAST,KAAT,CAAeW,IAAf,EAAqBC,MAArB,EAA6Bd,KAA7B,EAAoCC,KAApC,EAA2Cc,IAA3C,EAAiDC,KAAjD,EAAwD;AACvD,MAAI,CAACH,IAAL,EAAW;;AAEX,MAAIb,KAAJ,EAAW;AACV,UAAMiB,WAAW,GAAGd,UAApB;AACAA,IAAAA,UAAU,GAAG,KAAb;AACAH,IAAAA,KAAK,CAACY,IAAN,CAAWR,OAAX,EAAoBS,IAApB,EAA0BC,MAA1B,EAAkCC,IAAlC,EAAwCC,KAAxC;AACA,UAAME,OAAO,GAAGf,UAAhB;AACAA,IAAAA,UAAU,GAAGc,WAAb;AAEA,QAAIC,OAAJ,EAAa;AACb;;AAED,QAAMC,IAAI,GAAGN,IAAI,CAACO,IAAL,IAAad,SAAS,CAACO,IAAI,CAACO,IAAN,CAAtB,KACZd,SAAS,CAACO,IAAI,CAACO,IAAN,CAAT,GAAuBZ,MAAM,CAACW,IAAP,CAAYN,IAAZ,EAAkBQ,MAAlB,CAAyBC,GAAG,IAAI,OAAOT,IAAI,CAACS,GAAD,CAAX,KAAqB,QAArD,CADX,CAAb;;AAIA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACK,MAAzB,EAAiCD,CAAC,IAAI,CAAtC,EAAyC;AACxC,UAAMD,GAAG,GAAGH,IAAI,CAACI,CAAD,CAAhB;AACA,UAAME,KAAK,GAAGZ,IAAI,CAACS,GAAD,CAAlB;;AAEA,QAAIZ,OAAO,CAACe,KAAD,CAAX,EAAoB;AACnB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACD,MAA1B,EAAkCE,CAAC,IAAI,CAAvC,EAA0C;AACzCD,QAAAA,KAAK,CAACC,CAAD,CAAL,IAAYD,KAAK,CAACC,CAAD,CAAL,CAASN,IAArB,IAA6BlB,KAAK,CAACuB,KAAK,CAACC,CAAD,CAAN,EAAWb,IAAX,EAAiBb,KAAjB,EAAwBC,KAAxB,EAA+BqB,GAA/B,EAAoCI,CAApC,CAAlC;AACA;AACD,KAJD,MAMK,IAAID,KAAK,IAAIA,KAAK,CAACL,IAAnB,EAAyB;AAC7BlB,MAAAA,KAAK,CAACuB,KAAD,EAAQZ,IAAR,EAAcb,KAAd,EAAqBC,KAArB,EAA4BqB,GAA5B,EAAiC,IAAjC,CAAL;AACA;AACD;;AAED,MAAIrB,KAAJ,EAAW;AACVA,IAAAA,KAAK,CAACY,IAAD,EAAOC,MAAP,EAAeC,IAAf,EAAqBC,KAArB,CAAL;AACA;AACD","sourcesContent":["export function walk(ast, { enter, leave }) {\n\tvisit(ast, null, enter, leave);\n}\n\nlet shouldSkip = false;\nconst context = { skip: () => shouldSkip = true };\n\nexport const childKeys = {};\n\nconst toString = Object.prototype.toString;\n\nfunction isArray(thing) {\n\treturn toString.call(thing) === '[object Array]';\n}\n\nfunction visit(node, parent, enter, leave, prop, index) {\n\tif (!node) return;\n\n\tif (enter) {\n\t\tconst _shouldSkip = shouldSkip;\n\t\tshouldSkip = false;\n\t\tenter.call(context, node, parent, prop, index);\n\t\tconst skipped = shouldSkip;\n\t\tshouldSkip = _shouldSkip;\n\n\t\tif (skipped) return;\n\t}\n\n\tconst keys = node.type && childKeys[node.type] || (\n\t\tchildKeys[node.type] = Object.keys(node).filter(key => typeof node[key] === 'object')\n\t);\n\n\tfor (let i = 0; i < keys.length; i += 1) {\n\t\tconst key = keys[i];\n\t\tconst value = node[key];\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let j = 0; j < value.length; j += 1) {\n\t\t\t\tvalue[j] && value[j].type && visit(value[j], node, enter, leave, key, j);\n\t\t\t}\n\t\t}\n\n\t\telse if (value && value.type) {\n\t\t\tvisit(value, node, enter, leave, key, null);\n\t\t}\n\t}\n\n\tif (leave) {\n\t\tleave(node, parent, prop, index);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}