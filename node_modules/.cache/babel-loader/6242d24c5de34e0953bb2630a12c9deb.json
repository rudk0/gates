{"ast":null,"code":"/*!\n * strip-comments <https://github.com/jonschlinkert/strip-comments>\n *\n * Copyright (c) 2014-2016, 2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n'use strict';\n\nconst assign = Object.assign;\n\nconst extract = require('babel-extract-comments');\n/**\n * Strip all code comments from the given `input`, including protected\n * comments that start with `!`, unless disabled by setting `options.keepProtected`\n * to true.\n *\n * ```js\n * const str = strip('const foo = \"bar\";// this is a comment\\n /* me too *\\/');\n * console.log(str);\n * // => 'const foo = \"bar\";'\n * ```\n * @name  strip\n * @param  {String} `input` string from which to strip comments\n * @param  {Object} `options` optional options, passed to [extract-comments][extract-comments]\n * @option {Boolean} [options] `line` if `false` strip only block comments, default `true`\n * @option {Boolean} [options] `block` if `false` strip only line comments, default `true`\n * @option {Boolean} [options] `keepProtected` Keep ignored comments (e.g. `/*!` and `//!`)\n * @option {Boolean} [options] `preserveNewlines` Preserve newlines after comments are stripped\n * @return {String} modified input\n * @api public\n */\n\n\nfunction strip(input, options) {\n  return stripComments(input, assign({\n    block: true,\n    line: true\n  }, options));\n}\n/**\n * Strip only block comments.\n *\n * ```js\n * const strip = require('..');\n * const str = strip.block('const foo = \"bar\";// this is a comment\\n /* me too *\\/');\n * console.log(str);\n * // => 'const foo = \"bar\";// this is a comment'\n * ```\n * @name  .block\n * @param  {String} `input` string from which to strip comments\n * @param  {Object} `options` pass `opts.keepProtected: true` to keep ignored comments (e.g. `/*!`)\n * @return {String} modified string\n * @api public\n */\n\n\nstrip.block = function (input, options) {\n  return stripComments(input, assign({\n    block: true\n  }, options));\n};\n/**\n * Strip only line comments.\n *\n * ```js\n * const str = strip.line('const foo = \"bar\";// this is a comment\\n /* me too *\\/');\n * console.log(str);\n * // => 'const foo = \"bar\";\\n/* me too *\\/'\n * ```\n * @name  .line\n * @param  {String} `input` string from which to strip comments\n * @param  {Object} `options` pass `opts.keepProtected: true` to keep ignored comments (e.g. `//!`)\n * @return {String} modified string\n * @api public\n */\n\n\nstrip.line = function (input, options) {\n  return stripComments(input, assign({\n    line: true\n  }, options));\n};\n/**\n * Strip the first comment from the given `input`. Or, if `opts.keepProtected` is true,\n * the first non-protected comment will be stripped.\n *\n * ```js\n * const output = strip.first(input, { keepProtected: true });\n * console.log(output);\n * // => '//! first comment\\nfoo; '\n * ```\n * @name .first\n * @param {String} `input`\n * @param {Object} `options` pass `opts.keepProtected: true` to keep comments with `!`\n * @return {String}\n * @api public\n */\n\n\nstrip.first = function (input, options) {\n  const opts = assign({\n    block: true,\n    line: true,\n    first: true\n  }, options);\n  return stripComments(input, opts);\n};\n/**\n * Strip comments\n */\n\n\nfunction stripComments(input, options) {\n  if (typeof input !== 'string') {\n    throw new TypeError('expected a string');\n  } // strip all by default, including `ingored` comments.\n\n\n  const defaults = {\n    // we shouldn't care about this here since our goal is to strip comments,\n    // not transpiling, and this has been a common cause of parsing issues\n    allowReturnOutsideFunction: true,\n    block: false,\n    line: false,\n    safe: false,\n    first: false,\n    plugins: []\n  };\n  const opts = assign({}, defaults, options);\n  opts.plugins.push('objectRestSpread');\n\n  if (typeof opts.keepProtected !== 'boolean') {\n    opts.keepProtected = opts.safe;\n  }\n\n  try {\n    const comments = extract(input, opts);\n    let pos = {\n      start: 0,\n      end: 0,\n      removed: 0\n    };\n    if (!comments) return input;\n\n    for (const comment of comments) {\n      if (typeof opts.filter === 'function' && opts.filter(comment, opts) === false) {\n        continue;\n      }\n\n      input = remove(input, comment, opts, pos);\n\n      if (opts.first === true && !isProtected(comment, opts)) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (options.silent !== true) {\n      throw err;\n    }\n  }\n\n  return input;\n}\n/**\n * Remove a single comment from the given string.\n */\n\n\nfunction remove(str, comment, options, pos) {\n  let nl = '';\n\n  if (isProtected(comment, options)) {\n    return str;\n  }\n\n  if (options && options.preserveNewlines) {\n    nl = comment.value.replace(/[^\\r\\n]/g, '');\n  }\n\n  if (comment.type === 'CommentLine' && options.line === true) {\n    const before = str.slice(0, comment.start - pos.removed);\n    const after = str.slice(comment.end - pos.removed);\n    pos.removed += comment.end - comment.start - nl.length;\n    return before + nl + after;\n  }\n\n  if (comment.type === 'CommentBlock' && options.block === true) {\n    const before = str.slice(0, comment.start - pos.removed);\n    const after = str.slice(comment.end - pos.removed);\n    pos.removed += comment.end - comment.start - nl.length;\n    return before + nl + after;\n  }\n\n  return str;\n}\n\nfunction isProtected(comment, options) {\n  return options && options.keepProtected === true && /^\\*?!/.test(comment.value);\n}\n\nmodule.exports = strip;","map":{"version":3,"sources":["/home/agatha/open/node_modules/strip-comments/index.js"],"names":["assign","Object","extract","require","strip","input","options","stripComments","block","line","first","opts","TypeError","defaults","allowReturnOutsideFunction","safe","plugins","push","keepProtected","comments","pos","start","end","removed","comment","filter","remove","isProtected","err","silent","str","nl","preserveNewlines","value","replace","type","before","slice","after","length","test","module","exports"],"mappings":"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","sourcesContent":["/*!\n * strip-comments <https://github.com/jonschlinkert/strip-comments>\n *\n * Copyright (c) 2014-2016, 2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst assign = Object.assign;\nconst extract = require('babel-extract-comments');\n\n/**\n * Strip all code comments from the given `input`, including protected\n * comments that start with `!`, unless disabled by setting `options.keepProtected`\n * to true.\n *\n * ```js\n * const str = strip('const foo = \"bar\";// this is a comment\\n /* me too *\\/');\n * console.log(str);\n * // => 'const foo = \"bar\";'\n * ```\n * @name  strip\n * @param  {String} `input` string from which to strip comments\n * @param  {Object} `options` optional options, passed to [extract-comments][extract-comments]\n * @option {Boolean} [options] `line` if `false` strip only block comments, default `true`\n * @option {Boolean} [options] `block` if `false` strip only line comments, default `true`\n * @option {Boolean} [options] `keepProtected` Keep ignored comments (e.g. `/*!` and `//!`)\n * @option {Boolean} [options] `preserveNewlines` Preserve newlines after comments are stripped\n * @return {String} modified input\n * @api public\n */\n\nfunction strip(input, options) {\n  return stripComments(input, assign({ block: true, line: true }, options));\n}\n\n/**\n * Strip only block comments.\n *\n * ```js\n * const strip = require('..');\n * const str = strip.block('const foo = \"bar\";// this is a comment\\n /* me too *\\/');\n * console.log(str);\n * // => 'const foo = \"bar\";// this is a comment'\n * ```\n * @name  .block\n * @param  {String} `input` string from which to strip comments\n * @param  {Object} `options` pass `opts.keepProtected: true` to keep ignored comments (e.g. `/*!`)\n * @return {String} modified string\n * @api public\n */\n\nstrip.block = function(input, options) {\n  return stripComments(input, assign({ block: true }, options));\n};\n\n/**\n * Strip only line comments.\n *\n * ```js\n * const str = strip.line('const foo = \"bar\";// this is a comment\\n /* me too *\\/');\n * console.log(str);\n * // => 'const foo = \"bar\";\\n/* me too *\\/'\n * ```\n * @name  .line\n * @param  {String} `input` string from which to strip comments\n * @param  {Object} `options` pass `opts.keepProtected: true` to keep ignored comments (e.g. `//!`)\n * @return {String} modified string\n * @api public\n */\n\nstrip.line = function(input, options) {\n  return stripComments(input, assign({ line: true }, options));\n};\n\n/**\n * Strip the first comment from the given `input`. Or, if `opts.keepProtected` is true,\n * the first non-protected comment will be stripped.\n *\n * ```js\n * const output = strip.first(input, { keepProtected: true });\n * console.log(output);\n * // => '//! first comment\\nfoo; '\n * ```\n * @name .first\n * @param {String} `input`\n * @param {Object} `options` pass `opts.keepProtected: true` to keep comments with `!`\n * @return {String}\n * @api public\n */\n\nstrip.first = function(input, options) {\n  const opts = assign({ block: true, line: true, first: true }, options);\n  return stripComments(input, opts);\n};\n\n/**\n * Strip comments\n */\n\nfunction stripComments(input, options) {\n  if (typeof input !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // strip all by default, including `ingored` comments.\n  const defaults = {\n    // we shouldn't care about this here since our goal is to strip comments,\n    // not transpiling, and this has been a common cause of parsing issues\n    allowReturnOutsideFunction: true,\n    block: false,\n    line: false,\n    safe: false,\n    first: false,\n    plugins: []\n  };\n\n  const opts = assign({}, defaults, options);\n  opts.plugins.push('objectRestSpread');\n\n  if (typeof opts.keepProtected !== 'boolean') {\n    opts.keepProtected = opts.safe;\n  }\n\n  try {\n    const comments = extract(input, opts);\n    let pos = { start: 0, end: 0, removed: 0 };\n    if (!comments) return input;\n\n    for (const comment of comments) {\n      if (typeof opts.filter === 'function' && opts.filter(comment, opts) === false) {\n        continue;\n      }\n\n      input = remove(input, comment, opts, pos);\n\n      if (opts.first === true && !isProtected(comment, opts)) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (options.silent !== true) {\n      throw err;\n    }\n  }\n  return input;\n}\n\n/**\n * Remove a single comment from the given string.\n */\n\nfunction remove(str, comment, options, pos) {\n  let nl = '';\n\n  if (isProtected(comment, options)) {\n    return str;\n  }\n\n  if (options && options.preserveNewlines) {\n    nl = comment.value.replace(/[^\\r\\n]/g, '');\n  }\n\n  if (comment.type === 'CommentLine' && options.line === true) {\n    const before = str.slice(0, comment.start - pos.removed);\n    const after = str.slice(comment.end - pos.removed);\n    pos.removed += comment.end - comment.start - nl.length;\n    return before + nl + after;\n  }\n\n  if (comment.type === 'CommentBlock' && options.block === true) {\n    const before = str.slice(0, comment.start - pos.removed);\n    const after = str.slice(comment.end - pos.removed);\n    pos.removed += comment.end - comment.start - nl.length;\n    return before + nl + after;\n  }\n\n  return str;\n}\n\nfunction isProtected(comment, options) {\n  return options && options.keepProtected === true && /^\\*?!/.test(comment.value);\n}\n\nmodule.exports = strip;\n"]},"metadata":{},"sourceType":"script"}