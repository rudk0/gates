{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _tdz = require(\"./tdz\");\n\nvar _values = _interopRequireDefault(require(\"lodash/values\"));\n\nvar _extend = _interopRequireDefault(require(\"lodash/extend\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst DONE = new WeakSet();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    throwIfClosureRequired = false,\n    tdz: tdzEnabled = false\n  } = opts;\n\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n    visitor: {\n      VariableDeclaration(path) {\n        const {\n          node,\n          parent,\n          scope\n        } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        if (node._tdzThis) {\n          const nodes = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n\n            const assign = _core.types.assignmentExpression(\"=\", decl.id, decl.init || scope.buildUndefinedNode());\n\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(_core.types.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(path, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        const blockScoping = new BlockScoping(null, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(path, state) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);\n          blockScoping.run();\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;\n\nfunction ignoreBlock(path) {\n  return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = (0, _core.template)(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node) {\n  if (!_core.types.isVariableDeclaration(node)) return false;\n  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) return true;\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\nfunction isInLoop(path) {\n  const loopOrFunctionParent = path.find(path => path.isLoop() || path.isFunction());\n  return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();\n}\n\nfunction convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent = false) {\n  if (!node) {\n    node = path.node;\n  }\n\n  if (isInLoop(path) && !_core.types.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  node[_core.types.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node) {\n  return _core.types.isVariableDeclaration(node, {\n    kind: \"var\"\n  }) && !isBlockScoped(node);\n}\n\nconst letReferenceBlockVisitor = _core.traverse.visitors.merge([{\n  Loop: {\n    enter(path, state) {\n      state.loopDepth++;\n    },\n\n    exit(path, state) {\n      state.loopDepth--;\n    }\n\n  },\n\n  Function(path, state) {\n    if (state.loopDepth > 0) {\n      path.traverse(letReferenceFunctionVisitor, state);\n    } else {\n      path.traverse(_tdz.visitor, state);\n    }\n\n    return path.skip();\n  }\n\n}, _tdz.visitor]);\n\nconst letReferenceFunctionVisitor = _core.traverse.visitors.merge([{\n  ReferencedIdentifier(path, state) {\n    const ref = state.letReferences[path.node.name];\n    if (!ref) return;\n    const localBinding = path.scope.getBindingIdentifier(path.node.name);\n    if (localBinding && localBinding !== ref) return;\n    state.closurify = true;\n  }\n\n}, _tdz.visitor]);\n\nconst hoistVarDeclarationsVisitor = {\n  enter(path, self) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (path.isForStatement()) {\n      if (isVar(node.init, node)) {\n        const nodes = self.pushDeclar(node.init);\n\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = _core.types.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isFor()) {\n      if (isVar(node.left, node)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(node, parent)) {\n      path.replaceWithMultiple(self.pushDeclar(node).map(expr => _core.types.expressionStatement(expr)));\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  }\n\n};\nconst loopLabelVisitor = {\n  LabeledStatement({\n    node\n  }, state) {\n    state.innerLabels.push(node.label.name);\n  }\n\n};\nconst continuationVisitor = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) {\n          continue;\n        }\n\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  }\n\n};\n\nfunction loopNodeTo(node) {\n  if (_core.types.isBreakStatement(node)) {\n    return \"break\";\n  } else if (_core.types.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(path, state) {\n    const {\n      node,\n      scope\n    } = path;\n    if (node[this.LOOP_IGNORE]) return;\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (node.label) {\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        if (state.ignoreLabeless) return;\n        if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map[loopText] = node;\n      replace = _core.types.stringLiteral(loopText);\n    }\n\n    if (path.isReturnStatement()) {\n      state.hasReturn = true;\n      replace = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"v\"), node.argument || scope.buildUndefinedNode())]);\n    }\n\n    if (replace) {\n      replace = _core.types.returnStatement(replace);\n      replace[this.LOOP_IGNORE] = true;\n      path.skip();\n      path.replaceWith(_core.types.inherits(replace, node));\n    }\n  }\n\n};\n\nclass BlockScoping {\n  constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n    this.outsideLetReferences = Object.create(null);\n    this.hasLetReferences = false;\n    this.letReferences = Object.create(null);\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n    const needsClosure = this.getLetReferences();\n    this.checkConstants();\n\n    if (_core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !_core.types.isLabeledStatement(this.loopParent)) {\n      return _core.types.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const scope = this.scope;\n    const state = this.state;\n\n    for (const name of Object.keys(scope.bindings)) {\n      const binding = scope.bindings[name];\n      if (binding.kind !== \"const\") continue;\n\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n\n        const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);\n\n        if (violation.isAssignmentExpression()) {\n          violation.get(\"right\").replaceWith(_core.types.sequenceExpression([throwNode, violation.get(\"right\").node]));\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(_core.types.sequenceExpression([throwNode, violation.node]));\n        } else if (violation.isForXStatement()) {\n          violation.ensureBlock();\n          violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure) {\n    const blockScope = this.blockPath.scope;\n    const parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of Object.keys(letRefs)) {\n      const ref = letRefs[key];\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    for (const key of Object.keys(letRefs)) {\n      const ref = letRefs[key];\n\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        if (scope.hasOwnBinding(key)) {\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of Object.keys(outsideLetRefs)) {\n      const ref = letRefs[key];\n\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n    }\n\n    const block = this.block;\n    const outsideRefs = this.outsideLetReferences;\n\n    if (this.loop) {\n      for (const name of Object.keys(outsideRefs)) {\n        const id = outsideRefs[name];\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          delete outsideRefs[id.name];\n          delete this.letReferences[id.name];\n          this.scope.rename(id.name);\n          this.letReferences[id.name] = id;\n          outsideRefs[id.name] = id;\n        }\n      }\n    }\n\n    this.has = this.checkLoop();\n    this.hoistVarDeclarations();\n    const args = (0, _values.default)(outsideRefs).map(id => _core.types.cloneNode(id));\n    const params = args.map(id => _core.types.cloneNode(id));\n    const isSwitch = this.blockPath.isSwitchStatement();\n\n    const fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [block] : block.body));\n\n    this.addContinuations(fn);\n\n    let call = _core.types.callExpression(_core.types.nullLiteral(), args);\n\n    let basePath = \".callee\";\n\n    const hasYield = _core.traverse.hasType(fn.body, \"YieldExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasYield) {\n      fn.generator = true;\n      call = _core.types.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    const hasAsync = _core.traverse.hasType(fn.body, \"AwaitExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasAsync) {\n      fn.async = true;\n      call = _core.types.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n      this.body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(ret), call)]));\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n      this.buildHas(ret);\n    } else {\n      this.body.push(_core.types.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath;\n\n    if (isSwitch) {\n      const {\n        parentPath,\n        listKey,\n        key\n      } = this.blockPath;\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[key + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath);\n    let fnPath;\n\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(loopId), fn)]));\n      placeholder.replaceWith(_core.types.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  addContinuations(fn) {\n    const state = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences\n    };\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = _core.types.identifier(newParamName);\n      this.scope.rename(paramName, newParamName, fn);\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n      });\n      fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n    let declarators = [];\n\n    if (this.loop) {\n      const init = this.loop.left || this.loop.init;\n\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        (0, _extend.default)(this.outsideLetReferences, _core.types.getBindingIdentifiers(init));\n      }\n    }\n\n    const addDeclarationsFromChild = (path, node) => {\n      node = node || path.node;\n\n      if (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(path, node, block, this.scope);\n        }\n\n        declarators = declarators.concat(node.declarations || node);\n      }\n\n      if (_core.types.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.body) {\n      const declarPaths = this.blockPath.get(\"body\");\n\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i]);\n      }\n    }\n\n    if (block.cases) {\n      const declarPaths = this.blockPath.get(\"cases\");\n\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    }\n\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n\n      const keys = _core.types.getBindingIdentifiers(declar, false, true);\n\n      (0, _extend.default)(this.letReferences, keys);\n      this.hasLetReferences = true;\n    }\n\n    if (!this.hasLetReferences) return;\n    const state = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name)\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n    return state.closurify;\n  }\n\n  checkLoop() {\n    const state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: {},\n      LOOP_IGNORE: Symbol()\n    };\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n    return state;\n  }\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  pushDeclar(node) {\n    const declars = [];\n\n    const names = _core.types.getBindingIdentifiers(node);\n\n    for (const name of Object.keys(names)) {\n      declars.push(_core.types.variableDeclarator(names[name]));\n    }\n\n    this.body.push(_core.types.variableDeclaration(node.kind, declars));\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));\n\n      replace.push(_core.types.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret) {\n    const body = this.body;\n    let retCheck;\n    const has = this.has;\n    const cases = [];\n\n    if (has.hasReturn) {\n      retCheck = buildRetCheck({\n        RETURN: _core.types.identifier(ret)\n      });\n    }\n\n    if (has.hasBreakContinue) {\n      for (const key of Object.keys(has.map)) {\n        cases.push(_core.types.switchCase(_core.types.stringLiteral(key), [has.map[key]]));\n      }\n\n      if (has.hasReturn) {\n        cases.push(_core.types.switchCase(null, [retCheck]));\n      }\n\n      if (cases.length === 1) {\n        const single = cases[0];\n        body.push(_core.types.ifStatement(_core.types.binaryExpression(\"===\", _core.types.identifier(ret), single.test), single.consequent[0]));\n      } else {\n        if (this.loop) {\n          for (let i = 0; i < cases.length; i++) {\n            const caseConsequent = cases[i].consequent[0];\n\n            if (_core.types.isBreakStatement(caseConsequent) && !caseConsequent.label) {\n              if (!this.loopLabel) {\n                this.loopLabel = this.scope.generateUidIdentifier(\"loop\");\n              }\n\n              caseConsequent.label = _core.types.cloneNode(this.loopLabel);\n            }\n          }\n        }\n\n        body.push(_core.types.switchStatement(_core.types.identifier(ret), cases));\n      }\n    } else {\n      if (has.hasReturn) {\n        body.push(retCheck);\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-block-scoping/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_tdz","_values","_interopRequireDefault","_extend","_core","obj","__esModule","DONE","WeakSet","_default","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","VariableDeclaration","path","node","parent","scope","isBlockScoped","convertBlockScopedToVar","_tdzThis","nodes","i","declarations","length","decl","assign","types","assignmentExpression","id","init","buildUndefinedNode","_ignoreBlockScopingTDZ","push","expressionStatement","addHelper","_blockHoist","isCompletionRecord","replaceWithMultiple","Loop","state","ensureBlock","blockScoping","BlockScoping","get","replace","run","replaceWith","CatchClause","ignoreBlock","isLoop","isCatchClause","buildRetCheck","template","isVariableDeclaration","BLOCK_SCOPED_SYMBOL","kind","isInLoop","loopOrFunctionParent","find","isFunction","moveBindingsToParent","isFor","declar","parentScope","getFunctionParent","getProgramParent","keys","getBindingIdentifiers","binding","getOwnBinding","moveBindingTo","isVar","letReferenceBlockVisitor","traverse","visitors","merge","enter","loopDepth","exit","Function","letReferenceFunctionVisitor","skip","ReferencedIdentifier","ref","letReferences","localBinding","getBindingIdentifier","closurify","hoistVarDeclarationsVisitor","self","isForStatement","pushDeclar","sequenceExpression","left","map","expr","loopLabelVisitor","LabeledStatement","innerLabels","label","continuationVisitor","isAssignmentExpression","isUpdateExpression","outsideReferences","reassignments","isReturnStatement","returnStatements","loopNodeTo","isBreakStatement","isContinueStatement","loopVisitor","oldIgnoreLabeless","ignoreLabeless","SwitchCase","oldInSwitchCase","inSwitchCase","LOOP_IGNORE","loopText","indexOf","hasBreakContinue","stringLiteral","hasReturn","objectExpression","objectProperty","identifier","argument","returnStatement","inherits","constructor","loopPath","blockPath","block","outsideLetReferences","create","hasLetReferences","body","loopParent","loopLabel","isLabeledStatement","loop","has","add","needsClosure","getLetReferences","checkConstants","isProgram","updateScopeInfo","wrapClosure","remap","labeledStatement","bindings","violation","constantViolations","readOnlyError","throwNode","callExpression","isForXStatement","unshift","wrappedInClosure","blockScope","letRefs","key","getBinding","hasOwnBinding","removeBinding","outsideLetRefs","blockPathScope","parentHasBinding","hasGlobal","rename","buildCodeFrameError","outsideRefs","checkLoop","hoistVarDeclarations","args","cloneNode","params","isSwitch","isSwitchStatement","fn","functionExpression","blockStatement","addContinuations","call","nullLiteral","basePath","hasYield","hasType","FUNCTION_TYPES","generator","yieldExpression","hasAsync","async","awaitExpression","placeholderPath","index","ret","generateUid","variableDeclaration","variableDeclarator","buildHas","callPath","parentPath","listKey","placeholder","fnPath","loopId","p","insertBefore","unwrapFunctionEnvironment","param","paramName","newParamName","forEach","declarators","addDeclarationsFromChild","isClassDeclaration","isFunctionDeclaration","concat","declarPaths","cases","consequents","consequent","j","Symbol","declars","names","retCheck","RETURN","switchCase","single","ifStatement","binaryExpression","test","caseConsequent","generateUidIdentifier","switchStatement"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _tdz = require(\"./tdz\");\n\nvar _values = _interopRequireDefault(require(\"lodash/values\"));\n\nvar _extend = _interopRequireDefault(require(\"lodash/extend\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DONE = new WeakSet();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    throwIfClosureRequired = false,\n    tdz: tdzEnabled = false\n  } = opts;\n\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n    visitor: {\n      VariableDeclaration(path) {\n        const {\n          node,\n          parent,\n          scope\n        } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        if (node._tdzThis) {\n          const nodes = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n\n            const assign = _core.types.assignmentExpression(\"=\", decl.id, decl.init || scope.buildUndefinedNode());\n\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(_core.types.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(path, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        const blockScoping = new BlockScoping(null, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(path, state) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);\n          blockScoping.run();\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;\n\nfunction ignoreBlock(path) {\n  return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = (0, _core.template)(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node) {\n  if (!_core.types.isVariableDeclaration(node)) return false;\n  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) return true;\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\nfunction isInLoop(path) {\n  const loopOrFunctionParent = path.find(path => path.isLoop() || path.isFunction());\n  return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();\n}\n\nfunction convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent = false) {\n  if (!node) {\n    node = path.node;\n  }\n\n  if (isInLoop(path) && !_core.types.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  node[_core.types.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node) {\n  return _core.types.isVariableDeclaration(node, {\n    kind: \"var\"\n  }) && !isBlockScoped(node);\n}\n\nconst letReferenceBlockVisitor = _core.traverse.visitors.merge([{\n  Loop: {\n    enter(path, state) {\n      state.loopDepth++;\n    },\n\n    exit(path, state) {\n      state.loopDepth--;\n    }\n\n  },\n\n  Function(path, state) {\n    if (state.loopDepth > 0) {\n      path.traverse(letReferenceFunctionVisitor, state);\n    } else {\n      path.traverse(_tdz.visitor, state);\n    }\n\n    return path.skip();\n  }\n\n}, _tdz.visitor]);\n\nconst letReferenceFunctionVisitor = _core.traverse.visitors.merge([{\n  ReferencedIdentifier(path, state) {\n    const ref = state.letReferences[path.node.name];\n    if (!ref) return;\n    const localBinding = path.scope.getBindingIdentifier(path.node.name);\n    if (localBinding && localBinding !== ref) return;\n    state.closurify = true;\n  }\n\n}, _tdz.visitor]);\n\nconst hoistVarDeclarationsVisitor = {\n  enter(path, self) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (path.isForStatement()) {\n      if (isVar(node.init, node)) {\n        const nodes = self.pushDeclar(node.init);\n\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = _core.types.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isFor()) {\n      if (isVar(node.left, node)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(node, parent)) {\n      path.replaceWithMultiple(self.pushDeclar(node).map(expr => _core.types.expressionStatement(expr)));\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  }\n\n};\nconst loopLabelVisitor = {\n  LabeledStatement({\n    node\n  }, state) {\n    state.innerLabels.push(node.label.name);\n  }\n\n};\nconst continuationVisitor = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) {\n          continue;\n        }\n\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  }\n\n};\n\nfunction loopNodeTo(node) {\n  if (_core.types.isBreakStatement(node)) {\n    return \"break\";\n  } else if (_core.types.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(path, state) {\n    const {\n      node,\n      scope\n    } = path;\n    if (node[this.LOOP_IGNORE]) return;\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (node.label) {\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        if (state.ignoreLabeless) return;\n        if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map[loopText] = node;\n      replace = _core.types.stringLiteral(loopText);\n    }\n\n    if (path.isReturnStatement()) {\n      state.hasReturn = true;\n      replace = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"v\"), node.argument || scope.buildUndefinedNode())]);\n    }\n\n    if (replace) {\n      replace = _core.types.returnStatement(replace);\n      replace[this.LOOP_IGNORE] = true;\n      path.skip();\n      path.replaceWith(_core.types.inherits(replace, node));\n    }\n  }\n\n};\n\nclass BlockScoping {\n  constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n    this.outsideLetReferences = Object.create(null);\n    this.hasLetReferences = false;\n    this.letReferences = Object.create(null);\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n    const needsClosure = this.getLetReferences();\n    this.checkConstants();\n\n    if (_core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !_core.types.isLabeledStatement(this.loopParent)) {\n      return _core.types.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const scope = this.scope;\n    const state = this.state;\n\n    for (const name of Object.keys(scope.bindings)) {\n      const binding = scope.bindings[name];\n      if (binding.kind !== \"const\") continue;\n\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n\n        const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);\n\n        if (violation.isAssignmentExpression()) {\n          violation.get(\"right\").replaceWith(_core.types.sequenceExpression([throwNode, violation.get(\"right\").node]));\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(_core.types.sequenceExpression([throwNode, violation.node]));\n        } else if (violation.isForXStatement()) {\n          violation.ensureBlock();\n          violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure) {\n    const blockScope = this.blockPath.scope;\n    const parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of Object.keys(letRefs)) {\n      const ref = letRefs[key];\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    for (const key of Object.keys(letRefs)) {\n      const ref = letRefs[key];\n\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        if (scope.hasOwnBinding(key)) {\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of Object.keys(outsideLetRefs)) {\n      const ref = letRefs[key];\n\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n    }\n\n    const block = this.block;\n    const outsideRefs = this.outsideLetReferences;\n\n    if (this.loop) {\n      for (const name of Object.keys(outsideRefs)) {\n        const id = outsideRefs[name];\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          delete outsideRefs[id.name];\n          delete this.letReferences[id.name];\n          this.scope.rename(id.name);\n          this.letReferences[id.name] = id;\n          outsideRefs[id.name] = id;\n        }\n      }\n    }\n\n    this.has = this.checkLoop();\n    this.hoistVarDeclarations();\n    const args = (0, _values.default)(outsideRefs).map(id => _core.types.cloneNode(id));\n    const params = args.map(id => _core.types.cloneNode(id));\n    const isSwitch = this.blockPath.isSwitchStatement();\n\n    const fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [block] : block.body));\n\n    this.addContinuations(fn);\n\n    let call = _core.types.callExpression(_core.types.nullLiteral(), args);\n\n    let basePath = \".callee\";\n\n    const hasYield = _core.traverse.hasType(fn.body, \"YieldExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasYield) {\n      fn.generator = true;\n      call = _core.types.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    const hasAsync = _core.traverse.hasType(fn.body, \"AwaitExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasAsync) {\n      fn.async = true;\n      call = _core.types.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n      this.body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(ret), call)]));\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n      this.buildHas(ret);\n    } else {\n      this.body.push(_core.types.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath;\n\n    if (isSwitch) {\n      const {\n        parentPath,\n        listKey,\n        key\n      } = this.blockPath;\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[key + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath);\n    let fnPath;\n\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(loopId), fn)]));\n      placeholder.replaceWith(_core.types.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  addContinuations(fn) {\n    const state = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences\n    };\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = _core.types.identifier(newParamName);\n      this.scope.rename(paramName, newParamName, fn);\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n      });\n      fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n    let declarators = [];\n\n    if (this.loop) {\n      const init = this.loop.left || this.loop.init;\n\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        (0, _extend.default)(this.outsideLetReferences, _core.types.getBindingIdentifiers(init));\n      }\n    }\n\n    const addDeclarationsFromChild = (path, node) => {\n      node = node || path.node;\n\n      if (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(path, node, block, this.scope);\n        }\n\n        declarators = declarators.concat(node.declarations || node);\n      }\n\n      if (_core.types.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.body) {\n      const declarPaths = this.blockPath.get(\"body\");\n\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i]);\n      }\n    }\n\n    if (block.cases) {\n      const declarPaths = this.blockPath.get(\"cases\");\n\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    }\n\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n\n      const keys = _core.types.getBindingIdentifiers(declar, false, true);\n\n      (0, _extend.default)(this.letReferences, keys);\n      this.hasLetReferences = true;\n    }\n\n    if (!this.hasLetReferences) return;\n    const state = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name)\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n    return state.closurify;\n  }\n\n  checkLoop() {\n    const state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: {},\n      LOOP_IGNORE: Symbol()\n    };\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n    return state;\n  }\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  pushDeclar(node) {\n    const declars = [];\n\n    const names = _core.types.getBindingIdentifiers(node);\n\n    for (const name of Object.keys(names)) {\n      declars.push(_core.types.variableDeclarator(names[name]));\n    }\n\n    this.body.push(_core.types.variableDeclaration(node.kind, declars));\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));\n\n      replace.push(_core.types.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret) {\n    const body = this.body;\n    let retCheck;\n    const has = this.has;\n    const cases = [];\n\n    if (has.hasReturn) {\n      retCheck = buildRetCheck({\n        RETURN: _core.types.identifier(ret)\n      });\n    }\n\n    if (has.hasBreakContinue) {\n      for (const key of Object.keys(has.map)) {\n        cases.push(_core.types.switchCase(_core.types.stringLiteral(key), [has.map[key]]));\n      }\n\n      if (has.hasReturn) {\n        cases.push(_core.types.switchCase(null, [retCheck]));\n      }\n\n      if (cases.length === 1) {\n        const single = cases[0];\n        body.push(_core.types.ifStatement(_core.types.binaryExpression(\"===\", _core.types.identifier(ret), single.test), single.consequent[0]));\n      } else {\n        if (this.loop) {\n          for (let i = 0; i < cases.length; i++) {\n            const caseConsequent = cases[i].consequent[0];\n\n            if (_core.types.isBreakStatement(caseConsequent) && !caseConsequent.label) {\n              if (!this.loopLabel) {\n                this.loopLabel = this.scope.generateUidIdentifier(\"loop\");\n              }\n\n              caseConsequent.label = _core.types.cloneNode(this.loopLabel);\n            }\n          }\n        }\n\n        body.push(_core.types.switchStatement(_core.types.identifier(ret), cases));\n      }\n    } else {\n      if (has.hasReturn) {\n        body.push(retCheck);\n      }\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"script"}