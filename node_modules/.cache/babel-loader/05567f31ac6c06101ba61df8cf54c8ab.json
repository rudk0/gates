{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxNullishCoalescingOperator = _interopRequireDefault(require(\"@babel/plugin-syntax-nullish-coalescing-operator\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, {\n  loose = false\n}) => {\n  api.assertVersion(7);\n  return {\n    name: \"proposal-nullish-coalescing-operator\",\n    inherits: _pluginSyntaxNullishCoalescingOperator.default,\n    visitor: {\n      LogicalExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n\n        if (node.operator !== \"??\") {\n          return;\n        }\n\n        let ref = scope.maybeGenerateMemoised(node.left);\n        let assignment;\n\n        if (ref === null) {\n          ref = node.left;\n          assignment = _core.types.cloneNode(node.left);\n        } else {\n          assignment = _core.types.assignmentExpression(\"=\", ref, node.left);\n        }\n\n        path.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"!=\", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression(\"&&\", _core.types.binaryExpression(\"!==\", assignment, _core.types.nullLiteral()), _core.types.binaryExpression(\"!==\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxNullishCoalescingOperator","_interopRequireDefault","_core","obj","__esModule","_default","declare","api","loose","assertVersion","name","inherits","visitor","LogicalExpression","path","node","scope","operator","ref","maybeGenerateMemoised","left","assignment","types","cloneNode","assignmentExpression","replaceWith","conditionalExpression","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","right"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,kBAAkB,GAAGC,OAAO,CAAC,4BAAD,CAAhC;;AAEA,IAAIC,sCAAsC,GAAGC,sBAAsB,CAACF,OAAO,CAAC,kDAAD,CAAR,CAAnE;;AAEA,IAAIG,KAAK,GAAGH,OAAO,CAAC,aAAD,CAAnB;;AAEA,SAASE,sBAAT,CAAgCE,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEN,IAAAA,OAAO,EAAEM;AAAX,GAArC;AAAwD;;AAE/F,IAAIE,QAAQ,GAAG,CAAC,GAAGP,kBAAkB,CAACQ,OAAvB,EAAgC,CAACC,GAAD,EAAM;AACnDC,EAAAA,KAAK,GAAG;AAD2C,CAAN,KAEzC;AACJD,EAAAA,GAAG,CAACE,aAAJ,CAAkB,CAAlB;AACA,SAAO;AACLC,IAAAA,IAAI,EAAE,sCADD;AAELC,IAAAA,QAAQ,EAAEX,sCAAsC,CAACH,OAF5C;AAGLe,IAAAA,OAAO,EAAE;AACPC,MAAAA,iBAAiB,CAACC,IAAD,EAAO;AACtB,cAAM;AACJC,UAAAA,IADI;AAEJC,UAAAA;AAFI,YAGFF,IAHJ;;AAKA,YAAIC,IAAI,CAACE,QAAL,KAAkB,IAAtB,EAA4B;AAC1B;AACD;;AAED,YAAIC,GAAG,GAAGF,KAAK,CAACG,qBAAN,CAA4BJ,IAAI,CAACK,IAAjC,CAAV;AACA,YAAIC,UAAJ;;AAEA,YAAIH,GAAG,KAAK,IAAZ,EAAkB;AAChBA,UAAAA,GAAG,GAAGH,IAAI,CAACK,IAAX;AACAC,UAAAA,UAAU,GAAGnB,KAAK,CAACoB,KAAN,CAAYC,SAAZ,CAAsBR,IAAI,CAACK,IAA3B,CAAb;AACD,SAHD,MAGO;AACLC,UAAAA,UAAU,GAAGnB,KAAK,CAACoB,KAAN,CAAYE,oBAAZ,CAAiC,GAAjC,EAAsCN,GAAtC,EAA2CH,IAAI,CAACK,IAAhD,CAAb;AACD;;AAEDN,QAAAA,IAAI,CAACW,WAAL,CAAiBvB,KAAK,CAACoB,KAAN,CAAYI,qBAAZ,CAAkClB,KAAK,GAAGN,KAAK,CAACoB,KAAN,CAAYK,gBAAZ,CAA6B,IAA7B,EAAmCN,UAAnC,EAA+CnB,KAAK,CAACoB,KAAN,CAAYM,WAAZ,EAA/C,CAAH,GAA+E1B,KAAK,CAACoB,KAAN,CAAYO,iBAAZ,CAA8B,IAA9B,EAAoC3B,KAAK,CAACoB,KAAN,CAAYK,gBAAZ,CAA6B,KAA7B,EAAoCN,UAApC,EAAgDnB,KAAK,CAACoB,KAAN,CAAYM,WAAZ,EAAhD,CAApC,EAAgH1B,KAAK,CAACoB,KAAN,CAAYK,gBAAZ,CAA6B,KAA7B,EAAoCzB,KAAK,CAACoB,KAAN,CAAYC,SAAZ,CAAsBL,GAAtB,CAApC,EAAgEF,KAAK,CAACc,kBAAN,EAAhE,CAAhH,CAAtH,EAAoU5B,KAAK,CAACoB,KAAN,CAAYC,SAAZ,CAAsBL,GAAtB,CAApU,EAAgWH,IAAI,CAACgB,KAArW,CAAjB;AACD;;AAtBM;AAHJ,GAAP;AA6BD,CAjCc,CAAf;;AAmCApC,OAAO,CAACE,OAAR,GAAkBQ,QAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxNullishCoalescingOperator = _interopRequireDefault(require(\"@babel/plugin-syntax-nullish-coalescing-operator\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, {\n  loose = false\n}) => {\n  api.assertVersion(7);\n  return {\n    name: \"proposal-nullish-coalescing-operator\",\n    inherits: _pluginSyntaxNullishCoalescingOperator.default,\n    visitor: {\n      LogicalExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n\n        if (node.operator !== \"??\") {\n          return;\n        }\n\n        let ref = scope.maybeGenerateMemoised(node.left);\n        let assignment;\n\n        if (ref === null) {\n          ref = node.left;\n          assignment = _core.types.cloneNode(node.left);\n        } else {\n          assignment = _core.types.assignmentExpression(\"=\", ref, node.left);\n        }\n\n        path.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"!=\", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression(\"&&\", _core.types.binaryExpression(\"!==\", assignment, _core.types.nullLiteral()), _core.types.binaryExpression(\"!==\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}