{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nvar _private = require(\"private\");\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar getMarkInfo = (0, _private.makeAccessor)();\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/regenerator-transform/lib/visit.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","_assert","_hoist","_emit","_replaceShorthandObjectMethod","util","_private","exports","getVisitor","_ref","t","types","Method","path","state","node","shouldRegenerate","container","functionExpression","cloneNode","body","generator","async","get","set","returnStatement","callExpression","unwrapFunctionEnvironment","Function","exit","wrapWithTypes","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","hoist","usesThis","usesArguments","getArgsId","clone","argumentsThisVisitor","variableDeclaration","declarations","variableDeclarator","emitter","Emitter","explode","wrapArgs","getContextFunction","tryLocsList","getTryLocsList","nullLiteral","thisExpression","currentScope","hasOwnBinding","rename","parent","wrapCall","runtimeProperty","blockStatement","p","registerDeclaration","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","insertedLocs","getInsertedLocs","NumericLiteral","has","replaceWith","numericLiteral","value","requeue","opts","asyncGenerators","generators","funPath","getTypes","assertFunction","isFunctionDeclaration","getMarkedFunctionId","getMarkInfo","makeAccessor","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","FunctionExpressionFunctionDeclarationMethod","skip","Identifier","isReference","ThisExpression","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nvar _private = require(\"private\");\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar getMarkInfo = (0, _private.makeAccessor)();\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};"]},"metadata":{},"sourceType":"script"}