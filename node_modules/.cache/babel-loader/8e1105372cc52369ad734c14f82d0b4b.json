{"ast":null,"code":"\"use strict\";\n\nvar originalObject = Object;\nvar originalDefProp = Object.defineProperty;\nvar originalCreate = Object.create;\n\nfunction defProp(obj, name, value) {\n  if (originalDefProp) try {\n    originalDefProp.call(originalObject, obj, name, {\n      value: value\n    });\n  } catch (definePropertyIsBrokenInIE8) {\n    obj[name] = value;\n  } else {\n    obj[name] = value;\n  }\n} // For functions that will be invoked using .call or .apply, we need to\n// define those methods on the function objects themselves, rather than\n// inheriting them from Function.prototype, so that a malicious or clumsy\n// third party cannot interfere with the functionality of this module by\n// redefining Function.prototype.call or .apply.\n\n\nfunction makeSafeToCall(fun) {\n  if (fun) {\n    defProp(fun, \"call\", fun.call);\n    defProp(fun, \"apply\", fun.apply);\n  }\n\n  return fun;\n}\n\nmakeSafeToCall(originalDefProp);\nmakeSafeToCall(originalCreate);\nvar hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);\nvar numToStr = makeSafeToCall(Number.prototype.toString);\nvar strSlice = makeSafeToCall(String.prototype.slice);\n\nvar cloner = function () {};\n\nfunction create(prototype) {\n  if (originalCreate) {\n    return originalCreate.call(originalObject, prototype);\n  }\n\n  cloner.prototype = prototype || null;\n  return new cloner();\n}\n\nvar rand = Math.random;\nvar uniqueKeys = create(null);\n\nfunction makeUniqueKey() {\n  // Collisions are highly unlikely, but this module is in the business of\n  // making guarantees rather than safe bets.\n  do var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2)); while (hasOwn.call(uniqueKeys, uniqueKey));\n\n  return uniqueKeys[uniqueKey] = uniqueKey;\n}\n\nfunction internString(str) {\n  var obj = {};\n  obj[str] = true;\n  return Object.keys(obj)[0];\n} // External users might find this function useful, but it is not necessary\n// for the typical use of this module.\n\n\nexports.makeUniqueKey = makeUniqueKey; // Object.getOwnPropertyNames is the only way to enumerate non-enumerable\n// properties, so if we wrap it to ignore our secret keys, there should be\n// no way (except guessing) to access those properties.\n\nvar originalGetOPNs = Object.getOwnPropertyNames;\n\nObject.getOwnPropertyNames = function getOwnPropertyNames(object) {\n  for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {\n    if (!hasOwn.call(uniqueKeys, names[src])) {\n      if (src > dst) {\n        names[dst] = names[src];\n      }\n\n      ++dst;\n    }\n  }\n\n  names.length = dst;\n  return names;\n};\n\nfunction defaultCreatorFn(object) {\n  return create(null);\n}\n\nfunction makeAccessor(secretCreatorFn) {\n  var brand = makeUniqueKey();\n  var passkey = create(null);\n  secretCreatorFn = secretCreatorFn || defaultCreatorFn;\n\n  function register(object) {\n    var secret; // Created lazily.\n\n    function vault(key, forget) {\n      // Only code that has access to the passkey can retrieve (or forget)\n      // the secret object.\n      if (key === passkey) {\n        return forget ? secret = null : secret || (secret = secretCreatorFn(object));\n      }\n    }\n\n    defProp(object, brand, vault);\n  }\n\n  function accessor(object) {\n    if (!hasOwn.call(object, brand)) register(object);\n    return object[brand](passkey);\n  }\n\n  accessor.forget = function (object) {\n    if (hasOwn.call(object, brand)) object[brand](passkey, true);\n  };\n\n  return accessor;\n}\n\nexports.makeAccessor = makeAccessor;","map":{"version":3,"sources":["/home/agatha/open/node_modules/private/private.js"],"names":["originalObject","Object","originalDefProp","defineProperty","originalCreate","create","defProp","obj","name","value","call","definePropertyIsBrokenInIE8","makeSafeToCall","fun","apply","hasOwn","prototype","hasOwnProperty","numToStr","Number","toString","strSlice","String","slice","cloner","rand","Math","random","uniqueKeys","makeUniqueKey","uniqueKey","internString","str","keys","exports","originalGetOPNs","getOwnPropertyNames","object","names","src","dst","len","length","defaultCreatorFn","makeAccessor","secretCreatorFn","brand","passkey","register","secret","vault","key","forget","accessor"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar originalObject = Object;\nvar originalDefProp = Object.defineProperty;\nvar originalCreate = Object.create;\n\nfunction defProp(obj, name, value) {\n  if (originalDefProp) try {\n    originalDefProp.call(originalObject, obj, name, { value: value });\n  } catch (definePropertyIsBrokenInIE8) {\n    obj[name] = value;\n  } else {\n    obj[name] = value;\n  }\n}\n\n// For functions that will be invoked using .call or .apply, we need to\n// define those methods on the function objects themselves, rather than\n// inheriting them from Function.prototype, so that a malicious or clumsy\n// third party cannot interfere with the functionality of this module by\n// redefining Function.prototype.call or .apply.\nfunction makeSafeToCall(fun) {\n  if (fun) {\n    defProp(fun, \"call\", fun.call);\n    defProp(fun, \"apply\", fun.apply);\n  }\n  return fun;\n}\n\nmakeSafeToCall(originalDefProp);\nmakeSafeToCall(originalCreate);\n\nvar hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);\nvar numToStr = makeSafeToCall(Number.prototype.toString);\nvar strSlice = makeSafeToCall(String.prototype.slice);\n\nvar cloner = function(){};\nfunction create(prototype) {\n  if (originalCreate) {\n    return originalCreate.call(originalObject, prototype);\n  }\n  cloner.prototype = prototype || null;\n  return new cloner;\n}\n\nvar rand = Math.random;\nvar uniqueKeys = create(null);\n\nfunction makeUniqueKey() {\n  // Collisions are highly unlikely, but this module is in the business of\n  // making guarantees rather than safe bets.\n  do var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));\n  while (hasOwn.call(uniqueKeys, uniqueKey));\n  return uniqueKeys[uniqueKey] = uniqueKey;\n}\n\nfunction internString(str) {\n  var obj = {};\n  obj[str] = true;\n  return Object.keys(obj)[0];\n}\n\n// External users might find this function useful, but it is not necessary\n// for the typical use of this module.\nexports.makeUniqueKey = makeUniqueKey;\n\n// Object.getOwnPropertyNames is the only way to enumerate non-enumerable\n// properties, so if we wrap it to ignore our secret keys, there should be\n// no way (except guessing) to access those properties.\nvar originalGetOPNs = Object.getOwnPropertyNames;\nObject.getOwnPropertyNames = function getOwnPropertyNames(object) {\n  for (var names = originalGetOPNs(object),\n           src = 0,\n           dst = 0,\n           len = names.length;\n       src < len;\n       ++src) {\n    if (!hasOwn.call(uniqueKeys, names[src])) {\n      if (src > dst) {\n        names[dst] = names[src];\n      }\n      ++dst;\n    }\n  }\n  names.length = dst;\n  return names;\n};\n\nfunction defaultCreatorFn(object) {\n  return create(null);\n}\n\nfunction makeAccessor(secretCreatorFn) {\n  var brand = makeUniqueKey();\n  var passkey = create(null);\n\n  secretCreatorFn = secretCreatorFn || defaultCreatorFn;\n\n  function register(object) {\n    var secret; // Created lazily.\n\n    function vault(key, forget) {\n      // Only code that has access to the passkey can retrieve (or forget)\n      // the secret object.\n      if (key === passkey) {\n        return forget\n          ? secret = null\n          : secret || (secret = secretCreatorFn(object));\n      }\n    }\n\n    defProp(object, brand, vault);\n  }\n\n  function accessor(object) {\n    if (!hasOwn.call(object, brand))\n      register(object);\n    return object[brand](passkey);\n  }\n\n  accessor.forget = function(object) {\n    if (hasOwn.call(object, brand))\n      object[brand](passkey, true);\n  };\n\n  return accessor;\n}\n\nexports.makeAccessor = makeAccessor;\n"]},"metadata":{},"sourceType":"script"}