{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nconst buildWrapper = (0, _core.template)(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\nconst buildAnonymousWrapper = (0, _core.template)(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(path, wrapper) {\n  const {\n    body,\n    directives\n  } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdWrapper = path.pushContainer(\"body\", wrapper)[0];\n  const amdFactory = amdWrapper.get(\"expression.arguments\").filter(arg => arg.isFunctionExpression())[0].get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose,\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop\n  } = options;\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (!path.get(\"callee\").isImport()) return;\n        let {\n          requireId,\n          resolveId,\n          rejectId\n        } = state;\n\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result = _core.types.identifier(\"imported\");\n\n        if (!noInterop) result = (0, _helperModuleTransforms.wrapInterop)(path, result, \"namespace\");\n        path.replaceWith(_core.template.expression.ast`\n            new Promise((${resolveId}, ${rejectId}) =>\n              ${requireId}(\n                [${(0, _utils.getImportSource)(_core.types, path.node)}],\n                imported => ${resolveId}(${result}),\n                ${rejectId}\n              )\n            )`);\n      },\n\n      Program: {\n        exit(path, {\n          requireId\n        }) {\n          if (!(0, _helperModuleTransforms.isModule)(path)) {\n            if (requireId) {\n              injectWrapper(path, buildAnonymousWrapper({\n                REQUIRE: requireId\n              }));\n            }\n\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n\n          if (requireId) {\n            amdArgs.push(_core.types.stringLiteral(\"require\"));\n            importNames.push(requireId);\n          }\n\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          const {\n            meta,\n            headers\n          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {\n            loose,\n            strict,\n            strictMode,\n            allowTopLevelThis,\n            noInterop\n          });\n\n          if ((0, _helperModuleTransforms.hasExports)(meta)) {\n            amdArgs.push(_core.types.stringLiteral(\"exports\"));\n            importNames.push(_core.types.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(_core.types.stringLiteral(source));\n            importNames.push(_core.types.identifier(metadata.name));\n\n            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {\n              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);\n\n              if (interop) {\n                const header = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(metadata.name), interop));\n\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose));\n          }\n\n          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);\n          path.unshiftContainer(\"body\", headers);\n          injectWrapper(path, buildWrapper({\n            MODULE_NAME: moduleName,\n            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),\n            IMPORT_NAMES: importNames\n          }));\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-modules-amd/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_helperModuleTransforms","_core","_utils","buildWrapper","template","buildAnonymousWrapper","injectWrapper","path","wrapper","body","directives","node","amdWrapper","pushContainer","amdFactory","get","filter","arg","isFunctionExpression","_default","declare","api","options","assertVersion","loose","allowTopLevelThis","strict","strictMode","noInterop","name","pre","file","set","visitor","CallExpression","state","has","isImport","requireId","resolveId","rejectId","scope","generateUidIdentifier","result","types","identifier","wrapInterop","replaceWith","expression","ast","getImportSource","Program","exit","isModule","REQUIRE","amdArgs","importNames","push","stringLiteral","moduleName","getModuleName","opts","meta","headers","rewriteModuleStatementsAndPrepareHeader","hasExports","exportName","source","metadata","isSideEffectImport","interop","header","expressionStatement","assignmentExpression","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","IMPORT_NAMES"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nconst buildWrapper = (0, _core.template)(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\nconst buildAnonymousWrapper = (0, _core.template)(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(path, wrapper) {\n  const {\n    body,\n    directives\n  } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdWrapper = path.pushContainer(\"body\", wrapper)[0];\n  const amdFactory = amdWrapper.get(\"expression.arguments\").filter(arg => arg.isFunctionExpression())[0].get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose,\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop\n  } = options;\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (!path.get(\"callee\").isImport()) return;\n        let {\n          requireId,\n          resolveId,\n          rejectId\n        } = state;\n\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result = _core.types.identifier(\"imported\");\n\n        if (!noInterop) result = (0, _helperModuleTransforms.wrapInterop)(path, result, \"namespace\");\n        path.replaceWith(_core.template.expression.ast`\n            new Promise((${resolveId}, ${rejectId}) =>\n              ${requireId}(\n                [${(0, _utils.getImportSource)(_core.types, path.node)}],\n                imported => ${resolveId}(${result}),\n                ${rejectId}\n              )\n            )`);\n      },\n\n      Program: {\n        exit(path, {\n          requireId\n        }) {\n          if (!(0, _helperModuleTransforms.isModule)(path)) {\n            if (requireId) {\n              injectWrapper(path, buildAnonymousWrapper({\n                REQUIRE: requireId\n              }));\n            }\n\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n\n          if (requireId) {\n            amdArgs.push(_core.types.stringLiteral(\"require\"));\n            importNames.push(requireId);\n          }\n\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          const {\n            meta,\n            headers\n          } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {\n            loose,\n            strict,\n            strictMode,\n            allowTopLevelThis,\n            noInterop\n          });\n\n          if ((0, _helperModuleTransforms.hasExports)(meta)) {\n            amdArgs.push(_core.types.stringLiteral(\"exports\"));\n            importNames.push(_core.types.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(_core.types.stringLiteral(source));\n            importNames.push(_core.types.identifier(metadata.name));\n\n            if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {\n              const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);\n\n              if (interop) {\n                const header = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(metadata.name), interop));\n\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose));\n          }\n\n          (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);\n          path.unshiftContainer(\"body\", headers);\n          injectWrapper(path, buildWrapper({\n            MODULE_NAME: moduleName,\n            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),\n            IMPORT_NAMES: importNames\n          }));\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}