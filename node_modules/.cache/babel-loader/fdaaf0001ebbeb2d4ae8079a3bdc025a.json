{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Bourne = require('@hapi/bourne');\n\nvar Hoek = require('@hapi/hoek');\n\nvar Topo = require('@hapi/topo');\n\nvar Any = require('../any');\n\nvar Errors = require('../../errors');\n\nvar Cast = require('../../cast');\n\nvar State = require('../state');\n\nvar internals = {};\n\ninternals.Object = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'object';\n    _this._inner.children = null;\n    _this._inner.renames = [];\n    _this._inner.dependencies = [];\n    _this._inner.patterns = [];\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.keys.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var target = value;\n      var errors = [];\n\n      var finish = function finish() {\n        return {\n          value: target,\n          errors: errors.length ? errors : null\n        };\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        if (value.length > 1 && (value[0] === '{' || /^\\s*\\{/.test(value))) {\n          try {\n            value = Bourne.parse(value);\n          } catch (e) {}\n        }\n      }\n\n      var type = this._flags.func ? 'function' : 'object';\n\n      if (!value || typeof value !== type || Array.isArray(value)) {\n        errors.push(this.createError(type + '.base', {\n          value: value\n        }, state, options));\n        return finish();\n      } // Skip if there are no other rules to test\n\n\n      if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n      !this._inner.patterns.length) {\n        target = value;\n        return finish();\n      } // Ensure target is a local copy (parsed) or shallow copy\n\n\n      if (target === value) {\n        if (type === 'object') {\n          target = Object.create(Object.getPrototypeOf(value));\n        } else {\n          target = function target() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return value.apply(this, args);\n          };\n\n          target.prototype = Hoek.clone(value.prototype);\n        }\n\n        var valueKeys = Object.keys(value);\n\n        for (var i = 0; i < valueKeys.length; ++i) {\n          target[valueKeys[i]] = value[valueKeys[i]];\n        }\n      } else {\n        target = value;\n      } // Rename keys\n\n\n      var renamed = {};\n\n      for (var _i = 0; _i < this._inner.renames.length; ++_i) {\n        var rename = this._inner.renames[_i];\n\n        if (rename.isRegExp) {\n          var targetKeys = Object.keys(target);\n          var matchedTargetKeys = [];\n\n          for (var j = 0; j < targetKeys.length; ++j) {\n            if (rename.from.test(targetKeys[j])) {\n              matchedTargetKeys.push(targetKeys[j]);\n            }\n          }\n\n          var allUndefined = matchedTargetKeys.every(function (key) {\n            return target[key] === undefined;\n          });\n\n          if (rename.options.ignoreUndefined && allUndefined) {\n            continue;\n          }\n\n          if (!rename.options.multiple && renamed[rename.to]) {\n            errors.push(this.createError('object.rename.regex.multiple', {\n              from: matchedTargetKeys,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n            errors.push(this.createError('object.rename.regex.override', {\n              from: matchedTargetKeys,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (allUndefined) {\n            delete target[rename.to];\n          } else {\n            target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n          }\n\n          renamed[rename.to] = true;\n\n          if (!rename.options.alias) {\n            for (var _j = 0; _j < matchedTargetKeys.length; ++_j) {\n              delete target[matchedTargetKeys[_j]];\n            }\n          }\n        } else {\n          if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n            continue;\n          }\n\n          if (!rename.options.multiple && renamed[rename.to]) {\n            errors.push(this.createError('object.rename.multiple', {\n              from: rename.from,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n            errors.push(this.createError('object.rename.override', {\n              from: rename.from,\n              to: rename.to\n            }, state, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (target[rename.from] === undefined) {\n            delete target[rename.to];\n          } else {\n            target[rename.to] = target[rename.from];\n          }\n\n          renamed[rename.to] = true;\n\n          if (!rename.options.alias) {\n            delete target[rename.from];\n          }\n        }\n      } // Validate schema\n\n\n      if (!this._inner.children && // null allows any keys\n      !this._inner.patterns.length && !this._inner.dependencies.length) {\n        return finish();\n      }\n\n      var unprocessed = new Set(Object.keys(target));\n\n      if (this._inner.children) {\n        var stripProps = [];\n\n        for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {\n          var child = this._inner.children[_i2];\n          var key = child.key;\n          var item = target[key];\n          unprocessed.delete(key);\n          var localState = new State(key, [].concat(_toConsumableArray(state.path), [key]), target, state.reference);\n\n          var result = child.schema._validate(item, localState, options);\n\n          if (result.errors) {\n            errors.push(this.createError('object.child', {\n              key: key,\n              child: child.schema._getLabel(key),\n              reason: result.errors\n            }, localState, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          } else {\n            if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n              stripProps.push(key);\n              target[key] = result.finalValue;\n            } else if (result.value !== undefined) {\n              target[key] = result.value;\n            }\n          }\n        }\n\n        for (var _i3 = 0; _i3 < stripProps.length; ++_i3) {\n          delete target[stripProps[_i3]];\n        }\n      } // Unknown keys\n\n\n      if (unprocessed.size && this._inner.patterns.length) {\n        var _iterator = _createForOfIteratorHelper(unprocessed),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _key2 = _step.value;\n\n            var _localState = new State(_key2, [].concat(_toConsumableArray(state.path), [_key2]), target, state.reference);\n\n            var _item = target[_key2];\n\n            for (var _i4 = 0; _i4 < this._inner.patterns.length; ++_i4) {\n              var pattern = this._inner.patterns[_i4];\n\n              if (pattern.regex ? pattern.regex.test(_key2) : !pattern.schema._validate(_key2, state, _objectSpread(_objectSpread({}, options), {}, {\n                abortEarly: true\n              })).errors) {\n                unprocessed.delete(_key2);\n\n                var _result = pattern.rule._validate(_item, _localState, options);\n\n                if (_result.errors) {\n                  errors.push(this.createError('object.child', {\n                    key: _key2,\n                    child: pattern.rule._getLabel(_key2),\n                    reason: _result.errors\n                  }, _localState, options));\n\n                  if (options.abortEarly) {\n                    return finish();\n                  }\n                }\n\n                target[_key2] = _result.value;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n        if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n          var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n\n          var _iterator2 = _createForOfIteratorHelper(unprocessed),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _key3 = _step2.value;\n\n              if (stripUnknown) {\n                delete target[_key3];\n                unprocessed.delete(_key3);\n              } else if (typeof target[_key3] === 'function') {\n                unprocessed.delete(_key3);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n          var _iterator3 = _createForOfIteratorHelper(unprocessed),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var unprocessedKey = _step3.value;\n              errors.push(this.createError('object.allowUnknown', {\n                child: unprocessedKey,\n                value: target[unprocessedKey]\n              }, {\n                key: unprocessedKey,\n                path: [].concat(_toConsumableArray(state.path), [unprocessedKey])\n              }, options, {}));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } // Validate dependencies\n\n\n      for (var _i5 = 0; _i5 < this._inner.dependencies.length; ++_i5) {\n        var dep = this._inner.dependencies[_i5];\n        var hasKey = dep.key !== null;\n        var splitKey = hasKey && dep.key.split('.');\n\n        var _localState2 = hasKey ? new State(splitKey[splitKey.length - 1], [].concat(_toConsumableArray(state.path), _toConsumableArray(splitKey))) : new State(null, state.path);\n\n        var _err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, {\n          functions: true\n        }), dep.peers, target, _localState2, options);\n\n        if (_err instanceof Errors.Err) {\n          errors.push(_err);\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n      }\n\n      return finish();\n    }\n  }, {\n    key: \"keys\",\n    value: function keys(schema) {\n      Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n      Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n      var obj = this.clone();\n\n      if (!schema) {\n        obj._inner.children = null;\n        return obj;\n      }\n\n      var children = Object.keys(schema);\n\n      if (!children.length) {\n        obj._inner.children = [];\n        return obj;\n      }\n\n      var topo = new Topo();\n\n      if (obj._inner.children) {\n        for (var i = 0; i < obj._inner.children.length; ++i) {\n          var child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n          if (!children.includes(child.key)) {\n            topo.add(child, {\n              after: child._refs,\n              group: child.key\n            });\n          }\n        }\n      }\n\n      for (var _i6 = 0; _i6 < children.length; ++_i6) {\n        var key = children[_i6];\n        var _child = schema[key];\n\n        try {\n          var cast = Cast.schema(this._currentJoi, _child);\n          topo.add({\n            key: key,\n            schema: cast\n          }, {\n            after: cast._refs,\n            group: key\n          });\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = key + '.' + castErr.path;\n          } else {\n            castErr.path = key;\n          }\n\n          throw castErr;\n        }\n      }\n\n      obj._inner.children = topo.nodes;\n      return obj;\n    }\n  }, {\n    key: \"append\",\n    value: function append(schema) {\n      // Skip any changes\n      if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n        return this;\n      }\n\n      return this.keys(schema);\n    }\n  }, {\n    key: \"unknown\",\n    value: function unknown(allow) {\n      var value = allow !== false;\n\n      if (this._flags.allowUnknown === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.allowUnknown = value;\n      return obj;\n    }\n  }, {\n    key: \"length\",\n    value: function length(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('length', limit, function (value, state, options) {\n        if (Object.keys(value).length === limit) {\n          return value;\n        }\n\n        return this.createError('object.length', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"min\",\n    value: function min(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('min', limit, function (value, state, options) {\n        if (Object.keys(value).length >= limit) {\n          return value;\n        }\n\n        return this.createError('object.min', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"max\",\n    value: function max(limit) {\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n      return this._test('max', limit, function (value, state, options) {\n        if (Object.keys(value).length <= limit) {\n          return value;\n        }\n\n        return this.createError('object.max', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"pattern\",\n    value: function pattern(_pattern, schema) {\n      var isRegExp = _pattern instanceof RegExp;\n      Hoek.assert(isRegExp || _pattern instanceof Any, 'pattern must be a regex or schema');\n      Hoek.assert(schema !== undefined, 'Invalid rule');\n\n      if (isRegExp) {\n        Hoek.assert(!_pattern.flags.includes('g') && !_pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n      }\n\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        }\n\n        throw castErr;\n      }\n\n      var obj = this.clone();\n\n      if (isRegExp) {\n        obj._inner.patterns.push({\n          regex: _pattern,\n          rule: schema\n        });\n      } else {\n        obj._inner.patterns.push({\n          schema: _pattern,\n          rule: schema\n        });\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"schema\",\n    value: function schema() {\n      return this._test('schema', null, function (value, state, options) {\n        if (value instanceof Any) {\n          return value;\n        }\n\n        return this.createError('object.schema', null, state, options);\n      });\n    }\n  }, {\n    key: \"with\",\n    value: function _with(key, peers) {\n      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n      return this._dependency('with', key, peers);\n    }\n  }, {\n    key: \"without\",\n    value: function without(key, peers) {\n      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n      return this._dependency('without', key, peers);\n    }\n  }, {\n    key: \"xor\",\n    value: function xor() {\n      for (var _len2 = arguments.length, peers = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {\n        peers[_key4] = arguments[_key4];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('xor', null, peers);\n    }\n  }, {\n    key: \"oxor\",\n    value: function oxor() {\n      for (var _len3 = arguments.length, peers = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {\n        peers[_key5] = arguments[_key5];\n      }\n\n      return this._dependency('oxor', null, peers);\n    }\n  }, {\n    key: \"or\",\n    value: function or() {\n      for (var _len4 = arguments.length, peers = new Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {\n        peers[_key6] = arguments[_key6];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('or', null, peers);\n    }\n  }, {\n    key: \"and\",\n    value: function and() {\n      for (var _len5 = arguments.length, peers = new Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {\n        peers[_key7] = arguments[_key7];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('and', null, peers);\n    }\n  }, {\n    key: \"nand\",\n    value: function nand() {\n      for (var _len6 = arguments.length, peers = new Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {\n        peers[_key8] = arguments[_key8];\n      }\n\n      peers = Hoek.flatten(peers);\n      return this._dependency('nand', null, peers);\n    }\n  }, {\n    key: \"requiredKeys\",\n    value: function requiredKeys() {\n      for (var _len7 = arguments.length, children = new Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {\n        children[_key9] = arguments[_key9];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'required');\n    }\n  }, {\n    key: \"optionalKeys\",\n    value: function optionalKeys() {\n      for (var _len8 = arguments.length, children = new Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {\n        children[_key10] = arguments[_key10];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'optional');\n    }\n  }, {\n    key: \"forbiddenKeys\",\n    value: function forbiddenKeys() {\n      for (var _len9 = arguments.length, children = new Array(_len9), _key11 = 0; _key11 < _len9; _key11++) {\n        children[_key11] = arguments[_key11];\n      }\n\n      children = Hoek.flatten(children);\n      return this.applyFunctionToChildren(children, 'forbidden');\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(from, to, options) {\n      Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n      Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n      Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n      for (var i = 0; i < this._inner.renames.length; ++i) {\n        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n      }\n\n      var obj = this.clone();\n\n      obj._inner.renames.push({\n        from: from,\n        to: to,\n        options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n        isRegExp: from instanceof RegExp\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"applyFunctionToChildren\",\n    value: function applyFunctionToChildren(children, fn) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var root = arguments.length > 3 ? arguments[3] : undefined;\n      children = [].concat(children);\n      Hoek.assert(children.length > 0, 'expected at least one children');\n      var groupedChildren = internals.groupChildren(children);\n      var obj;\n\n      if ('' in groupedChildren) {\n        obj = this[fn].apply(this, _toConsumableArray(args));\n        delete groupedChildren[''];\n      } else {\n        obj = this.clone();\n      }\n\n      if (obj._inner.children) {\n        root = root ? root + '.' : '';\n\n        for (var i = 0; i < obj._inner.children.length; ++i) {\n          var child = obj._inner.children[i];\n          var group = groupedChildren[child.key];\n\n          if (group) {\n            obj._inner.children[i] = {\n              key: child.key,\n              _refs: child._refs,\n              schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n            };\n            delete groupedChildren[child.key];\n          }\n        }\n      }\n\n      var remaining = Object.keys(groupedChildren);\n      Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n      return obj;\n    }\n  }, {\n    key: \"_dependency\",\n    value: function _dependency(type, key, peers) {\n      peers = [].concat(peers);\n\n      for (var i = 0; i < peers.length; ++i) {\n        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n      }\n\n      var obj = this.clone();\n\n      obj._inner.dependencies.push({\n        type: type,\n        key: key,\n        peers: peers\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(shallow) {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      if (description.rules) {\n        for (var i = 0; i < description.rules.length; ++i) {\n          var rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n          if (\n          /* $lab:coverage:off$ */\n          rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n          /* $lab:coverage:on$ */\n          ) {\n              rule.arg = {\n                schema: rule.arg.schema.describe(),\n                ref: rule.arg.ref.toString()\n              };\n            }\n        }\n      }\n\n      if (this._inner.children && !shallow) {\n        description.children = {};\n\n        for (var _i7 = 0; _i7 < this._inner.children.length; ++_i7) {\n          var child = this._inner.children[_i7];\n          description.children[child.key] = child.schema.describe();\n        }\n      }\n\n      if (this._inner.dependencies.length) {\n        description.dependencies = Hoek.clone(this._inner.dependencies);\n      }\n\n      if (this._inner.patterns.length) {\n        description.patterns = [];\n\n        for (var _i8 = 0; _i8 < this._inner.patterns.length; ++_i8) {\n          var pattern = this._inner.patterns[_i8];\n\n          if (pattern.regex) {\n            description.patterns.push({\n              regex: pattern.regex.toString(),\n              rule: pattern.rule.describe()\n            });\n          } else {\n            description.patterns.push({\n              schema: pattern.schema.describe(),\n              rule: pattern.rule.describe()\n            });\n          }\n        }\n      }\n\n      if (this._inner.renames.length > 0) {\n        description.renames = Hoek.clone(this._inner.renames);\n      }\n\n      return description;\n    }\n  }, {\n    key: \"assert\",\n    value: function assert(ref, schema, message) {\n      ref = Cast.ref(ref);\n      Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n      message = message || 'pass the assertion test';\n      Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        }\n\n        throw castErr;\n      }\n\n      var key = ref.path[ref.path.length - 1];\n      var path = ref.path.join('.');\n      return this._test('assert', {\n        schema: schema,\n        ref: ref\n      }, function (value, state, options) {\n        var result = schema._validate(ref(value), null, options, value);\n\n        if (!result.errors) {\n          return value;\n        }\n\n        var localState = new State(key, ref.path, state.parent, state.reference);\n        return this.createError('object.assert', {\n          ref: path,\n          message: message\n        }, localState, options);\n      });\n    }\n  }, {\n    key: \"type\",\n    value: function type(constructor) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constructor.name;\n      Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n      var typeData = {\n        name: name,\n        ctor: constructor\n      };\n      return this._test('type', typeData, function (value, state, options) {\n        if (value instanceof constructor) {\n          return value;\n        }\n\n        return this.createError('object.type', {\n          type: typeData.name,\n          value: value\n        }, state, options);\n      });\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  var grouped = {};\n\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    var group = child.split('.')[0];\n    var childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  var children = schema._inner.children;\n\n  if (!children) {\n    return keys;\n  }\n\n  var findLabel = function findLabel(key) {\n    var matchingChild = schema._currentJoi.reach(schema, key);\n\n    return matchingChild ? matchingChild._getLabel(key) : key;\n  };\n\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n\n  return findLabel(keys);\n};\n\ninternals.with = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      return this.createError('object.with', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer: peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.without = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return this.createError('object.without', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer: peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return;\n  }\n\n  var context = {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.xor', context, state, options);\n};\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (!present.length || present.length === 1) {\n    return;\n  }\n\n  var context = {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.oxor', context, state, options);\n};\n\ninternals.or = function (key, value, peers, parent, state, options) {\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers: peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\n\ninternals.and = function (key, value, peers, parent, state, options) {\n  var missing = [];\n  var present = [];\n  var count = peers.length;\n\n  for (var i = 0; i < count; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  var aon = missing.length === count || present.length === count;\n\n  if (!aon) {\n    return this.createError('object.and', {\n      present: present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing: missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0; i < peers.length; ++i) {\n    var peer = peers[i];\n    var keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  var main = peers[0];\n  var values = peers.slice(1);\n  var allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main: main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/joi/lib/types/object/index.js"],"names":["Bourne","require","Hoek","Topo","Any","Errors","Cast","State","internals","Object","_type","_inner","children","renames","dependencies","patterns","length","keys","value","state","options","target","errors","finish","convert","test","parse","e","type","_flags","func","Array","isArray","push","createError","create","getPrototypeOf","args","apply","prototype","clone","valueKeys","i","renamed","rename","isRegExp","targetKeys","matchedTargetKeys","j","from","allUndefined","every","key","undefined","ignoreUndefined","multiple","to","abortEarly","hasOwnProperty","call","override","alias","unprocessed","Set","stripProps","child","item","delete","localState","path","reference","result","schema","_validate","_getLabel","reason","strip","finalValue","size","pattern","regex","rule","stripUnknown","allowUnknown","skipFunctions","objects","unprocessedKey","dep","hasKey","splitKey","split","err","reach","functions","peers","Err","assert","obj","topo","includes","add","after","_refs","group","cast","_currentJoi","castErr","nodes","allow","limit","Number","isSafeInteger","_test","RegExp","flags","message","arguments","_dependency","flatten","applyFunctionToChildren","applyToDefaults","renameDefaults","fn","root","concat","groupedChildren","groupChildren","remaining","join","shallow","description","rules","arg","ref","describe","toString","isContext","depth","parent","constructor","name","typeData","ctor","sort","grouped","childGroup","substring","keysToLabels","findLabel","matchingChild","map","with","peer","keysExist","main","mainWithLabel","peerWithLabel","without","xor","present","context","peersWithLabels","presentWithLabels","oxor","or","and","missing","count","aon","missingWithLabels","nand","values","slice","allPresent","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Bourne = require('@hapi/bourne');\nconst Hoek = require('@hapi/hoek');\nconst Topo = require('@hapi/topo');\n\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\nconst State = require('../state');\n\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.keys(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (value.length > 1 &&\n                (value[0] === '{' || /^\\s*\\{/.test(value))) {\n\n                try {\n                    value = Bourne.parse(value);\n                }\n                catch (e) { }\n            }\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', { value }, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function (...args) {\n\n                    return value.apply(this, args);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.isRegExp) {\n                const targetKeys = Object.keys(target);\n                const matchedTargetKeys = [];\n\n                for (let j = 0; j < targetKeys.length; ++j) {\n                    if (rename.from.test(targetKeys[j])) {\n                        matchedTargetKeys.push(targetKeys[j]);\n                    }\n                }\n\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\n                if (rename.options.ignoreUndefined && allUndefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (allUndefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\n                        delete target[matchedTargetKeys[j]];\n                    }\n                }\n            }\n            else {\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (target[rename.from] === undefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[rename.from];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    delete target[rename.from];\n                }\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = new Set(Object.keys(target));\n\n        if (this._inner.children) {\n            const stripProps = [];\n\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                unprocessed.delete(key);\n\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n                else {\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                        stripProps.push(key);\n                        target[key] = result.finalValue;\n                    }\n                    else if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n\n            for (let i = 0; i < stripProps.length; ++i) {\n                delete target[stripProps[i]];\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size && this._inner.patterns.length) {\n\n            for (const key of unprocessed) {\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const item = target[key];\n\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\n                    const pattern = this._inner.patterns[i];\n\n                    if (pattern.regex ?\n                        pattern.regex.test(key) :\n                        !pattern.schema._validate(key, state, { ...options, abortEarly:true }).errors) {\n\n                        unprocessed.delete(key);\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', {\n                                key,\n                                child: pattern.rule._getLabel(key),\n                                reason: result.errors\n                            }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (const key of unprocessed) {\n                    if (stripUnknown) {\n                        delete target[key];\n                        unprocessed.delete(key);\n                    }\n                    else if (typeof target[key] === 'function') {\n                        unprocessed.delete(key);\n                    }\n                }\n            }\n\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (const unprocessedKey of unprocessed) {\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\n                        key: unprocessedKey,\n                        path: [...state.path, unprocessedKey]\n                    }, options, {}));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const hasKey = dep.key !== null;\n            const splitKey = hasKey && dep.key.split('.');\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (!children.includes(child.key)) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(this._currentJoi, child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    append(schema) {\n        // Skip any changes\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n            return this;\n        }\n\n        return this.keys(schema);\n    }\n\n    unknown(allow) {\n\n        const value = allow !== false;\n\n        if (this._flags.allowUnknown === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = value;\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit, value }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit, value }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        const isRegExp = pattern instanceof RegExp;\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        if (isRegExp) {\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n        }\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const obj = this.clone();\n        if (isRegExp) {\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\n        }\n        else {\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\n        }\n\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('xor', null, peers);\n    }\n\n    oxor(...peers) {\n\n        return this._dependency('oxor', null, peers);\n    }\n\n    or(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('or', null, peers);\n    }\n\n    and(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('and', null, peers);\n    }\n\n    nand(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    forbiddenKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'forbidden');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n            isRegExp: from instanceof RegExp\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args = [], root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn](...args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = super.describe();\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                if (pattern.regex) {\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n                }\n                else {\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\n                }\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = new State(key, ref.path, state.parent, state.reference);\n            return this.createError('object.assert', { ref: path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name = constructor.name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\n        });\n    }\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    const children = schema._inner.children;\n\n    if (!children) {\n        return keys;\n    }\n\n    const findLabel = function (key) {\n\n        const matchingChild = schema._currentJoi.reach(schema, key);\n        return matchingChild ? matchingChild._getLabel(key) : key;\n    };\n\n    if (Array.isArray(keys)) {\n        return keys.map(findLabel);\n    }\n\n    return findLabel(keys);\n};\n\n\ninternals.with = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            return this.createError('object.with', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.without = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            return this.createError('object.without', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n\n    if (present.length === 0) {\n        return this.createError('object.missing', context, state, options);\n    }\n\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.xor', context, state, options);\n};\n\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (!present.length ||\n        present.length === 1) {\n\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.oxor', context, state, options);\n};\n\n\ninternals.or = function (key, value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            return;\n        }\n    }\n\n    return this.createError('object.missing', {\n        peers,\n        peersWithLabels: internals.keysToLabels(this, peers)\n    }, state, options);\n};\n\n\ninternals.and = function (key, value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n\n    if (!aon) {\n\n        return this.createError('object.and', {\n            present,\n            presentWithLabels: internals.keysToLabels(this, present),\n            missing,\n            missingWithLabels: internals.keysToLabels(this, missing)\n        }, state, options);\n    }\n};\n\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const main = peers[0];\n    const values = peers.slice(1);\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', {\n        main,\n        mainWithLabel: internals.keysToLabels(this, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(this, values)\n    }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n"]},"metadata":{},"sourceType":"script"}