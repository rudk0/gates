{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const {\n        object\n      } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t.assignmentExpression(\"=\", context, object));\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [context, ...node.arguments]);\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(({\n        node,\n        parent,\n        parentPath\n      }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (parentPath.isOptionalCallExpression()) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      if (rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      })) {\n        throw member.buildCodeFrameError(`can't handle delete`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const {\n        scope\n      } = member;\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const {\n          parentPath\n        } = current;\n\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      endPath.replaceWith(t.conditionalExpression(t.logicalExpression(\"||\", t.binaryExpression(\"===\", baseNeedsMemoised ? t.assignmentExpression(\"=\", baseRef, startingNode) : baseRef, t.nullLiteral()), t.binaryExpression(\"===\", t.cloneNode(baseRef), scope.buildUndefinedNode())), scope.buildUndefinedNode(), regular));\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier(\"call\"), false, true), [context, ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right\n      } = parent;\n      let value = right;\n\n      if (operator !== \"=\") {\n        this.memoise(member, 2);\n        value = t.binaryExpression(operator.slice(0, -1), this.get(member), value);\n      }\n\n      parentPath.replaceWith(this.set(member, value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"],"names":["Object","defineProperty","exports","value","default","memberExpressionToFunctions","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","AssignmentMemoiser","constructor","_map","record","count","assignmentExpression","toNonOptional","path","base","node","isOptionalMemberExpression","memberExpression","property","computed","isOptionalCallExpression","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","callExpression","identifier","arguments","isInDetachedTree","isProgram","parentPath","container","listKey","parentNode","handle","memoise","member","parent","endPath","find","rootParentPath","isUpdateExpression","argument","isAssignmentExpression","left","buildCodeFrameError","isUnaryExpression","operator","startingOptional","Error","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","parentIsCall","isCallExpression","optionalCall","boundGet","regular","current","endParentPath","isMemberExpression","conditionalExpression","logicalExpression","binaryExpression","nullLiteral","cloneNode","buildUndefinedNode","endParent","optionalCallExpression","optionalMemberExpression","simpleSet","prefix","unaryExpression","numericLiteral","ref","generateUidIdentifierBasedOnNode","push","id","sequenceExpression","right","slice","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","visitor","state","traverse","assign","memoiser"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const {\n        object\n      } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t.assignmentExpression(\"=\", context, object));\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [context, ...node.arguments]);\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(({\n        node,\n        parent,\n        parentPath\n      }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (parentPath.isOptionalCallExpression()) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      if (rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      })) {\n        throw member.buildCodeFrameError(`can't handle delete`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const {\n        scope\n      } = member;\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const {\n          parentPath\n        } = current;\n\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      endPath.replaceWith(t.conditionalExpression(t.logicalExpression(\"||\", t.binaryExpression(\"===\", baseNeedsMemoised ? t.assignmentExpression(\"=\", baseRef, startingNode) : baseRef, t.nullLiteral()), t.binaryExpression(\"===\", t.cloneNode(baseRef), scope.buildUndefinedNode())), scope.buildUndefinedNode(), regular));\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier(\"call\"), false, true), [context, ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right\n      } = parent;\n      let value = right;\n\n      if (operator !== \"=\") {\n        this.memoise(member, 2);\n        value = t.binaryExpression(operator.slice(0, -1), this.get(member), value);\n      }\n\n      parentPath.replaceWith(this.set(member, value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}"]},"metadata":{},"sourceType":"script"}