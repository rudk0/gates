{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar Assert = require('./assert');\n\nvar internals = {};\n\nmodule.exports = function (obj, chain, options) {\n  if (chain === false || chain === null || chain === undefined) {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  var isChainArray = Array.isArray(chain);\n  Assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');\n  var path = isChainArray ? chain : chain.split(options.separator || '.');\n  var ref = obj;\n\n  for (var i = 0; i < path.length; ++i) {\n    var key = path[i];\n    var type = options.iterables && internals.iterables(ref);\n\n    if (Array.isArray(ref) || type === 'set') {\n      var number = Number(key);\n\n      if (Number.isInteger(number)) {\n        key = number < 0 ? ref.length + number : number;\n      }\n    }\n\n    if (!ref || typeof ref === 'function' && options.functions === false || // Defaults to true\n    !type && ref[key] === undefined) {\n      Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    if (!type) {\n      ref = ref[key];\n    } else if (type === 'set') {\n      ref = _toConsumableArray(ref)[key];\n    } else {\n      // type === 'map'\n      ref = ref.get(key);\n    }\n  }\n\n  return ref;\n};\n\ninternals.iterables = function (ref) {\n  if (ref instanceof Set) {\n    return 'set';\n  }\n\n  if (ref instanceof Map) {\n    return 'map';\n  }\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/hoek/lib/reach.js"],"names":["Assert","require","internals","module","exports","obj","chain","options","undefined","separator","isChainArray","Array","isArray","path","split","ref","i","length","key","type","iterables","number","Number","isInteger","functions","strict","default","get","Set","Map"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('./assert');\n\n\nconst internals = {};\n\n\nmodule.exports = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        chain === undefined) {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const isChainArray = Array.isArray(chain);\n\n    Assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');\n\n    const path = isChainArray ? chain : chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        const type = options.iterables && internals.iterables(ref);\n\n        if (Array.isArray(ref) ||\n            type === 'set') {\n\n            const number = Number(key);\n            if (Number.isInteger(number)) {\n                key = number < 0 ? ref.length + number : number;\n            }\n        }\n\n        if (!ref ||\n            typeof ref === 'function' && options.functions === false ||         // Defaults to true\n            !type && ref[key] === undefined) {\n\n            Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        if (!type) {\n            ref = ref[key];\n        }\n        else if (type === 'set') {\n            ref = [...ref][key];\n        }\n        else {  // type === 'map'\n            ref = ref.get(key);\n        }\n    }\n\n    return ref;\n};\n\n\ninternals.iterables = function (ref) {\n\n    if (ref instanceof Set) {\n        return 'set';\n    }\n\n    if (ref instanceof Map) {\n        return 'map';\n    }\n};\n"]},"metadata":{},"sourceType":"script"}