{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Net = require('net');\n\nvar Address = require('@hapi/address');\n\nvar Hoek = require('@hapi/hoek');\n\nvar Any = require('../any');\n\nvar Ref = require('../../ref');\n\nvar JoiDate = require('../date');\n\nvar Uri = require('./uri');\n\nvar Ip = require('./ip');\n\nvar internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\ninternals.String = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'string';\n\n    _this._invalids.add('');\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      if (typeof value === 'string' && options.convert) {\n        if (this._flags.normalize) {\n          value = value.normalize(this._flags.normalize);\n        }\n\n        if (this._flags.case) {\n          value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n        }\n\n        if (this._flags.trim) {\n          value = value.trim();\n        }\n\n        if (this._inner.replacements) {\n          for (var i = 0; i < this._inner.replacements.length; ++i) {\n            var replacement = this._inner.replacements[i];\n            value = value.replace(replacement.pattern, replacement.replacement);\n          }\n        }\n\n        if (this._flags.truncate) {\n          for (var _i = 0; _i < this._tests.length; ++_i) {\n            var test = this._tests[_i];\n\n            if (test.name === 'max') {\n              value = value.slice(0, test.arg);\n              break;\n            }\n          }\n        }\n\n        if (this._flags.byteAligned && value.length % 2 !== 0) {\n          value = \"0\".concat(value);\n        }\n      }\n\n      return {\n        value: value,\n        errors: typeof value === 'string' ? null : this.createError('string.base', {\n          value: value\n        }, state, options)\n      };\n    }\n  }, {\n    key: \"insensitive\",\n    value: function insensitive() {\n      if (this._flags.insensitive) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.insensitive = true;\n      return obj;\n    }\n  }, {\n    key: \"creditCard\",\n    value: function creditCard() {\n      return this._test('creditCard', undefined, function (value, state, options) {\n        var i = value.length;\n        var sum = 0;\n        var mul = 1;\n\n        while (i--) {\n          var char = value.charAt(i) * mul;\n          sum = sum + (char - (char > 9) * 9);\n          mul = mul ^ 3;\n        }\n\n        var check = sum % 10 === 0 && sum > 0;\n        return check ? value : this.createError('string.creditCard', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"regex\",\n    value: function regex(pattern, patternOptions) {\n      Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n      Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n      var patternObject = {\n        pattern: pattern\n      };\n\n      if (typeof patternOptions === 'string') {\n        patternObject.name = patternOptions;\n      } else if (typeof patternOptions === 'object') {\n        patternObject.invert = !!patternOptions.invert;\n\n        if (patternOptions.name) {\n          patternObject.name = patternOptions.name;\n        }\n      }\n\n      var errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n      return this._test('regex', patternObject, function (value, state, options) {\n        var patternMatch = patternObject.pattern.test(value);\n\n        if (patternMatch ^ patternObject.invert) {\n          return value;\n        }\n\n        return this.createError(errorCode, {\n          name: patternObject.name,\n          pattern: patternObject.pattern,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"alphanum\",\n    value: function alphanum() {\n      return this._test('alphanum', undefined, function (value, state, options) {\n        if (/^[a-zA-Z0-9]+$/.test(value)) {\n          return value;\n        }\n\n        return this.createError('string.alphanum', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"token\",\n    value: function token() {\n      return this._test('token', undefined, function (value, state, options) {\n        if (/^\\w+$/.test(value)) {\n          return value;\n        }\n\n        return this.createError('string.token', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"email\",\n    value: function email(validationOptions) {\n      if (validationOptions) {\n        Hoek.assert(typeof validationOptions === 'object', 'email options must be an object'); // Migration validation for unsupported options\n\n        Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');\n        Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');\n        Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');\n        Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');\n        Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead'); // Validate options\n\n        if (validationOptions.tlds && typeof validationOptions.tlds === 'object') {\n          Hoek.assert(validationOptions.tlds.allow === undefined || validationOptions.tlds.allow === false || validationOptions.tlds.allow === true || Array.isArray(validationOptions.tlds.allow) || validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n          Hoek.assert(validationOptions.tlds.deny === undefined || Array.isArray(validationOptions.tlds.deny) || validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');\n\n          var normalizeTable = function normalizeTable(table) {\n            if (table === undefined || typeof table === 'boolean' || table instanceof Set) {\n              return table;\n            }\n\n            return new Set(table);\n          };\n\n          validationOptions = Object.assign({}, validationOptions); // Shallow cloned\n\n          validationOptions.tlds = {\n            allow: normalizeTable(validationOptions.tlds.allow),\n            deny: normalizeTable(validationOptions.tlds.deny)\n          };\n        }\n\n        Hoek.assert(validationOptions.minDomainSegments === undefined || Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n      }\n\n      return this._test('email', validationOptions, function (value, state, options) {\n        if (Address.email.isValid(value, validationOptions)) {\n          return value;\n        }\n\n        return this.createError('string.email', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"ip\",\n    value: function ip() {\n      var ipOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var regex = internals.ipRegex;\n      Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n      if (ipOptions.cidr) {\n        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n        ipOptions.cidr = ipOptions.cidr.toLowerCase();\n        Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n        if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n          regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n        }\n      } else {\n        // Set our default cidr strategy\n        ipOptions.cidr = 'optional';\n      }\n\n      var versions;\n\n      if (ipOptions.version) {\n        if (!Array.isArray(ipOptions.version)) {\n          ipOptions.version = [ipOptions.version];\n        }\n\n        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n        versions = [];\n\n        for (var i = 0; i < ipOptions.version.length; ++i) {\n          var version = ipOptions.version[i];\n          Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n          version = version.toLowerCase();\n          Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n          versions.push(version);\n        } // Make sure we have a set of versions\n\n\n        versions = Array.from(new Set(versions));\n        regex = Ip.createIpRegex(versions, ipOptions.cidr);\n      }\n\n      return this._test('ip', ipOptions, function (value, state, options) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        if (versions) {\n          return this.createError('string.ipVersion', {\n            value: value,\n            cidr: ipOptions.cidr,\n            version: versions\n          }, state, options);\n        }\n\n        return this.createError('string.ip', {\n          value: value,\n          cidr: ipOptions.cidr\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"uri\",\n    value: function uri(uriOptions) {\n      var customScheme = '';\n      var allowRelative = false;\n      var relativeOnly = false;\n      var allowQuerySquareBrackets = false;\n      var regex = internals.uriRegex;\n\n      if (uriOptions) {\n        Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n        var unknownOptions = Object.keys(uriOptions).filter(function (key) {\n          return !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key);\n        });\n        Hoek.assert(unknownOptions.length === 0, \"options contain unknown keys: \".concat(unknownOptions));\n\n        if (uriOptions.scheme) {\n          Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n          if (!Array.isArray(uriOptions.scheme)) {\n            uriOptions.scheme = [uriOptions.scheme];\n          }\n\n          Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n          for (var i = 0; i < uriOptions.scheme.length; ++i) {\n            var scheme = uriOptions.scheme[i];\n            Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n            customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n            if (scheme instanceof RegExp) {\n              customScheme = customScheme + scheme.source;\n            } else {\n              Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n              customScheme = customScheme + Hoek.escapeRegex(scheme);\n            }\n          }\n        }\n\n        if (uriOptions.allowRelative) {\n          allowRelative = true;\n        }\n\n        if (uriOptions.relativeOnly) {\n          relativeOnly = true;\n        }\n\n        if (uriOptions.allowQuerySquareBrackets) {\n          allowQuerySquareBrackets = true;\n        }\n      }\n\n      if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n        regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n      }\n\n      return this._test('uri', uriOptions, function (value, state, options) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        if (relativeOnly) {\n          return this.createError('string.uriRelativeOnly', {\n            value: value\n          }, state, options);\n        }\n\n        if (customScheme) {\n          return this.createError('string.uriCustomScheme', {\n            scheme: customScheme,\n            value: value\n          }, state, options);\n        }\n\n        return this.createError('string.uri', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"isoDate\",\n    value: function isoDate() {\n      return this._test('isoDate', undefined, function (value, state, options) {\n        if (JoiDate._isIsoDate(value)) {\n          if (!options.convert) {\n            return value;\n          }\n\n          var d = new Date(value);\n\n          if (!isNaN(d.getTime())) {\n            return d.toISOString();\n          }\n        }\n\n        return this.createError('string.isoDate', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"guid\",\n    value: function guid(guidOptions) {\n      var versionNumbers = '';\n\n      if (guidOptions && guidOptions.version) {\n        if (!Array.isArray(guidOptions.version)) {\n          guidOptions.version = [guidOptions.version];\n        }\n\n        Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n        var versions = new Set();\n\n        for (var i = 0; i < guidOptions.version.length; ++i) {\n          var version = guidOptions.version[i];\n          Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n          version = version.toLowerCase();\n          var versionNumber = internals.guidVersions[version];\n          Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n          Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');\n          versionNumbers += versionNumber;\n          versions.add(versionNumber);\n        }\n      }\n\n      var guidRegex = new RegExp(\"^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[\".concat(versionNumbers || '0-9A-F', \"][0-9A-F]{3}\\\\2?[\").concat(versionNumbers ? '89AB' : '0-9A-F', \"][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$\"), 'i');\n      return this._test('guid', guidOptions, function (value, state, options) {\n        var results = guidRegex.exec(value);\n\n        if (!results) {\n          return this.createError('string.guid', {\n            value: value\n          }, state, options);\n        } // Matching braces\n\n\n        if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n          return this.createError('string.guid', {\n            value: value\n          }, state, options);\n        }\n\n        return value;\n      });\n    }\n  }, {\n    key: \"hex\",\n    value: function hex() {\n      var hexOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n      Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');\n      var byteAligned = hexOptions.byteAligned === true;\n      var regex = /^[a-f0-9]+$/i;\n\n      var obj = this._test('hex', regex, function (value, state, options) {\n        if (regex.test(value)) {\n          if (byteAligned && value.length % 2 !== 0) {\n            return this.createError('string.hexAlign', {\n              value: value\n            }, state, options);\n          }\n\n          return value;\n        }\n\n        return this.createError('string.hex', {\n          value: value\n        }, state, options);\n      });\n\n      if (byteAligned) {\n        obj._flags.byteAligned = true;\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"base64\",\n    value: function base64() {\n      var base64Options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Validation.\n      Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n      Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean'); // Determine if padding is required.\n\n      var paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true; // Set validation based on preference.\n\n      var regex = paddingRequired ? // Padding is required.\n      /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ // Padding is optional.\n      : /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n      return this._test('base64', regex, function (value, state, options) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        return this.createError('string.base64', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"dataUri\",\n    value: function dataUri() {\n      var dataUriOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/; // Determine if padding is required.\n\n      var paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;\n      var base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n      return this._test('dataUri', regex, function (value, state, options) {\n        var matches = value.match(regex);\n\n        if (matches) {\n          if (!matches[2]) {\n            return value;\n          }\n\n          if (matches[2] !== 'base64') {\n            return value;\n          }\n\n          if (base64regex.test(matches[3])) {\n            return value;\n          }\n        }\n\n        return this.createError('string.dataUri', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"hostname\",\n    value: function hostname() {\n      var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n      return this._test('hostname', undefined, function (value, state, options) {\n        if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n          return value;\n        }\n\n        return this.createError('string.hostname', {\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';\n      Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n      var obj = this._test('normalize', form, function (value, state, options) {\n        if (options.convert || value === value.normalize(form)) {\n          return value;\n        }\n\n        return this.createError('string.normalize', {\n          value: value,\n          form: form\n        }, state, options);\n      });\n\n      obj._flags.normalize = form;\n      return obj;\n    }\n  }, {\n    key: \"lowercase\",\n    value: function lowercase() {\n      var obj = this._test('lowercase', undefined, function (value, state, options) {\n        if (options.convert || value === value.toLocaleLowerCase()) {\n          return value;\n        }\n\n        return this.createError('string.lowercase', {\n          value: value\n        }, state, options);\n      });\n\n      obj._flags.case = 'lower';\n      return obj;\n    }\n  }, {\n    key: \"uppercase\",\n    value: function uppercase() {\n      var obj = this._test('uppercase', undefined, function (value, state, options) {\n        if (options.convert || value === value.toLocaleUpperCase()) {\n          return value;\n        }\n\n        return this.createError('string.uppercase', {\n          value: value\n        }, state, options);\n      });\n\n      obj._flags.case = 'upper';\n      return obj;\n    }\n  }, {\n    key: \"trim\",\n    value: function trim() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n      if (this._flags.trim && enabled || !this._flags.trim && !enabled) {\n        return this;\n      }\n\n      var obj;\n\n      if (enabled) {\n        obj = this._test('trim', undefined, function (value, state, options) {\n          if (options.convert || value === value.trim()) {\n            return value;\n          }\n\n          return this.createError('string.trim', {\n            value: value\n          }, state, options);\n        });\n      } else {\n        obj = this.clone();\n        obj._tests = obj._tests.filter(function (test) {\n          return test.name !== 'trim';\n        });\n      }\n\n      obj._flags.trim = enabled;\n      return obj;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(pattern, replacement) {\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n      }\n\n      Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n      Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n      // anything from this rule, so just clone the current object\n\n      var obj = this.clone();\n\n      if (!obj._inner.replacements) {\n        obj._inner.replacements = [];\n      }\n\n      obj._inner.replacements.push({\n        pattern: pattern,\n        replacement: replacement\n      });\n\n      return obj;\n    }\n  }, {\n    key: \"truncate\",\n    value: function truncate(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.truncate === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.truncate = value;\n      return obj;\n    }\n  }]);\n\n  return _class;\n}(Any);\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    var isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      var compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!Number.isSafeInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit,\n            value: compareTo\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value: value,\n        encoding: encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n}); // Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/joi/lib/types/string/index.js"],"names":["Net","require","Address","Hoek","Any","Ref","JoiDate","Uri","Ip","internals","uriRegex","createUriRegex","ipRegex","createIpRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","cidrPresences","normalizationForms","String","_type","_invalids","add","value","state","options","convert","_flags","normalize","case","toLocaleUpperCase","toLocaleLowerCase","trim","_inner","replacements","i","length","replacement","replace","pattern","truncate","_tests","test","name","slice","arg","byteAligned","errors","createError","insensitive","obj","clone","_test","undefined","sum","mul","char","charAt","check","patternOptions","assert","RegExp","flags","includes","patternObject","invert","errorCode","join","patternMatch","validationOptions","checkDNS","errorLevel","minDomainAtoms","tldBlacklist","tldWhitelist","tlds","allow","Array","isArray","Set","deny","normalizeTable","table","Object","assign","minDomainSegments","Number","isSafeInteger","email","isValid","ipOptions","regex","cidr","toLowerCase","contain","version","versions","keys","push","from","uriOptions","customScheme","allowRelative","relativeOnly","allowQuerySquareBrackets","unknownOptions","filter","key","scheme","source","escapeRegex","_isIsoDate","d","Date","isNaN","getTime","toISOString","guidOptions","versionNumbers","versionNumber","has","guidRegex","results","exec","hexOptions","base64Options","paddingRequired","dataUriOptions","base64regex","matches","match","isIPv6","form","enabled","compare","type","limit","encoding","isRef","Buffer","isEncoding","compareTo","reference","parent","ref","prototype","min","byteLength","max","uuid","guid","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Net = require('net');\n\nconst Address = require('@hapi/address');\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\nconst Ref = require('../../ref');\nconst JoiDate = require('../date');\n\nconst Uri = require('./uri');\nconst Ip = require('./ip');\n\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    cidrPresences: ['required', 'optional', 'forbidden'],\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\n\ninternals.String = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'string';\n        this._invalids.add('');\n    }\n\n    _base(value, state, options) {\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (this._flags.normalize) {\n                value = value.normalize(this._flags.normalize);\n            }\n\n            if (this._flags.case) {\n                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n            }\n\n            if (this._flags.trim) {\n                value = value.trim();\n            }\n\n            if (this._inner.replacements) {\n\n                for (let i = 0; i < this._inner.replacements.length; ++i) {\n                    const replacement = this._inner.replacements[i];\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            if (this._flags.truncate) {\n                for (let i = 0; i < this._tests.length; ++i) {\n                    const test = this._tests[i];\n                    if (test.name === 'max') {\n                        value = value.slice(0, test.arg);\n                        break;\n                    }\n                }\n            }\n\n            if (this._flags.byteAligned && value.length % 2 !== 0) {\n                value = `0${value}`;\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)\n        };\n    }\n\n    insensitive() {\n\n        if (this._flags.insensitive) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.insensitive = true;\n        return obj;\n    }\n\n    creditCard() {\n\n        return this._test('creditCard', undefined, function (value, state, options) {\n\n            let i = value.length;\n            let sum = 0;\n            let mul = 1;\n\n            while (i--) {\n                const char = value.charAt(i) * mul;\n                sum = sum + (char - (char > 9) * 9);\n                mul = mul ^ 3;\n            }\n\n            const check = (sum % 10 === 0) && (sum > 0);\n            return check ? value : this.createError('string.creditCard', { value }, state, options);\n        });\n    }\n\n    regex(pattern, patternOptions) {\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n\n        const patternObject = { pattern };\n\n        if (typeof patternOptions === 'string') {\n            patternObject.name = patternOptions;\n        }\n        else if (typeof patternOptions === 'object') {\n            patternObject.invert = !!patternOptions.invert;\n\n            if (patternOptions.name) {\n                patternObject.name = patternOptions.name;\n            }\n        }\n\n        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n\n        return this._test('regex', patternObject, function (value, state, options) {\n\n            const patternMatch = patternObject.pattern.test(value);\n\n            if (patternMatch ^ patternObject.invert) {\n                return value;\n            }\n\n            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);\n        });\n    }\n\n    alphanum() {\n\n        return this._test('alphanum', undefined, function (value, state, options) {\n\n            if (/^[a-zA-Z0-9]+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.alphanum', { value }, state, options);\n        });\n    }\n\n    token() {\n\n        return this._test('token', undefined, function (value, state, options) {\n\n            if (/^\\w+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.token', { value }, state, options);\n        });\n    }\n\n    email(validationOptions) {\n\n        if (validationOptions) {\n            Hoek.assert(typeof validationOptions === 'object', 'email options must be an object');\n\n            // Migration validation for unsupported options\n\n            Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');\n            Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');\n            Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');\n            Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');\n            Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead');\n\n            // Validate options\n\n            if (validationOptions.tlds &&\n                typeof validationOptions.tlds === 'object') {\n\n                Hoek.assert(validationOptions.tlds.allow === undefined ||\n                    validationOptions.tlds.allow === false ||\n                    validationOptions.tlds.allow === true ||\n                    Array.isArray(validationOptions.tlds.allow) ||\n                    validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n\n                Hoek.assert(validationOptions.tlds.deny === undefined ||\n                    Array.isArray(validationOptions.tlds.deny) ||\n                    validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');\n\n                const normalizeTable = (table) => {\n\n                    if (table === undefined ||\n                        typeof table === 'boolean' ||\n                        table instanceof Set) {\n\n                        return table;\n                    }\n\n                    return new Set(table);\n                };\n\n                validationOptions = Object.assign({}, validationOptions);       // Shallow cloned\n                validationOptions.tlds = {\n                    allow: normalizeTable(validationOptions.tlds.allow),\n                    deny: normalizeTable(validationOptions.tlds.deny)\n                };\n            }\n\n            Hoek.assert(validationOptions.minDomainSegments === undefined ||\n                Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n        }\n\n        return this._test('email', validationOptions, function (value, state, options) {\n\n            if (Address.email.isValid(value, validationOptions)) {\n                return value;\n            }\n\n            return this.createError('string.email', { value }, state, options);\n        });\n    }\n\n    ip(ipOptions = {}) {\n\n        let regex = internals.ipRegex;\n        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n        if (ipOptions.cidr) {\n            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n            ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));\n\n            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n            if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n            }\n        }\n        else {\n\n            // Set our default cidr strategy\n            ipOptions.cidr = 'optional';\n        }\n\n        let versions;\n        if (ipOptions.version) {\n            if (!Array.isArray(ipOptions.version)) {\n                ipOptions.version = [ipOptions.version];\n            }\n\n            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n            versions = [];\n            for (let i = 0; i < ipOptions.version.length; ++i) {\n                let version = ipOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n                versions.push(version);\n            }\n\n            // Make sure we have a set of versions\n            versions = Array.from(new Set(versions));\n\n            regex = Ip.createIpRegex(versions, ipOptions.cidr);\n        }\n\n        return this._test('ip', ipOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (versions) {\n                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);\n            }\n\n            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);\n        });\n    }\n\n    uri(uriOptions) {\n\n        let customScheme = '';\n        let allowRelative = false;\n        let relativeOnly = false;\n        let allowQuerySquareBrackets = false;\n        let regex = internals.uriRegex;\n\n        if (uriOptions) {\n            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n            if (uriOptions.scheme) {\n                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n                if (!Array.isArray(uriOptions.scheme)) {\n                    uriOptions.scheme = [uriOptions.scheme];\n                }\n\n                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n                // Flatten the array into a string to be used to match the schemes.\n                for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                    const scheme = uriOptions.scheme[i];\n                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (scheme instanceof RegExp) {\n                        customScheme = customScheme + scheme.source;\n                    }\n                    else {\n                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                        customScheme = customScheme + Hoek.escapeRegex(scheme);\n                    }\n                }\n            }\n\n            if (uriOptions.allowRelative) {\n                allowRelative = true;\n            }\n\n            if (uriOptions.relativeOnly) {\n                relativeOnly = true;\n            }\n\n            if (uriOptions.allowQuerySquareBrackets) {\n                allowQuerySquareBrackets = true;\n            }\n        }\n\n        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n        }\n\n        return this._test('uri', uriOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (relativeOnly) {\n                return this.createError('string.uriRelativeOnly', { value }, state, options);\n            }\n\n            if (customScheme) {\n                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);\n            }\n\n            return this.createError('string.uri', { value }, state, options);\n        });\n    }\n\n    isoDate() {\n\n        return this._test('isoDate', undefined, function (value, state, options) {\n\n            if (JoiDate._isIsoDate(value)) {\n                if (!options.convert) {\n                    return value;\n                }\n\n                const d = new Date(value);\n                if (!isNaN(d.getTime())) {\n                    return d.toISOString();\n                }\n            }\n\n            return this.createError('string.isoDate', { value }, state, options);\n        });\n    }\n\n    guid(guidOptions) {\n\n        let versionNumbers = '';\n\n        if (guidOptions && guidOptions.version) {\n            if (!Array.isArray(guidOptions.version)) {\n                guidOptions.version = [guidOptions.version];\n            }\n\n            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n            const versions = new Set();\n\n            for (let i = 0; i < guidOptions.version.length; ++i) {\n                let version = guidOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                const versionNumber = internals.guidVersions[version];\n                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');\n\n                versionNumbers += versionNumber;\n                versions.add(versionNumber);\n            }\n        }\n\n        const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n        return this._test('guid', guidOptions, function (value, state, options) {\n\n            const results = guidRegex.exec(value);\n\n            if (!results) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching braces\n            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            return value;\n        });\n    }\n\n    hex(hexOptions = {}) {\n\n        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',\n            'byteAligned must be boolean');\n\n        const byteAligned = hexOptions.byteAligned === true;\n        const regex = /^[a-f0-9]+$/i;\n\n        const obj = this._test('hex', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                if (byteAligned && value.length % 2 !== 0) {\n                    return this.createError('string.hexAlign', { value }, state, options);\n                }\n\n                return value;\n            }\n\n            return this.createError('string.hex', { value }, state, options);\n        });\n\n        if (byteAligned) {\n            obj._flags.byteAligned = true;\n        }\n\n        return obj;\n    }\n\n    base64(base64Options = {}) {\n\n        // Validation.\n        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',\n            'paddingRequired must be boolean');\n\n        // Determine if padding is required.\n        const paddingRequired = base64Options.paddingRequired === false ?\n            base64Options.paddingRequired\n            : base64Options.paddingRequired || true;\n\n        // Set validation based on preference.\n        const regex = paddingRequired ?\n            // Padding is required.\n            /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            // Padding is optional.\n            : /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('base64', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.base64', { value }, state, options);\n        });\n    }\n\n    dataUri(dataUriOptions = {}) {\n\n        const regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/;\n\n        // Determine if padding is required.\n        const paddingRequired = dataUriOptions.paddingRequired === false ?\n            dataUriOptions.paddingRequired\n            : dataUriOptions.paddingRequired || true;\n\n        const base64regex = paddingRequired ?\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('dataUri', regex, function (value, state, options) {\n\n            const matches = value.match(regex);\n\n            if (matches) {\n                if (!matches[2]) {\n                    return value;\n                }\n\n                if (matches[2] !== 'base64') {\n                    return value;\n                }\n\n                if (base64regex.test(matches[3])) {\n                    return value;\n                }\n            }\n\n            return this.createError('string.dataUri', { value }, state, options);\n        });\n    }\n\n    hostname() {\n\n        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n        return this._test('hostname', undefined, function (value, state, options) {\n\n            if ((value.length <= 255 && regex.test(value)) ||\n                Net.isIPv6(value)) {\n\n                return value;\n            }\n\n            return this.createError('string.hostname', { value }, state, options);\n        });\n    }\n\n    normalize(form = 'NFC') {\n\n        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n        const obj = this._test('normalize', form, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.normalize(form)) {\n\n                return value;\n            }\n\n            return this.createError('string.normalize', { value, form }, state, options);\n        });\n\n        obj._flags.normalize = form;\n        return obj;\n    }\n\n    lowercase() {\n\n        const obj = this._test('lowercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleLowerCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.lowercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'lower';\n        return obj;\n    }\n\n    uppercase() {\n\n        const obj = this._test('uppercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleUpperCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.uppercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'upper';\n        return obj;\n    }\n\n    trim(enabled = true) {\n\n        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {\n            return this;\n        }\n\n        let obj;\n        if (enabled) {\n            obj = this._test('trim', undefined, function (value, state, options) {\n\n                if (options.convert ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return this.createError('string.trim', { value }, state, options);\n            });\n        }\n        else {\n            obj = this.clone();\n            obj._tests = obj._tests.filter((test) => test.name !== 'trim');\n        }\n\n        obj._flags.trim = enabled;\n        return obj;\n    }\n\n    replace(pattern, replacement) {\n\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n        }\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n        // This can not be considere a test like trim, we can't \"reject\"\n        // anything from this rule, so just clone the current object\n        const obj = this.clone();\n\n        if (!obj._inner.replacements) {\n            obj._inner.replacements = [];\n        }\n\n        obj._inner.replacements.push({\n            pattern,\n            replacement\n        });\n\n        return obj;\n    }\n\n    truncate(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.truncate === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.truncate = value;\n        return obj;\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!Number.isSafeInteger(compareTo)) {\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return value;\n            }\n\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\n        });\n    };\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\n\nmodule.exports = new internals.String();\n"]},"metadata":{},"sourceType":"script"}