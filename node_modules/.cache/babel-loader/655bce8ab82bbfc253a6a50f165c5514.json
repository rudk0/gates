{"ast":null,"code":"/*\n  @license\n\tRollup.js v1.32.1\n\tFri, 06 Mar 2020 09:32:39 GMT - commit f458cbf6cb8cfcc1678593d8dc595e4b8757eb6d\n\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport util from 'util';\nimport path, { relative as relative$1, extname, basename, dirname, resolve, sep } from 'path';\nimport { readFile as readFile$1, writeFile as writeFile$1, readdirSync, mkdirSync, lstatSync, realpathSync, statSync, watch as watch$1 } from 'fs';\nimport * as acorn__default from 'acorn';\nimport { Parser } from 'acorn';\nimport { createHash as createHash$2 } from 'crypto';\nimport { EventEmitter } from 'events';\nimport module from 'module';\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nvar version = \"1.32.1\";\nvar charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (var i = 0; i < chars.length; i++) {\n  charToInteger[chars.charCodeAt(i)] = i;\n}\n\nfunction decode(mappings) {\n  var decoded = [];\n  var line = [];\n  var segment = [0, 0, 0, 0, 0];\n  var j = 0;\n\n  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n    var c = mappings.charCodeAt(i);\n\n    if (c === 44) {\n      // \",\"\n      segmentify(line, segment, j);\n      j = 0;\n    } else if (c === 59) {\n      // \";\"\n      segmentify(line, segment, j);\n      j = 0;\n      decoded.push(line);\n      line = [];\n      segment[0] = 0;\n    } else {\n      var integer = charToInteger[c];\n\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n      }\n\n      var hasContinuationBit = integer & 32;\n      integer &= 31;\n      value += integer << shift;\n\n      if (hasContinuationBit) {\n        shift += 5;\n      } else {\n        var shouldNegate = value & 1;\n        value >>>= 1;\n\n        if (shouldNegate) {\n          value = value === 0 ? -0x80000000 : -value;\n        }\n\n        segment[j] += value;\n        j++;\n        value = shift = 0; // reset\n      }\n    }\n  }\n\n  segmentify(line, segment, j);\n  decoded.push(line);\n  return decoded;\n}\n\nfunction segmentify(line, segment, j) {\n  // This looks ugly, but we're creating specialized arrays with a specific\n  // length. This is much faster than creating a new array (which v8 expands to\n  // a capacity of 17 after pushing the first item), or slicing out a subarray\n  // (which is slow). Length 4 is assumed to be the most frequent, followed by\n  // length 5 (since not everything will have an associated name), followed by\n  // length 1 (it's probably rare for a source substring to not have an\n  // associated segment data).\n  if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n}\n\nfunction encode(decoded) {\n  var sourceFileIndex = 0; // second field\n\n  var sourceCodeLine = 0; // third field\n\n  var sourceCodeColumn = 0; // fourth field\n\n  var nameIndex = 0; // fifth field\n\n  var mappings = '';\n\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    if (i > 0) mappings += ';';\n    if (line.length === 0) continue;\n    var generatedCodeColumn = 0; // first field\n\n    var lineMappings = [];\n\n    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n      var segment = line_1[_i];\n      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n      generatedCodeColumn = segment[0];\n\n      if (segment.length > 1) {\n        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n        sourceFileIndex = segment[1];\n        sourceCodeLine = segment[2];\n        sourceCodeColumn = segment[3];\n      }\n\n      if (segment.length === 5) {\n        segmentMappings += encodeInteger(segment[4] - nameIndex);\n        nameIndex = segment[4];\n      }\n\n      lineMappings.push(segmentMappings);\n    }\n\n    mappings += lineMappings.join(',');\n  }\n\n  return mappings;\n}\n\nfunction encodeInteger(num) {\n  var result = '';\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n\n  do {\n    var clamped = num & 31;\n    num >>>= 5;\n\n    if (num > 0) {\n      clamped |= 32;\n    }\n\n    result += chars[clamped];\n  } while (num > 0);\n\n  return result;\n}\n\nvar BitSet = function BitSet(arg) {\n  this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\n\nBitSet.prototype.add = function add(n) {\n  this.bits[n >> 5] |= 1 << (n & 31);\n};\n\nBitSet.prototype.has = function has(n) {\n  return !!(this.bits[n >> 5] & 1 << (n & 31));\n};\n\nvar Chunk = function Chunk(start, end, content) {\n  this.start = start;\n  this.end = end;\n  this.original = content;\n  this.intro = '';\n  this.outro = '';\n  this.content = content;\n  this.storeName = false;\n  this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n  Object.defineProperties(this, {\n    previous: {\n      writable: true,\n      value: null\n    },\n    next: {\n      writable: true,\n      value: null\n    }\n  });\n};\n\nChunk.prototype.appendLeft = function appendLeft(content) {\n  this.outro += content;\n};\n\nChunk.prototype.appendRight = function appendRight(content) {\n  this.intro = this.intro + content;\n};\n\nChunk.prototype.clone = function clone() {\n  var chunk = new Chunk(this.start, this.end, this.original);\n  chunk.intro = this.intro;\n  chunk.outro = this.outro;\n  chunk.content = this.content;\n  chunk.storeName = this.storeName;\n  chunk.edited = this.edited;\n  return chunk;\n};\n\nChunk.prototype.contains = function contains(index) {\n  return this.start < index && index < this.end;\n};\n\nChunk.prototype.eachNext = function eachNext(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.next;\n  }\n};\n\nChunk.prototype.eachPrevious = function eachPrevious(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.previous;\n  }\n};\n\nChunk.prototype.edit = function edit(content, storeName, contentOnly) {\n  this.content = content;\n\n  if (!contentOnly) {\n    this.intro = '';\n    this.outro = '';\n  }\n\n  this.storeName = storeName;\n  this.edited = true;\n  return this;\n};\n\nChunk.prototype.prependLeft = function prependLeft(content) {\n  this.outro = content + this.outro;\n};\n\nChunk.prototype.prependRight = function prependRight(content) {\n  this.intro = content + this.intro;\n};\n\nChunk.prototype.split = function split(index) {\n  var sliceIndex = index - this.start;\n  var originalBefore = this.original.slice(0, sliceIndex);\n  var originalAfter = this.original.slice(sliceIndex);\n  this.original = originalBefore;\n  var newChunk = new Chunk(index, this.end, originalAfter);\n  newChunk.outro = this.outro;\n  this.outro = '';\n  this.end = index;\n\n  if (this.edited) {\n    // TODO is this block necessary?...\n    newChunk.edit('', false);\n    this.content = '';\n  } else {\n    this.content = originalBefore;\n  }\n\n  newChunk.next = this.next;\n\n  if (newChunk.next) {\n    newChunk.next.previous = newChunk;\n  }\n\n  newChunk.previous = this;\n  this.next = newChunk;\n  return newChunk;\n};\n\nChunk.prototype.toString = function toString() {\n  return this.intro + this.content + this.outro;\n};\n\nChunk.prototype.trimEnd = function trimEnd(rx) {\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.start + trimmed.length).edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.intro = this.intro.replace(rx, '');\n\n    if (this.intro.length) {\n      return true;\n    }\n  }\n};\n\nChunk.prototype.trimStart = function trimStart(rx) {\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.end - trimmed.length);\n      this.edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.outro = this.outro.replace(rx, '');\n\n    if (this.outro.length) {\n      return true;\n    }\n  }\n};\n\nvar btoa = function () {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = function (str) {\n    return window.btoa(unescape(encodeURIComponent(str)));\n  };\n} else if (typeof Buffer === 'function') {\n  btoa = function (str) {\n    return Buffer.from(str, 'utf-8').toString('base64');\n  };\n}\n\nvar SourceMap = function SourceMap(properties) {\n  this.version = 3;\n  this.file = properties.file;\n  this.sources = properties.sources;\n  this.sourcesContent = properties.sourcesContent;\n  this.names = properties.names;\n  this.mappings = encode(properties.mappings);\n};\n\nSourceMap.prototype.toString = function toString() {\n  return JSON.stringify(this);\n};\n\nSourceMap.prototype.toUrl = function toUrl() {\n  return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\n\nfunction guessIndent(code) {\n  var lines = code.split('\\n');\n  var tabbed = lines.filter(function (line) {\n    return /^\\t+/.test(line);\n  });\n  var spaced = lines.filter(function (line) {\n    return /^ {2,}/.test(line);\n  });\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  var min = spaced.reduce(function (previous, current) {\n    var numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n  var fromParts = from.split(/[/\\\\]/);\n  var toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  if (fromParts.length) {\n    var i = fromParts.length;\n\n    while (i--) {\n      fromParts[i] = '..';\n    }\n  }\n\n  return fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n  var originalLines = source.split('\\n');\n  var lineOffsets = [];\n\n  for (var i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n\n  return function locate(index) {\n    var i = 0;\n    var j = lineOffsets.length;\n\n    while (i < j) {\n      var m = i + j >> 1;\n\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    var line = i - 1;\n    var column = index - lineOffsets[line];\n    return {\n      line: line,\n      column: column\n    };\n  };\n}\n\nvar Mappings = function Mappings(hires) {\n  this.hires = hires;\n  this.generatedCodeLine = 0;\n  this.generatedCodeColumn = 0;\n  this.raw = [];\n  this.rawSegments = this.raw[this.generatedCodeLine] = [];\n  this.pending = null;\n};\n\nMappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n  if (content.length) {\n    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n    if (nameIndex >= 0) {\n      segment.push(nameIndex);\n    }\n\n    this.rawSegments.push(segment);\n  } else if (this.pending) {\n    this.rawSegments.push(this.pending);\n  }\n\n  this.advance(content);\n  this.pending = null;\n};\n\nMappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n  var originalCharIndex = chunk.start;\n  var first = true;\n\n  while (originalCharIndex < chunk.end) {\n    if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n    }\n\n    if (original[originalCharIndex] === '\\n') {\n      loc.line += 1;\n      loc.column = 0;\n      this.generatedCodeLine += 1;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      this.generatedCodeColumn = 0;\n      first = true;\n    } else {\n      loc.column += 1;\n      this.generatedCodeColumn += 1;\n      first = false;\n    }\n\n    originalCharIndex += 1;\n  }\n\n  this.pending = sourceIndex > 0 ? [this.generatedCodeColumn, sourceIndex, loc.line, loc.column] : null;\n};\n\nMappings.prototype.advance = function advance(str) {\n  if (!str) {\n    return;\n  }\n\n  var lines = str.split('\\n');\n\n  if (lines.length > 1) {\n    for (var i = 0; i < lines.length - 1; i++) {\n      this.generatedCodeLine++;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n    }\n\n    this.generatedCodeColumn = 0;\n  }\n\n  this.generatedCodeColumn += lines[lines.length - 1].length;\n};\n\nvar n = '\\n';\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\n\nvar MagicString = function MagicString(string, options) {\n  if (options === void 0) options = {};\n  var chunk = new Chunk(0, string.length, string);\n  Object.defineProperties(this, {\n    original: {\n      writable: true,\n      value: string\n    },\n    outro: {\n      writable: true,\n      value: ''\n    },\n    intro: {\n      writable: true,\n      value: ''\n    },\n    firstChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastSearchedChunk: {\n      writable: true,\n      value: chunk\n    },\n    byStart: {\n      writable: true,\n      value: {}\n    },\n    byEnd: {\n      writable: true,\n      value: {}\n    },\n    filename: {\n      writable: true,\n      value: options.filename\n    },\n    indentExclusionRanges: {\n      writable: true,\n      value: options.indentExclusionRanges\n    },\n    sourcemapLocations: {\n      writable: true,\n      value: new BitSet()\n    },\n    storedNames: {\n      writable: true,\n      value: {}\n    },\n    indentStr: {\n      writable: true,\n      value: guessIndent(string)\n    }\n  });\n  this.byStart[0] = chunk;\n  this.byEnd[string.length] = chunk;\n};\n\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n  this.sourcemapLocations.add(char);\n};\n\nMagicString.prototype.append = function append(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.outro += content;\n  return this;\n};\n\nMagicString.prototype.appendLeft = function appendLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.appendLeft(content);\n  } else {\n    this.intro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.appendRight = function appendRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.appendRight(content);\n  } else {\n    this.outro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.clone = function clone() {\n  var cloned = new MagicString(this.original, {\n    filename: this.filename\n  });\n  var originalChunk = this.firstChunk;\n  var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n  while (originalChunk) {\n    cloned.byStart[clonedChunk.start] = clonedChunk;\n    cloned.byEnd[clonedChunk.end] = clonedChunk;\n    var nextOriginalChunk = originalChunk.next;\n    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n    if (nextClonedChunk) {\n      clonedChunk.next = nextClonedChunk;\n      nextClonedChunk.previous = clonedChunk;\n      clonedChunk = nextClonedChunk;\n    }\n\n    originalChunk = nextOriginalChunk;\n  }\n\n  cloned.lastChunk = clonedChunk;\n\n  if (this.indentExclusionRanges) {\n    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n  }\n\n  cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n  cloned.intro = this.intro;\n  cloned.outro = this.outro;\n  return cloned;\n};\n\nMagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1 = this;\n  options = options || {};\n  var sourceIndex = 0;\n  var names = Object.keys(this.storedNames);\n  var mappings = new Mappings(options.hires);\n  var locate = getLocator(this.original);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.firstChunk.eachNext(function (chunk) {\n    var loc = locate(chunk.start);\n\n    if (chunk.intro.length) {\n      mappings.advance(chunk.intro);\n    }\n\n    if (chunk.edited) {\n      mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n    } else {\n      mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);\n    }\n\n    if (chunk.outro.length) {\n      mappings.advance(chunk.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n    sourcesContent: options.includeContent ? [this.original] : [null],\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nMagicString.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nMagicString.prototype.getIndentString = function getIndentString() {\n  return this.indentStr === null ? '\\t' : this.indentStr;\n};\n\nMagicString.prototype.indent = function indent(indentStr, options) {\n  var pattern = /^[^\\r\\n]/gm;\n\n  if (isObject(indentStr)) {\n    options = indentStr;\n    indentStr = undefined;\n  }\n\n  indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  options = options || {}; // Process exclusion ranges\n\n  var isExcluded = {};\n\n  if (options.exclude) {\n    var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n    exclusions.forEach(function (exclusion) {\n      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n        isExcluded[i] = true;\n      }\n    });\n  }\n\n  var shouldIndentNextCharacter = options.indentStart !== false;\n\n  var replacer = function (match) {\n    if (shouldIndentNextCharacter) {\n      return \"\" + indentStr + match;\n    }\n\n    shouldIndentNextCharacter = true;\n    return match;\n  };\n\n  this.intro = this.intro.replace(pattern, replacer);\n  var charIndex = 0;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    var end = chunk.end;\n\n    if (chunk.edited) {\n      if (!isExcluded[charIndex]) {\n        chunk.content = chunk.content.replace(pattern, replacer);\n\n        if (chunk.content.length) {\n          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n        }\n      }\n    } else {\n      charIndex = chunk.start;\n\n      while (charIndex < end) {\n        if (!isExcluded[charIndex]) {\n          var char = this.original[charIndex];\n\n          if (char === '\\n') {\n            shouldIndentNextCharacter = true;\n          } else if (char !== '\\r' && shouldIndentNextCharacter) {\n            shouldIndentNextCharacter = false;\n\n            if (charIndex === chunk.start) {\n              chunk.prependRight(indentStr);\n            } else {\n              this._splitChunk(chunk, charIndex);\n\n              chunk = chunk.next;\n              chunk.prependRight(indentStr);\n            }\n          }\n        }\n\n        charIndex += 1;\n      }\n    }\n\n    charIndex = chunk.end;\n    chunk = chunk.next;\n  }\n\n  this.outro = this.outro.replace(pattern, replacer);\n  return this;\n};\n\nMagicString.prototype.insert = function insert() {\n  throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\n\nMagicString.prototype.insertLeft = function insertLeft(index, content) {\n  if (!warned.insertLeft) {\n    console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n    warned.insertLeft = true;\n  }\n\n  return this.appendLeft(index, content);\n};\n\nMagicString.prototype.insertRight = function insertRight(index, content) {\n  if (!warned.insertRight) {\n    console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n    warned.insertRight = true;\n  }\n\n  return this.prependRight(index, content);\n};\n\nMagicString.prototype.move = function move(start, end, index) {\n  if (index >= start && index <= end) {\n    throw new Error('Cannot move a selection inside itself');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  this._split(index);\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n  var oldLeft = first.previous;\n  var oldRight = last.next;\n  var newRight = this.byStart[index];\n\n  if (!newRight && last === this.lastChunk) {\n    return this;\n  }\n\n  var newLeft = newRight ? newRight.previous : this.lastChunk;\n\n  if (oldLeft) {\n    oldLeft.next = oldRight;\n  }\n\n  if (oldRight) {\n    oldRight.previous = oldLeft;\n  }\n\n  if (newLeft) {\n    newLeft.next = first;\n  }\n\n  if (newRight) {\n    newRight.previous = last;\n  }\n\n  if (!first.previous) {\n    this.firstChunk = last.next;\n  }\n\n  if (!last.next) {\n    this.lastChunk = first.previous;\n    this.lastChunk.next = null;\n  }\n\n  first.previous = newLeft;\n  last.next = newRight || null;\n\n  if (!newLeft) {\n    this.firstChunk = first;\n  }\n\n  if (!newRight) {\n    this.lastChunk = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n  if (typeof content !== 'string') {\n    throw new TypeError('replacement content must be a string');\n  }\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (end > this.original.length) {\n    throw new Error('end is out of bounds');\n  }\n\n  if (start === end) {\n    throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  if (options === true) {\n    if (!warned.storeName) {\n      console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n      warned.storeName = true;\n    }\n\n    options = {\n      storeName: true\n    };\n  }\n\n  var storeName = options !== undefined ? options.storeName : false;\n  var contentOnly = options !== undefined ? options.contentOnly : false;\n\n  if (storeName) {\n    var original = this.original.slice(start, end);\n    this.storedNames[original] = true;\n  }\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n\n  if (first) {\n    if (end > first.end && first.next !== this.byStart[first.end]) {\n      throw new Error('Cannot overwrite across a split point');\n    }\n\n    first.edit(content, storeName, contentOnly);\n\n    if (first !== last) {\n      var chunk = first.next;\n\n      while (chunk !== last) {\n        chunk.edit('', false);\n        chunk = chunk.next;\n      }\n\n      chunk.edit('', false);\n    }\n  } else {\n    // must be inserting at the end\n    var newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n    last.next = newChunk;\n    newChunk.previous = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prepend = function prepend(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.intro = content + this.intro;\n  return this;\n};\n\nMagicString.prototype.prependLeft = function prependLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.prependLeft(content);\n  } else {\n    this.intro = content + this.intro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prependRight = function prependRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.prependRight(content);\n  } else {\n    this.outro = content + this.outro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.remove = function remove(start, end) {\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (start === end) {\n    return this;\n  }\n\n  if (start < 0 || end > this.original.length) {\n    throw new Error('Character is out of bounds');\n  }\n\n  if (start > end) {\n    throw new Error('end must be greater than start');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  var chunk = this.byStart[start];\n\n  while (chunk) {\n    chunk.intro = '';\n    chunk.outro = '';\n    chunk.edit('');\n    chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n  }\n\n  return this;\n};\n\nMagicString.prototype.lastChar = function lastChar() {\n  if (this.outro.length) {\n    return this.outro[this.outro.length - 1];\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length) {\n      return chunk.outro[chunk.outro.length - 1];\n    }\n\n    if (chunk.content.length) {\n      return chunk.content[chunk.content.length - 1];\n    }\n\n    if (chunk.intro.length) {\n      return chunk.intro[chunk.intro.length - 1];\n    }\n  } while (chunk = chunk.previous);\n\n  if (this.intro.length) {\n    return this.intro[this.intro.length - 1];\n  }\n\n  return '';\n};\n\nMagicString.prototype.lastLine = function lastLine() {\n  var lineIndex = this.outro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.outro.substr(lineIndex + 1);\n  }\n\n  var lineStr = this.outro;\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length > 0) {\n      lineIndex = chunk.outro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.outro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.outro + lineStr;\n    }\n\n    if (chunk.content.length > 0) {\n      lineIndex = chunk.content.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.content.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.content + lineStr;\n    }\n\n    if (chunk.intro.length > 0) {\n      lineIndex = chunk.intro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.intro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.intro + lineStr;\n    }\n  } while (chunk = chunk.previous);\n\n  lineIndex = this.intro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.intro.substr(lineIndex + 1) + lineStr;\n  }\n\n  return this.intro + lineStr;\n};\n\nMagicString.prototype.slice = function slice(start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = this.original.length;\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  var result = ''; // find start chunk\n\n  var chunk = this.firstChunk;\n\n  while (chunk && (chunk.start > start || chunk.end <= start)) {\n    // found end chunk before start\n    if (chunk.start < end && chunk.end >= end) {\n      return result;\n    }\n\n    chunk = chunk.next;\n  }\n\n  if (chunk && chunk.edited && chunk.start !== start) {\n    throw new Error(\"Cannot use replaced character \" + start + \" as slice start anchor.\");\n  }\n\n  var startChunk = chunk;\n\n  while (chunk) {\n    if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n      result += chunk.intro;\n    }\n\n    var containsEnd = chunk.start < end && chunk.end >= end;\n\n    if (containsEnd && chunk.edited && chunk.end !== end) {\n      throw new Error(\"Cannot use replaced character \" + end + \" as slice end anchor.\");\n    }\n\n    var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n    var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n    result += chunk.content.slice(sliceStart, sliceEnd);\n\n    if (chunk.outro && (!containsEnd || chunk.end === end)) {\n      result += chunk.outro;\n    }\n\n    if (containsEnd) {\n      break;\n    }\n\n    chunk = chunk.next;\n  }\n\n  return result;\n}; // TODO deprecate this? not really very useful\n\n\nMagicString.prototype.snip = function snip(start, end) {\n  var clone = this.clone();\n  clone.remove(0, start);\n  clone.remove(end, clone.original.length);\n  return clone;\n};\n\nMagicString.prototype._split = function _split(index) {\n  if (this.byStart[index] || this.byEnd[index]) {\n    return;\n  }\n\n  var chunk = this.lastSearchedChunk;\n  var searchForward = index > chunk.end;\n\n  while (chunk) {\n    if (chunk.contains(index)) {\n      return this._splitChunk(chunk, index);\n    }\n\n    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n  }\n};\n\nMagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n  if (chunk.edited && chunk.content.length) {\n    // zero-length edited chunks are a special case (overlapping replacements)\n    var loc = getLocator(this.original)(index);\n    throw new Error(\"Cannot split a chunk that has already been edited (\" + loc.line + \":\" + loc.column + \" – \\\"\" + chunk.original + \"\\\")\");\n  }\n\n  var newChunk = chunk.split(index);\n  this.byEnd[index] = chunk;\n  this.byStart[index] = newChunk;\n  this.byEnd[newChunk.end] = newChunk;\n\n  if (chunk === this.lastChunk) {\n    this.lastChunk = newChunk;\n  }\n\n  this.lastSearchedChunk = chunk;\n  return true;\n};\n\nMagicString.prototype.toString = function toString() {\n  var str = this.intro;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    str += chunk.toString();\n    chunk = chunk.next;\n  }\n\n  return str + this.outro;\n};\n\nMagicString.prototype.isEmpty = function isEmpty() {\n  var chunk = this.firstChunk;\n\n  do {\n    if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {\n      return false;\n    }\n  } while (chunk = chunk.next);\n\n  return true;\n};\n\nMagicString.prototype.length = function length() {\n  var chunk = this.firstChunk;\n  var length = 0;\n\n  do {\n    length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n  } while (chunk = chunk.next);\n\n  return length;\n};\n\nMagicString.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nMagicString.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nMagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n    if (chunk.end !== end) {\n      if (this.lastChunk === chunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.previous;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimEnd = function trimEnd(charType) {\n  this.trimEndAborted(charType);\n  return this;\n};\n\nMagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var chunk = this.firstChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimStart(rx);\n\n    if (chunk.end !== end) {\n      // special case...\n      if (chunk === this.lastChunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.next;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimStart = function trimStart(charType) {\n  this.trimStartAborted(charType);\n  return this;\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar Bundle = function Bundle(options) {\n  if (options === void 0) options = {};\n  this.intro = options.intro || '';\n  this.separator = options.separator !== undefined ? options.separator : '\\n';\n  this.sources = [];\n  this.uniqueSources = [];\n  this.uniqueSourceIndexByFilename = {};\n};\n\nBundle.prototype.addSource = function addSource(source) {\n  if (source instanceof MagicString) {\n    return this.addSource({\n      content: source,\n      filename: source.filename,\n      separator: this.separator\n    });\n  }\n\n  if (!isObject(source) || !source.content) {\n    throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n  }\n\n  ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n    if (!hasOwnProp.call(source, option)) {\n      source[option] = source.content[option];\n    }\n  });\n\n  if (source.separator === undefined) {\n    // TODO there's a bunch of this sort of thing, needs cleaning up\n    source.separator = this.separator;\n  }\n\n  if (source.filename) {\n    if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n      this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n      this.uniqueSources.push({\n        filename: source.filename,\n        content: source.content.original\n      });\n    } else {\n      var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n      if (source.content.original !== uniqueSource.content) {\n        throw new Error(\"Illegal source: same filename (\" + source.filename + \"), different contents\");\n      }\n    }\n  }\n\n  this.sources.push(source);\n  return this;\n};\n\nBundle.prototype.append = function append(str, options) {\n  this.addSource({\n    content: new MagicString(str),\n    separator: options && options.separator || ''\n  });\n  return this;\n};\n\nBundle.prototype.clone = function clone() {\n  var bundle = new Bundle({\n    intro: this.intro,\n    separator: this.separator\n  });\n  this.sources.forEach(function (source) {\n    bundle.addSource({\n      filename: source.filename,\n      content: source.content.clone(),\n      separator: source.separator\n    });\n  });\n  return bundle;\n};\n\nBundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n  var names = [];\n  this.sources.forEach(function (source) {\n    Object.keys(source.content.storedNames).forEach(function (name) {\n      if (!~names.indexOf(name)) {\n        names.push(name);\n      }\n    });\n  });\n  var mappings = new Mappings(options.hires);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.sources.forEach(function (source, i) {\n    if (i > 0) {\n      mappings.advance(this$1.separator);\n    }\n\n    var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;\n    var magicString = source.content;\n    var locate = getLocator(magicString.original);\n\n    if (magicString.intro) {\n      mappings.advance(magicString.intro);\n    }\n\n    magicString.firstChunk.eachNext(function (chunk) {\n      var loc = locate(chunk.start);\n\n      if (chunk.intro.length) {\n        mappings.advance(chunk.intro);\n      }\n\n      if (source.filename) {\n        if (chunk.edited) {\n          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n        } else {\n          mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n        }\n      } else {\n        mappings.advance(chunk.content);\n      }\n\n      if (chunk.outro.length) {\n        mappings.advance(chunk.outro);\n      }\n    });\n\n    if (magicString.outro) {\n      mappings.advance(magicString.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: this.uniqueSources.map(function (source) {\n      return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n    }),\n    sourcesContent: this.uniqueSources.map(function (source) {\n      return options.includeContent ? source.content : null;\n    }),\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nBundle.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nBundle.prototype.getIndentString = function getIndentString() {\n  var indentStringCounts = {};\n  this.sources.forEach(function (source) {\n    var indentStr = source.content.indentStr;\n\n    if (indentStr === null) {\n      return;\n    }\n\n    if (!indentStringCounts[indentStr]) {\n      indentStringCounts[indentStr] = 0;\n    }\n\n    indentStringCounts[indentStr] += 1;\n  });\n  return Object.keys(indentStringCounts).sort(function (a, b) {\n    return indentStringCounts[a] - indentStringCounts[b];\n  })[0] || '\\t';\n};\n\nBundle.prototype.indent = function indent(indentStr) {\n  var this$1 = this;\n\n  if (!arguments.length) {\n    indentStr = this.getIndentString();\n  }\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n  this.sources.forEach(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1.separator;\n    var indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n    source.content.indent(indentStr, {\n      exclude: source.indentExclusionRanges,\n      indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n    });\n    trailingNewline = source.content.lastChar() === '\\n';\n  });\n\n  if (this.intro) {\n    this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n      return index > 0 ? indentStr + match : match;\n    });\n  }\n\n  return this;\n};\n\nBundle.prototype.prepend = function prepend(str) {\n  this.intro = str + this.intro;\n  return this;\n};\n\nBundle.prototype.toString = function toString() {\n  var this$1 = this;\n  var body = this.sources.map(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1.separator;\n    var str = (i > 0 ? separator : '') + source.content.toString();\n    return str;\n  }).join('');\n  return this.intro + body;\n};\n\nBundle.prototype.isEmpty = function isEmpty() {\n  if (this.intro.length && this.intro.trim()) {\n    return false;\n  }\n\n  if (this.sources.some(function (source) {\n    return !source.content.isEmpty();\n  })) {\n    return false;\n  }\n\n  return true;\n};\n\nBundle.prototype.length = function length() {\n  return this.sources.reduce(function (length, source) {\n    return length + source.content.length();\n  }, this.intro.length);\n};\n\nBundle.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nBundle.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nBundle.prototype.trimStart = function trimStart(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (!this.intro) {\n    var source;\n    var i = 0;\n\n    do {\n      source = this.sources[i++];\n\n      if (!source) {\n        break;\n      }\n    } while (!source.content.trimStartAborted(charType));\n  }\n\n  return this;\n};\n\nBundle.prototype.trimEnd = function trimEnd(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  var source;\n  var i = this.sources.length - 1;\n\n  do {\n    source = this.sources[i--];\n\n    if (!source) {\n      this.intro = this.intro.replace(rx, '');\n      break;\n    }\n  } while (!source.content.trimEndAborted(charType));\n\n  return this;\n};\n\nvar minimalisticAssert = assert;\n\nfunction assert(val, msg) {\n  if (!val) throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar inherits_browser = createCommonjsModule(function (module) {\n  if (typeof Object.create === 'function') {\n    // implementation from standard node.js 'util' module\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    };\n  } else {\n    // old school shim for old browsers\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n\n      var TempCtor = function () {};\n\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    };\n  }\n});\nvar inherits = createCommonjsModule(function (module) {\n  try {\n    var util$1 = util;\n    if (typeof util$1.inherits !== 'function') throw '';\n    module.exports = util$1.inherits;\n  } catch (e) {\n    module.exports = inherits_browser;\n  }\n});\nvar inherits_1 = inherits;\n\nfunction isSurrogatePair(msg, i) {\n  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n    return false;\n  }\n\n  if (i < 0 || i + 1 >= msg.length) {\n    return false;\n  }\n\n  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n}\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg)) return msg.slice();\n  if (!msg) return [];\n  var res = [];\n\n  if (typeof msg === 'string') {\n    if (!enc) {\n      // Inspired by stringToUtf8ByteArray() in closure-library by Google\n      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n      // Apache License 2.0\n      // https://github.com/google/closure-library/blob/master/LICENSE\n      var p = 0;\n\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n\n        if (c < 128) {\n          res[p++] = c;\n        } else if (c < 2048) {\n          res[p++] = c >> 6 | 192;\n          res[p++] = c & 63 | 128;\n        } else if (isSurrogatePair(msg, i)) {\n          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n          res[p++] = c >> 18 | 240;\n          res[p++] = c >> 12 & 63 | 128;\n          res[p++] = c >> 6 & 63 | 128;\n          res[p++] = c & 63 | 128;\n        } else {\n          res[p++] = c >> 12 | 224;\n          res[p++] = c >> 6 & 63 | 128;\n          res[p++] = c & 63 | 128;\n        }\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0) msg = '0' + msg;\n\n      for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n  } else {\n    for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;\n  }\n\n  return res;\n}\n\nvar toArray_1 = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n\n  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));\n\n  return res;\n}\n\nvar toHex_1 = toHex;\n\nfunction htonl(w) {\n  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;\n  return res >>> 0;\n}\n\nvar htonl_1 = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little') w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n\n  return res;\n}\n\nvar toHex32_1 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1) return '0' + word;else return word;\n}\n\nvar zero2_1 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;\n}\n\nvar zero8_1 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  minimalisticAssert(len % 4 === 0);\n  var res = new Array(len / 4);\n\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];\n    res[i] = w >>> 0;\n  }\n\n  return res;\n}\n\nvar join32_1 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = m >>> 16 & 0xff;\n      res[k + 2] = m >>> 8 & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = m >>> 16 & 0xff;\n      res[k + 1] = m >>> 8 & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n\n  return res;\n}\n\nvar split32_1 = split32;\n\nfunction rotr32(w, b) {\n  return w >>> b | w << 32 - b;\n}\n\nvar rotr32_1 = rotr32;\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nvar rotl32_1 = rotl32;\n\nfunction sum32(a, b) {\n  return a + b >>> 0;\n}\n\nvar sum32_1 = sum32;\n\nfunction sum32_3(a, b, c) {\n  return a + b + c >>> 0;\n}\n\nvar sum32_3_1 = sum32_3;\n\nfunction sum32_4(a, b, c, d) {\n  return a + b + c + d >>> 0;\n}\n\nvar sum32_4_1 = sum32_4;\n\nfunction sum32_5(a, b, c, d, e) {\n  return a + b + c + d + e >>> 0;\n}\n\nvar sum32_5_1 = sum32_5;\n\nfunction sum64(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n  var lo = al + bl >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\n\nvar sum64_1 = sum64;\n\nfunction sum64_hi(ah, al, bh, bl) {\n  var lo = al + bl >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n}\n\nvar sum64_hi_1 = sum64_hi;\n\nfunction sum64_lo(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n}\n\nvar sum64_lo_1 = sum64_lo;\n\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = lo + bl >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = lo + cl >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = lo + dl >>> 0;\n  carry += lo < dl ? 1 : 0;\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n}\n\nvar sum64_4_hi_1 = sum64_4_hi;\n\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n}\n\nvar sum64_4_lo_1 = sum64_4_lo;\n\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = lo + bl >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = lo + cl >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = lo + dl >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = lo + el >>> 0;\n  carry += lo < el ? 1 : 0;\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n}\n\nvar sum64_5_hi_1 = sum64_5_hi;\n\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n  return lo >>> 0;\n}\n\nvar sum64_5_lo_1 = sum64_5_lo;\n\nfunction rotr64_hi(ah, al, num) {\n  var r = al << 32 - num | ah >>> num;\n  return r >>> 0;\n}\n\nvar rotr64_hi_1 = rotr64_hi;\n\nfunction rotr64_lo(ah, al, num) {\n  var r = ah << 32 - num | al >>> num;\n  return r >>> 0;\n}\n\nvar rotr64_lo_1 = rotr64_lo;\n\nfunction shr64_hi(ah, al, num) {\n  return ah >>> num;\n}\n\nvar shr64_hi_1 = shr64_hi;\n\nfunction shr64_lo(ah, al, num) {\n  var r = ah << 32 - num | al >>> num;\n  return r >>> 0;\n}\n\nvar shr64_lo_1 = shr64_lo;\nvar utils = {\n  inherits: inherits_1,\n  toArray: toArray_1,\n  toHex: toHex_1,\n  htonl: htonl_1,\n  toHex32: toHex32_1,\n  zero2: zero2_1,\n  zero8: zero8_1,\n  join32: join32_1,\n  split32: split32_1,\n  rotr32: rotr32_1,\n  rotl32: rotl32_1,\n  sum32: sum32_1,\n  sum32_3: sum32_3_1,\n  sum32_4: sum32_4_1,\n  sum32_5: sum32_5_1,\n  sum64: sum64_1,\n  sum64_hi: sum64_hi_1,\n  sum64_lo: sum64_lo_1,\n  sum64_4_hi: sum64_4_hi_1,\n  sum64_4_lo: sum64_4_lo_1,\n  sum64_5_hi: sum64_5_hi_1,\n  sum64_5_lo: sum64_5_lo_1,\n  rotr64_hi: rotr64_hi_1,\n  rotr64_lo: rotr64_lo_1,\n  shr64_hi: shr64_hi_1,\n  shr64_lo: shr64_lo_1\n};\n\nfunction BlockHash() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\n\nvar BlockHash_1 = BlockHash;\n\nBlockHash.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils.toArray(msg, enc);\n  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length; // Enough data, try updating\n\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending; // Process pending data in blocks\n\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0) this.pending = null;\n    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n\n    for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);\n  }\n\n  return this;\n};\n\nBlockHash.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  minimalisticAssert(this.pending === null);\n  return this._digest(enc);\n};\n\nBlockHash.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - (len + this.padLength) % bytes;\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n\n  for (var i = 1; i < k; i++) res[i] = 0; // Append length\n\n\n  len <<= 3;\n\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++) res[i++] = 0;\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = len >>> 24 & 0xff;\n    res[i++] = len >>> 16 & 0xff;\n    res[i++] = len >>> 8 & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = len >>> 8 & 0xff;\n    res[i++] = len >>> 16 & 0xff;\n    res[i++] = len >>> 24 & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (t = 8; t < this.padLength; t++) res[i++] = 0;\n  }\n\n  return res;\n};\n\nvar common = {\n  BlockHash: BlockHash_1\n};\nvar rotr32$1 = utils.rotr32;\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0) return ch32(x, y, z);\n  if (s === 1 || s === 3) return p32(x, y, z);\n  if (s === 2) return maj32(x, y, z);\n}\n\nvar ft_1_1 = ft_1;\n\nfunction ch32(x, y, z) {\n  return x & y ^ ~x & z;\n}\n\nvar ch32_1 = ch32;\n\nfunction maj32(x, y, z) {\n  return x & y ^ x & z ^ y & z;\n}\n\nvar maj32_1 = maj32;\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\n\nvar p32_1 = p32;\n\nfunction s0_256(x) {\n  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n}\n\nvar s0_256_1 = s0_256;\n\nfunction s1_256(x) {\n  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n}\n\nvar s1_256_1 = s1_256;\n\nfunction g0_256(x) {\n  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ x >>> 3;\n}\n\nvar g0_256_1 = g0_256;\n\nfunction g1_256(x) {\n  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ x >>> 10;\n}\n\nvar g1_256_1 = g1_256;\nvar common$1 = {\n  ft_1: ft_1_1,\n  ch32: ch32_1,\n  maj32: maj32_1,\n  p32: p32_1,\n  s0_256: s0_256_1,\n  s1_256: s1_256_1,\n  g0_256: g0_256_1,\n  g1_256: g1_256_1\n};\nvar sum32$1 = utils.sum32;\nvar sum32_4$1 = utils.sum32_4;\nvar sum32_5$1 = utils.sum32_5;\nvar ch32$1 = common$1.ch32;\nvar maj32$1 = common$1.maj32;\nvar s0_256$1 = common$1.s0_256;\nvar s1_256$1 = common$1.s1_256;\nvar g0_256$1 = common$1.g0_256;\nvar g1_256$1 = common$1.g1_256;\nvar BlockHash$1 = common.BlockHash;\nvar sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n\nfunction SHA256() {\n  if (!(this instanceof SHA256)) return new SHA256();\n  BlockHash$1.call(this);\n  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\n\nutils.inherits(SHA256, BlockHash$1);\nvar _256 = SHA256;\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\n\nSHA256.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++) W[i] = msg[start + i];\n\n  for (; i < W.length; i++) W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n  minimalisticAssert(this.k.length === W.length);\n\n  for (i = 0; i < W.length; i++) {\n    var T1 = sum32_5$1(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n    var T2 = sum32$1(s0_256$1(a), maj32$1(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32$1(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32$1(T1, T2);\n  }\n\n  this.h[0] = sum32$1(this.h[0], a);\n  this.h[1] = sum32$1(this.h[1], b);\n  this.h[2] = sum32$1(this.h[2], c);\n  this.h[3] = sum32$1(this.h[3], d);\n  this.h[4] = sum32$1(this.h[4], e);\n  this.h[5] = sum32$1(this.h[5], f);\n  this.h[6] = sum32$1(this.h[6], g);\n  this.h[7] = sum32$1(this.h[7], h);\n};\n\nSHA256.prototype._digest = function digest(enc) {\n  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');\n};\n\nconst createHash = () => _256();\n\nfunction relative(from, to) {\n  const fromParts = from.split(/[/\\\\]/).filter(Boolean);\n  const toParts = to.split(/[/\\\\]/).filter(Boolean);\n  if (fromParts[0] === '.') fromParts.shift();\n  if (toParts[0] === '.') toParts.shift();\n\n  while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  while (toParts[0] === '..' && fromParts.length > 0) {\n    toParts.shift();\n    fromParts.pop();\n  }\n\n  while (fromParts.pop()) {\n    toParts.unshift('..');\n  }\n\n  return toParts.join('/');\n}\n\nconst UnknownKey = Symbol('Unknown Key');\nconst EMPTY_PATH = [];\nconst UNKNOWN_PATH = [UnknownKey];\nconst EntitiesKey = Symbol('Entities');\n\nclass PathTracker {\n  constructor() {\n    this.entityPaths = Object.create(null, {\n      [EntitiesKey]: {\n        value: new Set()\n      }\n    });\n  }\n\n  getEntities(path) {\n    let currentPaths = this.entityPaths;\n\n    for (const pathSegment of path) {\n      currentPaths = currentPaths[pathSegment] = currentPaths[pathSegment] || Object.create(null, {\n        [EntitiesKey]: {\n          value: new Set()\n        }\n      });\n    }\n\n    return currentPaths[EntitiesKey];\n  }\n\n}\n\nconst SHARED_RECURSION_TRACKER = new PathTracker();\nconst BROKEN_FLOW_NONE = 0;\nconst BROKEN_FLOW_BREAK_CONTINUE = 1;\nconst BROKEN_FLOW_ERROR_RETURN_LABEL = 2;\n\nfunction createInclusionContext() {\n  return {\n    brokenFlow: BROKEN_FLOW_NONE,\n    includedLabels: new Set()\n  };\n}\n\nfunction createHasEffectsContext() {\n  return {\n    accessed: new PathTracker(),\n    assigned: new PathTracker(),\n    brokenFlow: BROKEN_FLOW_NONE,\n    called: new PathTracker(),\n    ignore: {\n      breaks: false,\n      continues: false,\n      labels: new Set(),\n      returnAwaitYield: false\n    },\n    includedLabels: new Set(),\n    instantiated: new PathTracker(),\n    replacedVariableInits: new Map()\n  };\n}\n\nconst BlockStatement = 'BlockStatement';\nconst CallExpression = 'CallExpression';\nconst ExportNamespaceSpecifier = 'ExportNamespaceSpecifier';\nconst ExpressionStatement = 'ExpressionStatement';\nconst FunctionExpression = 'FunctionExpression';\nconst Identifier = 'Identifier';\nconst ImportDefaultSpecifier = 'ImportDefaultSpecifier';\nconst ImportNamespaceSpecifier = 'ImportNamespaceSpecifier';\nconst Program = 'Program';\nconst Property = 'Property';\nconst ReturnStatement = 'ReturnStatement';\n\nfunction treeshakeNode(node, code, start, end) {\n  code.remove(start, end);\n\n  if (node.annotations) {\n    for (const annotation of node.annotations) {\n      if (annotation.start < start) {\n        code.remove(annotation.start, annotation.end);\n      } else {\n        return;\n      }\n    }\n  }\n}\n\nfunction removeAnnotations(node, code) {\n  if (!node.annotations && node.parent.type === ExpressionStatement) {\n    node = node.parent;\n  }\n\n  if (node.annotations) {\n    for (const annotation of node.annotations) {\n      code.remove(annotation.start, annotation.end);\n    }\n  }\n}\n\nconst NO_SEMICOLON = {\n  isNoStatement: true\n}; // This assumes there are only white-space and comments between start and the string we are looking for\n\nfunction findFirstOccurrenceOutsideComment(code, searchString, start = 0) {\n  let searchPos, charCodeAfterSlash;\n  searchPos = code.indexOf(searchString, start);\n\n  while (true) {\n    start = code.indexOf('/', start);\n    if (start === -1 || start >= searchPos) return searchPos;\n    charCodeAfterSlash = code.charCodeAt(++start);\n    ++start; // With our assumption, '/' always starts a comment. Determine comment type:\n\n    start = charCodeAfterSlash === 47\n    /*\"/\"*/\n    ? code.indexOf('\\n', start) + 1 : code.indexOf('*/', start) + 2;\n\n    if (start > searchPos) {\n      searchPos = code.indexOf(searchString, start);\n    }\n  }\n} // This assumes \"code\" only contains white-space and comments\n\n\nfunction findFirstLineBreakOutsideComment(code) {\n  let lineBreakPos,\n      charCodeAfterSlash,\n      start = 0;\n  lineBreakPos = code.indexOf('\\n', start);\n\n  while (true) {\n    start = code.indexOf('/', start);\n    if (start === -1 || start > lineBreakPos) return lineBreakPos; // With our assumption, '/' always starts a comment. Determine comment type:\n\n    charCodeAfterSlash = code.charCodeAt(++start);\n    if (charCodeAfterSlash === 47\n    /*\"/\"*/\n    ) return lineBreakPos;\n    start = code.indexOf('*/', start + 2) + 2;\n\n    if (start > lineBreakPos) {\n      lineBreakPos = code.indexOf('\\n', start);\n    }\n  }\n}\n\nfunction renderStatementList(statements, code, start, end, options) {\n  let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;\n  let nextNode = statements[0];\n  let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;\n\n  if (nextNodeNeedsBoundaries) {\n    nextNodeStart = start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start)) + 1;\n  }\n\n  for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {\n    currentNode = nextNode;\n    currentNodeStart = nextNodeStart;\n    currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;\n    nextNode = statements[nextIndex];\n    nextNodeNeedsBoundaries = nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;\n\n    if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {\n      nextNodeStart = currentNode.end + findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start)) + 1;\n\n      if (currentNode.included) {\n        currentNodeNeedsBoundaries ? currentNode.render(code, options, {\n          end: nextNodeStart,\n          start: currentNodeStart\n        }) : currentNode.render(code, options);\n      } else {\n        treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);\n      }\n    } else {\n      currentNode.render(code, options);\n    }\n  }\n} // This assumes that the first character is not part of the first node\n\n\nfunction getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {\n  const splitUpNodes = [];\n  let node, nextNode, nextNodeStart, contentEnd, char;\n  let separator = start - 1;\n\n  for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {\n    nextNode = nodes[nextIndex];\n\n    if (node !== undefined) {\n      separator = node.end + findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');\n    }\n\n    nextNodeStart = contentEnd = separator + 2 + findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start));\n\n    while (char = code.original.charCodeAt(nextNodeStart), char === 32\n    /*\" \"*/\n    || char === 9\n    /*\"\\t\"*/\n    || char === 10\n    /*\"\\n\"*/\n    || char === 13\n    /*\"\\r\"*/\n    ) nextNodeStart++;\n\n    if (node !== undefined) {\n      splitUpNodes.push({\n        contentEnd,\n        end: nextNodeStart,\n        node,\n        separator,\n        start\n      });\n    }\n\n    node = nextNode;\n    start = nextNodeStart;\n  }\n\n  splitUpNodes.push({\n    contentEnd: end,\n    end,\n    node: node,\n    separator: null,\n    start\n  });\n  return splitUpNodes;\n} // This assumes there are only white-space and comments between start and end\n\n\nfunction removeLineBreaks(code, start, end) {\n  while (true) {\n    const lineBreakPos = findFirstLineBreakOutsideComment(code.original.slice(start, end));\n\n    if (lineBreakPos === -1) {\n      break;\n    }\n\n    start = start + lineBreakPos + 1;\n    code.remove(start - 1, start);\n  }\n}\n\nconst chars$1 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';\nconst base = 64;\n\nfunction toBase64(num) {\n  let outStr = '';\n\n  do {\n    const curDigit = num % base;\n    num = Math.floor(num / base);\n    outStr = chars$1[curDigit] + outStr;\n  } while (num !== 0);\n\n  return outStr;\n} // Verified on IE 6/7 that these keywords can't be used for object properties without escaping:\n//   break case catch class const continue debugger default delete do\n//   else enum export extends false finally for function if import\n//   in instanceof new null return super switch this throw true\n//   try typeof var void while with\n\n\nconst RESERVED_NAMES = Object.assign(Object.create(null), {\n  await: true,\n  break: true,\n  case: true,\n  catch: true,\n  class: true,\n  const: true,\n  continue: true,\n  debugger: true,\n  default: true,\n  delete: true,\n  do: true,\n  else: true,\n  enum: true,\n  eval: true,\n  export: true,\n  extends: true,\n  false: true,\n  finally: true,\n  for: true,\n  function: true,\n  if: true,\n  implements: true,\n  import: true,\n  in: true,\n  instanceof: true,\n  interface: true,\n  let: true,\n  new: true,\n  null: true,\n  package: true,\n  private: true,\n  protected: true,\n  public: true,\n  return: true,\n  static: true,\n  super: true,\n  switch: true,\n  this: true,\n  throw: true,\n  true: true,\n  try: true,\n  typeof: true,\n  undefined: true,\n  var: true,\n  void: true,\n  while: true,\n  with: true,\n  yield: true\n});\n\nfunction getSafeName(baseName, usedNames) {\n  let safeName = baseName;\n  let count = 1;\n\n  while (usedNames.has(safeName) || RESERVED_NAMES[safeName]) {\n    safeName = `${baseName}$${toBase64(count++)}`;\n  }\n\n  usedNames.add(safeName);\n  return safeName;\n}\n\nconst NO_ARGS = [];\n\nfunction assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {\n  return Object.create(inheritedDescriptions, memberDescriptions);\n}\n\nconst UnknownValue = Symbol('Unknown Value');\nconst UNKNOWN_EXPRESSION = {\n  deoptimizePath: () => {},\n  getLiteralValueAtPath: () => UnknownValue,\n  getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,\n  hasEffectsWhenAccessedAtPath: path => path.length > 0,\n  hasEffectsWhenAssignedAtPath: path => path.length > 0,\n  hasEffectsWhenCalledAtPath: () => true,\n  include: () => {},\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  },\n\n  included: true,\n  toString: () => '[[UNKNOWN]]'\n};\nconst UNDEFINED_EXPRESSION = {\n  deoptimizePath: () => {},\n  getLiteralValueAtPath: () => undefined,\n  getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,\n  hasEffectsWhenAccessedAtPath: path => path.length > 0,\n  hasEffectsWhenAssignedAtPath: path => path.length > 0,\n  hasEffectsWhenCalledAtPath: () => true,\n  include: () => {},\n\n  includeCallArguments() {},\n\n  included: true,\n  toString: () => 'undefined'\n};\nconst returnsUnknown = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: false,\n    returns: null,\n    returnsPrimitive: UNKNOWN_EXPRESSION\n  }\n};\nconst mutatesSelfReturnsUnknown = {\n  value: {\n    returns: null,\n    returnsPrimitive: UNKNOWN_EXPRESSION,\n    callsArgs: null,\n    mutatesSelf: true\n  }\n};\nconst callsArgReturnsUnknown = {\n  value: {\n    returns: null,\n    returnsPrimitive: UNKNOWN_EXPRESSION,\n    callsArgs: [0],\n    mutatesSelf: false\n  }\n};\n\nclass UnknownArrayExpression {\n  constructor() {\n    this.included = false;\n  }\n\n  deoptimizePath() {}\n\n  getLiteralValueAtPath() {\n    return UnknownValue;\n  }\n\n  getReturnExpressionWhenCalledAtPath(path) {\n    if (path.length === 1) {\n      return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);\n    }\n\n    return UNKNOWN_EXPRESSION;\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenAssignedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length === 1) {\n      return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, context);\n    }\n\n    return true;\n  }\n\n  include() {\n    this.included = true;\n  }\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  }\n\n  toString() {\n    return '[[UNKNOWN ARRAY]]';\n  }\n\n}\n\nconst returnsArray = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: false,\n    returns: UnknownArrayExpression,\n    returnsPrimitive: null\n  }\n};\nconst mutatesSelfReturnsArray = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: true,\n    returns: UnknownArrayExpression,\n    returnsPrimitive: null\n  }\n};\nconst callsArgReturnsArray = {\n  value: {\n    callsArgs: [0],\n    mutatesSelf: false,\n    returns: UnknownArrayExpression,\n    returnsPrimitive: null\n  }\n};\nconst callsArgMutatesSelfReturnsArray = {\n  value: {\n    callsArgs: [0],\n    mutatesSelf: true,\n    returns: UnknownArrayExpression,\n    returnsPrimitive: null\n  }\n};\nconst UNKNOWN_LITERAL_BOOLEAN = {\n  deoptimizePath: () => {},\n  getLiteralValueAtPath: () => UnknownValue,\n  getReturnExpressionWhenCalledAtPath: path => {\n    if (path.length === 1) {\n      return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);\n    }\n\n    return UNKNOWN_EXPRESSION;\n  },\n  hasEffectsWhenAccessedAtPath: path => path.length > 1,\n  hasEffectsWhenAssignedAtPath: path => path.length > 0,\n  hasEffectsWhenCalledAtPath: path => {\n    if (path.length === 1) {\n      const subPath = path[0];\n      return typeof subPath !== 'string' || !literalBooleanMembers[subPath];\n    }\n\n    return true;\n  },\n  include: () => {},\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  },\n\n  included: true,\n  toString: () => '[[UNKNOWN BOOLEAN]]'\n};\nconst returnsBoolean = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: false,\n    returns: null,\n    returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN\n  }\n};\nconst callsArgReturnsBoolean = {\n  value: {\n    callsArgs: [0],\n    mutatesSelf: false,\n    returns: null,\n    returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN\n  }\n};\nconst UNKNOWN_LITERAL_NUMBER = {\n  deoptimizePath: () => {},\n  getLiteralValueAtPath: () => UnknownValue,\n  getReturnExpressionWhenCalledAtPath: path => {\n    if (path.length === 1) {\n      return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);\n    }\n\n    return UNKNOWN_EXPRESSION;\n  },\n  hasEffectsWhenAccessedAtPath: path => path.length > 1,\n  hasEffectsWhenAssignedAtPath: path => path.length > 0,\n  hasEffectsWhenCalledAtPath: path => {\n    if (path.length === 1) {\n      const subPath = path[0];\n      return typeof subPath !== 'string' || !literalNumberMembers[subPath];\n    }\n\n    return true;\n  },\n  include: () => {},\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  },\n\n  included: true,\n  toString: () => '[[UNKNOWN NUMBER]]'\n};\nconst returnsNumber = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: false,\n    returns: null,\n    returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n  }\n};\nconst mutatesSelfReturnsNumber = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: true,\n    returns: null,\n    returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n  }\n};\nconst callsArgReturnsNumber = {\n  value: {\n    callsArgs: [0],\n    mutatesSelf: false,\n    returns: null,\n    returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n  }\n};\nconst UNKNOWN_LITERAL_STRING = {\n  deoptimizePath: () => {},\n  getLiteralValueAtPath: () => UnknownValue,\n  getReturnExpressionWhenCalledAtPath: path => {\n    if (path.length === 1) {\n      return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);\n    }\n\n    return UNKNOWN_EXPRESSION;\n  },\n  hasEffectsWhenAccessedAtPath: path => path.length > 1,\n  hasEffectsWhenAssignedAtPath: path => path.length > 0,\n  hasEffectsWhenCalledAtPath: (path, callOptions, context) => {\n    if (path.length === 1) {\n      return hasMemberEffectWhenCalled(literalStringMembers, path[0], true, callOptions, context);\n    }\n\n    return true;\n  },\n  include: () => {},\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  },\n\n  included: true,\n  toString: () => '[[UNKNOWN STRING]]'\n};\nconst returnsString = {\n  value: {\n    callsArgs: null,\n    mutatesSelf: false,\n    returns: null,\n    returnsPrimitive: UNKNOWN_LITERAL_STRING\n  }\n};\n\nclass UnknownObjectExpression {\n  constructor() {\n    this.included = false;\n  }\n\n  deoptimizePath() {}\n\n  getLiteralValueAtPath() {\n    return UnknownValue;\n  }\n\n  getReturnExpressionWhenCalledAtPath(path) {\n    if (path.length === 1) {\n      return getMemberReturnExpressionWhenCalled(objectMembers, path[0]);\n    }\n\n    return UNKNOWN_EXPRESSION;\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenAssignedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length === 1) {\n      return hasMemberEffectWhenCalled(objectMembers, path[0], this.included, callOptions, context);\n    }\n\n    return true;\n  }\n\n  include() {\n    this.included = true;\n  }\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  }\n\n  toString() {\n    return '[[UNKNOWN OBJECT]]';\n  }\n\n}\n\nconst objectMembers = assembleMemberDescriptions({\n  hasOwnProperty: returnsBoolean,\n  isPrototypeOf: returnsBoolean,\n  propertyIsEnumerable: returnsBoolean,\n  toLocaleString: returnsString,\n  toString: returnsString,\n  valueOf: returnsUnknown\n});\nconst arrayMembers = assembleMemberDescriptions({\n  concat: returnsArray,\n  copyWithin: mutatesSelfReturnsArray,\n  every: callsArgReturnsBoolean,\n  fill: mutatesSelfReturnsArray,\n  filter: callsArgReturnsArray,\n  find: callsArgReturnsUnknown,\n  findIndex: callsArgReturnsNumber,\n  forEach: callsArgReturnsUnknown,\n  includes: returnsBoolean,\n  indexOf: returnsNumber,\n  join: returnsString,\n  lastIndexOf: returnsNumber,\n  map: callsArgReturnsArray,\n  pop: mutatesSelfReturnsUnknown,\n  push: mutatesSelfReturnsNumber,\n  reduce: callsArgReturnsUnknown,\n  reduceRight: callsArgReturnsUnknown,\n  reverse: mutatesSelfReturnsArray,\n  shift: mutatesSelfReturnsUnknown,\n  slice: returnsArray,\n  some: callsArgReturnsBoolean,\n  sort: callsArgMutatesSelfReturnsArray,\n  splice: mutatesSelfReturnsArray,\n  unshift: mutatesSelfReturnsNumber\n}, objectMembers);\nconst literalBooleanMembers = assembleMemberDescriptions({\n  valueOf: returnsBoolean\n}, objectMembers);\nconst literalNumberMembers = assembleMemberDescriptions({\n  toExponential: returnsString,\n  toFixed: returnsString,\n  toLocaleString: returnsString,\n  toPrecision: returnsString,\n  valueOf: returnsNumber\n}, objectMembers);\nconst literalStringMembers = assembleMemberDescriptions({\n  charAt: returnsString,\n  charCodeAt: returnsNumber,\n  codePointAt: returnsNumber,\n  concat: returnsString,\n  endsWith: returnsBoolean,\n  includes: returnsBoolean,\n  indexOf: returnsNumber,\n  lastIndexOf: returnsNumber,\n  localeCompare: returnsNumber,\n  match: returnsBoolean,\n  normalize: returnsString,\n  padEnd: returnsString,\n  padStart: returnsString,\n  repeat: returnsString,\n  replace: {\n    value: {\n      callsArgs: [1],\n      mutatesSelf: false,\n      returns: null,\n      returnsPrimitive: UNKNOWN_LITERAL_STRING\n    }\n  },\n  search: returnsNumber,\n  slice: returnsString,\n  split: returnsArray,\n  startsWith: returnsBoolean,\n  substr: returnsString,\n  substring: returnsString,\n  toLocaleLowerCase: returnsString,\n  toLocaleUpperCase: returnsString,\n  toLowerCase: returnsString,\n  toUpperCase: returnsString,\n  trim: returnsString,\n  valueOf: returnsString\n}, objectMembers);\n\nfunction getLiteralMembersForValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return literalBooleanMembers;\n\n    case 'number':\n      return literalNumberMembers;\n\n    case 'string':\n      return literalStringMembers;\n\n    default:\n      return Object.create(null);\n  }\n}\n\nfunction hasMemberEffectWhenCalled(members, memberName, parentIncluded, callOptions, context) {\n  if (typeof memberName !== 'string' || !members[memberName] || members[memberName].mutatesSelf && parentIncluded) return true;\n  if (!members[memberName].callsArgs) return false;\n\n  for (const argIndex of members[memberName].callsArgs) {\n    if (callOptions.args[argIndex] && callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, {\n      args: NO_ARGS,\n      withNew: false\n    }, context)) return true;\n  }\n\n  return false;\n}\n\nfunction getMemberReturnExpressionWhenCalled(members, memberName) {\n  if (typeof memberName !== 'string' || !members[memberName]) return UNKNOWN_EXPRESSION;\n  return members[memberName].returnsPrimitive !== null ? members[memberName].returnsPrimitive : new members[memberName].returns();\n}\n\nclass Variable {\n  constructor(name) {\n    this.alwaysRendered = false;\n    this.exportName = null;\n    this.included = false;\n    this.isId = false;\n    this.isReassigned = false;\n    this.renderBaseName = null;\n    this.renderName = null;\n    this.safeExportName = null;\n    this.name = name;\n  }\n  /**\n   * Binds identifiers that reference this variable to this variable.\n   * Necessary to be able to change variable names.\n   */\n\n\n  addReference(_identifier) {}\n\n  deoptimizePath(_path) {}\n\n  getBaseVariableName() {\n    return this.renderBaseName || this.renderName || this.name;\n  }\n\n  getLiteralValueAtPath(_path, _recursionTracker, _origin) {\n    return UnknownValue;\n  }\n\n  getName() {\n    const name = this.renderName || this.name;\n    return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;\n  }\n\n  getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {\n    return UNKNOWN_EXPRESSION;\n  }\n\n  hasEffectsWhenAccessedAtPath(path, _context) {\n    return path.length > 0;\n  }\n\n  hasEffectsWhenAssignedAtPath(_path, _context) {\n    return true;\n  }\n\n  hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {\n    return true;\n  }\n  /**\n   * Marks this variable as being part of the bundle, which is usually the case when one of\n   * its identifiers becomes part of the bundle. Returns true if it has not been included\n   * previously.\n   * Once a variable is included, it should take care all its declarations are included.\n   */\n\n\n  include(_context) {\n    this.included = true;\n  }\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  }\n\n  markCalledFromTryStatement() {}\n\n  setRenderNames(baseName, name) {\n    this.renderBaseName = baseName;\n    this.renderName = name;\n  }\n\n  setSafeName(name) {\n    this.renderName = name;\n  }\n\n  toString() {\n    return this.name;\n  }\n\n}\n\nconst getPropertyAccess = name => {\n  return /^(?!\\d)[\\w$]+$/.test(name) ? `.${name}` : `[${JSON.stringify(name)}]`;\n};\n\nclass ExternalVariable extends Variable {\n  constructor(module, name) {\n    super(name);\n    this.module = module;\n    this.isNamespace = name === '*';\n    this.referenced = false;\n  }\n\n  addReference(identifier) {\n    this.referenced = true;\n\n    if (this.name === 'default' || this.name === '*') {\n      this.module.suggestName(identifier.name);\n    }\n  }\n\n  include() {\n    if (!this.included) {\n      this.included = true;\n      this.module.used = true;\n    }\n  }\n\n}\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');\nconst builtins = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');\nconst blacklisted = new Set(reservedWords.concat(builtins));\nconst illegalCharacters = /[^$_a-zA-Z0-9]/g;\n\nconst startsWithDigit = str => /\\d/.test(str[0]);\n\nfunction isLegal(str) {\n  if (startsWithDigit(str) || blacklisted.has(str)) {\n    return false;\n  }\n\n  return !illegalCharacters.test(str);\n}\n\nfunction makeLegal(str) {\n  str = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');\n  if (startsWithDigit(str) || blacklisted.has(str)) str = `_${str}`;\n  return str || '_';\n}\n\nconst absolutePath = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst relativePath = /^\\.?\\.\\//;\n\nfunction isAbsolute(path) {\n  return absolutePath.test(path);\n}\n\nfunction isRelative(path) {\n  return relativePath.test(path);\n}\n\nfunction normalize(path) {\n  if (path.indexOf('\\\\') == -1) return path;\n  return path.replace(/\\\\/g, '/');\n}\n\nclass ExternalModule {\n  constructor(graph, id, moduleSideEffects) {\n    this.exportsNames = false;\n    this.exportsNamespace = false;\n    this.mostCommonSuggestion = 0;\n    this.reexported = false;\n    this.renderPath = undefined;\n    this.renormalizeRenderPath = false;\n    this.used = false;\n    this.graph = graph;\n    this.id = id;\n    this.execIndex = Infinity;\n    this.moduleSideEffects = moduleSideEffects;\n    const parts = id.split(/[\\\\/]/);\n    this.variableName = makeLegal(parts.pop());\n    this.nameSuggestions = Object.create(null);\n    this.declarations = Object.create(null);\n    this.exportedVariables = new Map();\n  }\n\n  getVariableForExportName(name) {\n    if (name === '*') {\n      this.exportsNamespace = true;\n    } else if (name !== 'default') {\n      this.exportsNames = true;\n    }\n\n    let declaration = this.declarations[name];\n    if (declaration) return declaration;\n    this.declarations[name] = declaration = new ExternalVariable(this, name);\n    this.exportedVariables.set(declaration, name);\n    return declaration;\n  }\n\n  setRenderPath(options, inputBase) {\n    this.renderPath = '';\n\n    if (options.paths) {\n      this.renderPath = typeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];\n    }\n\n    if (!this.renderPath) {\n      if (!isAbsolute(this.id)) {\n        this.renderPath = this.id;\n      } else {\n        this.renderPath = normalize(relative$1(inputBase, this.id));\n        this.renormalizeRenderPath = true;\n      }\n    }\n\n    return this.renderPath;\n  }\n\n  suggestName(name) {\n    if (!this.nameSuggestions[name]) this.nameSuggestions[name] = 0;\n    this.nameSuggestions[name] += 1;\n\n    if (this.nameSuggestions[name] > this.mostCommonSuggestion) {\n      this.mostCommonSuggestion = this.nameSuggestions[name];\n      this.variableName = name;\n    }\n  }\n\n  warnUnusedImports() {\n    const unused = Object.keys(this.declarations).filter(name => {\n      if (name === '*') return false;\n      const declaration = this.declarations[name];\n      return !declaration.included && !this.reexported && !declaration.referenced;\n    });\n    if (unused.length === 0) return;\n    const names = unused.length === 1 ? `'${unused[0]}' is` : `${unused.slice(0, -1).map(name => `'${name}'`).join(', ')} and '${unused.slice(-1)}' are`;\n    this.graph.warn({\n      code: 'UNUSED_EXTERNAL_IMPORT',\n      message: `${names} imported from external module '${this.id}' but never used`,\n      names: unused,\n      source: this.id\n    });\n  }\n\n}\n\nfunction markModuleAndImpureDependenciesAsExecuted(baseModule) {\n  baseModule.isExecuted = true;\n  const modules = [baseModule];\n  const visitedModules = new Set();\n\n  for (const module of modules) {\n    for (const dependency of module.dependencies) {\n      if (!(dependency instanceof ExternalModule) && !dependency.isExecuted && dependency.moduleSideEffects && !visitedModules.has(dependency.id)) {\n        dependency.isExecuted = true;\n        visitedModules.add(dependency.id);\n        modules.push(dependency);\n      }\n    }\n  }\n} // To avoid infinite recursions\n\n\nconst MAX_PATH_DEPTH = 7;\n\nclass LocalVariable extends Variable {\n  constructor(name, declarator, init, context) {\n    super(name);\n    this.additionalInitializers = null;\n    this.calledFromTryStatement = false;\n    this.expressionsToBeDeoptimized = [];\n    this.declarations = declarator ? [declarator] : [];\n    this.init = init;\n    this.deoptimizationTracker = context.deoptimizationTracker;\n    this.module = context.module;\n  }\n\n  addDeclaration(identifier, init) {\n    this.declarations.push(identifier);\n\n    if (this.additionalInitializers === null) {\n      this.additionalInitializers = this.init === null ? [] : [this.init];\n      this.init = UNKNOWN_EXPRESSION;\n      this.isReassigned = true;\n    }\n\n    if (init !== null) {\n      this.additionalInitializers.push(init);\n    }\n  }\n\n  consolidateInitializers() {\n    if (this.additionalInitializers !== null) {\n      for (const initializer of this.additionalInitializers) {\n        initializer.deoptimizePath(UNKNOWN_PATH);\n      }\n\n      this.additionalInitializers = null;\n    }\n  }\n\n  deoptimizePath(path) {\n    if (path.length > MAX_PATH_DEPTH || this.isReassigned) return;\n    const trackedEntities = this.deoptimizationTracker.getEntities(path);\n    if (trackedEntities.has(this)) return;\n    trackedEntities.add(this);\n\n    if (path.length === 0) {\n      if (!this.isReassigned) {\n        this.isReassigned = true;\n        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n        this.expressionsToBeDeoptimized = [];\n\n        for (const expression of expressionsToBeDeoptimized) {\n          expression.deoptimizeCache();\n        }\n\n        if (this.init) {\n          this.init.deoptimizePath(UNKNOWN_PATH);\n        }\n      }\n    } else if (this.init) {\n      this.init.deoptimizePath(path);\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    if (this.isReassigned || !this.init || path.length > MAX_PATH_DEPTH) {\n      return UnknownValue;\n    }\n\n    const trackedEntities = recursionTracker.getEntities(path);\n\n    if (trackedEntities.has(this.init)) {\n      return UnknownValue;\n    }\n\n    this.expressionsToBeDeoptimized.push(origin);\n    trackedEntities.add(this.init);\n    const value = this.init.getLiteralValueAtPath(path, recursionTracker, origin);\n    trackedEntities.delete(this.init);\n    return value;\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    if (this.isReassigned || !this.init || path.length > MAX_PATH_DEPTH) {\n      return UNKNOWN_EXPRESSION;\n    }\n\n    const trackedEntities = recursionTracker.getEntities(path);\n\n    if (trackedEntities.has(this.init)) {\n      return UNKNOWN_EXPRESSION;\n    }\n\n    this.expressionsToBeDeoptimized.push(origin);\n    trackedEntities.add(this.init);\n    const value = this.init.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    trackedEntities.delete(this.init);\n    return value;\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (path.length === 0) return false;\n    if (this.isReassigned || path.length > MAX_PATH_DEPTH) return true;\n    const trackedExpressions = context.accessed.getEntities(path);\n    if (trackedExpressions.has(this)) return false;\n    trackedExpressions.add(this);\n    return this.init && this.init.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (this.included || path.length > MAX_PATH_DEPTH) return true;\n    if (path.length === 0) return false;\n    if (this.isReassigned) return true;\n    const trackedExpressions = context.assigned.getEntities(path);\n    if (trackedExpressions.has(this)) return false;\n    trackedExpressions.add(this);\n    return this.init && this.init.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length > MAX_PATH_DEPTH || this.isReassigned) return true;\n    const trackedExpressions = (callOptions.withNew ? context.instantiated : context.called).getEntities(path);\n    if (trackedExpressions.has(this)) return false;\n    trackedExpressions.add(this);\n    return this.init && this.init.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  include(context) {\n    if (!this.included) {\n      this.included = true;\n\n      if (!this.module.isExecuted) {\n        markModuleAndImpureDependenciesAsExecuted(this.module);\n      }\n\n      for (const declaration of this.declarations) {\n        // If node is a default export, it can save a tree-shaking run to include the full declaration now\n        if (!declaration.included) declaration.include(context, false);\n        let node = declaration.parent;\n\n        while (!node.included) {\n          // We do not want to properly include parents in case they are part of a dead branch\n          // in which case .include() might pull in more dead code\n          node.included = true;\n          if (node.type === Program) break;\n          node = node.parent;\n        }\n      }\n    }\n  }\n\n  includeCallArguments(context, args) {\n    if (this.isReassigned) {\n      for (const arg of args) {\n        arg.include(context, false);\n      }\n    } else if (this.init) {\n      this.init.includeCallArguments(context, args);\n    }\n  }\n\n  markCalledFromTryStatement() {\n    this.calledFromTryStatement = true;\n  }\n\n}\n\nclass Scope {\n  constructor() {\n    this.children = [];\n    this.variables = new Map();\n  }\n\n  addDeclaration(identifier, context, init = null, _isHoisted) {\n    const name = identifier.name;\n    let variable = this.variables.get(name);\n\n    if (variable) {\n      variable.addDeclaration(identifier, init);\n    } else {\n      variable = new LocalVariable(identifier.name, identifier, init || UNDEFINED_EXPRESSION, context);\n      this.variables.set(name, variable);\n    }\n\n    return variable;\n  }\n\n  contains(name) {\n    return this.variables.has(name);\n  }\n\n  findVariable(_name) {\n    throw new Error('Internal Error: findVariable needs to be implemented by a subclass');\n  }\n\n}\n\nclass ChildScope extends Scope {\n  constructor(parent) {\n    super();\n    this.accessedOutsideVariables = new Map();\n    this.parent = parent;\n    parent.children.push(this);\n  }\n\n  addAccessedDynamicImport(importExpression) {\n    (this.accessedDynamicImports || (this.accessedDynamicImports = new Set())).add(importExpression);\n\n    if (this.parent instanceof ChildScope) {\n      this.parent.addAccessedDynamicImport(importExpression);\n    }\n  }\n\n  addAccessedGlobalsByFormat(globalsByFormat) {\n    const accessedGlobalVariablesByFormat = this.accessedGlobalVariablesByFormat || (this.accessedGlobalVariablesByFormat = new Map());\n\n    for (const format of Object.keys(globalsByFormat)) {\n      let accessedGlobalVariables = accessedGlobalVariablesByFormat.get(format);\n\n      if (!accessedGlobalVariables) {\n        accessedGlobalVariables = new Set();\n        accessedGlobalVariablesByFormat.set(format, accessedGlobalVariables);\n      }\n\n      for (const name of globalsByFormat[format]) {\n        accessedGlobalVariables.add(name);\n      }\n    }\n\n    if (this.parent instanceof ChildScope) {\n      this.parent.addAccessedGlobalsByFormat(globalsByFormat);\n    }\n  }\n\n  addNamespaceMemberAccess(name, variable) {\n    this.accessedOutsideVariables.set(name, variable);\n    this.parent.addNamespaceMemberAccess(name, variable);\n  }\n\n  addReturnExpression(expression) {\n    this.parent instanceof ChildScope && this.parent.addReturnExpression(expression);\n  }\n\n  addUsedOutsideNames(usedNames, format) {\n    for (const variable of this.accessedOutsideVariables.values()) {\n      if (variable.included) {\n        usedNames.add(variable.getBaseVariableName());\n\n        if (variable.exportName && format === 'system') {\n          usedNames.add('exports');\n        }\n      }\n    }\n\n    const accessedGlobalVariables = this.accessedGlobalVariablesByFormat && this.accessedGlobalVariablesByFormat.get(format);\n\n    if (accessedGlobalVariables) {\n      for (const name of accessedGlobalVariables) {\n        usedNames.add(name);\n      }\n    }\n  }\n\n  contains(name) {\n    return this.variables.has(name) || this.parent.contains(name);\n  }\n\n  deconflict(format) {\n    const usedNames = new Set();\n    this.addUsedOutsideNames(usedNames, format);\n\n    if (this.accessedDynamicImports) {\n      for (const importExpression of this.accessedDynamicImports) {\n        if (importExpression.inlineNamespace) {\n          usedNames.add(importExpression.inlineNamespace.getBaseVariableName());\n        }\n      }\n    }\n\n    for (const [name, variable] of this.variables) {\n      if (variable.included || variable.alwaysRendered) {\n        variable.setSafeName(getSafeName(name, usedNames));\n      }\n    }\n\n    for (const scope of this.children) {\n      scope.deconflict(format);\n    }\n  }\n\n  findLexicalBoundary() {\n    return this.parent.findLexicalBoundary();\n  }\n\n  findVariable(name) {\n    const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);\n\n    if (knownVariable) {\n      return knownVariable;\n    }\n\n    const variable = this.parent.findVariable(name);\n    this.accessedOutsideVariables.set(name, variable);\n    return variable;\n  }\n\n}\n\nfunction getLocator$1(source, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var offsetLine = options.offsetLine || 0;\n  var offsetColumn = options.offsetColumn || 0;\n  var originalLines = source.split('\\n');\n  var start = 0;\n  var lineRanges = originalLines.map(function (line, i) {\n    var end = start + line.length + 1;\n    var range = {\n      start: start,\n      end: end,\n      line: i\n    };\n    start = end;\n    return range;\n  });\n  var i = 0;\n\n  function rangeContains(range, index) {\n    return range.start <= index && index < range.end;\n  }\n\n  function getLocation(range, index) {\n    return {\n      line: offsetLine + range.line,\n      column: offsetColumn + index - range.start,\n      character: index\n    };\n  }\n\n  function locate(search, startIndex) {\n    if (typeof search === 'string') {\n      search = source.indexOf(search, startIndex || 0);\n    }\n\n    var range = lineRanges[i];\n    var d = search >= range.end ? 1 : -1;\n\n    while (range) {\n      if (rangeContains(range, search)) return getLocation(range, search);\n      i += d;\n      range = lineRanges[i];\n    }\n  }\n\n  return locate;\n}\n\nfunction locate(source, search, options) {\n  if (typeof options === 'number') {\n    throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n  }\n\n  return getLocator$1(source, options)(search, options && options.startIndex);\n}\n\nconst keys = {\n  Literal: [],\n  Program: ['body']\n};\n\nfunction getAndCreateKeys(esTreeNode) {\n  keys[esTreeNode.type] = Object.keys(esTreeNode).filter(key => typeof esTreeNode[key] === 'object');\n  return keys[esTreeNode.type];\n}\n\nconst INCLUDE_PARAMETERS = 'variables';\n\nclass NodeBase {\n  constructor(esTreeNode, parent, parentScope) {\n    this.included = false;\n    this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);\n    this.parent = parent;\n    this.context = parent.context;\n    this.createScope(parentScope);\n    this.parseNode(esTreeNode);\n    this.initialise();\n    this.context.magicString.addSourcemapLocation(this.start);\n    this.context.magicString.addSourcemapLocation(this.end);\n  }\n  /**\n   * Override this to bind assignments to variables and do any initialisations that\n   * require the scopes to be populated with variables.\n   */\n\n\n  bind() {\n    for (const key of this.keys) {\n      const value = this[key];\n      if (value === null || key === 'annotations') continue;\n\n      if (Array.isArray(value)) {\n        for (const child of value) {\n          if (child !== null) child.bind();\n        }\n      } else {\n        value.bind();\n      }\n    }\n  }\n  /**\n   * Override if this node should receive a different scope than the parent scope.\n   */\n\n\n  createScope(parentScope) {\n    this.scope = parentScope;\n  }\n\n  declare(_kind, _init) {\n    return [];\n  }\n\n  deoptimizePath(_path) {}\n\n  getLiteralValueAtPath(_path, _recursionTracker, _origin) {\n    return UnknownValue;\n  }\n\n  getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {\n    return UNKNOWN_EXPRESSION;\n  }\n\n  hasEffects(context) {\n    for (const key of this.keys) {\n      const value = this[key];\n      if (value === null || key === 'annotations') continue;\n\n      if (Array.isArray(value)) {\n        for (const child of value) {\n          if (child !== null && child.hasEffects(context)) return true;\n        }\n      } else if (value.hasEffects(context)) return true;\n    }\n\n    return false;\n  }\n\n  hasEffectsWhenAccessedAtPath(path, _context) {\n    return path.length > 0;\n  }\n\n  hasEffectsWhenAssignedAtPath(_path, _context) {\n    return true;\n  }\n\n  hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {\n    return true;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    for (const key of this.keys) {\n      const value = this[key];\n      if (value === null || key === 'annotations') continue;\n\n      if (Array.isArray(value)) {\n        for (const child of value) {\n          if (child !== null) child.include(context, includeChildrenRecursively);\n        }\n      } else {\n        value.include(context, includeChildrenRecursively);\n      }\n    }\n  }\n\n  includeCallArguments(context, args) {\n    for (const arg of args) {\n      arg.include(context, false);\n    }\n  }\n\n  includeWithAllDeclaredVariables(includeChildrenRecursively, context) {\n    this.include(context, includeChildrenRecursively);\n  }\n  /**\n   * Override to perform special initialisation steps after the scope is initialised\n   */\n\n\n  initialise() {}\n\n  insertSemicolon(code) {\n    if (code.original[this.end - 1] !== ';') {\n      code.appendLeft(this.end, ';');\n    }\n  }\n\n  locate() {\n    // useful for debugging\n    const location = locate(this.context.code, this.start, {\n      offsetLine: 1\n    });\n    location.file = this.context.fileName;\n\n    location.toString = () => JSON.stringify(location);\n\n    return location;\n  }\n\n  parseNode(esTreeNode) {\n    for (const key of Object.keys(esTreeNode)) {\n      // That way, we can override this function to add custom initialisation and then call super.parseNode\n      if (this.hasOwnProperty(key)) continue;\n      const value = esTreeNode[key];\n\n      if (typeof value !== 'object' || value === null || key === 'annotations') {\n        this[key] = value;\n      } else if (Array.isArray(value)) {\n        this[key] = [];\n\n        for (const child of value) {\n          this[key].push(child === null ? null : new (this.context.nodeConstructors[child.type] || this.context.nodeConstructors.UnknownNode)(child, this, this.scope));\n        }\n      } else {\n        this[key] = new (this.context.nodeConstructors[value.type] || this.context.nodeConstructors.UnknownNode)(value, this, this.scope);\n      }\n    }\n  }\n\n  render(code, options) {\n    for (const key of this.keys) {\n      const value = this[key];\n      if (value === null || key === 'annotations') continue;\n\n      if (Array.isArray(value)) {\n        for (const child of value) {\n          if (child !== null) child.render(code, options);\n        }\n      } else {\n        value.render(code, options);\n      }\n    }\n  }\n\n  shouldBeIncluded(context) {\n    return this.included || !context.brokenFlow && this.hasEffects(createHasEffectsContext());\n  }\n\n  toString() {\n    return this.context.code.slice(this.start, this.end);\n  }\n\n}\n\nclass ClassNode extends NodeBase {\n  createScope(parentScope) {\n    this.scope = new ChildScope(parentScope);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenAssignedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (!callOptions.withNew) return true;\n    return this.body.hasEffectsWhenCalledAtPath(path, callOptions, context) || this.superClass !== null && this.superClass.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  initialise() {\n    if (this.id !== null) {\n      this.id.declare('class', this);\n    }\n  }\n\n}\n\nclass ClassDeclaration extends ClassNode {\n  initialise() {\n    super.initialise();\n\n    if (this.id !== null) {\n      this.id.variable.isId = true;\n    }\n  }\n\n  parseNode(esTreeNode) {\n    if (esTreeNode.id !== null) {\n      this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope.parent);\n    }\n\n    super.parseNode(esTreeNode);\n  }\n\n  render(code, options) {\n    if (options.format === 'system' && this.id && this.id.variable.exportName) {\n      code.appendLeft(this.end, ` exports('${this.id.variable.exportName}', ${this.id.variable.getName()});`);\n    }\n\n    super.render(code, options);\n  }\n\n}\n\nclass ArgumentsVariable extends LocalVariable {\n  constructor(context) {\n    super('arguments', null, UNKNOWN_EXPRESSION, context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenAssignedAtPath() {\n    return true;\n  }\n\n  hasEffectsWhenCalledAtPath() {\n    return true;\n  }\n\n}\n\nclass ThisVariable extends LocalVariable {\n  constructor(context) {\n    super('this', null, null, context);\n  }\n\n  getLiteralValueAtPath() {\n    return UnknownValue;\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    return this.getInit(context).hasEffectsWhenAccessedAtPath(path, context) || super.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    return this.getInit(context).hasEffectsWhenAssignedAtPath(path, context) || super.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    return this.getInit(context).hasEffectsWhenCalledAtPath(path, callOptions, context) || super.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  getInit(context) {\n    return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;\n  }\n\n}\n\nclass ParameterScope extends ChildScope {\n  constructor(parent, context) {\n    super(parent);\n    this.parameters = [];\n    this.hasRest = false;\n    this.context = context;\n    this.hoistedBodyVarScope = new ChildScope(this);\n  }\n  /**\n   * Adds a parameter to this scope. Parameters must be added in the correct\n   * order, e.g. from left to right.\n   */\n\n\n  addParameterDeclaration(identifier) {\n    const name = identifier.name;\n    let variable = this.hoistedBodyVarScope.variables.get(name);\n\n    if (variable) {\n      variable.addDeclaration(identifier, null);\n    } else {\n      variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);\n    }\n\n    this.variables.set(name, variable);\n    return variable;\n  }\n\n  addParameterVariables(parameters, hasRest) {\n    this.parameters = parameters;\n\n    for (const parameterList of parameters) {\n      for (const parameter of parameterList) {\n        parameter.alwaysRendered = true;\n      }\n    }\n\n    this.hasRest = hasRest;\n  }\n\n  includeCallArguments(context, args) {\n    let calledFromTryStatement = false;\n    let argIncluded = false;\n    const restParam = this.hasRest && this.parameters[this.parameters.length - 1];\n\n    for (let index = args.length - 1; index >= 0; index--) {\n      const paramVars = this.parameters[index] || restParam;\n      const arg = args[index];\n\n      if (paramVars) {\n        calledFromTryStatement = false;\n\n        for (const variable of paramVars) {\n          if (variable.included) {\n            argIncluded = true;\n          }\n\n          if (variable.calledFromTryStatement) {\n            calledFromTryStatement = true;\n          }\n        }\n      }\n\n      if (!argIncluded && arg.shouldBeIncluded(context)) {\n        argIncluded = true;\n      }\n\n      if (argIncluded) {\n        arg.include(context, calledFromTryStatement);\n      }\n    }\n  }\n\n}\n\nclass ReturnValueScope extends ParameterScope {\n  constructor() {\n    super(...arguments);\n    this.returnExpression = null;\n    this.returnExpressions = [];\n  }\n\n  addReturnExpression(expression) {\n    this.returnExpressions.push(expression);\n  }\n\n  getReturnExpression() {\n    if (this.returnExpression === null) this.updateReturnExpression();\n    return this.returnExpression;\n  }\n\n  updateReturnExpression() {\n    if (this.returnExpressions.length === 1) {\n      this.returnExpression = this.returnExpressions[0];\n    } else {\n      this.returnExpression = UNKNOWN_EXPRESSION;\n\n      for (const expression of this.returnExpressions) {\n        expression.deoptimizePath(UNKNOWN_PATH);\n      }\n    }\n  }\n\n}\n\nclass FunctionScope extends ReturnValueScope {\n  constructor(parent, context) {\n    super(parent, context);\n    this.variables.set('arguments', this.argumentsVariable = new ArgumentsVariable(context));\n    this.variables.set('this', this.thisVariable = new ThisVariable(context));\n  }\n\n  findLexicalBoundary() {\n    return this;\n  }\n\n  includeCallArguments(context, args) {\n    super.includeCallArguments(context, args);\n\n    if (this.argumentsVariable.included) {\n      for (const arg of args) {\n        if (!arg.included) {\n          arg.include(context, false);\n        }\n      }\n    }\n  }\n\n}\n\nfunction isReference(node, parent) {\n  if (node.type === 'MemberExpression') {\n    return !node.computed && isReference(node.object, node);\n  }\n\n  if (node.type === 'Identifier') {\n    if (!parent) return true;\n\n    switch (parent.type) {\n      // disregard `bar` in `foo.bar`\n      case 'MemberExpression':\n        return parent.computed || node === parent.object;\n      // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`\n\n      case 'MethodDefinition':\n        return parent.computed;\n      // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`\n\n      case 'Property':\n        return parent.computed || node === parent.value;\n      // disregard the `bar` in `export { foo as bar }` or\n      // the foo in `import { foo as bar }`\n\n      case 'ExportSpecifier':\n      case 'ImportSpecifier':\n        return node === parent.local;\n      // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`\n\n      case 'LabeledStatement':\n      case 'BreakStatement':\n      case 'ContinueStatement':\n        return false;\n\n      default:\n        return true;\n    }\n  }\n\n  return false;\n}\n\nconst BLANK = Object.create(null);\nconst ValueProperties = Symbol('Value Properties');\nconst PURE = {\n  pure: true\n};\nconst IMPURE = {\n  pure: false\n}; // We use shortened variables to reduce file size here\n\n/* OBJECT */\n\nconst O = {\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: IMPURE\n};\n/* PURE FUNCTION */\n\nconst PF = {\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: PURE\n};\n/* CONSTRUCTOR */\n\nconst C = {\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: IMPURE,\n  prototype: O\n};\n/* PURE CONSTRUCTOR */\n\nconst PC = {\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: PURE,\n  prototype: O\n};\nconst ARRAY_TYPE = {\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: PURE,\n  from: PF,\n  of: PF,\n  prototype: O\n};\nconst INTL_MEMBER = {\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: PURE,\n  supportedLocalesOf: PC\n};\nconst knownGlobals = {\n  // Placeholders for global objects to avoid shape mutations\n  global: O,\n  globalThis: O,\n  self: O,\n  window: O,\n  // Common globals\n  // @ts-ignore\n  __proto__: null,\n  [ValueProperties]: IMPURE,\n  Array: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    from: PF,\n    isArray: PF,\n    of: PF,\n    prototype: O\n  },\n  ArrayBuffer: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    isView: PF,\n    prototype: O\n  },\n  Atomics: O,\n  BigInt: C,\n  BigInt64Array: C,\n  BigUint64Array: C,\n  Boolean: PC,\n  // @ts-ignore\n  constructor: C,\n  DataView: PC,\n  Date: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    now: PF,\n    parse: PF,\n    prototype: O,\n    UTC: PF\n  },\n  decodeURI: PF,\n  decodeURIComponent: PF,\n  encodeURI: PF,\n  encodeURIComponent: PF,\n  Error: PC,\n  escape: PF,\n  eval: O,\n  EvalError: PC,\n  Float32Array: ARRAY_TYPE,\n  Float64Array: ARRAY_TYPE,\n  Function: C,\n  // @ts-ignore\n  hasOwnProperty: O,\n  Infinity: O,\n  Int16Array: ARRAY_TYPE,\n  Int32Array: ARRAY_TYPE,\n  Int8Array: ARRAY_TYPE,\n  isFinite: PF,\n  isNaN: PF,\n  // @ts-ignore\n  isPrototypeOf: O,\n  JSON: O,\n  Map: PC,\n  Math: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    abs: PF,\n    acos: PF,\n    acosh: PF,\n    asin: PF,\n    asinh: PF,\n    atan: PF,\n    atan2: PF,\n    atanh: PF,\n    cbrt: PF,\n    ceil: PF,\n    clz32: PF,\n    cos: PF,\n    cosh: PF,\n    exp: PF,\n    expm1: PF,\n    floor: PF,\n    fround: PF,\n    hypot: PF,\n    imul: PF,\n    log: PF,\n    log10: PF,\n    log1p: PF,\n    log2: PF,\n    max: PF,\n    min: PF,\n    pow: PF,\n    random: PF,\n    round: PF,\n    sign: PF,\n    sin: PF,\n    sinh: PF,\n    sqrt: PF,\n    tan: PF,\n    tanh: PF,\n    trunc: PF\n  },\n  NaN: O,\n  Number: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    isFinite: PF,\n    isInteger: PF,\n    isNaN: PF,\n    isSafeInteger: PF,\n    parseFloat: PF,\n    parseInt: PF,\n    prototype: O\n  },\n  Object: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    create: PF,\n    getNotifier: PF,\n    getOwn: PF,\n    getOwnPropertyDescriptor: PF,\n    getOwnPropertyNames: PF,\n    getOwnPropertySymbols: PF,\n    getPrototypeOf: PF,\n    is: PF,\n    isExtensible: PF,\n    isFrozen: PF,\n    isSealed: PF,\n    keys: PF,\n    prototype: O\n  },\n  parseFloat: PF,\n  parseInt: PF,\n  Promise: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    all: PF,\n    prototype: O,\n    race: PF,\n    resolve: PF\n  },\n  // @ts-ignore\n  propertyIsEnumerable: O,\n  Proxy: O,\n  RangeError: PC,\n  ReferenceError: PC,\n  Reflect: O,\n  RegExp: PC,\n  Set: PC,\n  SharedArrayBuffer: C,\n  String: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    fromCharCode: PF,\n    fromCodePoint: PF,\n    prototype: O,\n    raw: PF\n  },\n  Symbol: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    for: PF,\n    keyFor: PF,\n    prototype: O\n  },\n  SyntaxError: PC,\n  // @ts-ignore\n  toLocaleString: O,\n  // @ts-ignore\n  toString: O,\n  TypeError: PC,\n  Uint16Array: ARRAY_TYPE,\n  Uint32Array: ARRAY_TYPE,\n  Uint8Array: ARRAY_TYPE,\n  Uint8ClampedArray: ARRAY_TYPE,\n  // Technically, this is a global, but it needs special handling\n  // undefined: ?,\n  unescape: PF,\n  URIError: PC,\n  // @ts-ignore\n  valueOf: O,\n  WeakMap: PC,\n  WeakSet: PC,\n  // Additional globals shared by Node and Browser that are not strictly part of the language\n  clearInterval: C,\n  clearTimeout: C,\n  console: O,\n  Intl: {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    Collator: INTL_MEMBER,\n    DateTimeFormat: INTL_MEMBER,\n    ListFormat: INTL_MEMBER,\n    NumberFormat: INTL_MEMBER,\n    PluralRules: INTL_MEMBER,\n    RelativeTimeFormat: INTL_MEMBER\n  },\n  setInterval: C,\n  setTimeout: C,\n  TextDecoder: C,\n  TextEncoder: C,\n  URL: C,\n  URLSearchParams: C,\n  // Browser specific globals\n  AbortController: C,\n  AbortSignal: C,\n  addEventListener: O,\n  alert: O,\n  AnalyserNode: C,\n  Animation: C,\n  AnimationEvent: C,\n  applicationCache: O,\n  ApplicationCache: C,\n  ApplicationCacheErrorEvent: C,\n  atob: O,\n  Attr: C,\n  Audio: C,\n  AudioBuffer: C,\n  AudioBufferSourceNode: C,\n  AudioContext: C,\n  AudioDestinationNode: C,\n  AudioListener: C,\n  AudioNode: C,\n  AudioParam: C,\n  AudioProcessingEvent: C,\n  AudioScheduledSourceNode: C,\n  AudioWorkletNode: C,\n  BarProp: C,\n  BaseAudioContext: C,\n  BatteryManager: C,\n  BeforeUnloadEvent: C,\n  BiquadFilterNode: C,\n  Blob: C,\n  BlobEvent: C,\n  blur: O,\n  BroadcastChannel: C,\n  btoa: O,\n  ByteLengthQueuingStrategy: C,\n  Cache: C,\n  caches: O,\n  CacheStorage: C,\n  cancelAnimationFrame: O,\n  cancelIdleCallback: O,\n  CanvasCaptureMediaStreamTrack: C,\n  CanvasGradient: C,\n  CanvasPattern: C,\n  CanvasRenderingContext2D: C,\n  ChannelMergerNode: C,\n  ChannelSplitterNode: C,\n  CharacterData: C,\n  clientInformation: O,\n  ClipboardEvent: C,\n  close: O,\n  closed: O,\n  CloseEvent: C,\n  Comment: C,\n  CompositionEvent: C,\n  confirm: O,\n  ConstantSourceNode: C,\n  ConvolverNode: C,\n  CountQueuingStrategy: C,\n  createImageBitmap: O,\n  Credential: C,\n  CredentialsContainer: C,\n  crypto: O,\n  Crypto: C,\n  CryptoKey: C,\n  CSS: C,\n  CSSConditionRule: C,\n  CSSFontFaceRule: C,\n  CSSGroupingRule: C,\n  CSSImportRule: C,\n  CSSKeyframeRule: C,\n  CSSKeyframesRule: C,\n  CSSMediaRule: C,\n  CSSNamespaceRule: C,\n  CSSPageRule: C,\n  CSSRule: C,\n  CSSRuleList: C,\n  CSSStyleDeclaration: C,\n  CSSStyleRule: C,\n  CSSStyleSheet: C,\n  CSSSupportsRule: C,\n  CustomElementRegistry: C,\n  customElements: O,\n  CustomEvent: C,\n  DataTransfer: C,\n  DataTransferItem: C,\n  DataTransferItemList: C,\n  defaultstatus: O,\n  defaultStatus: O,\n  DelayNode: C,\n  DeviceMotionEvent: C,\n  DeviceOrientationEvent: C,\n  devicePixelRatio: O,\n  dispatchEvent: O,\n  document: O,\n  Document: C,\n  DocumentFragment: C,\n  DocumentType: C,\n  DOMError: C,\n  DOMException: C,\n  DOMImplementation: C,\n  DOMMatrix: C,\n  DOMMatrixReadOnly: C,\n  DOMParser: C,\n  DOMPoint: C,\n  DOMPointReadOnly: C,\n  DOMQuad: C,\n  DOMRect: C,\n  DOMRectReadOnly: C,\n  DOMStringList: C,\n  DOMStringMap: C,\n  DOMTokenList: C,\n  DragEvent: C,\n  DynamicsCompressorNode: C,\n  Element: C,\n  ErrorEvent: C,\n  Event: C,\n  EventSource: C,\n  EventTarget: C,\n  external: O,\n  fetch: O,\n  File: C,\n  FileList: C,\n  FileReader: C,\n  find: O,\n  focus: O,\n  FocusEvent: C,\n  FontFace: C,\n  FontFaceSetLoadEvent: C,\n  FormData: C,\n  frames: O,\n  GainNode: C,\n  Gamepad: C,\n  GamepadButton: C,\n  GamepadEvent: C,\n  getComputedStyle: O,\n  getSelection: O,\n  HashChangeEvent: C,\n  Headers: C,\n  history: O,\n  History: C,\n  HTMLAllCollection: C,\n  HTMLAnchorElement: C,\n  HTMLAreaElement: C,\n  HTMLAudioElement: C,\n  HTMLBaseElement: C,\n  HTMLBodyElement: C,\n  HTMLBRElement: C,\n  HTMLButtonElement: C,\n  HTMLCanvasElement: C,\n  HTMLCollection: C,\n  HTMLContentElement: C,\n  HTMLDataElement: C,\n  HTMLDataListElement: C,\n  HTMLDetailsElement: C,\n  HTMLDialogElement: C,\n  HTMLDirectoryElement: C,\n  HTMLDivElement: C,\n  HTMLDListElement: C,\n  HTMLDocument: C,\n  HTMLElement: C,\n  HTMLEmbedElement: C,\n  HTMLFieldSetElement: C,\n  HTMLFontElement: C,\n  HTMLFormControlsCollection: C,\n  HTMLFormElement: C,\n  HTMLFrameElement: C,\n  HTMLFrameSetElement: C,\n  HTMLHeadElement: C,\n  HTMLHeadingElement: C,\n  HTMLHRElement: C,\n  HTMLHtmlElement: C,\n  HTMLIFrameElement: C,\n  HTMLImageElement: C,\n  HTMLInputElement: C,\n  HTMLLabelElement: C,\n  HTMLLegendElement: C,\n  HTMLLIElement: C,\n  HTMLLinkElement: C,\n  HTMLMapElement: C,\n  HTMLMarqueeElement: C,\n  HTMLMediaElement: C,\n  HTMLMenuElement: C,\n  HTMLMetaElement: C,\n  HTMLMeterElement: C,\n  HTMLModElement: C,\n  HTMLObjectElement: C,\n  HTMLOListElement: C,\n  HTMLOptGroupElement: C,\n  HTMLOptionElement: C,\n  HTMLOptionsCollection: C,\n  HTMLOutputElement: C,\n  HTMLParagraphElement: C,\n  HTMLParamElement: C,\n  HTMLPictureElement: C,\n  HTMLPreElement: C,\n  HTMLProgressElement: C,\n  HTMLQuoteElement: C,\n  HTMLScriptElement: C,\n  HTMLSelectElement: C,\n  HTMLShadowElement: C,\n  HTMLSlotElement: C,\n  HTMLSourceElement: C,\n  HTMLSpanElement: C,\n  HTMLStyleElement: C,\n  HTMLTableCaptionElement: C,\n  HTMLTableCellElement: C,\n  HTMLTableColElement: C,\n  HTMLTableElement: C,\n  HTMLTableRowElement: C,\n  HTMLTableSectionElement: C,\n  HTMLTemplateElement: C,\n  HTMLTextAreaElement: C,\n  HTMLTimeElement: C,\n  HTMLTitleElement: C,\n  HTMLTrackElement: C,\n  HTMLUListElement: C,\n  HTMLUnknownElement: C,\n  HTMLVideoElement: C,\n  IDBCursor: C,\n  IDBCursorWithValue: C,\n  IDBDatabase: C,\n  IDBFactory: C,\n  IDBIndex: C,\n  IDBKeyRange: C,\n  IDBObjectStore: C,\n  IDBOpenDBRequest: C,\n  IDBRequest: C,\n  IDBTransaction: C,\n  IDBVersionChangeEvent: C,\n  IdleDeadline: C,\n  IIRFilterNode: C,\n  Image: C,\n  ImageBitmap: C,\n  ImageBitmapRenderingContext: C,\n  ImageCapture: C,\n  ImageData: C,\n  indexedDB: O,\n  innerHeight: O,\n  innerWidth: O,\n  InputEvent: C,\n  IntersectionObserver: C,\n  IntersectionObserverEntry: C,\n  isSecureContext: O,\n  KeyboardEvent: C,\n  KeyframeEffect: C,\n  length: O,\n  localStorage: O,\n  location: O,\n  Location: C,\n  locationbar: O,\n  matchMedia: O,\n  MediaDeviceInfo: C,\n  MediaDevices: C,\n  MediaElementAudioSourceNode: C,\n  MediaEncryptedEvent: C,\n  MediaError: C,\n  MediaKeyMessageEvent: C,\n  MediaKeySession: C,\n  MediaKeyStatusMap: C,\n  MediaKeySystemAccess: C,\n  MediaList: C,\n  MediaQueryList: C,\n  MediaQueryListEvent: C,\n  MediaRecorder: C,\n  MediaSettingsRange: C,\n  MediaSource: C,\n  MediaStream: C,\n  MediaStreamAudioDestinationNode: C,\n  MediaStreamAudioSourceNode: C,\n  MediaStreamEvent: C,\n  MediaStreamTrack: C,\n  MediaStreamTrackEvent: C,\n  menubar: O,\n  MessageChannel: C,\n  MessageEvent: C,\n  MessagePort: C,\n  MIDIAccess: C,\n  MIDIConnectionEvent: C,\n  MIDIInput: C,\n  MIDIInputMap: C,\n  MIDIMessageEvent: C,\n  MIDIOutput: C,\n  MIDIOutputMap: C,\n  MIDIPort: C,\n  MimeType: C,\n  MimeTypeArray: C,\n  MouseEvent: C,\n  moveBy: O,\n  moveTo: O,\n  MutationEvent: C,\n  MutationObserver: C,\n  MutationRecord: C,\n  name: O,\n  NamedNodeMap: C,\n  NavigationPreloadManager: C,\n  navigator: O,\n  Navigator: C,\n  NetworkInformation: C,\n  Node: C,\n  NodeFilter: O,\n  NodeIterator: C,\n  NodeList: C,\n  Notification: C,\n  OfflineAudioCompletionEvent: C,\n  OfflineAudioContext: C,\n  offscreenBuffering: O,\n  OffscreenCanvas: C,\n  open: O,\n  openDatabase: O,\n  Option: C,\n  origin: O,\n  OscillatorNode: C,\n  outerHeight: O,\n  outerWidth: O,\n  PageTransitionEvent: C,\n  pageXOffset: O,\n  pageYOffset: O,\n  PannerNode: C,\n  parent: O,\n  Path2D: C,\n  PaymentAddress: C,\n  PaymentRequest: C,\n  PaymentRequestUpdateEvent: C,\n  PaymentResponse: C,\n  performance: O,\n  Performance: C,\n  PerformanceEntry: C,\n  PerformanceLongTaskTiming: C,\n  PerformanceMark: C,\n  PerformanceMeasure: C,\n  PerformanceNavigation: C,\n  PerformanceNavigationTiming: C,\n  PerformanceObserver: C,\n  PerformanceObserverEntryList: C,\n  PerformancePaintTiming: C,\n  PerformanceResourceTiming: C,\n  PerformanceTiming: C,\n  PeriodicWave: C,\n  Permissions: C,\n  PermissionStatus: C,\n  personalbar: O,\n  PhotoCapabilities: C,\n  Plugin: C,\n  PluginArray: C,\n  PointerEvent: C,\n  PopStateEvent: C,\n  postMessage: O,\n  Presentation: C,\n  PresentationAvailability: C,\n  PresentationConnection: C,\n  PresentationConnectionAvailableEvent: C,\n  PresentationConnectionCloseEvent: C,\n  PresentationConnectionList: C,\n  PresentationReceiver: C,\n  PresentationRequest: C,\n  print: O,\n  ProcessingInstruction: C,\n  ProgressEvent: C,\n  PromiseRejectionEvent: C,\n  prompt: O,\n  PushManager: C,\n  PushSubscription: C,\n  PushSubscriptionOptions: C,\n  queueMicrotask: O,\n  RadioNodeList: C,\n  Range: C,\n  ReadableStream: C,\n  RemotePlayback: C,\n  removeEventListener: O,\n  Request: C,\n  requestAnimationFrame: O,\n  requestIdleCallback: O,\n  resizeBy: O,\n  ResizeObserver: C,\n  ResizeObserverEntry: C,\n  resizeTo: O,\n  Response: C,\n  RTCCertificate: C,\n  RTCDataChannel: C,\n  RTCDataChannelEvent: C,\n  RTCDtlsTransport: C,\n  RTCIceCandidate: C,\n  RTCIceTransport: C,\n  RTCPeerConnection: C,\n  RTCPeerConnectionIceEvent: C,\n  RTCRtpReceiver: C,\n  RTCRtpSender: C,\n  RTCSctpTransport: C,\n  RTCSessionDescription: C,\n  RTCStatsReport: C,\n  RTCTrackEvent: C,\n  screen: O,\n  Screen: C,\n  screenLeft: O,\n  ScreenOrientation: C,\n  screenTop: O,\n  screenX: O,\n  screenY: O,\n  ScriptProcessorNode: C,\n  scroll: O,\n  scrollbars: O,\n  scrollBy: O,\n  scrollTo: O,\n  scrollX: O,\n  scrollY: O,\n  SecurityPolicyViolationEvent: C,\n  Selection: C,\n  ServiceWorker: C,\n  ServiceWorkerContainer: C,\n  ServiceWorkerRegistration: C,\n  sessionStorage: O,\n  ShadowRoot: C,\n  SharedWorker: C,\n  SourceBuffer: C,\n  SourceBufferList: C,\n  speechSynthesis: O,\n  SpeechSynthesisEvent: C,\n  SpeechSynthesisUtterance: C,\n  StaticRange: C,\n  status: O,\n  statusbar: O,\n  StereoPannerNode: C,\n  stop: O,\n  Storage: C,\n  StorageEvent: C,\n  StorageManager: C,\n  styleMedia: O,\n  StyleSheet: C,\n  StyleSheetList: C,\n  SubtleCrypto: C,\n  SVGAElement: C,\n  SVGAngle: C,\n  SVGAnimatedAngle: C,\n  SVGAnimatedBoolean: C,\n  SVGAnimatedEnumeration: C,\n  SVGAnimatedInteger: C,\n  SVGAnimatedLength: C,\n  SVGAnimatedLengthList: C,\n  SVGAnimatedNumber: C,\n  SVGAnimatedNumberList: C,\n  SVGAnimatedPreserveAspectRatio: C,\n  SVGAnimatedRect: C,\n  SVGAnimatedString: C,\n  SVGAnimatedTransformList: C,\n  SVGAnimateElement: C,\n  SVGAnimateMotionElement: C,\n  SVGAnimateTransformElement: C,\n  SVGAnimationElement: C,\n  SVGCircleElement: C,\n  SVGClipPathElement: C,\n  SVGComponentTransferFunctionElement: C,\n  SVGDefsElement: C,\n  SVGDescElement: C,\n  SVGDiscardElement: C,\n  SVGElement: C,\n  SVGEllipseElement: C,\n  SVGFEBlendElement: C,\n  SVGFEColorMatrixElement: C,\n  SVGFEComponentTransferElement: C,\n  SVGFECompositeElement: C,\n  SVGFEConvolveMatrixElement: C,\n  SVGFEDiffuseLightingElement: C,\n  SVGFEDisplacementMapElement: C,\n  SVGFEDistantLightElement: C,\n  SVGFEDropShadowElement: C,\n  SVGFEFloodElement: C,\n  SVGFEFuncAElement: C,\n  SVGFEFuncBElement: C,\n  SVGFEFuncGElement: C,\n  SVGFEFuncRElement: C,\n  SVGFEGaussianBlurElement: C,\n  SVGFEImageElement: C,\n  SVGFEMergeElement: C,\n  SVGFEMergeNodeElement: C,\n  SVGFEMorphologyElement: C,\n  SVGFEOffsetElement: C,\n  SVGFEPointLightElement: C,\n  SVGFESpecularLightingElement: C,\n  SVGFESpotLightElement: C,\n  SVGFETileElement: C,\n  SVGFETurbulenceElement: C,\n  SVGFilterElement: C,\n  SVGForeignObjectElement: C,\n  SVGGElement: C,\n  SVGGeometryElement: C,\n  SVGGradientElement: C,\n  SVGGraphicsElement: C,\n  SVGImageElement: C,\n  SVGLength: C,\n  SVGLengthList: C,\n  SVGLinearGradientElement: C,\n  SVGLineElement: C,\n  SVGMarkerElement: C,\n  SVGMaskElement: C,\n  SVGMatrix: C,\n  SVGMetadataElement: C,\n  SVGMPathElement: C,\n  SVGNumber: C,\n  SVGNumberList: C,\n  SVGPathElement: C,\n  SVGPatternElement: C,\n  SVGPoint: C,\n  SVGPointList: C,\n  SVGPolygonElement: C,\n  SVGPolylineElement: C,\n  SVGPreserveAspectRatio: C,\n  SVGRadialGradientElement: C,\n  SVGRect: C,\n  SVGRectElement: C,\n  SVGScriptElement: C,\n  SVGSetElement: C,\n  SVGStopElement: C,\n  SVGStringList: C,\n  SVGStyleElement: C,\n  SVGSVGElement: C,\n  SVGSwitchElement: C,\n  SVGSymbolElement: C,\n  SVGTextContentElement: C,\n  SVGTextElement: C,\n  SVGTextPathElement: C,\n  SVGTextPositioningElement: C,\n  SVGTitleElement: C,\n  SVGTransform: C,\n  SVGTransformList: C,\n  SVGTSpanElement: C,\n  SVGUnitTypes: C,\n  SVGUseElement: C,\n  SVGViewElement: C,\n  TaskAttributionTiming: C,\n  Text: C,\n  TextEvent: C,\n  TextMetrics: C,\n  TextTrack: C,\n  TextTrackCue: C,\n  TextTrackCueList: C,\n  TextTrackList: C,\n  TimeRanges: C,\n  toolbar: O,\n  top: O,\n  Touch: C,\n  TouchEvent: C,\n  TouchList: C,\n  TrackEvent: C,\n  TransitionEvent: C,\n  TreeWalker: C,\n  UIEvent: C,\n  ValidityState: C,\n  visualViewport: O,\n  VisualViewport: C,\n  VTTCue: C,\n  WaveShaperNode: C,\n  WebAssembly: O,\n  WebGL2RenderingContext: C,\n  WebGLActiveInfo: C,\n  WebGLBuffer: C,\n  WebGLContextEvent: C,\n  WebGLFramebuffer: C,\n  WebGLProgram: C,\n  WebGLQuery: C,\n  WebGLRenderbuffer: C,\n  WebGLRenderingContext: C,\n  WebGLSampler: C,\n  WebGLShader: C,\n  WebGLShaderPrecisionFormat: C,\n  WebGLSync: C,\n  WebGLTexture: C,\n  WebGLTransformFeedback: C,\n  WebGLUniformLocation: C,\n  WebGLVertexArrayObject: C,\n  WebSocket: C,\n  WheelEvent: C,\n  Window: C,\n  Worker: C,\n  WritableStream: C,\n  XMLDocument: C,\n  XMLHttpRequest: C,\n  XMLHttpRequestEventTarget: C,\n  XMLHttpRequestUpload: C,\n  XMLSerializer: C,\n  XPathEvaluator: C,\n  XPathExpression: C,\n  XPathResult: C,\n  XSLTProcessor: C\n};\n\nfor (const global of ['window', 'global', 'self', 'globalThis']) {\n  knownGlobals[global] = knownGlobals;\n}\n\nfunction getGlobalAtPath(path) {\n  let currentGlobal = knownGlobals;\n\n  for (const pathSegment of path) {\n    if (typeof pathSegment !== 'string') {\n      return null;\n    }\n\n    currentGlobal = currentGlobal[pathSegment];\n\n    if (!currentGlobal) {\n      return null;\n    }\n  }\n\n  return currentGlobal[ValueProperties];\n}\n\nfunction isPureGlobal(path) {\n  const globalAtPath = getGlobalAtPath(path);\n  return globalAtPath !== null && globalAtPath.pure;\n}\n\nfunction isGlobalMember(path) {\n  if (path.length === 1) {\n    return path[0] === 'undefined' || getGlobalAtPath(path) !== null;\n  }\n\n  return getGlobalAtPath(path.slice(0, -1)) !== null;\n}\n\nclass GlobalVariable extends Variable {\n  hasEffectsWhenAccessedAtPath(path) {\n    return !isGlobalMember([this.name, ...path]);\n  }\n\n  hasEffectsWhenCalledAtPath(path) {\n    return !isPureGlobal([this.name, ...path]);\n  }\n\n}\n\nclass Identifier$1 extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.variable = null;\n    this.bound = false;\n  }\n\n  addExportedVariables(variables) {\n    if (this.variable !== null && this.variable.exportName) {\n      variables.push(this.variable);\n    }\n  }\n\n  bind() {\n    if (this.bound) return;\n    this.bound = true;\n\n    if (this.variable === null && isReference(this, this.parent)) {\n      this.variable = this.scope.findVariable(this.name);\n      this.variable.addReference(this);\n    }\n\n    if (this.variable !== null && this.variable instanceof LocalVariable && this.variable.additionalInitializers !== null) {\n      this.variable.consolidateInitializers();\n    }\n  }\n\n  declare(kind, init) {\n    let variable;\n\n    switch (kind) {\n      case 'var':\n        variable = this.scope.addDeclaration(this, this.context, init, true);\n        break;\n\n      case 'function':\n        variable = this.scope.addDeclaration(this, this.context, init, 'function');\n        break;\n\n      case 'let':\n      case 'const':\n      case 'class':\n        variable = this.scope.addDeclaration(this, this.context, init, false);\n        break;\n\n      case 'parameter':\n        variable = this.scope.addParameterDeclaration(this);\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        /* istanbul ignore next */\n        throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);\n    }\n\n    return [this.variable = variable];\n  }\n\n  deoptimizePath(path) {\n    if (!this.bound) this.bind();\n\n    if (path.length === 0 && !this.scope.contains(this.name)) {\n      this.disallowImportReassignment();\n    }\n\n    this.variable.deoptimizePath(path);\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    if (!this.bound) this.bind();\n    return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    if (!this.bound) this.bind();\n    return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n  }\n\n  hasEffects() {\n    return this.context.unknownGlobalSideEffects && this.variable instanceof GlobalVariable && this.variable.hasEffectsWhenAccessedAtPath(EMPTY_PATH);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    return this.variable !== null && this.variable.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    return !this.variable || this.variable.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    return !this.variable || this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  include(context) {\n    if (!this.included) {\n      this.included = true;\n\n      if (this.variable !== null) {\n        this.context.includeVariable(context, this.variable);\n      }\n    }\n  }\n\n  includeCallArguments(context, args) {\n    this.variable.includeCallArguments(context, args);\n  }\n\n  render(code, _options, {\n    renderedParentType,\n    isCalleeOfRenderedParent,\n    isShorthandProperty\n  } = BLANK) {\n    if (this.variable) {\n      const name = this.variable.getName();\n\n      if (name !== this.name) {\n        code.overwrite(this.start, this.end, name, {\n          contentOnly: true,\n          storeName: true\n        });\n\n        if (isShorthandProperty) {\n          code.prependRight(this.start, `${this.name}: `);\n        }\n      } // In strict mode, any variable named \"eval\" must be the actual \"eval\" function\n\n\n      if (name === 'eval' && renderedParentType === CallExpression && isCalleeOfRenderedParent) {\n        code.appendRight(this.start, '0, ');\n      }\n    }\n  }\n\n  disallowImportReassignment() {\n    return this.context.error({\n      code: 'ILLEGAL_REASSIGNMENT',\n      message: `Illegal reassignment to import '${this.name}'`\n    }, this.start);\n  }\n\n}\n\nclass RestElement extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.declarationInit = null;\n  }\n\n  addExportedVariables(variables) {\n    this.argument.addExportedVariables(variables);\n  }\n\n  bind() {\n    super.bind();\n\n    if (this.declarationInit !== null) {\n      this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);\n    }\n  }\n\n  declare(kind, init) {\n    this.declarationInit = init;\n    return this.argument.declare(kind, UNKNOWN_EXPRESSION);\n  }\n\n  deoptimizePath(path) {\n    path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    return path.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n  }\n\n}\n\nclass FunctionNode extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.isPrototypeDeoptimized = false;\n  }\n\n  createScope(parentScope) {\n    this.scope = new FunctionScope(parentScope, this.context);\n  }\n\n  deoptimizePath(path) {\n    if (path.length === 1) {\n      if (path[0] === 'prototype') {\n        this.isPrototypeDeoptimized = true;\n      } else if (path[0] === UnknownKey) {\n        this.isPrototypeDeoptimized = true; // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track\n        // which means the return expression needs to be reassigned as well\n\n        this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);\n      }\n    }\n  }\n\n  getReturnExpressionWhenCalledAtPath(path) {\n    return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;\n  }\n\n  hasEffects() {\n    return this.id !== null && this.id.hasEffects();\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    if (path.length <= 1) return false;\n    return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;\n  }\n\n  hasEffectsWhenAssignedAtPath(path) {\n    if (path.length <= 1) {\n      return false;\n    }\n\n    return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length > 0) return true;\n\n    for (const param of this.params) {\n      if (param.hasEffects(context)) return true;\n    }\n\n    const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);\n    context.replacedVariableInits.set(this.scope.thisVariable, callOptions.withNew ? new UnknownObjectExpression() : UNKNOWN_EXPRESSION);\n    const {\n      brokenFlow,\n      ignore\n    } = context;\n    context.ignore = {\n      breaks: false,\n      continues: false,\n      labels: new Set(),\n      returnAwaitYield: true\n    };\n    if (this.body.hasEffects(context)) return true;\n    context.brokenFlow = brokenFlow;\n\n    if (thisInit) {\n      context.replacedVariableInits.set(this.scope.thisVariable, thisInit);\n    } else {\n      context.replacedVariableInits.delete(this.scope.thisVariable);\n    }\n\n    context.ignore = ignore;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    if (this.id) this.id.include(context);\n    const hasArguments = this.scope.argumentsVariable.included;\n\n    for (const param of this.params) {\n      if (!(param instanceof Identifier$1) || hasArguments) {\n        param.include(context, includeChildrenRecursively);\n      }\n    }\n\n    const {\n      brokenFlow\n    } = context;\n    context.brokenFlow = BROKEN_FLOW_NONE;\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n  includeCallArguments(context, args) {\n    this.scope.includeCallArguments(context, args);\n  }\n\n  initialise() {\n    if (this.id !== null) {\n      this.id.declare('function', this);\n    }\n\n    this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);\n    this.body.addImplicitReturnExpressionToScope();\n  }\n\n  parseNode(esTreeNode) {\n    this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);\n    super.parseNode(esTreeNode);\n  }\n\n}\n\nFunctionNode.prototype.preventChildBlockScope = true;\n\nclass FunctionDeclaration extends FunctionNode {\n  initialise() {\n    super.initialise();\n\n    if (this.id !== null) {\n      this.id.variable.isId = true;\n    }\n  }\n\n  parseNode(esTreeNode) {\n    if (esTreeNode.id !== null) {\n      this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope.parent);\n    }\n\n    super.parseNode(esTreeNode);\n  }\n\n}\n\nconst WHITESPACE = /\\s/; // The header ends at the first non-white-space after \"default\"\n\nfunction getDeclarationStart(code, start = 0) {\n  start = findFirstOccurrenceOutsideComment(code, 'default', start) + 7;\n\n  while (WHITESPACE.test(code[start])) start++;\n\n  return start;\n}\n\nfunction getIdInsertPosition(code, declarationKeyword, start = 0) {\n  const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;\n  code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, '{', declarationEnd));\n  const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');\n\n  if (generatorStarPos === -1) {\n    return declarationEnd;\n  }\n\n  return declarationEnd + generatorStarPos + 1;\n}\n\nclass ExportDefaultDeclaration extends NodeBase {\n  include(context, includeChildrenRecursively) {\n    super.include(context, includeChildrenRecursively);\n\n    if (includeChildrenRecursively) {\n      this.context.includeVariable(context, this.variable);\n    }\n  }\n\n  initialise() {\n    const declaration = this.declaration;\n    this.declarationName = declaration.id && declaration.id.name || this.declaration.name;\n    this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);\n    this.context.addExport(this);\n  }\n\n  render(code, options, nodeRenderOptions) {\n    const {\n      start,\n      end\n    } = nodeRenderOptions;\n    const declarationStart = getDeclarationStart(code.original, this.start);\n\n    if (this.declaration instanceof FunctionDeclaration) {\n      this.renderNamedDeclaration(code, declarationStart, 'function', this.declaration.id === null, options);\n    } else if (this.declaration instanceof ClassDeclaration) {\n      this.renderNamedDeclaration(code, declarationStart, 'class', this.declaration.id === null, options);\n    } else if (this.variable.getOriginalVariable() !== this.variable) {\n      // Remove altogether to prevent re-declaring the same variable\n      if (options.format === 'system' && this.variable.exportName) {\n        code.overwrite(start, end, `exports('${this.variable.exportName}', ${this.variable.getName()});`);\n      } else {\n        treeshakeNode(this, code, start, end);\n      }\n\n      return;\n    } else if (this.variable.included) {\n      this.renderVariableDeclaration(code, declarationStart, options);\n    } else {\n      code.remove(this.start, declarationStart);\n      this.declaration.render(code, options, {\n        isCalleeOfRenderedParent: false,\n        renderedParentType: ExpressionStatement\n      });\n\n      if (code.original[this.end - 1] !== ';') {\n        code.appendLeft(this.end, ';');\n      }\n\n      return;\n    }\n\n    this.declaration.render(code, options);\n  }\n\n  renderNamedDeclaration(code, declarationStart, declarationKeyword, needsId, options) {\n    const name = this.variable.getName(); // Remove `export default`\n\n    code.remove(this.start, declarationStart);\n\n    if (needsId) {\n      code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, declarationStart), ` ${name}`);\n    }\n\n    if (options.format === 'system' && this.declaration instanceof ClassDeclaration && this.variable.exportName) {\n      code.appendLeft(this.end, ` exports('${this.variable.exportName}', ${name});`);\n    }\n  }\n\n  renderVariableDeclaration(code, declarationStart, options) {\n    const systemBinding = options.format === 'system' && this.variable.exportName ? `exports('${this.variable.exportName}', ` : '';\n    code.overwrite(this.start, declarationStart, `${options.varOrConst} ${this.variable.getName()} = ${systemBinding}`);\n    const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59;\n    /*\";\"*/\n\n    if (systemBinding) {\n      code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));\n    } else if (!hasTrailingSemicolon) {\n      code.appendLeft(this.end, ';');\n    }\n  }\n\n}\n\nExportDefaultDeclaration.prototype.needsBoundaries = true;\n\nclass ExportDefaultVariable extends LocalVariable {\n  constructor(name, exportDefaultDeclaration, context) {\n    super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context);\n    this.hasId = false; // Not initialised during construction\n\n    this.originalId = null;\n    this.originalVariable = null;\n    const declaration = exportDefaultDeclaration.declaration;\n\n    if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) && declaration.id) {\n      this.hasId = true;\n      this.originalId = declaration.id;\n    } else if (declaration instanceof Identifier$1) {\n      this.originalId = declaration;\n    }\n  }\n\n  addReference(identifier) {\n    if (!this.hasId) {\n      this.name = identifier.name;\n    }\n  }\n\n  getAssignedVariableName() {\n    return this.originalId && this.originalId.name || null;\n  }\n\n  getBaseVariableName() {\n    const original = this.getOriginalVariable();\n\n    if (original === this) {\n      return super.getBaseVariableName();\n    } else {\n      return original.getBaseVariableName();\n    }\n  }\n\n  getName() {\n    const original = this.getOriginalVariable();\n\n    if (original === this) {\n      return super.getName();\n    } else {\n      return original.getName();\n    }\n  }\n\n  getOriginalVariable() {\n    if (this.originalVariable === null) {\n      if (!this.originalId || !this.hasId && this.originalId.variable.isReassigned) {\n        this.originalVariable = this;\n      } else {\n        const assignedOriginal = this.originalId.variable;\n        this.originalVariable = assignedOriginal instanceof ExportDefaultVariable ? assignedOriginal.getOriginalVariable() : assignedOriginal;\n      }\n    }\n\n    return this.originalVariable;\n  }\n\n  setRenderNames(baseName, name) {\n    const original = this.getOriginalVariable();\n\n    if (original === this) {\n      super.setRenderNames(baseName, name);\n    } else {\n      original.setRenderNames(baseName, name);\n    }\n  }\n\n  setSafeName(name) {\n    const original = this.getOriginalVariable();\n\n    if (original === this) {\n      super.setSafeName(name);\n    } else {\n      original.setSafeName(name);\n    }\n  }\n\n}\n\nconst MISSING_EXPORT_SHIM_VARIABLE = '_missingExportShim';\nconst INTEROP_DEFAULT_VARIABLE = '_interopDefault';\nconst INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';\n\nclass ExportShimVariable extends Variable {\n  constructor(module) {\n    super(MISSING_EXPORT_SHIM_VARIABLE);\n    this.module = module;\n  }\n\n}\n\nclass NamespaceVariable extends Variable {\n  constructor(context, syntheticNamedExports) {\n    super(context.getModuleName());\n    this.memberVariables = Object.create(null);\n    this.containsExternalNamespace = false;\n    this.referencedEarly = false;\n    this.references = [];\n    this.context = context;\n    this.module = context.module;\n    this.syntheticNamedExports = syntheticNamedExports;\n  }\n\n  addReference(identifier) {\n    this.references.push(identifier);\n    this.name = identifier.name;\n  } // This is only called if \"UNKNOWN_PATH\" is reassigned as in all other situations, either the\n  // build fails due to an illegal namespace reassignment or MemberExpression already forwards\n  // the reassignment to the right variable. This means we lost track of this variable and thus\n  // need to reassign all exports.\n\n\n  deoptimizePath() {\n    for (const key in this.memberVariables) {\n      this.memberVariables[key].deoptimizePath(UNKNOWN_PATH);\n    }\n  }\n\n  include(context) {\n    if (!this.included) {\n      if (this.containsExternalNamespace) {\n        return this.context.error({\n          code: 'NAMESPACE_CANNOT_CONTAIN_EXTERNAL',\n          id: this.module.id,\n          message: `Cannot create an explicit namespace object for module \"${this.context.getModuleName()}\" because it contains a reexported external namespace`\n        });\n      }\n\n      this.included = true;\n\n      for (const identifier of this.references) {\n        if (identifier.context.getModuleExecIndex() <= this.context.getModuleExecIndex()) {\n          this.referencedEarly = true;\n          break;\n        }\n      }\n\n      if (this.context.preserveModules) {\n        for (const memberName of Object.keys(this.memberVariables)) this.memberVariables[memberName].include(context);\n      } else {\n        for (const memberName of Object.keys(this.memberVariables)) this.context.includeVariable(context, this.memberVariables[memberName]);\n      }\n    }\n  }\n\n  initialise() {\n    for (const name of this.context.getExports().concat(this.context.getReexports())) {\n      if (name[0] === '*' && name.length > 1) this.containsExternalNamespace = true;\n      this.memberVariables[name] = this.context.traceExport(name);\n    }\n  }\n\n  renderBlock(options) {\n    const _ = options.compact ? '' : ' ';\n\n    const n = options.compact ? '' : '\\n';\n    const t = options.indent;\n    const members = Object.keys(this.memberVariables).map(name => {\n      const original = this.memberVariables[name];\n\n      if (this.referencedEarly || original.isReassigned) {\n        return `${t}get ${name}${_}()${_}{${_}return ${original.getName()}${options.compact ? '' : ';'}${_}}`;\n      }\n\n      const safeName = RESERVED_NAMES[name] ? `'${name}'` : name;\n      return `${t}${safeName}: ${original.getName()}`;\n    });\n    members.unshift(`${t}__proto__:${_}null`);\n\n    if (options.namespaceToStringTag) {\n      members.unshift(`${t}[Symbol.toStringTag]:${_}'Module'`);\n    }\n\n    const name = this.getName();\n    let output = `{${n}${members.join(`,${n}`)}${n}}`;\n\n    if (this.syntheticNamedExports) {\n      output = `/*#__PURE__*/Object.assign(${output}, ${this.module.getDefaultExport().getName()})`;\n    }\n\n    if (options.freeze) {\n      output = `/*#__PURE__*/Object.freeze(${output})`;\n    }\n\n    output = `${options.varOrConst} ${name}${_}=${_}${output};`;\n\n    if (options.format === 'system' && this.exportName) {\n      output += `${n}exports('${this.exportName}',${_}${name});`;\n    }\n\n    return output;\n  }\n\n  renderFirst() {\n    return this.referencedEarly;\n  }\n\n}\n\nNamespaceVariable.prototype.isNamespace = true;\nconst esModuleExport = `Object.defineProperty(exports, '__esModule', { value: true });`;\nconst compactEsModuleExport = `Object.defineProperty(exports,'__esModule',{value:true});`;\n\nfunction getExportBlock(exports, dependencies, namedExportsMode, interop, compact, t, mechanism = 'return ') {\n  const _ = compact ? '' : ' ';\n\n  const n = compact ? '' : '\\n';\n\n  if (!namedExportsMode) {\n    let local;\n\n    if (exports.length > 0) {\n      local = exports[0].local;\n    } else {\n      for (const dep of dependencies) {\n        if (dep.reexports) {\n          const expt = dep.reexports[0];\n          local = dep.namedExportsMode && expt.imported !== '*' && expt.imported !== 'default' ? `${dep.name}.${expt.imported}` : dep.name;\n          break;\n        }\n      }\n    }\n\n    return `${mechanism}${local};`;\n  }\n\n  let exportBlock = ''; // star exports must always output first for precedence\n\n  for (const {\n    name,\n    reexports\n  } of dependencies) {\n    if (reexports && namedExportsMode) {\n      for (const specifier of reexports) {\n        if (specifier.reexported === '*') {\n          if (exportBlock) exportBlock += n;\n\n          if (specifier.needsLiveBinding) {\n            exportBlock += `Object.keys(${name}).forEach(function${_}(k)${_}{${n}` + `${t}if${_}(k${_}!==${_}'default')${_}Object.defineProperty(exports,${_}k,${_}{${n}` + `${t}${t}enumerable:${_}true,${n}` + `${t}${t}get:${_}function${_}()${_}{${n}` + `${t}${t}${t}return ${name}[k];${n}` + `${t}${t}}${n}${t}});${n}});`;\n          } else {\n            exportBlock += `Object.keys(${name}).forEach(function${_}(k)${_}{${n}` + `${t}if${_}(k${_}!==${_}'default')${_}exports[k]${_}=${_}${name}[k];${n}});`;\n          }\n        }\n      }\n    }\n  }\n\n  for (const {\n    name,\n    imports,\n    reexports,\n    isChunk,\n    namedExportsMode: depNamedExportsMode,\n    exportsNames\n  } of dependencies) {\n    if (reexports && namedExportsMode) {\n      for (const specifier of reexports) {\n        if (specifier.imported === 'default' && !isChunk) {\n          if (exportBlock) exportBlock += n;\n\n          if (exportsNames && (reexports.some(specifier => specifier.imported === 'default' ? specifier.reexported === 'default' : specifier.imported !== '*') || imports && imports.some(specifier => specifier.imported !== 'default'))) {\n            exportBlock += `exports.${specifier.reexported}${_}=${_}${name}${interop !== false ? '__default' : '.default'};`;\n          } else {\n            exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;\n          }\n        } else if (specifier.imported !== '*') {\n          if (exportBlock) exportBlock += n;\n          const importName = specifier.imported === 'default' && !depNamedExportsMode ? name : `${name}.${specifier.imported}`;\n          exportBlock += specifier.needsLiveBinding ? `Object.defineProperty(exports,${_}'${specifier.reexported}',${_}{${n}` + `${t}enumerable:${_}true,${n}` + `${t}get:${_}function${_}()${_}{${n}` + `${t}${t}return ${importName};${n}${t}}${n}});` : `exports.${specifier.reexported}${_}=${_}${importName};`;\n        } else if (specifier.reexported !== '*') {\n          if (exportBlock) exportBlock += n;\n          exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;\n        }\n      }\n    }\n  }\n\n  for (const expt of exports) {\n    const lhs = `exports.${expt.exported}`;\n    const rhs = expt.local;\n\n    if (lhs !== rhs) {\n      if (exportBlock) exportBlock += n;\n      exportBlock += `${lhs}${_}=${_}${rhs};`;\n    }\n  }\n\n  return exportBlock;\n}\n\nfunction getInteropBlock(dependencies, options, varOrConst) {\n  const _ = options.compact ? '' : ' ';\n\n  return dependencies.map(({\n    name,\n    exportsNames,\n    exportsDefault,\n    namedExportsMode\n  }) => {\n    if (!namedExportsMode || !exportsDefault || options.interop === false) return null;\n\n    if (exportsNames) {\n      return `${varOrConst} ${name}__default${_}=${_}'default'${_}in ${name}${_}?` + `${_}${name}['default']${_}:${_}${name};`;\n    }\n\n    return `${name}${_}=${_}${name}${_}&&${_}Object.prototype.hasOwnProperty.call(${name},${_}'default')${_}?` + `${_}${name}['default']${_}:${_}${name};`;\n  }).filter(Boolean).join(options.compact ? '' : '\\n');\n}\n\nfunction copyPropertyLiveBinding(_, n, t, i) {\n  return `${i}var d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` + `${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` + `${i}${t}enumerable:${_}true,${n}` + `${i}${t}get:${_}function${_}()${_}{${n}` + `${i}${t}${t}return e[k];${n}` + `${i}${t}}${n}` + `${i}});${n}`;\n}\n\nfunction copyPropertyStatic(_, n, _t, i) {\n  return `${i}n[k]${_}=e${_}[k];${n}`;\n}\n\nfunction getInteropNamespace(_, n, t, liveBindings) {\n  return `function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n}` + `${t}if${_}(e${_}&&${_}e.__esModule)${_}{${_}return e;${_}}${_}else${_}{${n}` + `${t}${t}var n${_}=${_}{};${n}` + `${t}${t}if${_}(e)${_}{${n}` + `${t}${t}${t}Object.keys(e).forEach(function${_}(k)${_}{${n}` + (liveBindings ? copyPropertyLiveBinding : copyPropertyStatic)(_, n, t, t + t + t + t) + `${t}${t}${t}});${n}` + `${t}${t}}${n}` + `${t}${t}n['default']${_}=${_}e;${n}` + `${t}${t}return n;${n}` + `${t}}${n}` + `}${n}${n}`;\n}\n\nconst builtins$1 = {\n  assert: true,\n  buffer: true,\n  console: true,\n  constants: true,\n  domain: true,\n  events: true,\n  http: true,\n  https: true,\n  os: true,\n  path: true,\n  process: true,\n  punycode: true,\n  querystring: true,\n  stream: true,\n  string_decoder: true,\n  timers: true,\n  tty: true,\n  url: true,\n  util: true,\n  vm: true,\n  zlib: true\n}; // Creating a browser chunk that depends on Node.js built-in modules ('util'). You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins\n\nfunction warnOnBuiltins(warn, dependencies) {\n  const externalBuiltins = dependencies.map(({\n    id\n  }) => id).filter(id => id in builtins$1);\n  if (!externalBuiltins.length) return;\n  const detail = externalBuiltins.length === 1 ? `module ('${externalBuiltins[0]}')` : `modules (${externalBuiltins.slice(0, -1).map(name => `'${name}'`).join(', ')} and '${externalBuiltins.slice(-1)}')`;\n  warn({\n    code: 'MISSING_NODE_BUILTINS',\n    message: `Creating a browser bundle that depends on Node.js built-in ${detail}. You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins`,\n    modules: externalBuiltins\n  });\n} // AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.\n// The assumption is that this makes sense for all relative ids:\n// https://requirejs.org/docs/api.html#jsfiles\n\n\nfunction removeExtensionFromRelativeAmdId(id) {\n  if (id[0] === '.' && id.endsWith('.js')) {\n    return id.slice(0, -3);\n  }\n\n  return id;\n}\n\nfunction amd(magicString, {\n  accessedGlobals,\n  dependencies,\n  exports,\n  hasExports,\n  indentString: t,\n  intro,\n  isEntryModuleFacade,\n  namedExportsMode,\n  outro,\n  varOrConst,\n  warn\n}, options) {\n  warnOnBuiltins(warn, dependencies);\n  const deps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);\n  const args = dependencies.map(m => m.name);\n  const n = options.compact ? '' : '\\n';\n\n  const _ = options.compact ? '' : ' ';\n\n  if (namedExportsMode && hasExports) {\n    args.unshift(`exports`);\n    deps.unshift(`'exports'`);\n  }\n\n  if (accessedGlobals.has('require')) {\n    args.unshift('require');\n    deps.unshift(`'require'`);\n  }\n\n  if (accessedGlobals.has('module')) {\n    args.unshift('module');\n    deps.unshift(`'module'`);\n  }\n\n  const amdOptions = options.amd || {};\n  const params = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) + (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);\n  const useStrict = options.strict !== false ? `${_}'use strict';` : ``;\n  const define = amdOptions.define || 'define';\n  const wrapperStart = `${define}(${params}function${_}(${args.join(`,${_}`)})${_}{${useStrict}${n}${n}`; // var foo__default = 'default' in foo ? foo['default'] : foo;\n\n  const interopBlock = getInteropBlock(dependencies, options, varOrConst);\n\n  if (interopBlock) {\n    magicString.prepend(interopBlock + n + n);\n  }\n\n  if (accessedGlobals.has(INTEROP_NAMESPACE_VARIABLE)) {\n    magicString.prepend(getInteropNamespace(_, n, t, options.externalLiveBindings !== false));\n  }\n\n  if (intro) magicString.prepend(intro);\n  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);\n  if (exportBlock) magicString.append(n + n + exportBlock);\n  if (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule) magicString.append(`${n}${n}${options.compact ? compactEsModuleExport : esModuleExport}`);\n  if (outro) magicString.append(outro);\n  return magicString.indent(t).append(n + n + '});').prepend(wrapperStart);\n}\n\nfunction cjs(magicString, {\n  accessedGlobals,\n  dependencies,\n  exports,\n  hasExports,\n  indentString: t,\n  intro,\n  isEntryModuleFacade,\n  namedExportsMode,\n  outro,\n  varOrConst\n}, options) {\n  const n = options.compact ? '' : '\\n';\n\n  const _ = options.compact ? '' : ' ';\n\n  intro = (options.strict === false ? intro : `'use strict';${n}${n}${intro}`) + (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule ? `${options.compact ? compactEsModuleExport : esModuleExport}${n}${n}` : '');\n  let needsInterop = false;\n  const interop = options.interop !== false;\n  let importBlock;\n  let definingVariable = false;\n  importBlock = '';\n\n  for (const {\n    id,\n    namedExportsMode,\n    isChunk,\n    name,\n    reexports,\n    imports,\n    exportsNames,\n    exportsDefault\n  } of dependencies) {\n    if (!reexports && !imports) {\n      if (importBlock) {\n        importBlock += !options.compact || definingVariable ? `;${n}` : ',';\n      }\n\n      definingVariable = false;\n      importBlock += `require('${id}')`;\n    } else {\n      importBlock += options.compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${varOrConst} `;\n      definingVariable = true;\n\n      if (!interop || isChunk || !exportsDefault || !namedExportsMode) {\n        importBlock += `${name}${_}=${_}require('${id}')`;\n      } else {\n        needsInterop = true;\n        if (exportsNames) importBlock += `${name}${_}=${_}require('${id}')${options.compact ? ',' : `;\\n${varOrConst} `}${name}__default${_}=${_}${INTEROP_DEFAULT_VARIABLE}(${name})`;else importBlock += `${name}${_}=${_}${INTEROP_DEFAULT_VARIABLE}(require('${id}'))`;\n      }\n    }\n  }\n\n  if (importBlock) importBlock += ';';\n\n  if (needsInterop) {\n    const ex = options.compact ? 'e' : 'ex';\n    intro += `function ${INTEROP_DEFAULT_VARIABLE}${_}(${ex})${_}{${_}return${_}` + `(${ex}${_}&&${_}(typeof ${ex}${_}===${_}'object')${_}&&${_}'default'${_}in ${ex})${_}` + `?${_}${ex}['default']${_}:${_}${ex}${options.compact ? '' : '; '}}${n}${n}`;\n  }\n\n  if (accessedGlobals.has(INTEROP_NAMESPACE_VARIABLE)) {\n    intro += getInteropNamespace(_, n, t, options.externalLiveBindings !== false);\n  }\n\n  if (importBlock) intro += importBlock + n + n;\n  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t, `module.exports${_}=${_}`);\n  magicString.prepend(intro);\n  if (exportBlock) magicString.append(n + n + exportBlock);\n  if (outro) magicString.append(outro);\n  return magicString;\n}\n\nfunction esm(magicString, {\n  intro,\n  outro,\n  dependencies,\n  exports\n}, options) {\n  const _ = options.compact ? '' : ' ';\n\n  const n = options.compact ? '' : '\\n';\n  const importBlock = getImportBlock(dependencies, _);\n  if (importBlock.length > 0) intro += importBlock.join(n) + n + n;\n  if (intro) magicString.prepend(intro);\n  const exportBlock = getExportBlock$1(exports, _);\n  if (exportBlock.length) magicString.append(n + n + exportBlock.join(n).trim());\n  if (outro) magicString.append(outro);\n  return magicString.trim();\n}\n\nfunction getImportBlock(dependencies, _) {\n  const importBlock = [];\n\n  for (const {\n    id,\n    reexports,\n    imports,\n    name\n  } of dependencies) {\n    if (!reexports && !imports) {\n      importBlock.push(`import${_}'${id}';`);\n      continue;\n    }\n\n    if (imports) {\n      let defaultImport = null;\n      let starImport = null;\n      const importedNames = [];\n\n      for (const specifier of imports) {\n        if (specifier.imported === 'default') {\n          defaultImport = specifier;\n        } else if (specifier.imported === '*') {\n          starImport = specifier;\n        } else {\n          importedNames.push(specifier);\n        }\n      }\n\n      if (starImport) {\n        importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);\n      }\n\n      if (defaultImport && importedNames.length === 0) {\n        importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);\n      } else if (importedNames.length > 0) {\n        importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames.map(specifier => {\n          if (specifier.imported === specifier.local) {\n            return specifier.imported;\n          } else {\n            return `${specifier.imported} as ${specifier.local}`;\n          }\n        }).join(`,${_}`)}${_}}${_}from${_}'${id}';`);\n      }\n    }\n\n    if (reexports) {\n      let starExport = null;\n      const namespaceReexports = [];\n      const namedReexports = [];\n\n      for (const specifier of reexports) {\n        if (specifier.reexported === '*') {\n          starExport = specifier;\n        } else if (specifier.imported === '*') {\n          namespaceReexports.push(specifier);\n        } else {\n          namedReexports.push(specifier);\n        }\n      }\n\n      if (starExport) {\n        importBlock.push(`export${_}*${_}from${_}'${id}';`);\n      }\n\n      if (namespaceReexports.length > 0) {\n        if (!imports || !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {\n          importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);\n        }\n\n        for (const specifier of namespaceReexports) {\n          importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);\n        }\n      }\n\n      if (namedReexports.length > 0) {\n        importBlock.push(`export${_}{${_}${namedReexports.map(specifier => {\n          if (specifier.imported === specifier.reexported) {\n            return specifier.imported;\n          } else {\n            return `${specifier.imported} as ${specifier.reexported}`;\n          }\n        }).join(`,${_}`)}${_}}${_}from${_}'${id}';`);\n      }\n    }\n  }\n\n  return importBlock;\n}\n\nfunction getExportBlock$1(exports, _) {\n  const exportBlock = [];\n  const exportDeclaration = [];\n\n  for (const specifier of exports) {\n    if (specifier.exported === 'default') {\n      exportBlock.push(`export default ${specifier.local};`);\n    } else {\n      exportDeclaration.push(specifier.exported === specifier.local ? specifier.local : `${specifier.local} as ${specifier.exported}`);\n    }\n  }\n\n  if (exportDeclaration.length) {\n    exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);\n  }\n\n  return exportBlock;\n}\n\nfunction spaces(i) {\n  let result = '';\n\n  while (i--) result += ' ';\n\n  return result;\n}\n\nfunction tabsToSpaces(str) {\n  return str.replace(/^\\t+/, match => match.split('\\t').join('  '));\n}\n\nfunction getCodeFrame(source, line, column) {\n  let lines = source.split('\\n');\n  const frameStart = Math.max(0, line - 3);\n  let frameEnd = Math.min(line + 2, lines.length);\n  lines = lines.slice(frameStart, frameEnd);\n\n  while (!/\\S/.test(lines[lines.length - 1])) {\n    lines.pop();\n    frameEnd -= 1;\n  }\n\n  const digits = String(frameEnd).length;\n  return lines.map((str, i) => {\n    const isErrorLine = frameStart + i + 1 === line;\n    let lineNum = String(i + frameStart + 1);\n\n    while (lineNum.length < digits) lineNum = ` ${lineNum}`;\n\n    if (isErrorLine) {\n      const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';\n      return `${lineNum}: ${tabsToSpaces(str)}\\n${indicator}`;\n    }\n\n    return `${lineNum}: ${tabsToSpaces(str)}`;\n  }).join('\\n');\n}\n\nfunction sanitizeFileName(name) {\n  return name.replace(/[\\0?*]/g, '_');\n}\n\nfunction getAliasName(id) {\n  const base = basename(id);\n  return base.substr(0, base.length - extname(id).length);\n}\n\nfunction relativeId(id) {\n  if (typeof process === 'undefined' || !isAbsolute(id)) return id;\n  return relative$1(process.cwd(), id);\n}\n\nfunction isPlainPathFragment(name) {\n  // not starting with \"/\", \"./\", \"../\"\n  return name[0] !== '/' && !(name[0] === '.' && (name[1] === '/' || name[1] === '.')) && sanitizeFileName(name) === name;\n}\n\nfunction error(base, props) {\n  if (!(base instanceof Error)) base = Object.assign(new Error(base.message), base);\n  if (props) Object.assign(base, props);\n  throw base;\n}\n\nfunction augmentCodeLocation(object, pos, source, id) {\n  if (typeof pos === 'object') {\n    const {\n      line,\n      column\n    } = pos;\n    object.loc = {\n      file: id,\n      line,\n      column\n    };\n  } else {\n    object.pos = pos;\n    const {\n      line,\n      column\n    } = locate(source, pos, {\n      offsetLine: 1\n    });\n    object.loc = {\n      file: id,\n      line,\n      column\n    };\n  }\n\n  if (object.frame === undefined) {\n    const {\n      line,\n      column\n    } = object.loc;\n    object.frame = getCodeFrame(source, line, column);\n  }\n}\n\nvar Errors;\n\n(function (Errors) {\n  Errors[\"ASSET_NOT_FINALISED\"] = \"ASSET_NOT_FINALISED\";\n  Errors[\"ASSET_NOT_FOUND\"] = \"ASSET_NOT_FOUND\";\n  Errors[\"ASSET_SOURCE_ALREADY_SET\"] = \"ASSET_SOURCE_ALREADY_SET\";\n  Errors[\"ASSET_SOURCE_MISSING\"] = \"ASSET_SOURCE_MISSING\";\n  Errors[\"BAD_LOADER\"] = \"BAD_LOADER\";\n  Errors[\"CANNOT_EMIT_FROM_OPTIONS_HOOK\"] = \"CANNOT_EMIT_FROM_OPTIONS_HOOK\";\n  Errors[\"CHUNK_NOT_GENERATED\"] = \"CHUNK_NOT_GENERATED\";\n  Errors[\"DEPRECATED_FEATURE\"] = \"DEPRECATED_FEATURE\";\n  Errors[\"FILE_NOT_FOUND\"] = \"FILE_NOT_FOUND\";\n  Errors[\"FILE_NAME_CONFLICT\"] = \"FILE_NAME_CONFLICT\";\n  Errors[\"INPUT_HOOK_IN_OUTPUT_PLUGIN\"] = \"INPUT_HOOK_IN_OUTPUT_PLUGIN\";\n  Errors[\"INVALID_CHUNK\"] = \"INVALID_CHUNK\";\n  Errors[\"INVALID_EXPORT_OPTION\"] = \"INVALID_EXPORT_OPTION\";\n  Errors[\"INVALID_EXTERNAL_ID\"] = \"INVALID_EXTERNAL_ID\";\n  Errors[\"INVALID_OPTION\"] = \"INVALID_OPTION\";\n  Errors[\"INVALID_PLUGIN_HOOK\"] = \"INVALID_PLUGIN_HOOK\";\n  Errors[\"INVALID_ROLLUP_PHASE\"] = \"INVALID_ROLLUP_PHASE\";\n  Errors[\"MIXED_EXPORTS\"] = \"MIXED_EXPORTS\";\n  Errors[\"NAMESPACE_CONFLICT\"] = \"NAMESPACE_CONFLICT\";\n  Errors[\"PLUGIN_ERROR\"] = \"PLUGIN_ERROR\";\n  Errors[\"UNRESOLVED_ENTRY\"] = \"UNRESOLVED_ENTRY\";\n  Errors[\"UNRESOLVED_IMPORT\"] = \"UNRESOLVED_IMPORT\";\n  Errors[\"VALIDATION_ERROR\"] = \"VALIDATION_ERROR\";\n  Errors[\"EXTERNAL_SYNTHETIC_EXPORTS\"] = \"EXTERNAL_SYNTHETIC_EXPORTS\";\n  Errors[\"SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT\"] = \"SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT\";\n})(Errors || (Errors = {}));\n\nfunction errAssetNotFinalisedForFileName(name) {\n  return {\n    code: Errors.ASSET_NOT_FINALISED,\n    message: `Plugin error - Unable to get file name for asset \"${name}\". Ensure that the source is set and that generate is called first.`\n  };\n}\n\nfunction errCannotEmitFromOptionsHook() {\n  return {\n    code: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,\n    message: `Cannot emit files or set asset sources in the \"outputOptions\" hook, use the \"renderStart\" hook instead.`\n  };\n}\n\nfunction errChunkNotGeneratedForFileName(name) {\n  return {\n    code: Errors.CHUNK_NOT_GENERATED,\n    message: `Plugin error - Unable to get file name for chunk \"${name}\". Ensure that generate is called first.`\n  };\n}\n\nfunction errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {\n  return {\n    code: Errors.ASSET_NOT_FOUND,\n    message: `Plugin error - Unable to set the source for unknown asset \"${assetReferenceId}\".`\n  };\n}\n\nfunction errAssetSourceAlreadySet(name) {\n  return {\n    code: Errors.ASSET_SOURCE_ALREADY_SET,\n    message: `Unable to set the source for asset \"${name}\", source already set.`\n  };\n}\n\nfunction errNoAssetSourceSet(assetName) {\n  return {\n    code: Errors.ASSET_SOURCE_MISSING,\n    message: `Plugin error creating asset \"${assetName}\" - no asset source set.`\n  };\n}\n\nfunction errBadLoader(id) {\n  return {\n    code: Errors.BAD_LOADER,\n    message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`\n  };\n}\n\nfunction errDeprecation(deprecation) {\n  return Object.assign({\n    code: Errors.DEPRECATED_FEATURE\n  }, typeof deprecation === 'string' ? {\n    message: deprecation\n  } : deprecation);\n}\n\nfunction errFileReferenceIdNotFoundForFilename(assetReferenceId) {\n  return {\n    code: Errors.FILE_NOT_FOUND,\n    message: `Plugin error - Unable to get file name for unknown file \"${assetReferenceId}\".`\n  };\n}\n\nfunction errFileNameConflict(fileName) {\n  return {\n    code: Errors.FILE_NAME_CONFLICT,\n    message: `The emitted file \"${fileName}\" overwrites a previously emitted file of the same name.`\n  };\n}\n\nfunction errInputHookInOutputPlugin(pluginName, hookName) {\n  return {\n    code: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,\n    message: `The \"${hookName}\" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`\n  };\n}\n\nfunction errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {\n  return {\n    code: Errors.INVALID_CHUNK,\n    message: `Cannot assign ${relativeId(moduleId)} to the \"${assignToAlias}\" chunk as it is already in the \"${currentAlias}\" chunk.`\n  };\n}\n\nfunction errInvalidExportOptionValue(optionValue) {\n  return {\n    code: Errors.INVALID_EXPORT_OPTION,\n    message: `\"output.exports\" must be \"default\", \"named\", \"none\", \"auto\", or left unspecified (defaults to \"auto\"), received \"${optionValue}\"`,\n    url: `https://rollupjs.org/guide/en/#output-exports`\n  };\n}\n\nfunction errIncompatibleExportOptionValue(optionValue, keys, entryModule) {\n  return {\n    code: 'INVALID_EXPORT_OPTION',\n    message: `\"${optionValue}\" was specified for \"output.exports\", but entry module \"${relativeId(entryModule)}\" has the following exports: ${keys.join(', ')}`\n  };\n}\n\nfunction errInternalIdCannotBeExternal(source, importer) {\n  return {\n    code: Errors.INVALID_EXTERNAL_ID,\n    message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`\n  };\n}\n\nfunction errInvalidOption(option, explanation) {\n  return {\n    code: Errors.INVALID_OPTION,\n    message: `Invalid value for option \"${option}\" - ${explanation}.`\n  };\n}\n\nfunction errInvalidRollupPhaseForAddWatchFile() {\n  return {\n    code: Errors.INVALID_ROLLUP_PHASE,\n    message: `Cannot call addWatchFile after the build has finished.`\n  };\n}\n\nfunction errInvalidRollupPhaseForChunkEmission() {\n  return {\n    code: Errors.INVALID_ROLLUP_PHASE,\n    message: `Cannot emit chunks after module loading has finished.`\n  };\n}\n\nfunction errMixedExport(facadeModuleId, name) {\n  return {\n    code: Errors.MIXED_EXPORTS,\n    id: facadeModuleId,\n    message: `Entry module \"${relativeId(facadeModuleId)}\" is using named and default exports together. Consumers of your bundle will have to use \\`${name || 'chunk'}[\"default\"]\\` to access the default export, which may not be what you want. Use \\`output.exports: \"named\"\\` to disable this warning`,\n    url: `https://rollupjs.org/guide/en/#output-exports`\n  };\n}\n\nfunction errNamespaceConflict(name, reexportingModule, additionalExportAllModule) {\n  return {\n    code: Errors.NAMESPACE_CONFLICT,\n    message: `Conflicting namespaces: ${relativeId(reexportingModule.id)} re-exports '${name}' from both ${relativeId(reexportingModule.exportsAll[name])} and ${relativeId(additionalExportAllModule.exportsAll[name])} (will be ignored)`,\n    name,\n    reexporter: reexportingModule.id,\n    sources: [reexportingModule.exportsAll[name], additionalExportAllModule.exportsAll[name]]\n  };\n}\n\nfunction errEntryCannotBeExternal(unresolvedId) {\n  return {\n    code: Errors.UNRESOLVED_ENTRY,\n    message: `Entry module cannot be external (${relativeId(unresolvedId)}).`\n  };\n}\n\nfunction errUnresolvedEntry(unresolvedId) {\n  return {\n    code: Errors.UNRESOLVED_ENTRY,\n    message: `Could not resolve entry module (${relativeId(unresolvedId)}).`\n  };\n}\n\nfunction errUnresolvedImport(source, importer) {\n  return {\n    code: Errors.UNRESOLVED_IMPORT,\n    message: `Could not resolve '${source}' from ${relativeId(importer)}`\n  };\n}\n\nfunction errUnresolvedImportTreatedAsExternal(source, importer) {\n  return {\n    code: Errors.UNRESOLVED_IMPORT,\n    importer: relativeId(importer),\n    message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved – treating it as an external dependency`,\n    source,\n    url: 'https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency'\n  };\n}\n\nfunction errExternalSyntheticExports(source, importer) {\n  return {\n    code: Errors.EXTERNAL_SYNTHETIC_EXPORTS,\n    importer: relativeId(importer),\n    message: `External '${source}' can not have 'syntheticNamedExports' enabled.`,\n    source\n  };\n}\n\nfunction errFailedValidation(message) {\n  return {\n    code: Errors.VALIDATION_ERROR,\n    message\n  };\n} // Generate strings which dereference dotted properties, but use array notation `['prop-deref']`\n// if the property name isn't trivial\n\n\nconst shouldUseDot = /^[a-zA-Z$_][a-zA-Z0-9$_]*$/;\n\nfunction property(prop) {\n  return shouldUseDot.test(prop) ? `.${prop}` : `['${prop}']`;\n}\n\nfunction keypath(keypath) {\n  return keypath.split('.').map(property).join('');\n}\n\nfunction setupNamespace(name, root, globals, compact) {\n  const parts = name.split('.');\n\n  if (globals) {\n    parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];\n  }\n\n  const _ = compact ? '' : ' ';\n\n  parts.pop();\n  let acc = root;\n  return parts.map(part => (acc += property(part), `${acc}${_}=${_}${acc}${_}||${_}{}${compact ? '' : ';'}`)).join(compact ? ',' : '\\n') + (compact && parts.length ? ';' : '\\n');\n}\n\nfunction assignToDeepVariable(deepName, root, globals, compact, assignment) {\n  const _ = compact ? '' : ' ';\n\n  const parts = deepName.split('.');\n\n  if (globals) {\n    parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];\n  }\n\n  const last = parts.pop();\n  let acc = root;\n  let deepAssignment = parts.map(part => (acc += property(part), `${acc}${_}=${_}${acc}${_}||${_}{}`)).concat(`${acc}${property(last)}`).join(`,${_}`).concat(`${_}=${_}${assignment}`);\n\n  if (parts.length > 0) {\n    deepAssignment = `(${deepAssignment})`;\n  }\n\n  return deepAssignment;\n}\n\nfunction trimEmptyImports(dependencies) {\n  let i = dependencies.length;\n\n  while (i--) {\n    const dependency = dependencies[i];\n\n    if (dependency.exportsDefault || dependency.exportsNames) {\n      return dependencies.slice(0, i + 1);\n    }\n  }\n\n  return [];\n}\n\nconst thisProp = name => `this${keypath(name)}`;\n\nfunction iife(magicString, {\n  dependencies,\n  exports,\n  hasExports,\n  indentString: t,\n  intro,\n  namedExportsMode,\n  outro,\n  varOrConst,\n  warn\n}, options) {\n  const _ = options.compact ? '' : ' ';\n\n  const n = options.compact ? '' : '\\n';\n  const {\n    extend,\n    name\n  } = options;\n  const isNamespaced = name && name.indexOf('.') !== -1;\n  const useVariableAssignment = !extend && !isNamespaced;\n\n  if (name && useVariableAssignment && !isLegal(name)) {\n    return error({\n      code: 'ILLEGAL_IDENTIFIER_AS_NAME',\n      message: `Given name \"${name}\" is not a legal JS identifier. If you need this, you can try \"output.extend: true\".`\n    });\n  }\n\n  warnOnBuiltins(warn, dependencies);\n  const external = trimEmptyImports(dependencies);\n  const deps = external.map(dep => dep.globalName || 'null');\n  const args = external.map(m => m.name);\n\n  if (hasExports && !name) {\n    warn({\n      code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',\n      message: `If you do not supply \"output.name\", you may not be able to access the exports of an IIFE bundle.`\n    });\n  }\n\n  if (namedExportsMode && hasExports) {\n    if (extend) {\n      deps.unshift(`${thisProp(name)}${_}=${_}${thisProp(name)}${_}||${_}{}`);\n      args.unshift('exports');\n    } else {\n      deps.unshift('{}');\n      args.unshift('exports');\n    }\n  }\n\n  const useStrict = options.strict !== false ? `${t}'use strict';${n}${n}` : ``;\n  let wrapperIntro = `(function${_}(${args.join(`,${_}`)})${_}{${n}${useStrict}`;\n\n  if (hasExports && (!extend || !namedExportsMode) && name) {\n    wrapperIntro = (useVariableAssignment ? `${varOrConst} ${name}` : thisProp(name)) + `${_}=${_}${wrapperIntro}`;\n  }\n\n  if (isNamespaced && hasExports) {\n    wrapperIntro = setupNamespace(name, 'this', options.globals, options.compact) + wrapperIntro;\n  }\n\n  let wrapperOutro = `${n}${n}}(${deps.join(`,${_}`)}));`;\n\n  if (!extend && namedExportsMode && hasExports) {\n    wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;\n  } // var foo__default = 'default' in foo ? foo['default'] : foo;\n\n\n  const interopBlock = getInteropBlock(dependencies, options, varOrConst);\n  if (interopBlock) magicString.prepend(interopBlock + n + n);\n  if (intro) magicString.prepend(intro);\n  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);\n  if (exportBlock) magicString.append(n + n + exportBlock);\n  if (outro) magicString.append(outro);\n  return magicString.indent(t).prepend(wrapperIntro).append(wrapperOutro);\n}\n\nfunction getStarExcludes({\n  dependencies,\n  exports\n}) {\n  const starExcludes = new Set(exports.map(expt => expt.exported));\n  if (!starExcludes.has('default')) starExcludes.add('default'); // also include reexport names\n\n  for (const {\n    reexports\n  } of dependencies) {\n    if (reexports) {\n      for (const reexport of reexports) {\n        if (reexport.imported !== '*' && !starExcludes.has(reexport.reexported)) starExcludes.add(reexport.reexported);\n      }\n    }\n  }\n\n  return starExcludes;\n}\n\nconst getStarExcludesBlock = (starExcludes, varOrConst, _, t, n) => starExcludes ? `${n}${t}${varOrConst} _starExcludes${_}=${_}{${_}${Array.from(starExcludes).join(`:${_}1,${_}`)}${starExcludes.size ? `:${_}1` : ''}${_}};` : '';\n\nconst getImportBindingsBlock = (importBindings, _, t, n) => importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '';\n\nfunction getExportsBlock(exports, _, t, n) {\n  if (exports.length === 0) {\n    return '';\n  }\n\n  if (exports.length === 1) {\n    return `${t}${t}${t}exports('${exports[0].name}',${_}${exports[0].value});${n}${n}`;\n  }\n\n  return `${t}${t}${t}exports({${n}` + exports.map(({\n    name,\n    value\n  }) => `${t}${t}${t}${t}${name}:${_}${value}`).join(`,${n}`) + `${n}${t}${t}${t}});${n}${n}`;\n}\n\nconst getHoistedExportsBlock = (exports, _, t, n) => getExportsBlock(exports.filter(expt => expt.hoisted || expt.uninitialized).map(expt => ({\n  name: expt.exported,\n  value: expt.uninitialized ? 'void 0' : expt.local\n})), _, t, n);\n\nconst getMissingExportsBlock = (exports, _, t, n) => getExportsBlock(exports.filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE).map(expt => ({\n  name: expt.exported,\n  value: MISSING_EXPORT_SHIM_VARIABLE\n})), _, t, n);\n\nfunction system(magicString, {\n  accessedGlobals,\n  dependencies,\n  exports,\n  hasExports,\n  indentString: t,\n  intro,\n  outro,\n  usesTopLevelAwait,\n  varOrConst\n}, options) {\n  const n = options.compact ? '' : '\\n';\n\n  const _ = options.compact ? '' : ' ';\n\n  const dependencyIds = dependencies.map(m => `'${m.id}'`);\n  const importBindings = [];\n  let starExcludes;\n  const setters = [];\n\n  for (const {\n    imports,\n    reexports\n  } of dependencies) {\n    const setter = [];\n\n    if (imports) {\n      for (const specifier of imports) {\n        importBindings.push(specifier.local);\n\n        if (specifier.imported === '*') {\n          setter.push(`${specifier.local}${_}=${_}module;`);\n        } else {\n          setter.push(`${specifier.local}${_}=${_}module.${specifier.imported};`);\n        }\n      }\n    }\n\n    if (reexports) {\n      let createdSetter = false; // bulk-reexport form\n\n      if (reexports.length > 1 || reexports.length === 1 && (reexports[0].reexported === '*' || reexports[0].imported === '*')) {\n        // star reexports\n        for (const specifier of reexports) {\n          if (specifier.reexported !== '*') continue; // need own exports list for deduping in star export case\n\n          if (!starExcludes) {\n            starExcludes = getStarExcludes({\n              dependencies,\n              exports\n            });\n          }\n\n          if (!createdSetter) {\n            setter.push(`${varOrConst} _setter${_}=${_}{};`);\n            createdSetter = true;\n          }\n\n          setter.push(`for${_}(var _$p${_}in${_}module)${_}{`);\n          setter.push(`${t}if${_}(!_starExcludes[_$p])${_}_setter[_$p]${_}=${_}module[_$p];`);\n          setter.push('}');\n        } // star import reexport\n\n\n        for (const specifier of reexports) {\n          if (specifier.imported !== '*' || specifier.reexported === '*') continue;\n          setter.push(`exports('${specifier.reexported}',${_}module);`);\n        } // reexports\n\n\n        for (const specifier of reexports) {\n          if (specifier.reexported === '*' || specifier.imported === '*') continue;\n\n          if (!createdSetter) {\n            setter.push(`${varOrConst} _setter${_}=${_}{};`);\n            createdSetter = true;\n          }\n\n          setter.push(`_setter.${specifier.reexported}${_}=${_}module.${specifier.imported};`);\n        }\n\n        if (createdSetter) {\n          setter.push('exports(_setter);');\n        }\n      } else {\n        // single reexport\n        for (const specifier of reexports) {\n          setter.push(`exports('${specifier.reexported}',${_}module.${specifier.imported});`);\n        }\n      }\n    }\n\n    setters.push(setter.join(`${n}${t}${t}${t}`));\n  }\n\n  const registeredName = options.name ? `'${options.name}',${_}` : '';\n  const wrapperParams = accessedGlobals.has('module') ? `exports,${_}module` : hasExports ? 'exports' : '';\n  let wrapperStart = `System.register(${registeredName}[` + dependencyIds.join(`,${_}`) + `],${_}function${_}(${wrapperParams})${_}{${n}${t}${options.strict ? \"'use strict';\" : ''}` + getStarExcludesBlock(starExcludes, varOrConst, _, t, n) + getImportBindingsBlock(importBindings, _, t, n) + `${n}${t}return${_}{${setters.length ? `${n}${t}${t}setters:${_}[${setters.map(s => s ? `function${_}(module)${_}{${n}${t}${t}${t}${s}${n}${t}${t}}` : `function${_}()${_}{}`).join(`,${_}`)}],` : ''}${n}`;\n  wrapperStart += `${t}${t}execute:${_}${usesTopLevelAwait ? `async${_}` : ''}function${_}()${_}{${n}${n}` + getHoistedExportsBlock(exports, _, t, n);\n  const wrapperEnd = `${n}${n}` + getMissingExportsBlock(exports, _, t, n) + `${t}${t}}${n}${t}}${options.compact ? '' : ';'}${n}});`;\n  if (intro) magicString.prepend(intro);\n  if (outro) magicString.append(outro);\n  return magicString.indent(`${t}${t}${t}`).append(wrapperEnd).prepend(wrapperStart);\n}\n\nfunction globalProp(name, globalVar) {\n  if (!name) return 'null';\n  return `${globalVar}${keypath(name)}`;\n}\n\nfunction safeAccess(name, globalVar, _) {\n  const parts = name.split('.');\n  let acc = globalVar;\n  return parts.map(part => (acc += property(part), acc)).join(`${_}&&${_}`);\n}\n\nfunction umd(magicString, {\n  dependencies,\n  exports,\n  hasExports,\n  indentString: t,\n  intro,\n  namedExportsMode,\n  outro,\n  varOrConst,\n  warn\n}, options) {\n  const _ = options.compact ? '' : ' ';\n\n  const n = options.compact ? '' : '\\n';\n  const factoryVar = options.compact ? 'f' : 'factory';\n  const globalVar = options.compact ? 'g' : 'global';\n\n  if (hasExports && !options.name) {\n    return error({\n      code: 'INVALID_OPTION',\n      message: 'You must supply \"output.name\" for UMD bundles.'\n    });\n  }\n\n  warnOnBuiltins(warn, dependencies);\n  const amdDeps = dependencies.map(m => `'${m.id}'`);\n  const cjsDeps = dependencies.map(m => `require('${m.id}')`);\n  const trimmedImports = trimEmptyImports(dependencies);\n  const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar));\n  const factoryArgs = trimmedImports.map(m => m.name);\n\n  if (namedExportsMode && (hasExports || options.noConflict === true)) {\n    amdDeps.unshift(`'exports'`);\n    cjsDeps.unshift(`exports`);\n    globalDeps.unshift(assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${options.extend ? `${globalProp(options.name, globalVar)}${_}||${_}` : ''}{}`));\n    factoryArgs.unshift('exports');\n  }\n\n  const amdOptions = options.amd || {};\n  const amdParams = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) + (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);\n  const define = amdOptions.define || 'define';\n  const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;\n  const useStrict = options.strict !== false ? `${_}'use strict';${n}` : ``;\n  let iifeExport;\n\n  if (options.noConflict === true) {\n    const noConflictExportsVar = options.compact ? 'e' : 'exports';\n    let factory;\n\n    if (!namedExportsMode && hasExports) {\n      factory = `var ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${factoryVar}(${globalDeps.join(`,${_}`)})`)};`;\n    } else if (namedExportsMode) {\n      const module = globalDeps.shift();\n      factory = `var ${noConflictExportsVar}${_}=${_}${module};${n}` + `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;\n    }\n\n    iifeExport = `(function${_}()${_}{${n}` + `${t}${t}var current${_}=${_}${safeAccess(options.name, globalVar, _)};${n}` + `${t}${t}${factory}${n}` + `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}function${_}()${_}{${_}` + `${globalProp(options.name, globalVar)}${_}=${_}current;${_}return ${noConflictExportsVar}${options.compact ? '' : '; '}};${n}` + `${t}}())`;\n  } else {\n    iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;\n\n    if (!namedExportsMode && hasExports) {\n      iifeExport = assignToDeepVariable(options.name, globalVar, options.globals, options.compact, iifeExport);\n    }\n  }\n\n  const iifeNeedsGlobal = hasExports || options.noConflict === true && namedExportsMode || globalDeps.length > 0;\n  const globalParam = iifeNeedsGlobal ? `${globalVar},${_}` : '';\n  const globalArg = iifeNeedsGlobal ? `this,${_}` : '';\n  const iifeStart = iifeNeedsGlobal ? `(${globalVar}${_}=${_}${globalVar}${_}||${_}self,${_}` : '';\n  const iifeEnd = iifeNeedsGlobal ? ')' : '';\n  const cjsIntro = iifeNeedsGlobal ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` + `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}` : ''; // factory function should be wrapped by parentheses to avoid lazy parsing\n\n  const wrapperIntro = `(function${_}(${globalParam}${factoryVar})${_}{${n}` + cjsIntro + `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` + `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` + `}(${globalArg}(function${_}(${factoryArgs.join(', ')})${_}{${useStrict}${n}`;\n  const wrapperOutro = n + n + '})));'; // var foo__default = 'default' in foo ? foo['default'] : foo;\n\n  const interopBlock = getInteropBlock(dependencies, options, varOrConst);\n  if (interopBlock) magicString.prepend(interopBlock + n + n);\n  if (intro) magicString.prepend(intro);\n  const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);\n  if (exportBlock) magicString.append(n + n + exportBlock);\n  if (namedExportsMode && hasExports && options.esModule) magicString.append(n + n + (options.compact ? compactEsModuleExport : esModuleExport));\n  if (outro) magicString.append(outro);\n  return magicString.trim().indent(t).append(wrapperOutro).prepend(wrapperIntro);\n}\n\nvar finalisers = {\n  system,\n  amd,\n  cjs,\n  es: esm,\n  iife,\n  umd\n};\nconst extractors = {\n  ArrayPattern(names, param) {\n    for (const element of param.elements) {\n      if (element) extractors[element.type](names, element);\n    }\n  },\n\n  AssignmentPattern(names, param) {\n    extractors[param.left.type](names, param.left);\n  },\n\n  Identifier(names, param) {\n    names.push(param.name);\n  },\n\n  MemberExpression() {},\n\n  ObjectPattern(names, param) {\n    for (const prop of param.properties) {\n      if (prop.type === 'RestElement') {\n        extractors.RestElement(names, prop);\n      } else {\n        extractors[prop.value.type](names, prop.value);\n      }\n    }\n  },\n\n  RestElement(names, param) {\n    extractors[param.argument.type](names, param.argument);\n  }\n\n};\n\nconst extractAssignedNames = function extractAssignedNames(param) {\n  const names = [];\n  extractors[param.type](names, param);\n  return names;\n};\n\nclass ExportAllDeclaration extends NodeBase {\n  hasEffects() {\n    return false;\n  }\n\n  initialise() {\n    this.context.addExport(this);\n  }\n\n  render(code, _options, nodeRenderOptions) {\n    code.remove(nodeRenderOptions.start, nodeRenderOptions.end);\n  }\n\n}\n\nExportAllDeclaration.prototype.needsBoundaries = true;\n\nclass ArrayExpression extends NodeBase {\n  bind() {\n    super.bind();\n\n    for (const element of this.elements) {\n      if (element !== null) element.deoptimizePath(UNKNOWN_PATH);\n    }\n  }\n\n  getReturnExpressionWhenCalledAtPath(path) {\n    if (path.length !== 1) return UNKNOWN_EXPRESSION;\n    return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length === 1) {\n      return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, context);\n    }\n\n    return true;\n  }\n\n}\n\nclass ArrayPattern extends NodeBase {\n  addExportedVariables(variables) {\n    for (const element of this.elements) {\n      if (element !== null) {\n        element.addExportedVariables(variables);\n      }\n    }\n  }\n\n  declare(kind) {\n    const variables = [];\n\n    for (const element of this.elements) {\n      if (element !== null) {\n        variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));\n      }\n    }\n\n    return variables;\n  }\n\n  deoptimizePath(path) {\n    if (path.length === 0) {\n      for (const element of this.elements) {\n        if (element !== null) {\n          element.deoptimizePath(path);\n        }\n      }\n    }\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (path.length > 0) return true;\n\n    for (const element of this.elements) {\n      if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)) return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass BlockScope extends ChildScope {\n  addDeclaration(identifier, context, init = null, isHoisted) {\n    if (isHoisted) {\n      return this.parent.addDeclaration(identifier, context, isHoisted === 'function' ? init : UNKNOWN_EXPRESSION, isHoisted);\n    } else {\n      return super.addDeclaration(identifier, context, init, false);\n    }\n  }\n\n}\n\nclass ExpressionStatement$1 extends NodeBase {\n  initialise() {\n    if (this.directive && this.directive !== 'use strict' && this.parent.type === Program) {\n      this.context.warn( // This is necessary, because either way (deleting or not) can lead to errors.\n      {\n        code: 'MODULE_LEVEL_DIRECTIVE',\n        message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`\n      }, this.start);\n    }\n  }\n\n  render(code, options) {\n    super.render(code, options);\n    if (this.included) this.insertSemicolon(code);\n  }\n\n  shouldBeIncluded(context) {\n    if (this.directive && this.directive !== 'use strict') return this.parent.type !== Program;\n    return super.shouldBeIncluded(context);\n  }\n\n}\n\nclass BlockStatement$1 extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.directlyIncluded = false;\n  }\n\n  addImplicitReturnExpressionToScope() {\n    const lastStatement = this.body[this.body.length - 1];\n\n    if (!lastStatement || lastStatement.type !== ReturnStatement) {\n      this.scope.addReturnExpression(UNKNOWN_EXPRESSION);\n    }\n  }\n\n  createScope(parentScope) {\n    this.scope = this.parent.preventChildBlockScope ? parentScope : new BlockScope(parentScope);\n  }\n\n  hasEffects(context) {\n    if (this.deoptimizeBody) return true;\n\n    for (const node of this.body) {\n      if (node.hasEffects(context)) return true;\n      if (context.brokenFlow) break;\n    }\n\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    if (!this.deoptimizeBody || !this.directlyIncluded) {\n      this.included = true;\n      this.directlyIncluded = true;\n      if (this.deoptimizeBody) includeChildrenRecursively = true;\n\n      for (const node of this.body) {\n        if (includeChildrenRecursively || node.shouldBeIncluded(context)) node.include(context, includeChildrenRecursively);\n      }\n    }\n  }\n\n  initialise() {\n    const firstBodyStatement = this.body[0];\n    this.deoptimizeBody = firstBodyStatement instanceof ExpressionStatement$1 && firstBodyStatement.directive === 'use asm';\n  }\n\n  render(code, options) {\n    if (this.body.length) {\n      renderStatementList(this.body, code, this.start + 1, this.end - 1, options);\n    } else {\n      super.render(code, options);\n    }\n  }\n\n}\n\nclass ArrowFunctionExpression extends NodeBase {\n  createScope(parentScope) {\n    this.scope = new ReturnValueScope(parentScope, this.context);\n  }\n\n  deoptimizePath(path) {\n    // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track\n    // which means the return expression needs to be reassigned\n    if (path.length === 1 && path[0] === UnknownKey) {\n      this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);\n    }\n  }\n\n  getReturnExpressionWhenCalledAtPath(path) {\n    return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;\n  }\n\n  hasEffects() {\n    return false;\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenAssignedAtPath(path) {\n    return path.length > 1;\n  }\n\n  hasEffectsWhenCalledAtPath(path, _callOptions, context) {\n    if (path.length > 0) return true;\n\n    for (const param of this.params) {\n      if (param.hasEffects(context)) return true;\n    }\n\n    const {\n      ignore,\n      brokenFlow\n    } = context;\n    context.ignore = {\n      breaks: false,\n      continues: false,\n      labels: new Set(),\n      returnAwaitYield: true\n    };\n    if (this.body.hasEffects(context)) return true;\n    context.ignore = ignore;\n    context.brokenFlow = brokenFlow;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    for (const param of this.params) {\n      if (!(param instanceof Identifier$1)) {\n        param.include(context, includeChildrenRecursively);\n      }\n    }\n\n    const {\n      brokenFlow\n    } = context;\n    context.brokenFlow = BROKEN_FLOW_NONE;\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n  includeCallArguments(context, args) {\n    this.scope.includeCallArguments(context, args);\n  }\n\n  initialise() {\n    this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);\n\n    if (this.body instanceof BlockStatement$1) {\n      this.body.addImplicitReturnExpressionToScope();\n    } else {\n      this.scope.addReturnExpression(this.body);\n    }\n  }\n\n  parseNode(esTreeNode) {\n    if (esTreeNode.body.type === BlockStatement) {\n      this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);\n    }\n\n    super.parseNode(esTreeNode);\n  }\n\n}\n\nArrowFunctionExpression.prototype.preventChildBlockScope = true;\n\nfunction getSystemExportStatement(exportedVariables) {\n  if (exportedVariables.length === 1) {\n    return `exports('${exportedVariables[0].safeExportName || exportedVariables[0].exportName}', ${exportedVariables[0].getName()});`;\n  } else {\n    return `exports({${exportedVariables.map(variable => `${variable.safeExportName || variable.exportName}: ${variable.getName()}`).join(', ')}});`;\n  }\n}\n\nclass AssignmentExpression extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.deoptimized = false;\n  }\n\n  hasEffects(context) {\n    if (!this.deoptimized) this.applyDeoptimizations();\n    return this.right.hasEffects(context) || this.left.hasEffects(context) || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    return path.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    if (!this.deoptimized) this.applyDeoptimizations();\n    this.included = true;\n    this.left.include(context, includeChildrenRecursively);\n    this.right.include(context, includeChildrenRecursively);\n  }\n\n  render(code, options) {\n    this.left.render(code, options);\n    this.right.render(code, options);\n\n    if (options.format === 'system') {\n      if (this.left.variable && this.left.variable.exportName) {\n        const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);\n        const operation = this.operator.length > 1 ? ` ${this.left.variable.exportName} ${this.operator.slice(0, -1)}` : '';\n        code.overwrite(operatorPos, operatorPos + this.operator.length, `= exports('${this.left.variable.exportName}',${operation}`);\n        code.appendLeft(this.right.end, `)`);\n      } else if ('addExportedVariables' in this.left) {\n        const systemPatternExports = [];\n        this.left.addExportedVariables(systemPatternExports);\n\n        if (systemPatternExports.length > 0) {\n          code.prependRight(this.start, `function (v) {${getSystemExportStatement(systemPatternExports)} return v;} (`);\n          code.appendLeft(this.end, ')');\n        }\n      }\n    }\n  }\n\n  applyDeoptimizations() {\n    this.deoptimized = true;\n    this.left.deoptimizePath(EMPTY_PATH);\n    this.right.deoptimizePath(UNKNOWN_PATH);\n  }\n\n}\n\nclass AssignmentPattern extends NodeBase {\n  addExportedVariables(variables) {\n    this.left.addExportedVariables(variables);\n  }\n\n  bind() {\n    super.bind();\n    this.left.deoptimizePath(EMPTY_PATH);\n    this.right.deoptimizePath(UNKNOWN_PATH);\n  }\n\n  declare(kind, init) {\n    return this.left.declare(kind, init);\n  }\n\n  deoptimizePath(path) {\n    path.length === 0 && this.left.deoptimizePath(path);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    return path.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n  }\n\n  render(code, options, {\n    isShorthandProperty\n  } = BLANK) {\n    this.left.render(code, options, {\n      isShorthandProperty\n    });\n    this.right.render(code, options);\n  }\n\n}\n\nclass AwaitExpression extends NodeBase {\n  hasEffects(context) {\n    return !context.ignore.returnAwaitYield || this.argument.hasEffects(context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    if (!this.included) {\n      this.included = true;\n\n      checkTopLevelAwait: if (!this.context.usesTopLevelAwait) {\n        let parent = this.parent;\n\n        do {\n          if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression) break checkTopLevelAwait;\n        } while (parent = parent.parent);\n\n        this.context.usesTopLevelAwait = true;\n      }\n    }\n\n    this.argument.include(context, includeChildrenRecursively);\n  }\n\n}\n\nconst binaryOperators = {\n  '!=': (left, right) => left != right,\n  '!==': (left, right) => left !== right,\n  '%': (left, right) => left % right,\n  '&': (left, right) => left & right,\n  '*': (left, right) => left * right,\n  // At the moment, \"**\" will be transpiled to Math.pow\n  '**': (left, right) => Math.pow(left, right),\n  '+': (left, right) => left + right,\n  '-': (left, right) => left - right,\n  '/': (left, right) => left / right,\n  '<': (left, right) => left < right,\n  '<<': (left, right) => left << right,\n  '<=': (left, right) => left <= right,\n  '==': (left, right) => left == right,\n  '===': (left, right) => left === right,\n  '>': (left, right) => left > right,\n  '>=': (left, right) => left >= right,\n  '>>': (left, right) => left >> right,\n  '>>>': (left, right) => left >>> right,\n  '^': (left, right) => left ^ right,\n  in: () => UnknownValue,\n  instanceof: () => UnknownValue,\n  '|': (left, right) => left | right\n};\n\nclass BinaryExpression extends NodeBase {\n  deoptimizeCache() {}\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    if (path.length > 0) return UnknownValue;\n    const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n    if (leftValue === UnknownValue) return UnknownValue;\n    const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n    if (rightValue === UnknownValue) return UnknownValue;\n    const operatorFn = binaryOperators[this.operator];\n    if (!operatorFn) return UnknownValue;\n    return operatorFn(leftValue, rightValue);\n  }\n\n  hasEffects(context) {\n    // support some implicit type coercion runtime errors\n    if (this.operator === '+' && this.parent instanceof ExpressionStatement$1 && this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '') return true;\n    return super.hasEffects(context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n}\n\nclass BreakStatement extends NodeBase {\n  hasEffects(context) {\n    if (this.label) {\n      if (!context.ignore.labels.has(this.label.name)) return true;\n      context.includedLabels.add(this.label.name);\n      context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n    } else {\n      if (!context.ignore.breaks) return true;\n      context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;\n    }\n\n    return false;\n  }\n\n  include(context) {\n    this.included = true;\n\n    if (this.label) {\n      this.label.include(context);\n      context.includedLabels.add(this.label.name);\n    }\n\n    context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;\n  }\n\n}\n\nclass Literal extends NodeBase {\n  getLiteralValueAtPath(path) {\n    if (path.length > 0 || // unknown literals can also be null but do not start with an \"n\"\n    this.value === null && this.context.code.charCodeAt(this.start) !== 110 || typeof this.value === 'bigint' || // to support shims for regular expressions\n    this.context.code.charCodeAt(this.start) === 47) {\n      return UnknownValue;\n    }\n\n    return this.value;\n  }\n\n  getReturnExpressionWhenCalledAtPath(path) {\n    if (path.length !== 1) return UNKNOWN_EXPRESSION;\n    return getMemberReturnExpressionWhenCalled(this.members, path[0]);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    if (this.value === null) {\n      return path.length > 0;\n    }\n\n    return path.length > 1;\n  }\n\n  hasEffectsWhenAssignedAtPath(path) {\n    return path.length > 0;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length === 1) {\n      return hasMemberEffectWhenCalled(this.members, path[0], this.included, callOptions, context);\n    }\n\n    return true;\n  }\n\n  initialise() {\n    this.members = getLiteralMembersForValue(this.value);\n  }\n\n  render(code) {\n    if (typeof this.value === 'string') {\n      code.indentExclusionRanges.push([this.start + 1, this.end - 1]);\n    }\n  }\n\n}\n\nfunction getResolvablePropertyKey(memberExpression) {\n  return memberExpression.computed ? getResolvableComputedPropertyKey(memberExpression.property) : memberExpression.property.name;\n}\n\nfunction getResolvableComputedPropertyKey(propertyKey) {\n  if (propertyKey instanceof Literal) {\n    return String(propertyKey.value);\n  }\n\n  return null;\n}\n\nfunction getPathIfNotComputed(memberExpression) {\n  const nextPathKey = memberExpression.propertyKey;\n  const object = memberExpression.object;\n\n  if (typeof nextPathKey === 'string') {\n    if (object instanceof Identifier$1) {\n      return [{\n        key: object.name,\n        pos: object.start\n      }, {\n        key: nextPathKey,\n        pos: memberExpression.property.start\n      }];\n    }\n\n    if (object instanceof MemberExpression) {\n      const parentPath = getPathIfNotComputed(object);\n      return parentPath && [...parentPath, {\n        key: nextPathKey,\n        pos: memberExpression.property.start\n      }];\n    }\n  }\n\n  return null;\n}\n\nfunction getStringFromPath(path) {\n  let pathString = path[0].key;\n\n  for (let index = 1; index < path.length; index++) {\n    pathString += '.' + path[index].key;\n  }\n\n  return pathString;\n}\n\nclass MemberExpression extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.variable = null;\n    this.bound = false;\n    this.expressionsToBeDeoptimized = [];\n    this.replacement = null;\n    this.wasPathDeoptimizedWhileOptimized = false;\n  }\n\n  addExportedVariables() {}\n\n  bind() {\n    if (this.bound) return;\n    this.bound = true;\n    const path = getPathIfNotComputed(this);\n    const baseVariable = path && this.scope.findVariable(path[0].key);\n\n    if (baseVariable && baseVariable.isNamespace) {\n      const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path.slice(1));\n\n      if (!resolvedVariable) {\n        super.bind();\n      } else if (typeof resolvedVariable === 'string') {\n        this.replacement = resolvedVariable;\n      } else {\n        if (resolvedVariable instanceof ExternalVariable && resolvedVariable.module) {\n          resolvedVariable.module.suggestName(path[0].key);\n        }\n\n        this.variable = resolvedVariable;\n        this.scope.addNamespaceMemberAccess(getStringFromPath(path), resolvedVariable);\n      }\n    } else {\n      super.bind(); // ensure the propertyKey is set for the tree-shaking passes\n\n      this.getPropertyKey();\n    }\n  }\n\n  deoptimizeCache() {\n    const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n    this.expressionsToBeDeoptimized = [];\n    this.propertyKey = UnknownKey;\n\n    if (this.wasPathDeoptimizedWhileOptimized) {\n      this.object.deoptimizePath(UNKNOWN_PATH);\n    }\n\n    for (const expression of expressionsToBeDeoptimized) {\n      expression.deoptimizeCache();\n    }\n  }\n\n  deoptimizePath(path) {\n    if (!this.bound) this.bind();\n    if (path.length === 0) this.disallowNamespaceReassignment();\n\n    if (this.variable) {\n      this.variable.deoptimizePath(path);\n    } else {\n      const propertyKey = this.getPropertyKey();\n\n      if (propertyKey === UnknownKey) {\n        this.object.deoptimizePath(UNKNOWN_PATH);\n      } else {\n        this.wasPathDeoptimizedWhileOptimized = true;\n        this.object.deoptimizePath([propertyKey, ...path]);\n      }\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    if (!this.bound) this.bind();\n\n    if (this.variable !== null) {\n      return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n\n    this.expressionsToBeDeoptimized.push(origin);\n    return this.object.getLiteralValueAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    if (!this.bound) this.bind();\n\n    if (this.variable !== null) {\n      return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    }\n\n    this.expressionsToBeDeoptimized.push(origin);\n    return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);\n  }\n\n  hasEffects(context) {\n    return this.property.hasEffects(context) || this.object.hasEffects(context) || this.context.propertyReadSideEffects && this.object.hasEffectsWhenAccessedAtPath([this.propertyKey], context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (path.length === 0) return false;\n\n    if (this.variable !== null) {\n      return this.variable.hasEffectsWhenAccessedAtPath(path, context);\n    }\n\n    return this.object.hasEffectsWhenAccessedAtPath([this.propertyKey, ...path], context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (this.variable !== null) {\n      return this.variable.hasEffectsWhenAssignedAtPath(path, context);\n    }\n\n    return this.object.hasEffectsWhenAssignedAtPath([this.propertyKey, ...path], context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (this.variable !== null) {\n      return this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n\n    return this.object.hasEffectsWhenCalledAtPath([this.propertyKey, ...path], callOptions, context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    if (!this.included) {\n      this.included = true;\n\n      if (this.variable !== null) {\n        this.context.includeVariable(context, this.variable);\n      }\n    }\n\n    this.object.include(context, includeChildrenRecursively);\n    this.property.include(context, includeChildrenRecursively);\n  }\n\n  includeCallArguments(context, args) {\n    if (this.variable) {\n      this.variable.includeCallArguments(context, args);\n    } else {\n      super.includeCallArguments(context, args);\n    }\n  }\n\n  initialise() {\n    this.propertyKey = getResolvablePropertyKey(this);\n  }\n\n  render(code, options, {\n    renderedParentType,\n    isCalleeOfRenderedParent\n  } = BLANK) {\n    const isCalleeOfDifferentParent = renderedParentType === CallExpression && isCalleeOfRenderedParent;\n\n    if (this.variable || this.replacement) {\n      let replacement = this.variable ? this.variable.getName() : this.replacement;\n      if (isCalleeOfDifferentParent) replacement = '0, ' + replacement;\n      code.overwrite(this.start, this.end, replacement, {\n        contentOnly: true,\n        storeName: true\n      });\n    } else {\n      if (isCalleeOfDifferentParent) {\n        code.appendRight(this.start, '0, ');\n      }\n\n      super.render(code, options);\n    }\n  }\n\n  disallowNamespaceReassignment() {\n    if (this.object instanceof Identifier$1 && this.scope.findVariable(this.object.name).isNamespace) {\n      return this.context.error({\n        code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',\n        message: `Illegal reassignment to import '${this.object.name}'`\n      }, this.start);\n    }\n  }\n\n  getPropertyKey() {\n    if (this.propertyKey === null) {\n      this.propertyKey = UnknownKey;\n      const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n      return this.propertyKey = value === UnknownValue ? UnknownKey : String(value);\n    }\n\n    return this.propertyKey;\n  }\n\n  resolveNamespaceVariables(baseVariable, path) {\n    if (path.length === 0) return baseVariable;\n    if (!baseVariable.isNamespace) return null;\n    const exportName = path[0].key;\n    const variable = baseVariable instanceof ExternalVariable ? baseVariable.module.getVariableForExportName(exportName) : baseVariable.context.traceExport(exportName);\n\n    if (!variable) {\n      const fileName = baseVariable instanceof ExternalVariable ? baseVariable.module.id : baseVariable.context.fileName;\n      this.context.warn({\n        code: 'MISSING_EXPORT',\n        exporter: relativeId(fileName),\n        importer: relativeId(this.context.fileName),\n        message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,\n        missing: exportName,\n        url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`\n      }, path[0].pos);\n      return 'undefined';\n    }\n\n    return this.resolveNamespaceVariables(variable, path.slice(1));\n  }\n\n}\n\nclass CallExpression$1 extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.expressionsToBeDeoptimized = [];\n    this.returnExpression = null;\n    this.wasPathDeoptmizedWhileOptimized = false;\n  }\n\n  bind() {\n    super.bind();\n\n    if (this.callee instanceof Identifier$1) {\n      const variable = this.scope.findVariable(this.callee.name);\n\n      if (variable.isNamespace) {\n        return this.context.error({\n          code: 'CANNOT_CALL_NAMESPACE',\n          message: `Cannot call a namespace ('${this.callee.name}')`\n        }, this.start);\n      }\n\n      if (this.callee.name === 'eval') {\n        this.context.warn({\n          code: 'EVAL',\n          message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,\n          url: 'https://rollupjs.org/guide/en/#avoiding-eval'\n        }, this.start);\n      }\n    } // ensure the returnExpression is set for the tree-shaking passes\n\n\n    this.getReturnExpression(SHARED_RECURSION_TRACKER); // This deoptimizes \"this\" for non-namespace calls until we have a better solution\n\n    if (this.callee instanceof MemberExpression && !this.callee.variable) {\n      this.callee.object.deoptimizePath(UNKNOWN_PATH);\n    }\n\n    for (const argument of this.arguments) {\n      // This will make sure all properties of parameters behave as \"unknown\"\n      argument.deoptimizePath(UNKNOWN_PATH);\n    }\n  }\n\n  deoptimizeCache() {\n    if (this.returnExpression !== UNKNOWN_EXPRESSION) {\n      this.returnExpression = null;\n      const returnExpression = this.getReturnExpression(SHARED_RECURSION_TRACKER);\n      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n\n      if (returnExpression !== UNKNOWN_EXPRESSION) {\n        // We need to replace here because is possible new expressions are added\n        // while we are deoptimizing the old ones\n        this.expressionsToBeDeoptimized = [];\n\n        if (this.wasPathDeoptmizedWhileOptimized) {\n          returnExpression.deoptimizePath(UNKNOWN_PATH);\n          this.wasPathDeoptmizedWhileOptimized = false;\n        }\n      }\n\n      for (const expression of expressionsToBeDeoptimized) {\n        expression.deoptimizeCache();\n      }\n    }\n  }\n\n  deoptimizePath(path) {\n    if (path.length === 0) return;\n    const trackedEntities = this.context.deoptimizationTracker.getEntities(path);\n    if (trackedEntities.has(this)) return;\n    trackedEntities.add(this);\n    const returnExpression = this.getReturnExpression(SHARED_RECURSION_TRACKER);\n\n    if (returnExpression !== UNKNOWN_EXPRESSION) {\n      this.wasPathDeoptmizedWhileOptimized = true;\n      returnExpression.deoptimizePath(path);\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    const returnExpression = this.getReturnExpression(recursionTracker);\n\n    if (returnExpression === UNKNOWN_EXPRESSION) {\n      return UnknownValue;\n    }\n\n    const trackedEntities = recursionTracker.getEntities(path);\n\n    if (trackedEntities.has(returnExpression)) {\n      return UnknownValue;\n    }\n\n    this.expressionsToBeDeoptimized.push(origin);\n    trackedEntities.add(returnExpression);\n    const value = returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);\n    trackedEntities.delete(returnExpression);\n    return value;\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    const returnExpression = this.getReturnExpression(recursionTracker);\n\n    if (this.returnExpression === UNKNOWN_EXPRESSION) {\n      return UNKNOWN_EXPRESSION;\n    }\n\n    const trackedEntities = recursionTracker.getEntities(path);\n\n    if (trackedEntities.has(returnExpression)) {\n      return UNKNOWN_EXPRESSION;\n    }\n\n    this.expressionsToBeDeoptimized.push(origin);\n    trackedEntities.add(returnExpression);\n    const value = returnExpression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    trackedEntities.delete(returnExpression);\n    return value;\n  }\n\n  hasEffects(context) {\n    for (const argument of this.arguments) {\n      if (argument.hasEffects(context)) return true;\n    }\n\n    if (this.context.annotations && this.annotatedPure) return false;\n    return this.callee.hasEffects(context) || this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (path.length === 0) return false;\n    const trackedExpressions = context.accessed.getEntities(path);\n    if (trackedExpressions.has(this)) return false;\n    trackedExpressions.add(this);\n    return this.returnExpression.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (path.length === 0) return true;\n    const trackedExpressions = context.assigned.getEntities(path);\n    if (trackedExpressions.has(this)) return false;\n    trackedExpressions.add(this);\n    return this.returnExpression.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    const trackedExpressions = (callOptions.withNew ? context.instantiated : context.called).getEntities(path);\n    if (trackedExpressions.has(this)) return false;\n    trackedExpressions.add(this);\n    return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    if (includeChildrenRecursively) {\n      super.include(context, includeChildrenRecursively);\n\n      if (includeChildrenRecursively === INCLUDE_PARAMETERS && this.callee instanceof Identifier$1 && this.callee.variable) {\n        this.callee.variable.markCalledFromTryStatement();\n      }\n    } else {\n      this.included = true;\n      this.callee.include(context, false);\n    }\n\n    this.callee.includeCallArguments(context, this.arguments);\n\n    if (!this.returnExpression.included) {\n      this.returnExpression.include(context, false);\n    }\n  }\n\n  initialise() {\n    this.callOptions = {\n      args: this.arguments,\n      withNew: false\n    };\n  }\n\n  render(code, options, {\n    renderedParentType\n  } = BLANK) {\n    this.callee.render(code, options);\n\n    if (this.arguments.length > 0) {\n      if (this.arguments[this.arguments.length - 1].included) {\n        for (const arg of this.arguments) {\n          arg.render(code, options);\n        }\n      } else {\n        let lastIncludedIndex = this.arguments.length - 2;\n\n        while (lastIncludedIndex >= 0 && !this.arguments[lastIncludedIndex].included) {\n          lastIncludedIndex--;\n        }\n\n        if (lastIncludedIndex >= 0) {\n          for (let index = 0; index <= lastIncludedIndex; index++) {\n            this.arguments[index].render(code, options);\n          }\n\n          code.remove(findFirstOccurrenceOutsideComment(code.original, ',', this.arguments[lastIncludedIndex].end), this.end - 1);\n        } else {\n          code.remove(findFirstOccurrenceOutsideComment(code.original, '(', this.callee.end) + 1, this.end - 1);\n        }\n      }\n    }\n\n    if (renderedParentType === ExpressionStatement && this.callee.type === FunctionExpression) {\n      code.appendRight(this.start, '(');\n      code.prependLeft(this.end, ')');\n    }\n  }\n\n  getReturnExpression(recursionTracker) {\n    if (this.returnExpression === null) {\n      this.returnExpression = UNKNOWN_EXPRESSION;\n      return this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, recursionTracker, this);\n    }\n\n    return this.returnExpression;\n  }\n\n}\n\nclass CatchScope extends ParameterScope {\n  addDeclaration(identifier, context, init, isHoisted) {\n    if (isHoisted) {\n      return this.parent.addDeclaration(identifier, context, init, isHoisted);\n    } else {\n      return super.addDeclaration(identifier, context, init, false);\n    }\n  }\n\n}\n\nclass CatchClause extends NodeBase {\n  createScope(parentScope) {\n    this.scope = new CatchScope(parentScope, this.context);\n  }\n\n  initialise() {\n    if (this.param) {\n      this.param.declare('parameter', UNKNOWN_EXPRESSION);\n    }\n  }\n\n  parseNode(esTreeNode) {\n    this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope);\n    super.parseNode(esTreeNode);\n  }\n\n}\n\nCatchClause.prototype.preventChildBlockScope = true;\n\nclass ClassBody extends NodeBase {\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (path.length > 0) return true;\n    return this.classConstructor !== null && this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context);\n  }\n\n  initialise() {\n    for (const method of this.body) {\n      if (method.kind === 'constructor') {\n        this.classConstructor = method;\n        return;\n      }\n    }\n\n    this.classConstructor = null;\n  }\n\n}\n\nclass ClassExpression extends ClassNode {}\n\nclass MultiExpression {\n  constructor(expressions) {\n    this.included = false;\n    this.expressions = expressions;\n  }\n\n  deoptimizePath(path) {\n    for (const expression of this.expressions) {\n      expression.deoptimizePath(path);\n    }\n  }\n\n  getLiteralValueAtPath() {\n    return UnknownValue;\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)));\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    for (const expression of this.expressions) {\n      if (expression.hasEffectsWhenAccessedAtPath(path, context)) return true;\n    }\n\n    return false;\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    for (const expression of this.expressions) {\n      if (expression.hasEffectsWhenAssignedAtPath(path, context)) return true;\n    }\n\n    return false;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    for (const expression of this.expressions) {\n      if (expression.hasEffectsWhenCalledAtPath(path, callOptions, context)) return true;\n    }\n\n    return false;\n  }\n\n  include() {}\n\n  includeCallArguments() {}\n\n}\n\nclass ConditionalExpression extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.expressionsToBeDeoptimized = [];\n    this.isBranchResolutionAnalysed = false;\n    this.usedBranch = null;\n    this.wasPathDeoptimizedWhileOptimized = false;\n  }\n\n  bind() {\n    super.bind(); // ensure the usedBranch is set for the tree-shaking passes\n\n    this.getUsedBranch();\n  }\n\n  deoptimizeCache() {\n    if (this.usedBranch !== null) {\n      const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;\n      this.usedBranch = null;\n      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n      this.expressionsToBeDeoptimized = [];\n\n      if (this.wasPathDeoptimizedWhileOptimized) {\n        unusedBranch.deoptimizePath(UNKNOWN_PATH);\n      }\n\n      for (const expression of expressionsToBeDeoptimized) {\n        expression.deoptimizeCache();\n      }\n    }\n  }\n\n  deoptimizePath(path) {\n    if (path.length > 0) {\n      const usedBranch = this.getUsedBranch();\n\n      if (usedBranch === null) {\n        this.consequent.deoptimizePath(path);\n        this.alternate.deoptimizePath(path);\n      } else {\n        this.wasPathDeoptimizedWhileOptimized = true;\n        usedBranch.deoptimizePath(path);\n      }\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    const usedBranch = this.getUsedBranch();\n    if (usedBranch === null) return UnknownValue;\n    this.expressionsToBeDeoptimized.push(origin);\n    return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    const usedBranch = this.getUsedBranch();\n    if (usedBranch === null) return new MultiExpression([this.consequent.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin), this.alternate.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)]);\n    this.expressionsToBeDeoptimized.push(origin);\n    return usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n  }\n\n  hasEffects(context) {\n    if (this.test.hasEffects(context)) return true;\n\n    if (this.usedBranch === null) {\n      return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);\n    }\n\n    return this.usedBranch.hasEffects(context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (path.length === 0) return false;\n\n    if (this.usedBranch === null) {\n      return this.consequent.hasEffectsWhenAccessedAtPath(path, context) || this.alternate.hasEffectsWhenAccessedAtPath(path, context);\n    }\n\n    return this.usedBranch.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (path.length === 0) return true;\n\n    if (this.usedBranch === null) {\n      return this.consequent.hasEffectsWhenAssignedAtPath(path, context) || this.alternate.hasEffectsWhenAssignedAtPath(path, context);\n    }\n\n    return this.usedBranch.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (this.usedBranch === null) {\n      return this.consequent.hasEffectsWhenCalledAtPath(path, callOptions, context) || this.alternate.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n\n    return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    if (includeChildrenRecursively || this.test.shouldBeIncluded(context) || this.usedBranch === null) {\n      this.test.include(context, includeChildrenRecursively);\n      this.consequent.include(context, includeChildrenRecursively);\n      this.alternate.include(context, includeChildrenRecursively);\n    } else {\n      this.usedBranch.include(context, includeChildrenRecursively);\n    }\n  }\n\n  render(code, options, {\n    renderedParentType,\n    isCalleeOfRenderedParent,\n    preventASI\n  } = BLANK) {\n    if (!this.test.included) {\n      const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);\n      const inclusionStart = (this.consequent.included ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end) : colonPos) + 1;\n\n      if (preventASI) {\n        removeLineBreaks(code, inclusionStart, this.usedBranch.start);\n      }\n\n      code.remove(this.start, inclusionStart);\n\n      if (this.consequent.included) {\n        code.remove(colonPos, this.end);\n      }\n\n      removeAnnotations(this, code);\n      this.usedBranch.render(code, options, {\n        isCalleeOfRenderedParent: renderedParentType ? isCalleeOfRenderedParent : this.parent.callee === this,\n        renderedParentType: renderedParentType || this.parent.type\n      });\n    } else {\n      super.render(code, options);\n    }\n  }\n\n  getUsedBranch() {\n    if (this.isBranchResolutionAnalysed) {\n      return this.usedBranch;\n    }\n\n    this.isBranchResolutionAnalysed = true;\n    const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n    return testValue === UnknownValue ? null : this.usedBranch = testValue ? this.consequent : this.alternate;\n  }\n\n}\n\nclass ContinueStatement extends NodeBase {\n  hasEffects(context) {\n    if (this.label) {\n      if (!context.ignore.labels.has(this.label.name)) return true;\n      context.includedLabels.add(this.label.name);\n      context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n    } else {\n      if (!context.ignore.continues) return true;\n      context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;\n    }\n\n    return false;\n  }\n\n  include(context) {\n    this.included = true;\n\n    if (this.label) {\n      this.label.include(context);\n      context.includedLabels.add(this.label.name);\n    }\n\n    context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;\n  }\n\n}\n\nclass DoWhileStatement extends NodeBase {\n  hasEffects(context) {\n    if (this.test.hasEffects(context)) return true;\n    const {\n      brokenFlow,\n      ignore: {\n        breaks,\n        continues\n      }\n    } = context;\n    context.ignore.breaks = true;\n    context.ignore.continues = true;\n    if (this.body.hasEffects(context)) return true;\n    context.ignore.breaks = breaks;\n    context.ignore.continues = continues;\n    context.brokenFlow = brokenFlow;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    this.test.include(context, includeChildrenRecursively);\n    const {\n      brokenFlow\n    } = context;\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n}\n\nclass EmptyStatement extends NodeBase {\n  hasEffects() {\n    return false;\n  }\n\n}\n\nclass ExportNamedDeclaration extends NodeBase {\n  bind() {\n    // Do not bind specifiers\n    if (this.declaration !== null) this.declaration.bind();\n  }\n\n  hasEffects(context) {\n    return this.declaration !== null && this.declaration.hasEffects(context);\n  }\n\n  initialise() {\n    this.context.addExport(this);\n  }\n\n  render(code, options, nodeRenderOptions) {\n    const {\n      start,\n      end\n    } = nodeRenderOptions;\n\n    if (this.declaration === null) {\n      code.remove(start, end);\n    } else {\n      code.remove(this.start, this.declaration.start);\n      this.declaration.render(code, options, {\n        start,\n        end\n      });\n    }\n  }\n\n}\n\nExportNamedDeclaration.prototype.needsBoundaries = true;\n\nclass ForInStatement extends NodeBase {\n  bind() {\n    this.left.bind();\n    this.left.deoptimizePath(EMPTY_PATH);\n    this.right.bind();\n    this.body.bind();\n  }\n\n  createScope(parentScope) {\n    this.scope = new BlockScope(parentScope);\n  }\n\n  hasEffects(context) {\n    if (this.left && (this.left.hasEffects(context) || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)) || this.right && this.right.hasEffects(context)) return true;\n    const {\n      brokenFlow,\n      ignore: {\n        breaks,\n        continues\n      }\n    } = context;\n    context.ignore.breaks = true;\n    context.ignore.continues = true;\n    if (this.body.hasEffects(context)) return true;\n    context.ignore.breaks = breaks;\n    context.ignore.continues = continues;\n    context.brokenFlow = brokenFlow;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    this.left.includeWithAllDeclaredVariables(includeChildrenRecursively, context);\n    this.left.deoptimizePath(EMPTY_PATH);\n    this.right.include(context, includeChildrenRecursively);\n    const {\n      brokenFlow\n    } = context;\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n  render(code, options) {\n    this.left.render(code, options, NO_SEMICOLON);\n    this.right.render(code, options, NO_SEMICOLON); // handle no space between \"in\" and the right side\n\n    if (code.original.charCodeAt(this.right.start - 1) === 110\n    /* n */\n    ) {\n        code.prependLeft(this.right.start, ' ');\n      }\n\n    this.body.render(code, options);\n  }\n\n}\n\nclass ForOfStatement extends NodeBase {\n  bind() {\n    this.left.bind();\n    this.left.deoptimizePath(EMPTY_PATH);\n    this.right.bind();\n    this.body.bind();\n  }\n\n  createScope(parentScope) {\n    this.scope = new BlockScope(parentScope);\n  }\n\n  hasEffects() {\n    // Placeholder until proper Symbol.Iterator support\n    return true;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    this.left.includeWithAllDeclaredVariables(includeChildrenRecursively, context);\n    this.left.deoptimizePath(EMPTY_PATH);\n    this.right.include(context, includeChildrenRecursively);\n    const {\n      brokenFlow\n    } = context;\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n  render(code, options) {\n    this.left.render(code, options, NO_SEMICOLON);\n    this.right.render(code, options, NO_SEMICOLON); // handle no space between \"of\" and the right side\n\n    if (code.original.charCodeAt(this.right.start - 1) === 102\n    /* f */\n    ) {\n        code.prependLeft(this.right.start, ' ');\n      }\n\n    this.body.render(code, options);\n  }\n\n}\n\nclass ForStatement extends NodeBase {\n  createScope(parentScope) {\n    this.scope = new BlockScope(parentScope);\n  }\n\n  hasEffects(context) {\n    if (this.init && this.init.hasEffects(context) || this.test && this.test.hasEffects(context) || this.update && this.update.hasEffects(context)) return true;\n    const {\n      brokenFlow,\n      ignore: {\n        breaks,\n        continues\n      }\n    } = context;\n    context.ignore.breaks = true;\n    context.ignore.continues = true;\n    if (this.body.hasEffects(context)) return true;\n    context.ignore.breaks = breaks;\n    context.ignore.continues = continues;\n    context.brokenFlow = brokenFlow;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    if (this.init) this.init.include(context, includeChildrenRecursively);\n    if (this.test) this.test.include(context, includeChildrenRecursively);\n    const {\n      brokenFlow\n    } = context;\n    if (this.update) this.update.include(context, includeChildrenRecursively);\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n  render(code, options) {\n    if (this.init) this.init.render(code, options, NO_SEMICOLON);\n    if (this.test) this.test.render(code, options, NO_SEMICOLON);\n    if (this.update) this.update.render(code, options, NO_SEMICOLON);\n    this.body.render(code, options);\n  }\n\n}\n\nclass FunctionExpression$1 extends FunctionNode {}\n\nconst unset = Symbol('unset');\n\nclass IfStatement extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.testValue = unset;\n  }\n\n  deoptimizeCache() {\n    this.testValue = UnknownValue;\n  }\n\n  hasEffects(context) {\n    if (this.test.hasEffects(context)) {\n      return true;\n    }\n\n    const testValue = this.getTestValue();\n\n    if (testValue === UnknownValue) {\n      const {\n        brokenFlow\n      } = context;\n      if (this.consequent.hasEffects(context)) return true;\n      const consequentBrokenFlow = context.brokenFlow;\n      context.brokenFlow = brokenFlow;\n      if (this.alternate === null) return false;\n      if (this.alternate.hasEffects(context)) return true;\n      context.brokenFlow = context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;\n      return false;\n    }\n\n    return testValue ? this.consequent.hasEffects(context) : this.alternate !== null && this.alternate.hasEffects(context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    if (includeChildrenRecursively) {\n      this.includeRecursively(includeChildrenRecursively, context);\n    } else {\n      const testValue = this.getTestValue();\n\n      if (testValue === UnknownValue) {\n        this.includeUnknownTest(context);\n      } else {\n        this.includeKnownTest(context, testValue);\n      }\n    }\n  }\n\n  render(code, options) {\n    // Note that unknown test values are always included\n    const testValue = this.getTestValue();\n\n    if (!this.test.included && (testValue ? this.alternate === null || !this.alternate.included : !this.consequent.included)) {\n      const singleRetainedBranch = testValue ? this.consequent : this.alternate;\n      code.remove(this.start, singleRetainedBranch.start);\n      code.remove(singleRetainedBranch.end, this.end);\n      removeAnnotations(this, code);\n      singleRetainedBranch.render(code, options);\n    } else {\n      if (this.test.included) {\n        this.test.render(code, options);\n      } else {\n        code.overwrite(this.test.start, this.test.end, testValue ? 'true' : 'false');\n      }\n\n      if (this.consequent.included) {\n        this.consequent.render(code, options);\n      } else {\n        code.overwrite(this.consequent.start, this.consequent.end, ';');\n      }\n\n      if (this.alternate !== null) {\n        if (this.alternate.included) {\n          if (code.original.charCodeAt(this.alternate.start - 1) === 101\n          /* e */\n          ) {\n              code.prependLeft(this.alternate.start, ' ');\n            }\n\n          this.alternate.render(code, options);\n        } else {\n          code.remove(this.consequent.end, this.alternate.end);\n        }\n      }\n    }\n  }\n\n  getTestValue() {\n    if (this.testValue === unset) {\n      return this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n    }\n\n    return this.testValue;\n  }\n\n  includeKnownTest(context, testValue) {\n    if (this.test.shouldBeIncluded(context)) {\n      this.test.include(context, false);\n    }\n\n    if (testValue && this.consequent.shouldBeIncluded(context)) {\n      this.consequent.include(context, false);\n    }\n\n    if (this.alternate !== null && !testValue && this.alternate.shouldBeIncluded(context)) {\n      this.alternate.include(context, false);\n    }\n  }\n\n  includeRecursively(includeChildrenRecursively, context) {\n    this.test.include(context, includeChildrenRecursively);\n    this.consequent.include(context, includeChildrenRecursively);\n\n    if (this.alternate !== null) {\n      this.alternate.include(context, includeChildrenRecursively);\n    }\n  }\n\n  includeUnknownTest(context) {\n    this.test.include(context, false);\n    const {\n      brokenFlow\n    } = context;\n    let consequentBrokenFlow = BROKEN_FLOW_NONE;\n\n    if (this.consequent.shouldBeIncluded(context)) {\n      this.consequent.include(context, false);\n      consequentBrokenFlow = context.brokenFlow;\n      context.brokenFlow = brokenFlow;\n    }\n\n    if (this.alternate !== null && this.alternate.shouldBeIncluded(context)) {\n      this.alternate.include(context, false);\n      context.brokenFlow = context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;\n    }\n  }\n\n}\n\nclass ImportDeclaration extends NodeBase {\n  bind() {}\n\n  hasEffects() {\n    return false;\n  }\n\n  initialise() {\n    this.context.addImport(this);\n  }\n\n  render(code, _options, nodeRenderOptions) {\n    code.remove(nodeRenderOptions.start, nodeRenderOptions.end);\n  }\n\n}\n\nImportDeclaration.prototype.needsBoundaries = true;\n\nclass Import extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.exportMode = 'auto';\n  }\n\n  hasEffects() {\n    return true;\n  }\n\n  include(context, includeChildrenRecursively) {\n    if (!this.included) {\n      this.included = true;\n      this.context.includeDynamicImport(this);\n      this.scope.addAccessedDynamicImport(this);\n    }\n\n    this.source.include(context, includeChildrenRecursively);\n  }\n\n  initialise() {\n    this.context.addDynamicImport(this);\n  }\n\n  render(code, options) {\n    if (this.inlineNamespace) {\n      const _ = options.compact ? '' : ' ';\n\n      const s = options.compact ? '' : ';';\n      code.overwrite(this.start, this.end, `Promise.resolve().then(function${_}()${_}{${_}return ${this.inlineNamespace.getName()}${s}${_}})`);\n      return;\n    }\n\n    const importMechanism = this.getDynamicImportMechanism(options);\n\n    if (importMechanism) {\n      code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, importMechanism.left);\n      code.overwrite(this.end - 1, this.end, importMechanism.right);\n    }\n\n    this.source.render(code, options);\n  }\n\n  renderFinalResolution(code, resolution, format) {\n    if (this.included) {\n      if (format === 'amd' && resolution.startsWith(\"'.\") && resolution.endsWith(\".js'\")) {\n        resolution = resolution.slice(0, -4) + \"'\";\n      }\n\n      code.overwrite(this.source.start, this.source.end, resolution);\n    }\n  }\n\n  setResolution(exportMode, inlineNamespace) {\n    this.exportMode = exportMode;\n\n    if (inlineNamespace) {\n      this.inlineNamespace = inlineNamespace;\n    } else {\n      this.scope.addAccessedGlobalsByFormat({\n        amd: ['require'],\n        cjs: ['require'],\n        system: ['module']\n      });\n\n      if (exportMode === 'auto') {\n        this.scope.addAccessedGlobalsByFormat({\n          amd: [INTEROP_NAMESPACE_VARIABLE],\n          cjs: [INTEROP_NAMESPACE_VARIABLE]\n        });\n      }\n    }\n  }\n\n  getDynamicImportMechanism(options) {\n    switch (options.format) {\n      case 'cjs':\n        {\n          const _ = options.compact ? '' : ' ';\n\n          const resolve = options.compact ? 'c' : 'resolve';\n\n          switch (this.exportMode) {\n            case 'default':\n              return {\n                left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}({${_}'default':${_}require(`,\n                right: `)${_}});${_}})`\n              };\n\n            case 'auto':\n              return {\n                left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}(${INTEROP_NAMESPACE_VARIABLE}(require(`,\n                right: `)));${_}})`\n              };\n\n            default:\n              return {\n                left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}(require(`,\n                right: `));${_}})`\n              };\n          }\n        }\n\n      case 'amd':\n        {\n          const _ = options.compact ? '' : ' ';\n\n          const resolve = options.compact ? 'c' : 'resolve';\n          const reject = options.compact ? 'e' : 'reject';\n          const resolveNamespace = this.exportMode === 'default' ? `function${_}(m)${_}{${_}${resolve}({${_}'default':${_}m${_}});${_}}` : this.exportMode === 'auto' ? `function${_}(m)${_}{${_}${resolve}(${INTEROP_NAMESPACE_VARIABLE}(m));${_}}` : resolve;\n          return {\n            left: `new Promise(function${_}(${resolve},${_}${reject})${_}{${_}require([`,\n            right: `],${_}${resolveNamespace},${_}${reject})${_}})`\n          };\n        }\n\n      case 'system':\n        return {\n          left: 'module.import(',\n          right: ')'\n        };\n\n      case 'es':\n        if (options.dynamicImportFunction) {\n          return {\n            left: `${options.dynamicImportFunction}(`,\n            right: ')'\n          };\n        }\n\n    }\n\n    return null;\n  }\n\n}\n\nclass LabeledStatement extends NodeBase {\n  hasEffects(context) {\n    const brokenFlow = context.brokenFlow;\n    context.ignore.labels.add(this.label.name);\n    if (this.body.hasEffects(context)) return true;\n    context.ignore.labels.delete(this.label.name);\n\n    if (context.includedLabels.has(this.label.name)) {\n      context.includedLabels.delete(this.label.name);\n      context.brokenFlow = brokenFlow;\n    }\n\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    const brokenFlow = context.brokenFlow;\n    this.body.include(context, includeChildrenRecursively);\n\n    if (context.includedLabels.has(this.label.name)) {\n      this.label.include(context);\n      context.includedLabels.delete(this.label.name);\n      context.brokenFlow = brokenFlow;\n    }\n  }\n\n  render(code, options) {\n    if (this.label.included) {\n      this.label.render(code, options);\n    } else {\n      code.remove(this.start, findFirstOccurrenceOutsideComment(code.original, ':', this.label.end) + 1);\n    }\n\n    this.body.render(code, options);\n  }\n\n}\n\nclass LogicalExpression extends NodeBase {\n  constructor() {\n    super(...arguments); // We collect deoptimization information if usedBranch !== null\n\n    this.expressionsToBeDeoptimized = [];\n    this.isBranchResolutionAnalysed = false;\n    this.unusedBranch = null;\n    this.usedBranch = null;\n    this.wasPathDeoptimizedWhileOptimized = false;\n  }\n\n  bind() {\n    super.bind(); // ensure the usedBranch is set for the tree-shaking passes\n\n    this.getUsedBranch();\n  }\n\n  deoptimizeCache() {\n    if (this.usedBranch !== null) {\n      this.usedBranch = null;\n      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n      this.expressionsToBeDeoptimized = [];\n\n      if (this.wasPathDeoptimizedWhileOptimized) {\n        this.unusedBranch.deoptimizePath(UNKNOWN_PATH);\n      }\n\n      for (const expression of expressionsToBeDeoptimized) {\n        expression.deoptimizeCache();\n      }\n    }\n  }\n\n  deoptimizePath(path) {\n    const usedBranch = this.getUsedBranch();\n\n    if (usedBranch === null) {\n      this.left.deoptimizePath(path);\n      this.right.deoptimizePath(path);\n    } else {\n      this.wasPathDeoptimizedWhileOptimized = true;\n      usedBranch.deoptimizePath(path);\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    const usedBranch = this.getUsedBranch();\n    if (usedBranch === null) return UnknownValue;\n    this.expressionsToBeDeoptimized.push(origin);\n    return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    const usedBranch = this.getUsedBranch();\n    if (usedBranch === null) return new MultiExpression([this.left.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin), this.right.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)]);\n    this.expressionsToBeDeoptimized.push(origin);\n    return usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n  }\n\n  hasEffects(context) {\n    if (this.usedBranch === null) {\n      return this.left.hasEffects(context) || this.right.hasEffects(context);\n    }\n\n    return this.usedBranch.hasEffects(context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (path.length === 0) return false;\n\n    if (this.usedBranch === null) {\n      return this.left.hasEffectsWhenAccessedAtPath(path, context) || this.right.hasEffectsWhenAccessedAtPath(path, context);\n    }\n\n    return this.usedBranch.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (path.length === 0) return true;\n\n    if (this.usedBranch === null) {\n      return this.left.hasEffectsWhenAssignedAtPath(path, context) || this.right.hasEffectsWhenAssignedAtPath(path, context);\n    }\n\n    return this.usedBranch.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (this.usedBranch === null) {\n      return this.left.hasEffectsWhenCalledAtPath(path, callOptions, context) || this.right.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n\n    return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    if (includeChildrenRecursively || this.usedBranch === this.right && this.left.shouldBeIncluded(context) || this.usedBranch === null) {\n      this.left.include(context, includeChildrenRecursively);\n      this.right.include(context, includeChildrenRecursively);\n    } else {\n      this.usedBranch.include(context, includeChildrenRecursively);\n    }\n  }\n\n  render(code, options, {\n    renderedParentType,\n    isCalleeOfRenderedParent,\n    preventASI\n  } = BLANK) {\n    if (!this.left.included || !this.right.included) {\n      const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);\n\n      if (this.right.included) {\n        code.remove(this.start, operatorPos + 2);\n\n        if (preventASI) {\n          removeLineBreaks(code, operatorPos + 2, this.right.start);\n        }\n      } else {\n        code.remove(operatorPos, this.end);\n      }\n\n      removeAnnotations(this, code);\n      this.usedBranch.render(code, options, {\n        isCalleeOfRenderedParent: renderedParentType ? isCalleeOfRenderedParent : this.parent.callee === this,\n        renderedParentType: renderedParentType || this.parent.type\n      });\n    } else {\n      super.render(code, options);\n    }\n  }\n\n  getUsedBranch() {\n    if (!this.isBranchResolutionAnalysed) {\n      this.isBranchResolutionAnalysed = true;\n      const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n\n      if (leftValue === UnknownValue) {\n        return null;\n      } else {\n        if (this.operator === '||' ? leftValue : !leftValue) {\n          this.usedBranch = this.left;\n          this.unusedBranch = this.right;\n        } else {\n          this.usedBranch = this.right;\n          this.unusedBranch = this.left;\n        }\n      }\n    }\n\n    return this.usedBranch;\n  }\n\n}\n\nconst readFile = file => new Promise((fulfil, reject) => readFile$1(file, 'utf-8', (err, contents) => err ? reject(err) : fulfil(contents)));\n\nfunction mkdirpath(path) {\n  const dir = dirname(path);\n\n  try {\n    readdirSync(dir);\n  } catch (err) {\n    mkdirpath(dir);\n\n    try {\n      mkdirSync(dir);\n    } catch (err2) {\n      if (err2.code !== 'EEXIST') {\n        throw err2;\n      }\n    }\n  }\n}\n\nfunction writeFile(dest, data) {\n  return new Promise((fulfil, reject) => {\n    mkdirpath(dest);\n    writeFile$1(dest, data, err => {\n      if (err) {\n        reject(err);\n      } else {\n        fulfil();\n      }\n    });\n  });\n}\n\nfunction getRollupDefaultPlugin(preserveSymlinks) {\n  return {\n    name: 'Rollup Core',\n    resolveId: createResolveId(preserveSymlinks),\n\n    load(id) {\n      return readFile(id);\n    },\n\n    resolveFileUrl({\n      relativePath,\n      format\n    }) {\n      return relativeUrlMechanisms[format](relativePath);\n    },\n\n    resolveImportMeta(prop, {\n      chunkId,\n      format\n    }) {\n      const mechanism = importMetaMechanisms[format] && importMetaMechanisms[format](prop, chunkId);\n\n      if (mechanism) {\n        return mechanism;\n      }\n    }\n\n  };\n}\n\nfunction findFile(file, preserveSymlinks) {\n  try {\n    const stats = lstatSync(file);\n    if (!preserveSymlinks && stats.isSymbolicLink()) return findFile(realpathSync(file), preserveSymlinks);\n\n    if (preserveSymlinks && stats.isSymbolicLink() || stats.isFile()) {\n      // check case\n      const name = basename(file);\n      const files = readdirSync(dirname(file));\n      if (files.indexOf(name) !== -1) return file;\n    }\n  } catch (err) {// suppress\n  }\n}\n\nfunction addJsExtensionIfNecessary(file, preserveSymlinks) {\n  let found = findFile(file, preserveSymlinks);\n  if (found) return found;\n  found = findFile(file + '.mjs', preserveSymlinks);\n  if (found) return found;\n  found = findFile(file + '.js', preserveSymlinks);\n  return found;\n}\n\nfunction createResolveId(preserveSymlinks) {\n  return function (source, importer) {\n    if (typeof process === 'undefined') {\n      return error({\n        code: 'MISSING_PROCESS',\n        message: `It looks like you're using Rollup in a non-Node.js environment. This means you must supply a plugin with custom resolveId and load functions`,\n        url: 'https://rollupjs.org/guide/en/#a-simple-example'\n      });\n    } // external modules (non-entry modules that start with neither '.' or '/')\n    // are skipped at this stage.\n\n\n    if (importer !== undefined && !isAbsolute(source) && source[0] !== '.') return null; // `resolve` processes paths from right to left, prepending them until an\n    // absolute path is created. Absolute importees therefore shortcircuit the\n    // resolve call and require no special handing on our part.\n    // See https://nodejs.org/api/path.html#path_path_resolve_paths\n\n    return addJsExtensionIfNecessary(resolve(importer ? dirname(importer) : resolve(), source), preserveSymlinks);\n  };\n}\n\nconst getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;\n\nconst getUrlFromDocument = chunkId => `(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;\n\nconst getGenericImportMetaMechanism = getUrl => (prop, chunkId) => {\n  const urlMechanism = getUrl(chunkId);\n  return prop === null ? `({ url: ${urlMechanism} })` : prop === 'url' ? urlMechanism : 'undefined';\n};\n\nconst importMetaMechanisms = {\n  amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),\n  cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),\n  iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),\n  system: prop => prop === null ? `module.meta` : `module.meta.${prop}`,\n  umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`)\n};\n\nconst getRelativeUrlFromDocument = relativePath => getResolveUrl(`'${relativePath}', document.currentScript && document.currentScript.src || document.baseURI`);\n\nconst relativeUrlMechanisms = {\n  amd: relativePath => {\n    if (relativePath[0] !== '.') relativePath = './' + relativePath;\n    return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);\n  },\n  cjs: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,\n  es: relativePath => getResolveUrl(`'${relativePath}', import.meta.url`),\n  iife: relativePath => getRelativeUrlFromDocument(relativePath),\n  system: relativePath => getResolveUrl(`'${relativePath}', module.meta.url`),\n  umd: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`\n};\nconst accessedMetaUrlGlobals = {\n  amd: ['document', 'module', 'URL'],\n  cjs: ['document', 'require', 'URL'],\n  iife: ['document', 'URL'],\n  system: ['module'],\n  umd: ['document', 'require', 'URL']\n};\nconst accessedFileUrlGlobals = {\n  amd: ['document', 'require', 'URL'],\n  cjs: ['document', 'require', 'URL'],\n  iife: ['document', 'URL'],\n  system: ['module', 'URL'],\n  umd: ['document', 'require', 'URL']\n};\nconst ASSET_PREFIX = 'ROLLUP_ASSET_URL_';\nconst CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';\nconst FILE_PREFIX = 'ROLLUP_FILE_URL_';\n\nclass MetaProperty extends NodeBase {\n  hasEffects() {\n    return false;\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  include() {\n    if (!this.included) {\n      this.included = true;\n      const parent = this.parent;\n      const metaProperty = this.metaProperty = parent instanceof MemberExpression && typeof parent.propertyKey === 'string' ? parent.propertyKey : null;\n\n      if (metaProperty && (metaProperty.startsWith(FILE_PREFIX) || metaProperty.startsWith(ASSET_PREFIX) || metaProperty.startsWith(CHUNK_PREFIX))) {\n        this.scope.addAccessedGlobalsByFormat(accessedFileUrlGlobals);\n      } else {\n        this.scope.addAccessedGlobalsByFormat(accessedMetaUrlGlobals);\n      }\n    }\n  }\n\n  initialise() {\n    if (this.meta.name === 'import') {\n      this.context.addImportMeta(this);\n    }\n  }\n\n  renderFinalMechanism(code, chunkId, format, outputPluginDriver) {\n    if (!this.included) return;\n    const parent = this.parent;\n    const metaProperty = this.metaProperty;\n\n    if (metaProperty && (metaProperty.startsWith(FILE_PREFIX) || metaProperty.startsWith(ASSET_PREFIX) || metaProperty.startsWith(CHUNK_PREFIX))) {\n      let referenceId = null;\n      let assetReferenceId = null;\n      let chunkReferenceId = null;\n      let fileName;\n\n      if (metaProperty.startsWith(FILE_PREFIX)) {\n        referenceId = metaProperty.substr(FILE_PREFIX.length);\n        fileName = outputPluginDriver.getFileName(referenceId);\n      } else if (metaProperty.startsWith(ASSET_PREFIX)) {\n        this.context.warnDeprecation(`Using the \"${ASSET_PREFIX}\" prefix to reference files is deprecated. Use the \"${FILE_PREFIX}\" prefix instead.`, false);\n        assetReferenceId = metaProperty.substr(ASSET_PREFIX.length);\n        fileName = outputPluginDriver.getFileName(assetReferenceId);\n      } else {\n        this.context.warnDeprecation(`Using the \"${CHUNK_PREFIX}\" prefix to reference files is deprecated. Use the \"${FILE_PREFIX}\" prefix instead.`, false);\n        chunkReferenceId = metaProperty.substr(CHUNK_PREFIX.length);\n        fileName = outputPluginDriver.getFileName(chunkReferenceId);\n      }\n\n      const relativePath = normalize(relative$1(dirname(chunkId), fileName));\n      let replacement;\n\n      if (assetReferenceId !== null) {\n        replacement = outputPluginDriver.hookFirstSync('resolveAssetUrl', [{\n          assetFileName: fileName,\n          chunkId,\n          format,\n          moduleId: this.context.module.id,\n          relativeAssetPath: relativePath\n        }]);\n      }\n\n      if (!replacement) {\n        replacement = outputPluginDriver.hookFirstSync('resolveFileUrl', [{\n          assetReferenceId,\n          chunkId,\n          chunkReferenceId,\n          fileName,\n          format,\n          moduleId: this.context.module.id,\n          referenceId: referenceId || assetReferenceId || chunkReferenceId,\n          relativePath\n        }]);\n      }\n\n      code.overwrite(parent.start, parent.end, replacement, {\n        contentOnly: true\n      });\n      return;\n    }\n\n    const replacement = outputPluginDriver.hookFirstSync('resolveImportMeta', [metaProperty, {\n      chunkId,\n      format,\n      moduleId: this.context.module.id\n    }]);\n\n    if (typeof replacement === 'string') {\n      if (parent instanceof MemberExpression) {\n        code.overwrite(parent.start, parent.end, replacement, {\n          contentOnly: true\n        });\n      } else {\n        code.overwrite(this.start, this.end, replacement, {\n          contentOnly: true\n        });\n      }\n    }\n  }\n\n}\n\nclass MethodDefinition extends NodeBase {\n  hasEffects(context) {\n    return this.key.hasEffects(context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    return path.length > 0 || this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context);\n  }\n\n}\n\nclass NewExpression extends NodeBase {\n  bind() {\n    super.bind();\n\n    for (const argument of this.arguments) {\n      // This will make sure all properties of parameters behave as \"unknown\"\n      argument.deoptimizePath(UNKNOWN_PATH);\n    }\n  }\n\n  hasEffects(context) {\n    for (const argument of this.arguments) {\n      if (argument.hasEffects(context)) return true;\n    }\n\n    if (this.context.annotations && this.annotatedPure) return false;\n    return this.callee.hasEffects(context) || this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  initialise() {\n    this.callOptions = {\n      args: this.arguments,\n      withNew: true\n    };\n  }\n\n}\n\nclass SpreadElement extends NodeBase {\n  bind() {\n    super.bind(); // Only properties of properties of the argument could become subject to reassignment\n    // This will also reassign the return values of iterators\n\n    this.argument.deoptimizePath([UnknownKey, UnknownKey]);\n  }\n\n}\n\nclass ObjectExpression extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.deoptimizedPaths = new Set(); // We collect deoptimization information if we can resolve a computed property access\n\n    this.expressionsToBeDeoptimized = new Map();\n    this.hasUnknownDeoptimizedProperty = false;\n    this.propertyMap = null;\n    this.unmatchablePropertiesRead = [];\n    this.unmatchablePropertiesWrite = [];\n  }\n\n  bind() {\n    super.bind(); // ensure the propertyMap is set for the tree-shaking passes\n\n    this.getPropertyMap();\n  } // We could also track this per-property but this would quickly become much more complex\n\n\n  deoptimizeCache() {\n    if (!this.hasUnknownDeoptimizedProperty) this.deoptimizeAllProperties();\n  }\n\n  deoptimizePath(path) {\n    if (this.hasUnknownDeoptimizedProperty) return;\n    const propertyMap = this.getPropertyMap();\n    const key = path[0];\n\n    if (path.length === 1) {\n      if (typeof key !== 'string') {\n        this.deoptimizeAllProperties();\n        return;\n      }\n\n      if (!this.deoptimizedPaths.has(key)) {\n        this.deoptimizedPaths.add(key); // we only deoptimizeCache exact matches as in all other cases,\n        // we do not return a literal value or return expression\n\n        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n\n        if (expressionsToBeDeoptimized) {\n          for (const expression of expressionsToBeDeoptimized) {\n            expression.deoptimizeCache();\n          }\n        }\n      }\n    }\n\n    const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);\n\n    for (const property of typeof key === 'string' ? propertyMap[key] ? propertyMap[key].propertiesRead : [] : this.properties) {\n      property.deoptimizePath(subPath);\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    const propertyMap = this.getPropertyMap();\n    const key = path[0];\n    if (path.length === 0 || this.hasUnknownDeoptimizedProperty || typeof key !== 'string' || this.deoptimizedPaths.has(key)) return UnknownValue;\n\n    if (path.length === 1 && !propertyMap[key] && !objectMembers[key] && this.unmatchablePropertiesRead.length === 0) {\n      const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n\n      if (expressionsToBeDeoptimized) {\n        expressionsToBeDeoptimized.push(origin);\n      } else {\n        this.expressionsToBeDeoptimized.set(key, [origin]);\n      }\n\n      return undefined;\n    }\n\n    if (!propertyMap[key] || propertyMap[key].exactMatchRead === null || propertyMap[key].propertiesRead.length > 1) {\n      return UnknownValue;\n    }\n\n    const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n\n    if (expressionsToBeDeoptimized) {\n      expressionsToBeDeoptimized.push(origin);\n    } else {\n      this.expressionsToBeDeoptimized.set(key, [origin]);\n    }\n\n    return propertyMap[key].exactMatchRead.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    const propertyMap = this.getPropertyMap();\n    const key = path[0];\n    if (path.length === 0 || this.hasUnknownDeoptimizedProperty || typeof key !== 'string' || this.deoptimizedPaths.has(key)) return UNKNOWN_EXPRESSION;\n    if (path.length === 1 && objectMembers[key] && this.unmatchablePropertiesRead.length === 0 && (!propertyMap[key] || propertyMap[key].exactMatchRead === null)) return getMemberReturnExpressionWhenCalled(objectMembers, key);\n    if (!propertyMap[key] || propertyMap[key].exactMatchRead === null || propertyMap[key].propertiesRead.length > 1) return UNKNOWN_EXPRESSION;\n    const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n\n    if (expressionsToBeDeoptimized) {\n      expressionsToBeDeoptimized.push(origin);\n    } else {\n      this.expressionsToBeDeoptimized.set(key, [origin]);\n    }\n\n    return propertyMap[key].exactMatchRead.getReturnExpressionWhenCalledAtPath(path.slice(1), recursionTracker, origin);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (path.length === 0) return false;\n    const key = path[0];\n    const propertyMap = this.propertyMap;\n    if (path.length > 1 && (this.hasUnknownDeoptimizedProperty || typeof key !== 'string' || this.deoptimizedPaths.has(key) || !propertyMap[key] || propertyMap[key].exactMatchRead === null)) return true;\n    const subPath = path.slice(1);\n\n    for (const property of typeof key !== 'string' ? this.properties : propertyMap[key] ? propertyMap[key].propertiesRead : []) {\n      if (property.hasEffectsWhenAccessedAtPath(subPath, context)) return true;\n    }\n\n    return false;\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    const key = path[0];\n    const propertyMap = this.propertyMap;\n\n    if (path.length > 1 && (this.hasUnknownDeoptimizedProperty || this.deoptimizedPaths.has(key) || !propertyMap[key] || propertyMap[key].exactMatchRead === null)) {\n      return true;\n    }\n\n    const subPath = path.slice(1);\n\n    for (const property of typeof key !== 'string' ? this.properties : path.length > 1 ? propertyMap[key].propertiesRead : propertyMap[key] ? propertyMap[key].propertiesWrite : []) {\n      if (property.hasEffectsWhenAssignedAtPath(subPath, context)) return true;\n    }\n\n    return false;\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    const key = path[0];\n\n    if (typeof key !== 'string' || this.hasUnknownDeoptimizedProperty || this.deoptimizedPaths.has(key) || (this.propertyMap[key] ? !this.propertyMap[key].exactMatchRead : path.length > 1 || !objectMembers[key])) {\n      return true;\n    }\n\n    const subPath = path.slice(1);\n\n    if (this.propertyMap[key]) {\n      for (const property of this.propertyMap[key].propertiesRead) {\n        if (property.hasEffectsWhenCalledAtPath(subPath, callOptions, context)) return true;\n      }\n    }\n\n    if (path.length === 1 && objectMembers[key]) return hasMemberEffectWhenCalled(objectMembers, key, this.included, callOptions, context);\n    return false;\n  }\n\n  render(code, options, {\n    renderedParentType\n  } = BLANK) {\n    super.render(code, options);\n\n    if (renderedParentType === ExpressionStatement) {\n      code.appendRight(this.start, '(');\n      code.prependLeft(this.end, ')');\n    }\n  }\n\n  deoptimizeAllProperties() {\n    this.hasUnknownDeoptimizedProperty = true;\n\n    for (const property of this.properties) {\n      property.deoptimizePath(UNKNOWN_PATH);\n    }\n\n    for (const expressionsToBeDeoptimized of this.expressionsToBeDeoptimized.values()) {\n      for (const expression of expressionsToBeDeoptimized) {\n        expression.deoptimizeCache();\n      }\n    }\n  }\n\n  getPropertyMap() {\n    if (this.propertyMap !== null) {\n      return this.propertyMap;\n    }\n\n    const propertyMap = this.propertyMap = Object.create(null);\n\n    for (let index = this.properties.length - 1; index >= 0; index--) {\n      const property = this.properties[index];\n\n      if (property instanceof SpreadElement) {\n        this.unmatchablePropertiesRead.push(property);\n        continue;\n      }\n\n      const isWrite = property.kind !== 'get';\n      const isRead = property.kind !== 'set';\n      let key;\n\n      if (property.computed) {\n        const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n\n        if (keyValue === UnknownValue) {\n          if (isRead) {\n            this.unmatchablePropertiesRead.push(property);\n          } else {\n            this.unmatchablePropertiesWrite.push(property);\n          }\n\n          continue;\n        }\n\n        key = String(keyValue);\n      } else if (property.key instanceof Identifier$1) {\n        key = property.key.name;\n      } else {\n        key = String(property.key.value);\n      }\n\n      const propertyMapProperty = propertyMap[key];\n\n      if (!propertyMapProperty) {\n        propertyMap[key] = {\n          exactMatchRead: isRead ? property : null,\n          exactMatchWrite: isWrite ? property : null,\n          propertiesRead: isRead ? [property, ...this.unmatchablePropertiesRead] : [],\n          propertiesWrite: isWrite && !isRead ? [property, ...this.unmatchablePropertiesWrite] : []\n        };\n        continue;\n      }\n\n      if (isRead && propertyMapProperty.exactMatchRead === null) {\n        propertyMapProperty.exactMatchRead = property;\n        propertyMapProperty.propertiesRead.push(property, ...this.unmatchablePropertiesRead);\n      }\n\n      if (isWrite && !isRead && propertyMapProperty.exactMatchWrite === null) {\n        propertyMapProperty.exactMatchWrite = property;\n        propertyMapProperty.propertiesWrite.push(property, ...this.unmatchablePropertiesWrite);\n      }\n    }\n\n    return propertyMap;\n  }\n\n}\n\nclass ObjectPattern extends NodeBase {\n  addExportedVariables(variables) {\n    for (const property of this.properties) {\n      if (property.type === Property) {\n        property.value.addExportedVariables(variables);\n      } else {\n        property.argument.addExportedVariables(variables);\n      }\n    }\n  }\n\n  declare(kind, init) {\n    const variables = [];\n\n    for (const property of this.properties) {\n      variables.push(...property.declare(kind, init));\n    }\n\n    return variables;\n  }\n\n  deoptimizePath(path) {\n    if (path.length === 0) {\n      for (const property of this.properties) {\n        property.deoptimizePath(path);\n      }\n    }\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (path.length > 0) return true;\n\n    for (const property of this.properties) {\n      if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)) return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass Program$1 extends NodeBase {\n  hasEffects(context) {\n    for (const node of this.body) {\n      if (node.hasEffects(context)) return true;\n    }\n\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    for (const node of this.body) {\n      if (includeChildrenRecursively || node.shouldBeIncluded(context)) {\n        node.include(context, includeChildrenRecursively);\n      }\n    }\n  }\n\n  render(code, options) {\n    if (this.body.length) {\n      renderStatementList(this.body, code, this.start, this.end, options);\n    } else {\n      super.render(code, options);\n    }\n  }\n\n}\n\nclass Property$1 extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.declarationInit = null;\n    this.returnExpression = null;\n  }\n\n  bind() {\n    super.bind();\n\n    if (this.kind === 'get') {\n      // ensure the returnExpression is set for the tree-shaking passes\n      this.getReturnExpression();\n    }\n\n    if (this.declarationInit !== null) {\n      this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);\n    }\n  }\n\n  declare(kind, init) {\n    this.declarationInit = init;\n    return this.value.declare(kind, UNKNOWN_EXPRESSION);\n  } // As getter properties directly receive their values from function expressions that always\n  // have a fixed return value, there is no known situation where a getter is deoptimized.\n\n\n  deoptimizeCache() {}\n\n  deoptimizePath(path) {\n    if (this.kind === 'get') {\n      this.getReturnExpression().deoptimizePath(path);\n    } else {\n      this.value.deoptimizePath(path);\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    if (this.kind === 'get') {\n      return this.getReturnExpression().getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n\n    return this.value.getLiteralValueAtPath(path, recursionTracker, origin);\n  }\n\n  getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n    if (this.kind === 'get') {\n      return this.getReturnExpression().getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    }\n\n    return this.value.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n  }\n\n  hasEffects(context) {\n    return this.key.hasEffects(context) || this.value.hasEffects(context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    if (this.kind === 'get') {\n      const trackedExpressions = context.accessed.getEntities(path);\n      if (trackedExpressions.has(this)) return false;\n      trackedExpressions.add(this);\n      return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context) || path.length > 0 && this.returnExpression.hasEffectsWhenAccessedAtPath(path, context);\n    }\n\n    return this.value.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    if (this.kind === 'get') {\n      const trackedExpressions = context.assigned.getEntities(path);\n      if (trackedExpressions.has(this)) return false;\n      trackedExpressions.add(this);\n      return this.returnExpression.hasEffectsWhenAssignedAtPath(path, context);\n    }\n\n    if (this.kind === 'set') {\n      const trackedExpressions = context.assigned.getEntities(path);\n      if (trackedExpressions.has(this)) return false;\n      trackedExpressions.add(this);\n      return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);\n    }\n\n    return this.value.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    if (this.kind === 'get') {\n      const trackedExpressions = (callOptions.withNew ? context.instantiated : context.called).getEntities(path);\n      if (trackedExpressions.has(this)) return false;\n      trackedExpressions.add(this);\n      return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n\n    return this.value.hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  initialise() {\n    this.accessorCallOptions = {\n      args: NO_ARGS,\n      withNew: false\n    };\n  }\n\n  render(code, options) {\n    if (!this.shorthand) {\n      this.key.render(code, options);\n    }\n\n    this.value.render(code, options, {\n      isShorthandProperty: this.shorthand\n    });\n  }\n\n  getReturnExpression() {\n    if (this.returnExpression === null) {\n      this.returnExpression = UNKNOWN_EXPRESSION;\n      return this.returnExpression = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n    }\n\n    return this.returnExpression;\n  }\n\n}\n\nclass ReturnStatement$1 extends NodeBase {\n  hasEffects(context) {\n    if (!context.ignore.returnAwaitYield || this.argument !== null && this.argument.hasEffects(context)) return true;\n    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    if (this.argument) {\n      this.argument.include(context, includeChildrenRecursively);\n    }\n\n    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n  }\n\n  initialise() {\n    this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);\n  }\n\n  render(code, options) {\n    if (this.argument) {\n      this.argument.render(code, options, {\n        preventASI: true\n      });\n\n      if (this.argument.start === this.start + 6\n      /* 'return'.length */\n      ) {\n          code.prependLeft(this.start + 6, ' ');\n        }\n    }\n  }\n\n}\n\nclass SequenceExpression extends NodeBase {\n  deoptimizePath(path) {\n    if (path.length > 0) this.expressions[this.expressions.length - 1].deoptimizePath(path);\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);\n  }\n\n  hasEffects(context) {\n    for (const expression of this.expressions) {\n      if (expression.hasEffects(context)) return true;\n    }\n\n    return false;\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    return path.length > 0 && this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    return path.length === 0 || this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  hasEffectsWhenCalledAtPath(path, callOptions, context) {\n    return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path, callOptions, context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    for (let i = 0; i < this.expressions.length - 1; i++) {\n      const node = this.expressions[i];\n      if (includeChildrenRecursively || node.shouldBeIncluded(context)) node.include(context, includeChildrenRecursively);\n    }\n\n    this.expressions[this.expressions.length - 1].include(context, includeChildrenRecursively);\n  }\n\n  render(code, options, {\n    renderedParentType,\n    isCalleeOfRenderedParent,\n    preventASI\n  } = BLANK) {\n    let includedNodes = 0;\n\n    for (const {\n      node,\n      start,\n      end\n    } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {\n      if (!node.included) {\n        treeshakeNode(node, code, start, end);\n        continue;\n      }\n\n      includedNodes++;\n\n      if (includedNodes === 1 && preventASI) {\n        removeLineBreaks(code, start, node.start);\n      }\n\n      if (node === this.expressions[this.expressions.length - 1] && includedNodes === 1) {\n        node.render(code, options, {\n          isCalleeOfRenderedParent: renderedParentType ? isCalleeOfRenderedParent : this.parent.callee === this,\n          renderedParentType: renderedParentType || this.parent.type\n        });\n      } else {\n        node.render(code, options);\n      }\n    }\n  }\n\n}\n\nclass SwitchCase extends NodeBase {\n  hasEffects(context) {\n    if (this.test && this.test.hasEffects(context)) return true;\n\n    for (const node of this.consequent) {\n      if (context.brokenFlow) break;\n      if (node.hasEffects(context)) return true;\n    }\n\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    if (this.test) this.test.include(context, includeChildrenRecursively);\n\n    for (const node of this.consequent) {\n      if (includeChildrenRecursively || node.shouldBeIncluded(context)) node.include(context, includeChildrenRecursively);\n    }\n  }\n\n  render(code, options, nodeRenderOptions) {\n    if (this.consequent.length) {\n      this.test && this.test.render(code, options);\n      const testEnd = this.test ? this.test.end : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;\n      const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;\n      renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);\n    } else {\n      super.render(code, options);\n    }\n  }\n\n}\n\nSwitchCase.prototype.needsBoundaries = true;\n\nclass SwitchStatement extends NodeBase {\n  createScope(parentScope) {\n    this.scope = new BlockScope(parentScope);\n  }\n\n  hasEffects(context) {\n    if (this.discriminant.hasEffects(context)) return true;\n    const {\n      brokenFlow,\n      ignore: {\n        breaks\n      }\n    } = context;\n    let minBrokenFlow = Infinity;\n    context.ignore.breaks = true;\n\n    for (const switchCase of this.cases) {\n      if (switchCase.hasEffects(context)) return true;\n      minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;\n      context.brokenFlow = brokenFlow;\n    }\n\n    if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {\n      context.brokenFlow = minBrokenFlow;\n    }\n\n    context.ignore.breaks = breaks;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    this.discriminant.include(context, includeChildrenRecursively);\n    const {\n      brokenFlow\n    } = context;\n    let minBrokenFlow = Infinity;\n    let isCaseIncluded = includeChildrenRecursively || this.defaultCase !== null && this.defaultCase < this.cases.length - 1;\n\n    for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {\n      const switchCase = this.cases[caseIndex];\n\n      if (switchCase.included) {\n        isCaseIncluded = true;\n      }\n\n      if (!isCaseIncluded) {\n        const hasEffectsContext = createHasEffectsContext();\n        hasEffectsContext.ignore.breaks = true;\n        isCaseIncluded = switchCase.hasEffects(hasEffectsContext);\n      }\n\n      if (isCaseIncluded) {\n        switchCase.include(context, includeChildrenRecursively);\n        minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;\n        context.brokenFlow = brokenFlow;\n      } else {\n        minBrokenFlow = brokenFlow;\n      }\n    }\n\n    if (isCaseIncluded && this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {\n      context.brokenFlow = minBrokenFlow;\n    }\n  }\n\n  initialise() {\n    for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {\n      if (this.cases[caseIndex].test === null) {\n        this.defaultCase = caseIndex;\n        return;\n      }\n    }\n\n    this.defaultCase = null;\n  }\n\n  render(code, options) {\n    this.discriminant.render(code, options);\n\n    if (this.cases.length > 0) {\n      renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);\n    }\n  }\n\n}\n\nclass TaggedTemplateExpression extends NodeBase {\n  bind() {\n    super.bind();\n\n    if (this.tag.type === Identifier) {\n      const name = this.tag.name;\n      const variable = this.scope.findVariable(name);\n\n      if (variable.isNamespace) {\n        return this.context.error({\n          code: 'CANNOT_CALL_NAMESPACE',\n          message: `Cannot call a namespace ('${name}')`\n        }, this.start);\n      }\n\n      if (name === 'eval') {\n        this.context.warn({\n          code: 'EVAL',\n          message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,\n          url: 'https://rollupjs.org/guide/en/#avoiding-eval'\n        }, this.start);\n      }\n    }\n  }\n\n  hasEffects(context) {\n    return super.hasEffects(context) || this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context);\n  }\n\n  initialise() {\n    this.callOptions = {\n      args: NO_ARGS,\n      withNew: false\n    };\n  }\n\n}\n\nclass TemplateElement extends NodeBase {\n  hasEffects() {\n    return false;\n  }\n\n}\n\nclass TemplateLiteral extends NodeBase {\n  getLiteralValueAtPath(path) {\n    if (path.length > 0 || this.quasis.length !== 1) {\n      return UnknownValue;\n    }\n\n    return this.quasis[0].value.cooked;\n  }\n\n  render(code, options) {\n    code.indentExclusionRanges.push([this.start, this.end]);\n    super.render(code, options);\n  }\n\n}\n\nclass ModuleScope extends ChildScope {\n  constructor(parent, context) {\n    super(parent);\n    this.context = context;\n    this.variables.set('this', new LocalVariable('this', null, UNDEFINED_EXPRESSION, context));\n  }\n\n  addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {\n    const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);\n    this.variables.set('default', variable);\n    return variable;\n  }\n\n  addNamespaceMemberAccess(_name, variable) {\n    if (variable instanceof GlobalVariable) {\n      this.accessedOutsideVariables.set(variable.name, variable);\n    }\n  }\n\n  deconflict(format) {\n    // all module level variables are already deconflicted when deconflicting the chunk\n    for (const scope of this.children) scope.deconflict(format);\n  }\n\n  findLexicalBoundary() {\n    return this;\n  }\n\n  findVariable(name) {\n    const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);\n\n    if (knownVariable) {\n      return knownVariable;\n    }\n\n    const variable = this.context.traceVariable(name) || this.parent.findVariable(name);\n\n    if (variable instanceof GlobalVariable) {\n      this.accessedOutsideVariables.set(name, variable);\n    }\n\n    return variable;\n  }\n\n}\n\nclass ThisExpression extends NodeBase {\n  bind() {\n    super.bind();\n    this.variable = this.scope.findVariable('this');\n  }\n\n  hasEffectsWhenAccessedAtPath(path, context) {\n    return path.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path, context);\n  }\n\n  hasEffectsWhenAssignedAtPath(path, context) {\n    return this.variable.hasEffectsWhenAssignedAtPath(path, context);\n  }\n\n  initialise() {\n    this.alias = this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;\n\n    if (this.alias === 'undefined') {\n      this.context.warn({\n        code: 'THIS_IS_UNDEFINED',\n        message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,\n        url: `https://rollupjs.org/guide/en/#error-this-is-undefined`\n      }, this.start);\n    }\n  }\n\n  render(code) {\n    if (this.alias !== null) {\n      code.overwrite(this.start, this.end, this.alias, {\n        contentOnly: false,\n        storeName: true\n      });\n    }\n  }\n\n}\n\nclass ThrowStatement extends NodeBase {\n  hasEffects() {\n    return true;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    this.argument.include(context, includeChildrenRecursively);\n    context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n  }\n\n  render(code, options) {\n    this.argument.render(code, options, {\n      preventASI: true\n    });\n\n    if (this.argument.start === this.start + 5\n    /* 'throw'.length */\n    ) {\n        code.prependLeft(this.start + 5, ' ');\n      }\n  }\n\n}\n\nclass TryStatement extends NodeBase {\n  constructor() {\n    super(...arguments);\n    this.directlyIncluded = false;\n  }\n\n  hasEffects(context) {\n    return (this.context.tryCatchDeoptimization ? this.block.body.length > 0 : this.block.hasEffects(context)) || this.finalizer !== null && this.finalizer.hasEffects(context);\n  }\n\n  include(context, includeChildrenRecursively) {\n    const {\n      brokenFlow\n    } = context;\n\n    if (!this.directlyIncluded || !this.context.tryCatchDeoptimization) {\n      this.included = true;\n      this.directlyIncluded = true;\n      this.block.include(context, this.context.tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);\n      context.brokenFlow = brokenFlow;\n    }\n\n    if (this.handler !== null) {\n      this.handler.include(context, includeChildrenRecursively);\n      context.brokenFlow = brokenFlow;\n    }\n\n    if (this.finalizer !== null) {\n      this.finalizer.include(context, includeChildrenRecursively);\n    }\n  }\n\n}\n\nconst unaryOperators = {\n  '!': value => !value,\n  '+': value => +value,\n  '-': value => -value,\n  delete: () => UnknownValue,\n  typeof: value => typeof value,\n  void: () => undefined,\n  '~': value => ~value\n};\n\nclass UnaryExpression extends NodeBase {\n  bind() {\n    super.bind();\n\n    if (this.operator === 'delete') {\n      this.argument.deoptimizePath(EMPTY_PATH);\n    }\n  }\n\n  getLiteralValueAtPath(path, recursionTracker, origin) {\n    if (path.length > 0) return UnknownValue;\n    const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n    if (argumentValue === UnknownValue) return UnknownValue;\n    return unaryOperators[this.operator](argumentValue);\n  }\n\n  hasEffects(context) {\n    if (this.operator === 'typeof' && this.argument instanceof Identifier$1) return false;\n    return this.argument.hasEffects(context) || this.operator === 'delete' && this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    if (this.operator === 'void') {\n      return path.length > 0;\n    }\n\n    return path.length > 1;\n  }\n\n}\n\nclass UnknownNode extends NodeBase {\n  hasEffects() {\n    return true;\n  }\n\n  include(context) {\n    super.include(context, true);\n  }\n\n}\n\nclass UpdateExpression extends NodeBase {\n  bind() {\n    super.bind();\n    this.argument.deoptimizePath(EMPTY_PATH);\n\n    if (this.argument instanceof Identifier$1) {\n      const variable = this.scope.findVariable(this.argument.name);\n      variable.isReassigned = true;\n    }\n  }\n\n  hasEffects(context) {\n    return this.argument.hasEffects(context) || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n  }\n\n  hasEffectsWhenAccessedAtPath(path) {\n    return path.length > 1;\n  }\n\n  render(code, options) {\n    this.argument.render(code, options);\n    const variable = this.argument.variable;\n\n    if (options.format === 'system' && variable && variable.exportName) {\n      const name = variable.getName();\n\n      if (this.prefix) {\n        code.overwrite(this.start, this.end, `exports('${variable.exportName}', ${this.operator}${name})`);\n      } else {\n        let op;\n\n        switch (this.operator) {\n          case '++':\n            op = `${name} + 1`;\n            break;\n\n          case '--':\n            op = `${name} - 1`;\n            break;\n        }\n\n        code.overwrite(this.start, this.end, `(exports('${variable.exportName}', ${op}), ${name}${this.operator})`);\n      }\n    }\n  }\n\n}\n\nfunction isReassignedExportsMember(variable) {\n  return variable.renderBaseName !== null && variable.exportName !== null && variable.isReassigned;\n}\n\nfunction areAllDeclarationsIncludedAndNotExported(declarations) {\n  for (const declarator of declarations) {\n    if (!declarator.included) return false;\n\n    if (declarator.id.type === Identifier) {\n      if (declarator.id.variable.exportName) return false;\n    } else {\n      const exportedVariables = [];\n      declarator.id.addExportedVariables(exportedVariables);\n      if (exportedVariables.length > 0) return false;\n    }\n  }\n\n  return true;\n}\n\nclass VariableDeclaration extends NodeBase {\n  deoptimizePath() {\n    for (const declarator of this.declarations) {\n      declarator.deoptimizePath(EMPTY_PATH);\n    }\n  }\n\n  hasEffectsWhenAssignedAtPath() {\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n\n    for (const declarator of this.declarations) {\n      if (includeChildrenRecursively || declarator.shouldBeIncluded(context)) declarator.include(context, includeChildrenRecursively);\n    }\n  }\n\n  includeWithAllDeclaredVariables(includeChildrenRecursively, context) {\n    this.included = true;\n\n    for (const declarator of this.declarations) {\n      declarator.include(context, includeChildrenRecursively);\n    }\n  }\n\n  initialise() {\n    for (const declarator of this.declarations) {\n      declarator.declareDeclarator(this.kind);\n    }\n  }\n\n  render(code, options, nodeRenderOptions = BLANK) {\n    if (areAllDeclarationsIncludedAndNotExported(this.declarations)) {\n      for (const declarator of this.declarations) {\n        declarator.render(code, options);\n      }\n\n      if (!nodeRenderOptions.isNoStatement && code.original.charCodeAt(this.end - 1) !== 59\n      /*\";\"*/\n      ) {\n          code.appendLeft(this.end, ';');\n        }\n    } else {\n      this.renderReplacedDeclarations(code, options, nodeRenderOptions);\n    }\n  }\n\n  renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, addSemicolon, systemPatternExports) {\n    if (code.original.charCodeAt(this.end - 1) === 59\n    /*\";\"*/\n    ) {\n        code.remove(this.end - 1, this.end);\n      }\n\n    if (addSemicolon) {\n      separatorString += ';';\n    }\n\n    if (lastSeparatorPos !== null) {\n      if (code.original.charCodeAt(actualContentEnd - 1) === 10\n      /*\"\\n\"*/\n      && (code.original.charCodeAt(this.end) === 10\n      /*\"\\n\"*/\n      || code.original.charCodeAt(this.end) === 13)\n      /*\"\\r\"*/\n      ) {\n          actualContentEnd--;\n\n          if (code.original.charCodeAt(actualContentEnd) === 13\n          /*\"\\r\"*/\n          ) {\n              actualContentEnd--;\n            }\n        }\n\n      if (actualContentEnd === lastSeparatorPos + 1) {\n        code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);\n      } else {\n        code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);\n        code.remove(actualContentEnd, renderedContentEnd);\n      }\n    } else {\n      code.appendLeft(renderedContentEnd, separatorString);\n    }\n\n    if (systemPatternExports.length > 0) {\n      code.appendLeft(renderedContentEnd, ' ' + getSystemExportStatement(systemPatternExports));\n    }\n  }\n\n  renderReplacedDeclarations(code, options, {\n    start = this.start,\n    end = this.end,\n    isNoStatement\n  }) {\n    const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59\n    /*\";\"*/\n    ? 1 : 0));\n    let actualContentEnd, renderedContentEnd;\n\n    if (/\\n\\s*$/.test(code.slice(this.start, separatedNodes[0].start))) {\n      renderedContentEnd = this.start + this.kind.length;\n    } else {\n      renderedContentEnd = separatedNodes[0].start;\n    }\n\n    let lastSeparatorPos = renderedContentEnd - 1;\n    code.remove(this.start, lastSeparatorPos);\n    let isInDeclaration = false;\n    let hasRenderedContent = false;\n    let separatorString = '',\n        leadingString,\n        nextSeparatorString;\n    const systemPatternExports = [];\n\n    for (const {\n      node,\n      start,\n      separator,\n      contentEnd,\n      end\n    } of separatedNodes) {\n      if (!node.included || node.id instanceof Identifier$1 && isReassignedExportsMember(node.id.variable) && node.init === null) {\n        code.remove(start, end);\n        continue;\n      }\n\n      leadingString = '';\n      nextSeparatorString = '';\n\n      if (node.id instanceof Identifier$1 && isReassignedExportsMember(node.id.variable)) {\n        if (hasRenderedContent) {\n          separatorString += ';';\n        }\n\n        isInDeclaration = false;\n      } else {\n        if (options.format === 'system' && node.init !== null) {\n          if (node.id.type !== Identifier) {\n            node.id.addExportedVariables(systemPatternExports);\n          } else if (node.id.variable.exportName) {\n            code.prependLeft(code.original.indexOf('=', node.id.end) + 1, ` exports('${node.id.variable.safeExportName || node.id.variable.exportName}',`);\n            nextSeparatorString += ')';\n          }\n        }\n\n        if (isInDeclaration) {\n          separatorString += ',';\n        } else {\n          if (hasRenderedContent) {\n            separatorString += ';';\n          }\n\n          leadingString += `${this.kind} `;\n          isInDeclaration = true;\n        }\n      }\n\n      if (renderedContentEnd === lastSeparatorPos + 1) {\n        code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);\n      } else {\n        code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);\n        code.appendLeft(renderedContentEnd, leadingString);\n      }\n\n      node.render(code, options);\n      actualContentEnd = contentEnd;\n      renderedContentEnd = end;\n      hasRenderedContent = true;\n      lastSeparatorPos = separator;\n      separatorString = nextSeparatorString;\n    }\n\n    if (hasRenderedContent) {\n      this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, !isNoStatement, systemPatternExports);\n    } else {\n      code.remove(start, end);\n    }\n  }\n\n}\n\nclass VariableDeclarator extends NodeBase {\n  declareDeclarator(kind) {\n    this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);\n  }\n\n  deoptimizePath(path) {\n    this.id.deoptimizePath(path);\n  }\n\n  render(code, options) {\n    // This can happen for hoisted variables in dead branches\n    if (this.init !== null && !this.init.included) {\n      code.remove(this.id.end, this.end);\n      this.id.render(code, options);\n    } else {\n      super.render(code, options);\n    }\n  }\n\n}\n\nclass WhileStatement extends NodeBase {\n  hasEffects(context) {\n    if (this.test.hasEffects(context)) return true;\n    const {\n      brokenFlow,\n      ignore: {\n        breaks,\n        continues\n      }\n    } = context;\n    context.ignore.breaks = true;\n    context.ignore.continues = true;\n    if (this.body.hasEffects(context)) return true;\n    context.ignore.breaks = breaks;\n    context.ignore.continues = continues;\n    context.brokenFlow = brokenFlow;\n    return false;\n  }\n\n  include(context, includeChildrenRecursively) {\n    this.included = true;\n    this.test.include(context, includeChildrenRecursively);\n    const {\n      brokenFlow\n    } = context;\n    this.body.include(context, includeChildrenRecursively);\n    context.brokenFlow = brokenFlow;\n  }\n\n}\n\nclass YieldExpression extends NodeBase {\n  bind() {\n    super.bind();\n\n    if (this.argument !== null) {\n      this.argument.deoptimizePath(UNKNOWN_PATH);\n    }\n  }\n\n  hasEffects(context) {\n    return !context.ignore.returnAwaitYield || this.argument !== null && this.argument.hasEffects(context);\n  }\n\n  render(code, options) {\n    if (this.argument) {\n      this.argument.render(code, options);\n\n      if (this.argument.start === this.start + 5\n      /* 'yield'.length */\n      ) {\n          code.prependLeft(this.start + 5, ' ');\n        }\n    }\n  }\n\n}\n\nconst nodeConstructors = {\n  ArrayExpression,\n  ArrayPattern,\n  ArrowFunctionExpression,\n  AssignmentExpression,\n  AssignmentPattern,\n  AwaitExpression,\n  BinaryExpression,\n  BlockStatement: BlockStatement$1,\n  BreakStatement,\n  CallExpression: CallExpression$1,\n  CatchClause,\n  ClassBody,\n  ClassDeclaration,\n  ClassExpression,\n  ConditionalExpression,\n  ContinueStatement,\n  DoWhileStatement,\n  EmptyStatement,\n  ExportAllDeclaration,\n  ExportDefaultDeclaration,\n  ExportNamedDeclaration,\n  ExpressionStatement: ExpressionStatement$1,\n  ForInStatement,\n  ForOfStatement,\n  ForStatement,\n  FunctionDeclaration,\n  FunctionExpression: FunctionExpression$1,\n  Identifier: Identifier$1,\n  IfStatement,\n  ImportDeclaration,\n  ImportExpression: Import,\n  LabeledStatement,\n  Literal,\n  LogicalExpression,\n  MemberExpression,\n  MetaProperty,\n  MethodDefinition,\n  NewExpression,\n  ObjectExpression,\n  ObjectPattern,\n  Program: Program$1,\n  Property: Property$1,\n  RestElement,\n  ReturnStatement: ReturnStatement$1,\n  SequenceExpression,\n  SpreadElement,\n  SwitchCase,\n  SwitchStatement,\n  TaggedTemplateExpression,\n  TemplateElement,\n  TemplateLiteral,\n  ThisExpression,\n  ThrowStatement,\n  TryStatement,\n  UnaryExpression,\n  UnknownNode,\n  UpdateExpression,\n  VariableDeclaration,\n  VariableDeclarator,\n  WhileStatement,\n  YieldExpression\n};\n\nclass SyntheticNamedExportVariableVariable extends Variable {\n  constructor(context, name, defaultVariable) {\n    super(name);\n    this.context = context;\n    this.module = context.module;\n    this.defaultVariable = defaultVariable;\n    this.setRenderNames(defaultVariable.getName(), name);\n  }\n\n  include(context) {\n    if (!this.included) {\n      this.included = true;\n      this.context.includeVariable(context, this.defaultVariable);\n    }\n  }\n\n}\n\nfunction getOriginalLocation(sourcemapChain, location) {\n  // This cast is guaranteed. If it were a missing Map, it wouldn't have a mappings.\n  const filteredSourcemapChain = sourcemapChain.filter(sourcemap => sourcemap.mappings);\n\n  while (filteredSourcemapChain.length > 0) {\n    const sourcemap = filteredSourcemapChain.pop();\n    const line = sourcemap.mappings[location.line - 1];\n    let locationFound = false;\n\n    if (line !== undefined) {\n      for (const segment of line) {\n        if (segment[0] >= location.column) {\n          if (segment.length === 1) break;\n          location = {\n            column: segment[3],\n            line: segment[2] + 1,\n            name: segment.length === 5 ? sourcemap.names[segment[4]] : undefined,\n            source: sourcemap.sources[segment[1]]\n          };\n          locationFound = true;\n          break;\n        }\n      }\n    }\n\n    if (!locationFound) {\n      throw new Error(\"Can't resolve original location of error.\");\n    }\n  }\n\n  return location;\n} // AST walker module for Mozilla Parser API compatible trees\n\n\nfunction skipThrough(node, st, c) {\n  c(node, st);\n}\n\nfunction ignore(_node, _st, _c) {} // Node walkers.\n\n\nvar base$1 = {};\n\nbase$1.Program = base$1.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var stmt = list[i];\n    c(stmt, st, \"Statement\");\n  }\n};\n\nbase$1.Statement = skipThrough;\nbase$1.EmptyStatement = ignore;\n\nbase$1.ExpressionStatement = base$1.ParenthesizedExpression = function (node, st, c) {\n  return c(node.expression, st, \"Expression\");\n};\n\nbase$1.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n\n  if (node.alternate) {\n    c(node.alternate, st, \"Statement\");\n  }\n};\n\nbase$1.LabeledStatement = function (node, st, c) {\n  return c(node.body, st, \"Statement\");\n};\n\nbase$1.BreakStatement = base$1.ContinueStatement = ignore;\n\nbase$1.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase$1.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) {\n      c(cs.test, st, \"Expression\");\n    }\n\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1) {\n      var cons = list[i];\n      c(cons, st, \"Statement\");\n    }\n  }\n};\n\nbase$1.SwitchCase = function (node, st, c) {\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n\n  for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n    var cons = list[i];\n    c(cons, st, \"Statement\");\n  }\n};\n\nbase$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function (node, st, c) {\n  if (node.argument) {\n    c(node.argument, st, \"Expression\");\n  }\n};\n\nbase$1.ThrowStatement = base$1.SpreadElement = function (node, st, c) {\n  return c(node.argument, st, \"Expression\");\n};\n\nbase$1.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n\n  if (node.handler) {\n    c(node.handler, st);\n  }\n\n  if (node.finalizer) {\n    c(node.finalizer, st, \"Statement\");\n  }\n};\n\nbase$1.CatchClause = function (node, st, c) {\n  if (node.param) {\n    c(node.param, st, \"Pattern\");\n  }\n\n  c(node.body, st, \"Statement\");\n};\n\nbase$1.WhileStatement = base$1.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase$1.ForStatement = function (node, st, c) {\n  if (node.init) {\n    c(node.init, st, \"ForInit\");\n  }\n\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n\n  if (node.update) {\n    c(node.update, st, \"Expression\");\n  }\n\n  c(node.body, st, \"Statement\");\n};\n\nbase$1.ForInStatement = base$1.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase$1.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") {\n    c(node, st);\n  } else {\n    c(node, st, \"Expression\");\n  }\n};\n\nbase$1.DebuggerStatement = ignore;\n\nbase$1.FunctionDeclaration = function (node, st, c) {\n  return c(node, st, \"Function\");\n};\n\nbase$1.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n    var decl = list[i];\n    c(decl, st);\n  }\n};\n\nbase$1.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n\n  if (node.init) {\n    c(node.init, st, \"Expression\");\n  }\n};\n\nbase$1.Function = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    c(param, st, \"Pattern\");\n  }\n\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase$1.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\") {\n    c(node, st, \"VariablePattern\");\n  } else if (node.type === \"MemberExpression\") {\n    c(node, st, \"MemberPattern\");\n  } else {\n    c(node, st);\n  }\n};\n\nbase$1.VariablePattern = ignore;\nbase$1.MemberPattern = skipThrough;\n\nbase$1.RestElement = function (node, st, c) {\n  return c(node.argument, st, \"Pattern\");\n};\n\nbase$1.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) {\n      c(elt, st, \"Pattern\");\n    }\n  }\n};\n\nbase$1.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) {\n        c(prop.key, st, \"Expression\");\n      }\n\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase$1.Expression = skipThrough;\nbase$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;\n\nbase$1.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) {\n      c(elt, st, \"Expression\");\n    }\n  }\n};\n\nbase$1.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n    c(prop, st);\n  }\n};\n\nbase$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;\n\nbase$1.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n    var expr = list[i];\n    c(expr, st, \"Expression\");\n  }\n};\n\nbase$1.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1) {\n    var quasi = list[i];\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {\n    var expr = list$1[i$1];\n    c(expr, st, \"Expression\");\n  }\n};\n\nbase$1.TemplateElement = ignore;\n\nbase$1.UnaryExpression = base$1.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\n\nbase$1.BinaryExpression = base$1.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\n\nbase$1.AssignmentExpression = base$1.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\n\nbase$1.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\n\nbase$1.NewExpression = base$1.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n\n  if (node.arguments) {\n    for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n      var arg = list[i];\n      c(arg, st, \"Expression\");\n    }\n  }\n};\n\nbase$1.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n\n  if (node.computed) {\n    c(node.property, st, \"Expression\");\n  }\n};\n\nbase$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration) {\n    c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n  }\n\n  if (node.source) {\n    c(node.source, st, \"Expression\");\n  }\n};\n\nbase$1.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\n\nbase$1.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n    var spec = list[i];\n    c(spec, st);\n  }\n\n  c(node.source, st, \"Expression\");\n};\n\nbase$1.ImportExpression = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\n\nbase$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.Literal = ignore;\n\nbase$1.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\n\nbase$1.ClassDeclaration = base$1.ClassExpression = function (node, st, c) {\n  return c(node, st, \"Class\");\n};\n\nbase$1.Class = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n\n  if (node.superClass) {\n    c(node.superClass, st, \"Expression\");\n  }\n\n  c(node.body, st);\n};\n\nbase$1.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var elt = list[i];\n    c(elt, st);\n  }\n};\n\nbase$1.MethodDefinition = base$1.Property = function (node, st, c) {\n  if (node.computed) {\n    c(node.key, st, \"Expression\");\n  }\n\n  c(node.value, st, \"Expression\");\n}; // @ts-ignore\n\n\nfunction handlePureAnnotationsOfNode(node, state, type = node.type) {\n  let commentNode = state.commentNodes[state.commentIndex];\n\n  while (commentNode && node.start >= commentNode.end) {\n    markPureNode(node, commentNode);\n    commentNode = state.commentNodes[++state.commentIndex];\n  }\n\n  if (commentNode && commentNode.end <= node.end) {\n    base$1[type](node, state, handlePureAnnotationsOfNode);\n  }\n}\n\nfunction markPureNode(node, comment) {\n  if (node.annotations) {\n    node.annotations.push(comment);\n  } else {\n    node.annotations = [comment];\n  }\n\n  if (node.type === 'ExpressionStatement') {\n    node = node.expression;\n  }\n\n  if (node.type === 'CallExpression' || node.type === 'NewExpression') {\n    node.annotatedPure = true;\n  }\n}\n\nconst pureCommentRegex = /[@#]__PURE__/;\n\nconst isPureComment = comment => pureCommentRegex.test(comment.text);\n\nfunction markPureCallExpressions(comments, esTreeAst) {\n  handlePureAnnotationsOfNode(esTreeAst, {\n    commentIndex: 0,\n    commentNodes: comments.filter(isPureComment)\n  });\n} // this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\n\n\nlet SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\nconst SOURCEMAPPING_URL_RE = new RegExp(`^#\\\\s+${SOURCEMAPPING_URL}=.+\\\\n?`);\n\nconst NOOP = () => {};\n\nlet getStartTime = () => [0, 0];\n\nlet getElapsedTime = () => 0;\n\nlet getMemory = () => 0;\n\nlet timers = {};\n\nconst normalizeHrTime = time => time[0] * 1e3 + time[1] / 1e6;\n\nfunction setTimeHelpers() {\n  if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n    getStartTime = process.hrtime.bind(process);\n\n    getElapsedTime = previous => normalizeHrTime(process.hrtime(previous));\n  } else if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    getStartTime = () => [performance.now(), 0];\n\n    getElapsedTime = previous => performance.now() - previous[0];\n  }\n\n  if (typeof process !== 'undefined' && typeof process.memoryUsage === 'function') {\n    getMemory = () => process.memoryUsage().heapUsed;\n  }\n}\n\nfunction getPersistedLabel(label, level) {\n  switch (level) {\n    case 1:\n      return `# ${label}`;\n\n    case 2:\n      return `## ${label}`;\n\n    case 3:\n      return label;\n\n    default:\n      return `${'  '.repeat(level - 4)}- ${label}`;\n  }\n}\n\nfunction timeStartImpl(label, level = 3) {\n  label = getPersistedLabel(label, level);\n\n  if (!timers.hasOwnProperty(label)) {\n    timers[label] = {\n      memory: 0,\n      startMemory: undefined,\n      startTime: undefined,\n      time: 0,\n      totalMemory: 0\n    };\n  }\n\n  const currentMemory = getMemory();\n  timers[label].startTime = getStartTime();\n  timers[label].startMemory = currentMemory;\n}\n\nfunction timeEndImpl(label, level = 3) {\n  label = getPersistedLabel(label, level);\n\n  if (timers.hasOwnProperty(label)) {\n    const currentMemory = getMemory();\n    timers[label].time += getElapsedTime(timers[label].startTime);\n    timers[label].totalMemory = Math.max(timers[label].totalMemory, currentMemory);\n    timers[label].memory += currentMemory - timers[label].startMemory;\n  }\n}\n\nfunction getTimings() {\n  const newTimings = {};\n\n  for (const label of Object.keys(timers)) {\n    newTimings[label] = [timers[label].time, timers[label].memory, timers[label].totalMemory];\n  }\n\n  return newTimings;\n}\n\nlet timeStart = NOOP,\n    timeEnd = NOOP;\nconst TIMED_PLUGIN_HOOKS = {\n  load: true,\n  ongenerate: true,\n  onwrite: true,\n  resolveDynamicImport: true,\n  resolveId: true,\n  transform: true,\n  transformBundle: true\n};\n\nfunction getPluginWithTimers(plugin, index) {\n  const timedPlugin = {};\n\n  for (const hook of Object.keys(plugin)) {\n    if (TIMED_PLUGIN_HOOKS[hook] === true) {\n      let timerLabel = `plugin ${index}`;\n\n      if (plugin.name) {\n        timerLabel += ` (${plugin.name})`;\n      }\n\n      timerLabel += ` - ${hook}`;\n\n      timedPlugin[hook] = function () {\n        timeStart(timerLabel, 4);\n        const result = plugin[hook].apply(this === timedPlugin ? plugin : this, arguments);\n        timeEnd(timerLabel, 4);\n\n        if (result && typeof result.then === 'function') {\n          timeStart(`${timerLabel} (async)`, 4);\n          result.then(() => timeEnd(`${timerLabel} (async)`, 4));\n        }\n\n        return result;\n      };\n    } else {\n      timedPlugin[hook] = plugin[hook];\n    }\n  }\n\n  return timedPlugin;\n}\n\nfunction initialiseTimers(inputOptions) {\n  if (inputOptions.perf) {\n    timers = {};\n    setTimeHelpers();\n    timeStart = timeStartImpl;\n    timeEnd = timeEndImpl;\n    inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);\n  } else {\n    timeStart = NOOP;\n    timeEnd = NOOP;\n  }\n}\n\nconst defaultAcornOptions = {\n  ecmaVersion: 2020,\n  preserveParens: false,\n  sourceType: 'module'\n};\n\nfunction tryParse(module, Parser, acornOptions) {\n  try {\n    return Parser.parse(module.code, Object.assign(Object.assign(Object.assign({}, defaultAcornOptions), acornOptions), {\n      onComment: (block, text, start, end) => module.comments.push({\n        block,\n        text,\n        start,\n        end\n      })\n    }));\n  } catch (err) {\n    let message = err.message.replace(/ \\(\\d+:\\d+\\)$/, '');\n\n    if (module.id.endsWith('.json')) {\n      message += ' (Note that you need @rollup/plugin-json to import JSON files)';\n    } else if (!module.id.endsWith('.js')) {\n      message += ' (Note that you need plugins to import files that are not JavaScript)';\n    }\n\n    return module.error({\n      code: 'PARSE_ERROR',\n      message,\n      parserError: err\n    }, err.pos);\n  }\n}\n\nfunction handleMissingExport(exportName, importingModule, importedModule, importerStart) {\n  return importingModule.error({\n    code: 'MISSING_EXPORT',\n    message: `'${exportName}' is not exported by ${relativeId(importedModule)}, imported by ${relativeId(importingModule.id)}`,\n    url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`\n  }, importerStart);\n}\n\nconst MISSING_EXPORT_SHIM_DESCRIPTION = {\n  identifier: null,\n  localName: MISSING_EXPORT_SHIM_VARIABLE\n};\n\nfunction getVariableForExportNameRecursive(target, name, isExportAllSearch, searchedNamesAndModules = new Map()) {\n  const searchedModules = searchedNamesAndModules.get(name);\n\n  if (searchedModules) {\n    if (searchedModules.has(target)) {\n      return null;\n    }\n\n    searchedModules.add(target);\n  } else {\n    searchedNamesAndModules.set(name, new Set([target]));\n  }\n\n  return target.getVariableForExportName(name, isExportAllSearch, searchedNamesAndModules);\n}\n\nclass Module {\n  constructor(graph, id, moduleSideEffects, syntheticNamedExports, isEntry) {\n    this.chunk = null;\n    this.chunkFileNames = new Set();\n    this.chunkName = null;\n    this.comments = [];\n    this.dependencies = [];\n    this.dynamicallyImportedBy = [];\n    this.dynamicDependencies = [];\n    this.dynamicImports = [];\n    this.entryPointsHash = new Uint8Array(10);\n    this.execIndex = Infinity;\n    this.exportAllModules = [];\n    this.exportAllSources = new Set();\n    this.exports = Object.create(null);\n    this.exportsAll = Object.create(null);\n    this.exportShimVariable = new ExportShimVariable(this);\n    this.facadeChunk = null;\n    this.importDescriptions = Object.create(null);\n    this.importMetas = [];\n    this.imports = new Set();\n    this.isExecuted = false;\n    this.isUserDefinedEntryPoint = false;\n    this.manualChunkAlias = null;\n    this.reexportDescriptions = Object.create(null);\n    this.sources = new Set();\n    this.userChunkNames = new Set();\n    this.usesTopLevelAwait = false;\n    this.allExportNames = null;\n    this.defaultExport = null;\n    this.namespaceVariable = null;\n    this.syntheticExports = new Map();\n    this.transformDependencies = [];\n    this.transitiveReexports = null;\n    this.id = id;\n    this.graph = graph;\n    this.excludeFromSourcemap = /\\0/.test(id);\n    this.context = graph.getModuleContext(id);\n    this.moduleSideEffects = moduleSideEffects;\n    this.syntheticNamedExports = syntheticNamedExports;\n    this.isEntryPoint = isEntry;\n  }\n\n  basename() {\n    const base = basename(this.id);\n    const ext = extname(this.id);\n    return makeLegal(ext ? base.slice(0, -ext.length) : base);\n  }\n\n  bindReferences() {\n    this.ast.bind();\n  }\n\n  error(props, pos) {\n    if (typeof pos === 'number') {\n      props.pos = pos;\n      let location = locate(this.code, pos, {\n        offsetLine: 1\n      });\n\n      try {\n        location = getOriginalLocation(this.sourcemapChain, location);\n      } catch (e) {\n        this.warn({\n          code: 'SOURCEMAP_ERROR',\n          loc: {\n            column: location.column,\n            file: this.id,\n            line: location.line\n          },\n          message: `Error when using sourcemap for reporting an error: ${e.message}`,\n          pos\n        });\n      }\n\n      props.loc = {\n        column: location.column,\n        file: this.id,\n        line: location.line\n      };\n      props.frame = getCodeFrame(this.originalCode, location.line, location.column);\n    }\n\n    return error(props);\n  }\n\n  getAllExportNames() {\n    if (this.allExportNames) {\n      return this.allExportNames;\n    }\n\n    const allExportNames = this.allExportNames = new Set();\n\n    for (const name of Object.keys(this.exports)) {\n      allExportNames.add(name);\n    }\n\n    for (const name of Object.keys(this.reexportDescriptions)) {\n      allExportNames.add(name);\n    }\n\n    for (const module of this.exportAllModules) {\n      if (module instanceof ExternalModule) {\n        allExportNames.add(`*${module.id}`);\n        continue;\n      }\n\n      for (const name of module.getAllExportNames()) {\n        if (name !== 'default') allExportNames.add(name);\n      }\n    }\n\n    return allExportNames;\n  }\n\n  getDefaultExport() {\n    if (this.defaultExport === null) {\n      this.defaultExport = undefined;\n      this.defaultExport = this.getVariableForExportName('default');\n    }\n\n    if (!this.defaultExport) {\n      return error({\n        code: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT,\n        id: this.id,\n        message: `Modules with 'syntheticNamedExports' need a default export.`\n      });\n    }\n\n    return this.defaultExport;\n  }\n\n  getDynamicImportExpressions() {\n    return this.dynamicImports.map(({\n      node\n    }) => {\n      const importArgument = node.source;\n\n      if (importArgument instanceof TemplateLiteral && importArgument.quasis.length === 1 && importArgument.quasis[0].value.cooked) {\n        return importArgument.quasis[0].value.cooked;\n      }\n\n      if (importArgument instanceof Literal && typeof importArgument.value === 'string') {\n        return importArgument.value;\n      }\n\n      return importArgument;\n    });\n  }\n\n  getExportNamesByVariable() {\n    const exportNamesByVariable = new Map();\n\n    for (const exportName of this.getAllExportNames()) {\n      const tracedVariable = this.getVariableForExportName(exportName);\n\n      if (!tracedVariable || !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {\n        continue;\n      }\n\n      const existingExportNames = exportNamesByVariable.get(tracedVariable);\n\n      if (existingExportNames) {\n        existingExportNames.push(exportName);\n      } else {\n        exportNamesByVariable.set(tracedVariable, [exportName]);\n      }\n    }\n\n    return exportNamesByVariable;\n  }\n\n  getExports() {\n    return Object.keys(this.exports);\n  }\n\n  getOrCreateNamespace() {\n    if (!this.namespaceVariable) {\n      this.namespaceVariable = new NamespaceVariable(this.astContext, this.syntheticNamedExports);\n      this.namespaceVariable.initialise();\n    }\n\n    return this.namespaceVariable;\n  }\n\n  getReexports() {\n    if (this.transitiveReexports) {\n      return this.transitiveReexports;\n    } // to avoid infinite recursion when using circular `export * from X`\n\n\n    this.transitiveReexports = [];\n    const reexports = new Set();\n\n    for (const name in this.reexportDescriptions) {\n      reexports.add(name);\n    }\n\n    for (const module of this.exportAllModules) {\n      if (module instanceof ExternalModule) {\n        reexports.add(`*${module.id}`);\n      } else {\n        for (const name of module.getExports().concat(module.getReexports())) {\n          if (name !== 'default') reexports.add(name);\n        }\n      }\n    }\n\n    return this.transitiveReexports = Array.from(reexports);\n  }\n\n  getRenderedExports() {\n    // only direct exports are counted here, not reexports at all\n    const renderedExports = [];\n    const removedExports = [];\n\n    for (const exportName in this.exports) {\n      const variable = this.getVariableForExportName(exportName);\n      (variable && variable.included ? renderedExports : removedExports).push(exportName);\n    }\n\n    return {\n      renderedExports,\n      removedExports\n    };\n  }\n\n  getTransitiveDependencies() {\n    return this.dependencies.concat(this.getReexports().concat(this.getExports()).map(exportName => this.getVariableForExportName(exportName).module));\n  }\n\n  getVariableForExportName(name, isExportAllSearch, searchedNamesAndModules) {\n    if (name[0] === '*') {\n      if (name.length === 1) {\n        return this.getOrCreateNamespace();\n      } else {\n        // export * from 'external'\n        const module = this.graph.moduleById.get(name.slice(1));\n        return module.getVariableForExportName('*');\n      }\n    } // export { foo } from './other'\n\n\n    const reexportDeclaration = this.reexportDescriptions[name];\n\n    if (reexportDeclaration) {\n      const declaration = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, false, searchedNamesAndModules);\n\n      if (!declaration) {\n        return handleMissingExport(reexportDeclaration.localName, this, reexportDeclaration.module.id, reexportDeclaration.start);\n      }\n\n      return declaration;\n    }\n\n    const exportDeclaration = this.exports[name];\n\n    if (exportDeclaration) {\n      if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {\n        return this.exportShimVariable;\n      }\n\n      const name = exportDeclaration.localName;\n      return this.traceVariable(name) || this.graph.scope.findVariable(name);\n    }\n\n    if (name !== 'default') {\n      for (const module of this.exportAllModules) {\n        const declaration = getVariableForExportNameRecursive(module, name, true, searchedNamesAndModules);\n        if (declaration) return declaration;\n      }\n    } // we don't want to create shims when we are just\n    // probing export * modules for exports\n\n\n    if (!isExportAllSearch) {\n      if (this.syntheticNamedExports) {\n        let syntheticExport = this.syntheticExports.get(name);\n\n        if (!syntheticExport) {\n          const defaultExport = this.getDefaultExport();\n          syntheticExport = new SyntheticNamedExportVariableVariable(this.astContext, name, defaultExport);\n          this.syntheticExports.set(name, syntheticExport);\n          return syntheticExport;\n        }\n\n        return syntheticExport;\n      }\n\n      if (this.graph.shimMissingExports) {\n        this.shimMissingExport(name);\n        return this.exportShimVariable;\n      }\n    }\n\n    return null;\n  }\n\n  include() {\n    const context = createInclusionContext();\n    if (this.ast.shouldBeIncluded(context)) this.ast.include(context, false);\n  }\n\n  includeAllExports() {\n    if (!this.isExecuted) {\n      this.graph.needsTreeshakingPass = true;\n      markModuleAndImpureDependenciesAsExecuted(this);\n    }\n\n    const context = createInclusionContext();\n\n    for (const exportName of this.getExports()) {\n      const variable = this.getVariableForExportName(exportName);\n      variable.deoptimizePath(UNKNOWN_PATH);\n\n      if (!variable.included) {\n        variable.include(context);\n        this.graph.needsTreeshakingPass = true;\n      }\n    }\n\n    for (const name of this.getReexports()) {\n      const variable = this.getVariableForExportName(name);\n      variable.deoptimizePath(UNKNOWN_PATH);\n\n      if (!variable.included) {\n        variable.include(context);\n        this.graph.needsTreeshakingPass = true;\n      }\n\n      if (variable instanceof ExternalVariable) {\n        variable.module.reexported = true;\n      }\n    }\n  }\n\n  includeAllInBundle() {\n    this.ast.include(createInclusionContext(), true);\n  }\n\n  isIncluded() {\n    return this.ast.included || this.namespaceVariable && this.namespaceVariable.included;\n  }\n\n  linkDependencies() {\n    for (const source of this.sources) {\n      const id = this.resolvedIds[source].id;\n\n      if (id) {\n        const module = this.graph.moduleById.get(id);\n        this.dependencies.push(module);\n      }\n    }\n\n    for (const {\n      resolution\n    } of this.dynamicImports) {\n      if (resolution instanceof Module || resolution instanceof ExternalModule) {\n        this.dynamicDependencies.push(resolution);\n      }\n    }\n\n    this.addModulesToImportDescriptions(this.importDescriptions);\n    this.addModulesToImportDescriptions(this.reexportDescriptions);\n    const externalExportAllModules = [];\n\n    for (const source of this.exportAllSources) {\n      const module = this.graph.moduleById.get(this.resolvedIds[source].id);\n      (module instanceof ExternalModule ? externalExportAllModules : this.exportAllModules).push(module);\n    }\n\n    this.exportAllModules = this.exportAllModules.concat(externalExportAllModules);\n  }\n\n  render(options) {\n    const magicString = this.magicString.clone();\n    this.ast.render(magicString, options);\n    this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;\n    return magicString;\n  }\n\n  setSource({\n    ast,\n    code,\n    customTransformCache,\n    moduleSideEffects,\n    originalCode,\n    originalSourcemap,\n    resolvedIds,\n    sourcemapChain,\n    syntheticNamedExports,\n    transformDependencies,\n    transformFiles\n  }) {\n    this.code = code;\n    this.originalCode = originalCode;\n    this.originalSourcemap = originalSourcemap;\n    this.sourcemapChain = sourcemapChain;\n\n    if (transformFiles) {\n      this.transformFiles = transformFiles;\n    }\n\n    this.transformDependencies = transformDependencies;\n    this.customTransformCache = customTransformCache;\n\n    if (typeof moduleSideEffects === 'boolean') {\n      this.moduleSideEffects = moduleSideEffects;\n    }\n\n    if (typeof syntheticNamedExports === 'boolean') {\n      this.syntheticNamedExports = syntheticNamedExports;\n    }\n\n    timeStart('generate ast', 3);\n    this.esTreeAst = ast || tryParse(this, this.graph.acornParser, this.graph.acornOptions);\n    markPureCallExpressions(this.comments, this.esTreeAst);\n    timeEnd('generate ast', 3);\n    this.resolvedIds = resolvedIds || Object.create(null); // By default, `id` is the file name. Custom resolvers and loaders\n    // can change that, but it makes sense to use it for the source file name\n\n    const fileName = this.id;\n    this.magicString = new MagicString(code, {\n      filename: this.excludeFromSourcemap ? null : fileName,\n      indentExclusionRanges: []\n    });\n    this.removeExistingSourceMap();\n    timeStart('analyse ast', 3);\n    this.astContext = {\n      addDynamicImport: this.addDynamicImport.bind(this),\n      addExport: this.addExport.bind(this),\n      addImport: this.addImport.bind(this),\n      addImportMeta: this.addImportMeta.bind(this),\n      annotations: this.graph.treeshakingOptions && this.graph.treeshakingOptions.annotations,\n      code,\n      deoptimizationTracker: this.graph.deoptimizationTracker,\n      error: this.error.bind(this),\n      fileName,\n      getExports: this.getExports.bind(this),\n      getModuleExecIndex: () => this.execIndex,\n      getModuleName: this.basename.bind(this),\n      getReexports: this.getReexports.bind(this),\n      importDescriptions: this.importDescriptions,\n      includeDynamicImport: this.includeDynamicImport.bind(this),\n      includeVariable: this.includeVariable.bind(this),\n      isCrossChunkImport: importDescription => importDescription.module.chunk !== this.chunk,\n      magicString: this.magicString,\n      module: this,\n      moduleContext: this.context,\n      nodeConstructors,\n      preserveModules: this.graph.preserveModules,\n      propertyReadSideEffects: !this.graph.treeshakingOptions || this.graph.treeshakingOptions.propertyReadSideEffects,\n      traceExport: this.getVariableForExportName.bind(this),\n      traceVariable: this.traceVariable.bind(this),\n      treeshake: !!this.graph.treeshakingOptions,\n      tryCatchDeoptimization: !this.graph.treeshakingOptions || this.graph.treeshakingOptions.tryCatchDeoptimization,\n      unknownGlobalSideEffects: !this.graph.treeshakingOptions || this.graph.treeshakingOptions.unknownGlobalSideEffects,\n      usesTopLevelAwait: false,\n      warn: this.warn.bind(this),\n      warnDeprecation: this.graph.warnDeprecation.bind(this.graph)\n    };\n    this.scope = new ModuleScope(this.graph.scope, this.astContext);\n    this.ast = new Program$1(this.esTreeAst, {\n      type: 'Module',\n      context: this.astContext\n    }, this.scope);\n    timeEnd('analyse ast', 3);\n  }\n\n  toJSON() {\n    return {\n      ast: this.esTreeAst,\n      code: this.code,\n      customTransformCache: this.customTransformCache,\n      dependencies: this.dependencies.map(module => module.id),\n      id: this.id,\n      moduleSideEffects: this.moduleSideEffects,\n      originalCode: this.originalCode,\n      originalSourcemap: this.originalSourcemap,\n      resolvedIds: this.resolvedIds,\n      sourcemapChain: this.sourcemapChain,\n      syntheticNamedExports: this.syntheticNamedExports,\n      transformDependencies: this.transformDependencies,\n      transformFiles: this.transformFiles\n    };\n  }\n\n  traceVariable(name) {\n    const localVariable = this.scope.variables.get(name);\n\n    if (localVariable) {\n      return localVariable;\n    }\n\n    if (name in this.importDescriptions) {\n      const importDeclaration = this.importDescriptions[name];\n      const otherModule = importDeclaration.module;\n\n      if (otherModule instanceof Module && importDeclaration.name === '*') {\n        return otherModule.getOrCreateNamespace();\n      }\n\n      const declaration = otherModule.getVariableForExportName(importDeclaration.name);\n\n      if (!declaration) {\n        return handleMissingExport(importDeclaration.name, this, otherModule.id, importDeclaration.start);\n      }\n\n      return declaration;\n    }\n\n    return null;\n  }\n\n  warn(warning, pos) {\n    if (typeof pos === 'number') {\n      warning.pos = pos;\n      const {\n        line,\n        column\n      } = locate(this.code, pos, {\n        offsetLine: 1\n      }); // TODO trace sourcemaps, cf. error()\n\n      warning.loc = {\n        file: this.id,\n        line,\n        column\n      };\n      warning.frame = getCodeFrame(this.code, line, column);\n    }\n\n    warning.id = this.id;\n    this.graph.warn(warning);\n  }\n\n  addDynamicImport(node) {\n    this.dynamicImports.push({\n      node,\n      resolution: null\n    });\n  }\n\n  addExport(node) {\n    if (node instanceof ExportDefaultDeclaration) {\n      // export default foo;\n      this.exports.default = {\n        identifier: node.variable.getAssignedVariableName(),\n        localName: 'default'\n      };\n    } else if (node instanceof ExportAllDeclaration) {\n      // export * from './other'\n      const source = node.source.value;\n      this.sources.add(source);\n      this.exportAllSources.add(source);\n    } else if (node.source instanceof Literal) {\n      // export { name } from './other'\n      const source = node.source.value;\n      this.sources.add(source);\n\n      for (const specifier of node.specifiers) {\n        const name = specifier.exported.name;\n        this.reexportDescriptions[name] = {\n          localName: specifier.type === ExportNamespaceSpecifier ? '*' : specifier.local.name,\n          module: null,\n          source,\n          start: specifier.start\n        };\n      }\n    } else if (node.declaration) {\n      const declaration = node.declaration;\n\n      if (declaration instanceof VariableDeclaration) {\n        // export var { foo, bar } = ...\n        // export var foo = 1, bar = 2;\n        for (const declarator of declaration.declarations) {\n          for (const localName of extractAssignedNames(declarator.id)) {\n            this.exports[localName] = {\n              identifier: null,\n              localName\n            };\n          }\n        }\n      } else {\n        // export function foo () {}\n        const localName = declaration.id.name;\n        this.exports[localName] = {\n          identifier: null,\n          localName\n        };\n      }\n    } else {\n      // export { foo, bar, baz }\n      for (const specifier of node.specifiers) {\n        const localName = specifier.local.name;\n        const exportedName = specifier.exported.name;\n        this.exports[exportedName] = {\n          identifier: null,\n          localName\n        };\n      }\n    }\n  }\n\n  addImport(node) {\n    const source = node.source.value;\n    this.sources.add(source);\n\n    for (const specifier of node.specifiers) {\n      const localName = specifier.local.name;\n\n      if (this.importDescriptions[localName]) {\n        return this.error({\n          code: 'DUPLICATE_IMPORT',\n          message: `Duplicated import '${localName}'`\n        }, specifier.start);\n      }\n\n      const isDefault = specifier.type === ImportDefaultSpecifier;\n      const isNamespace = specifier.type === ImportNamespaceSpecifier;\n      const name = isDefault ? 'default' : isNamespace ? '*' : specifier.imported.name;\n      this.importDescriptions[localName] = {\n        module: null,\n        name,\n        source,\n        start: specifier.start\n      };\n    }\n  }\n\n  addImportMeta(node) {\n    this.importMetas.push(node);\n  }\n\n  addModulesToImportDescriptions(importDescription) {\n    for (const name of Object.keys(importDescription)) {\n      const specifier = importDescription[name];\n      const id = this.resolvedIds[specifier.source].id;\n      specifier.module = this.graph.moduleById.get(id);\n    }\n  }\n\n  includeDynamicImport(node) {\n    const resolution = this.dynamicImports.find(dynamicImport => dynamicImport.node === node).resolution;\n\n    if (resolution instanceof Module) {\n      resolution.dynamicallyImportedBy.push(this);\n      resolution.includeAllExports();\n    }\n  }\n\n  includeVariable(context, variable) {\n    const variableModule = variable.module;\n\n    if (!variable.included) {\n      variable.include(context);\n      this.graph.needsTreeshakingPass = true;\n    }\n\n    if (variableModule && variableModule !== this) {\n      this.imports.add(variable);\n    }\n  }\n\n  removeExistingSourceMap() {\n    for (const comment of this.comments) {\n      if (!comment.block && SOURCEMAPPING_URL_RE.test(comment.text)) {\n        this.magicString.remove(comment.start, comment.end);\n      }\n    }\n  }\n\n  shimMissingExport(name) {\n    if (!this.exports[name]) {\n      this.graph.warn({\n        code: 'SHIMMED_EXPORT',\n        exporter: relativeId(this.id),\n        exportName: name,\n        message: `Missing export \"${name}\" has been shimmed in module ${relativeId(this.id)}.`\n      });\n      this.exports[name] = MISSING_EXPORT_SHIM_DESCRIPTION;\n    }\n  }\n\n}\n\nclass Source {\n  constructor(filename, content) {\n    this.isOriginal = true;\n    this.filename = filename;\n    this.content = content;\n  }\n\n  traceSegment(line, column, name) {\n    return {\n      line,\n      column,\n      name,\n      source: this\n    };\n  }\n\n}\n\nclass Link {\n  constructor(map, sources) {\n    this.sources = sources;\n    this.names = map.names;\n    this.mappings = map.mappings;\n  }\n\n  traceMappings() {\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const mappings = [];\n\n    for (const line of this.mappings) {\n      const tracedLine = [];\n\n      for (const segment of line) {\n        if (segment.length == 1) continue;\n        const source = this.sources[segment[1]];\n        if (!source) continue;\n        const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');\n\n        if (traced) {\n          // newer sources are more likely to be used, so search backwards.\n          let sourceIndex = sources.lastIndexOf(traced.source.filename);\n\n          if (sourceIndex === -1) {\n            sourceIndex = sources.length;\n            sources.push(traced.source.filename);\n            sourcesContent[sourceIndex] = traced.source.content;\n          } else if (sourcesContent[sourceIndex] == null) {\n            sourcesContent[sourceIndex] = traced.source.content;\n          } else if (traced.source.content != null && sourcesContent[sourceIndex] !== traced.source.content) {\n            return error({\n              message: `Multiple conflicting contents for sourcemap source ${traced.source.filename}`\n            });\n          }\n\n          const tracedSegment = [segment[0], sourceIndex, traced.line, traced.column];\n\n          if (traced.name) {\n            let nameIndex = names.indexOf(traced.name);\n\n            if (nameIndex === -1) {\n              nameIndex = names.length;\n              names.push(traced.name);\n            }\n\n            tracedSegment[4] = nameIndex;\n          }\n\n          tracedLine.push(tracedSegment);\n        }\n      }\n\n      mappings.push(tracedLine);\n    }\n\n    return {\n      sources,\n      sourcesContent,\n      names,\n      mappings\n    };\n  }\n\n  traceSegment(line, column, name) {\n    const segments = this.mappings[line];\n    if (!segments) return null; // binary search through segments for the given column\n\n    let i = 0;\n    let j = segments.length - 1;\n\n    while (i <= j) {\n      const m = i + j >> 1;\n      const segment = segments[m];\n\n      if (segment[0] === column) {\n        if (segment.length == 1) return null;\n        const source = this.sources[segment[1]];\n        if (!source) return null;\n        return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);\n      }\n\n      if (segment[0] > column) {\n        j = m - 1;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction getLinkMap(graph) {\n  return function linkMap(source, map) {\n    if (map.mappings) {\n      return new Link(map, [source]);\n    }\n\n    graph.warn({\n      code: 'SOURCEMAP_BROKEN',\n      message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform ` + \"files, but didn't generate a sourcemap for the transformation. Consult the plugin \" + 'documentation for help',\n      plugin: map.plugin,\n      url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`\n    });\n    return new Link({\n      mappings: [],\n      names: []\n    }, [source]);\n  };\n}\n\nfunction getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {\n  let source;\n\n  if (!originalSourcemap) {\n    source = new Source(id, originalCode);\n  } else {\n    const sources = originalSourcemap.sources;\n    const sourcesContent = originalSourcemap.sourcesContent || []; // TODO indiscriminately treating IDs and sources as normal paths is probably bad.\n\n    const directory = dirname(id) || '.';\n    const sourceRoot = originalSourcemap.sourceRoot || '.';\n    const baseSources = sources.map((source, i) => new Source(resolve(directory, sourceRoot, source), sourcesContent[i]));\n    source = new Link(originalSourcemap, baseSources);\n  }\n\n  return sourcemapChain.reduce(linkMap, source);\n}\n\nfunction collapseSourcemaps(bundle, file, map, modules, bundleSourcemapChain, excludeContent) {\n  const linkMap = getLinkMap(bundle.graph);\n  const moduleSources = modules.filter(module => !module.excludeFromSourcemap).map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap)); // DecodedSourceMap (from magic-string) uses a number[] instead of the more\n  // correct SourceMapSegment tuples. Cast it here to gain type safety.\n\n  let source = new Link(map, moduleSources);\n  source = bundleSourcemapChain.reduce(linkMap, source);\n  let {\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  } = source.traceMappings();\n\n  if (file) {\n    const directory = dirname(file);\n    sources = sources.map(source => relative$1(directory, source));\n    file = basename(file);\n  }\n\n  sourcesContent = excludeContent ? null : sourcesContent;\n  return new SourceMap({\n    file,\n    sources,\n    sourcesContent,\n    names,\n    mappings\n  });\n}\n\nfunction collapseSourcemap(graph, id, originalCode, originalSourcemap, sourcemapChain) {\n  if (!sourcemapChain.length) {\n    return originalSourcemap;\n  }\n\n  const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(graph));\n  const map = source.traceMappings();\n  return Object.assign({\n    version: 3\n  }, map);\n}\n\nconst DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {\n  amd: deconflictImportsOther,\n  cjs: deconflictImportsOther,\n  es: deconflictImportsEsm,\n  iife: deconflictImportsOther,\n  system: deconflictImportsEsm,\n  umd: deconflictImportsOther\n};\n\nfunction deconflictChunk(modules, dependencies, imports, usedNames, format, interop, preserveModules) {\n  for (const module of modules) {\n    module.scope.addUsedOutsideNames(usedNames, format);\n  }\n\n  deconflictTopLevelVariables(usedNames, modules);\n  DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependencies, interop, preserveModules);\n\n  for (const module of modules) {\n    module.scope.deconflict(format);\n  }\n}\n\nfunction deconflictImportsEsm(usedNames, imports, _dependencies, interop) {\n  for (const variable of imports) {\n    const module = variable.module;\n    const name = variable.name;\n    let proposedName;\n\n    if (module instanceof ExternalModule && (name === '*' || name === 'default')) {\n      if (name === 'default' && interop && module.exportsNamespace) {\n        proposedName = module.variableName + '__default';\n      } else {\n        proposedName = module.variableName;\n      }\n    } else {\n      proposedName = name;\n    }\n\n    variable.setRenderNames(null, getSafeName(proposedName, usedNames));\n  }\n}\n\nfunction deconflictImportsOther(usedNames, imports, dependencies, interop, preserveModules) {\n  for (const chunkOrExternalModule of dependencies) {\n    chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.variableName, usedNames);\n  }\n\n  for (const variable of imports) {\n    const module = variable.module;\n\n    if (module instanceof ExternalModule) {\n      const name = variable.name;\n\n      if (name === 'default' && interop && (module.exportsNamespace || module.exportsNames)) {\n        variable.setRenderNames(null, module.variableName + '__default');\n      } else if (name === '*' || name === 'default') {\n        variable.setRenderNames(null, module.variableName);\n      } else {\n        variable.setRenderNames(module.variableName, null);\n      }\n    } else {\n      const chunk = module.chunk;\n\n      if (chunk.exportMode === 'default' || preserveModules && variable.isNamespace) {\n        variable.setRenderNames(null, chunk.variableName);\n      } else {\n        variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));\n      }\n    }\n  }\n}\n\nfunction deconflictTopLevelVariables(usedNames, modules) {\n  for (const module of modules) {\n    for (const variable of module.scope.variables.values()) {\n      if (variable.included && // this will only happen for exports in some formats\n      !(variable.renderBaseName || variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable)) {\n        variable.setRenderNames(null, getSafeName(variable.name, usedNames));\n      }\n    }\n\n    const namespace = module.getOrCreateNamespace();\n\n    if (namespace.included) {\n      namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));\n    }\n  }\n}\n\nconst compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;\n\nfunction sortByExecutionOrder(units) {\n  units.sort(compareExecIndex);\n}\n\nfunction analyseModuleExecution(entryModules) {\n  let nextExecIndex = 0;\n  const cyclePaths = [];\n  const analysedModules = {};\n  const orderedModules = [];\n  const dynamicImports = [];\n  const parents = {};\n\n  const analyseModule = module => {\n    if (analysedModules[module.id]) return;\n\n    if (module instanceof ExternalModule) {\n      module.execIndex = nextExecIndex++;\n      analysedModules[module.id] = true;\n      return;\n    }\n\n    for (const dependency of module.dependencies) {\n      if (dependency.id in parents) {\n        if (!analysedModules[dependency.id]) {\n          cyclePaths.push(getCyclePath(dependency.id, module.id, parents));\n        }\n\n        continue;\n      }\n\n      parents[dependency.id] = module.id;\n      analyseModule(dependency);\n    }\n\n    for (const {\n      resolution\n    } of module.dynamicImports) {\n      if (resolution instanceof Module && dynamicImports.indexOf(resolution) === -1) {\n        dynamicImports.push(resolution);\n      }\n    }\n\n    module.execIndex = nextExecIndex++;\n    analysedModules[module.id] = true;\n    orderedModules.push(module);\n  };\n\n  for (const curEntry of entryModules) {\n    if (!parents[curEntry.id]) {\n      parents[curEntry.id] = null;\n      analyseModule(curEntry);\n    }\n  }\n\n  for (const curEntry of dynamicImports) {\n    if (!parents[curEntry.id]) {\n      parents[curEntry.id] = null;\n      analyseModule(curEntry);\n    }\n  }\n\n  return {\n    orderedModules,\n    cyclePaths\n  };\n}\n\nfunction getCyclePath(id, parentId, parents) {\n  const path = [relativeId(id)];\n  let curId = parentId;\n\n  while (curId !== id) {\n    path.push(relativeId(curId));\n    curId = parents[curId];\n    if (!curId) break;\n  }\n\n  path.push(path[0]);\n  path.reverse();\n  return path;\n}\n\nfunction guessIndentString(code) {\n  const lines = code.split('\\n');\n  const tabbed = lines.filter(line => /^\\t+/.test(line));\n  const spaced = lines.filter(line => /^ {2,}/.test(line));\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getIndentString(modules, options) {\n  if (options.indent !== true) return options.indent || '';\n\n  for (let i = 0; i < modules.length; i++) {\n    const indent = guessIndentString(modules[i].originalCode);\n    if (indent !== null) return indent;\n  }\n\n  return '\\t';\n}\n\nfunction decodedSourcemap(map) {\n  if (!map) return null;\n\n  if (typeof map === 'string') {\n    map = JSON.parse(map);\n  }\n\n  if (map.mappings === '') {\n    return {\n      mappings: [],\n      names: [],\n      sources: [],\n      version: 3\n    };\n  }\n\n  let mappings;\n\n  if (typeof map.mappings === 'string') {\n    mappings = decode(map.mappings);\n  } else {\n    mappings = map.mappings;\n  }\n\n  return Object.assign(Object.assign({}, map), {\n    mappings\n  });\n}\n\nfunction renderChunk({\n  chunk,\n  code,\n  options,\n  outputPluginDriver,\n  renderChunk,\n  sourcemapChain\n}) {\n  const renderChunkReducer = (code, result, plugin) => {\n    if (result == null) return code;\n    if (typeof result === 'string') result = {\n      code: result,\n      map: undefined\n    }; // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning\n\n    if (result.map !== null) {\n      const map = decodedSourcemap(result.map);\n      sourcemapChain.push(map || {\n        missing: true,\n        plugin: plugin.name\n      });\n    }\n\n    return result.code;\n  };\n\n  let inTransformBundle = false;\n  let inRenderChunk = true;\n  return outputPluginDriver.hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer).then(code => {\n    inRenderChunk = false;\n    return outputPluginDriver.hookReduceArg0('transformChunk', [code, options, chunk], renderChunkReducer);\n  }).then(code => {\n    inTransformBundle = true;\n    return outputPluginDriver.hookReduceArg0('transformBundle', [code, options, chunk], renderChunkReducer);\n  }).catch(err => {\n    if (inRenderChunk) throw err;\n    return error(err, {\n      code: inTransformBundle ? 'BAD_BUNDLE_TRANSFORMER' : 'BAD_CHUNK_TRANSFORMER',\n      message: `Error transforming ${(inTransformBundle ? 'bundle' : 'chunk') + (err.plugin ? ` with '${err.plugin}' plugin` : '')}: ${err.message}`,\n      plugin: err.plugin\n    });\n  });\n}\n\nfunction renderNamePattern(pattern, patternName, replacements) {\n  if (!isPlainPathFragment(pattern)) return error(errFailedValidation(`Invalid pattern \"${pattern}\" for \"${patternName}\", patterns can be neither absolute nor relative paths and must not contain invalid characters.`));\n  return pattern.replace(/\\[(\\w+)\\]/g, (_match, type) => {\n    if (!replacements.hasOwnProperty(type)) {\n      return error(errFailedValidation(`\"[${type}]\" is not a valid placeholder in \"${patternName}\" pattern.`));\n    }\n\n    const replacement = replacements[type]();\n    if (!isPlainPathFragment(replacement)) return error(errFailedValidation(`Invalid substitution \"${replacement}\" for placeholder \"[${type}]\" in \"${patternName}\" pattern, can be neither absolute nor relative path.`));\n    return replacement;\n  });\n}\n\nfunction makeUnique(name, existingNames) {\n  const existingNamesLowercase = new Set(Object.keys(existingNames).map(key => key.toLowerCase()));\n  if (!existingNamesLowercase.has(name.toLocaleLowerCase())) return name;\n  const ext = extname(name);\n  name = name.substr(0, name.length - ext.length);\n  let uniqueName,\n      uniqueIndex = 1;\n\n  while (existingNamesLowercase.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()));\n\n  return uniqueName;\n}\n\nconst NON_ASSET_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];\n\nfunction getGlobalName(module, globals, graph, hasExports) {\n  let globalName;\n\n  if (typeof globals === 'function') {\n    globalName = globals(module.id);\n  } else if (globals) {\n    globalName = globals[module.id];\n  }\n\n  if (globalName) {\n    return globalName;\n  }\n\n  if (hasExports) {\n    graph.warn({\n      code: 'MISSING_GLOBAL_NAME',\n      guess: module.variableName,\n      message: `No name was provided for external module '${module.id}' in output.globals – guessing '${module.variableName}'`,\n      source: module.id\n    });\n    return module.variableName;\n  }\n}\n\nfunction isChunkRendered(chunk) {\n  return !chunk.isEmpty || chunk.entryModules.length > 0 || chunk.manualChunkAlias !== null;\n}\n\nclass Chunk$1 {\n  constructor(graph, orderedModules) {\n    this.entryModules = [];\n    this.exportMode = 'named';\n    this.facadeModule = null;\n    this.id = null;\n    this.indentString = undefined;\n    this.manualChunkAlias = null;\n    this.usedModules = undefined;\n    this.variableName = 'chunk';\n    this.dependencies = undefined;\n    this.dynamicDependencies = undefined;\n    this.exportNames = Object.create(null);\n    this.exports = new Set();\n    this.fileName = null;\n    this.imports = new Set();\n    this.name = null;\n    this.needsExportsShim = false;\n    this.renderedDeclarations = undefined;\n    this.renderedHash = undefined;\n    this.renderedModuleSources = new Map();\n    this.renderedSource = null;\n    this.renderedSourceLength = undefined;\n    this.sortedExportNames = null;\n    this.graph = graph;\n    this.orderedModules = orderedModules;\n    this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;\n    this.isEmpty = true;\n\n    for (const module of orderedModules) {\n      if (this.isEmpty && module.isIncluded()) {\n        this.isEmpty = false;\n      }\n\n      if (module.manualChunkAlias) {\n        this.manualChunkAlias = module.manualChunkAlias;\n      }\n\n      module.chunk = this;\n\n      if (module.isEntryPoint || module.dynamicallyImportedBy.some(module => orderedModules.indexOf(module) === -1)) {\n        this.entryModules.push(module);\n      }\n    }\n\n    const moduleForNaming = this.entryModules[0] || this.orderedModules[this.orderedModules.length - 1];\n\n    if (moduleForNaming) {\n      this.variableName = makeLegal(basename(moduleForNaming.chunkName || moduleForNaming.manualChunkAlias || getAliasName(moduleForNaming.id)));\n    }\n  }\n\n  static generateFacade(graph, facadedModule, facadeName) {\n    const chunk = new Chunk$1(graph, []);\n    chunk.assignFacadeName(facadeName, facadedModule);\n\n    if (!facadedModule.facadeChunk) {\n      facadedModule.facadeChunk = chunk;\n    }\n\n    chunk.dependencies = [facadedModule.chunk];\n    chunk.dynamicDependencies = [];\n    chunk.facadeModule = facadedModule;\n\n    for (const exportName of facadedModule.getAllExportNames()) {\n      const tracedVariable = facadedModule.getVariableForExportName(exportName);\n      chunk.exports.add(tracedVariable);\n      chunk.exportNames[exportName] = tracedVariable;\n    }\n\n    return chunk;\n  }\n\n  canModuleBeFacade(moduleExportNamesByVariable) {\n    for (const exposedVariable of this.exports) {\n      if (!moduleExportNamesByVariable.has(exposedVariable)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  generateFacades() {\n    const facades = [];\n\n    for (const module of this.entryModules) {\n      const requiredFacades = Array.from(module.userChunkNames).map(name => ({\n        name\n      }));\n\n      if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {\n        requiredFacades.push({});\n      }\n\n      requiredFacades.push(...Array.from(module.chunkFileNames).map(fileName => ({\n        fileName\n      })));\n\n      if (requiredFacades.length === 0) {\n        requiredFacades.push({});\n      }\n\n      if (!this.facadeModule) {\n        const exportNamesByVariable = module.getExportNamesByVariable();\n\n        if (this.graph.preserveModules || this.canModuleBeFacade(exportNamesByVariable)) {\n          this.facadeModule = module;\n          module.facadeChunk = this;\n\n          for (const [variable, exportNames] of exportNamesByVariable) {\n            for (const exportName of exportNames) {\n              this.exportNames[exportName] = variable;\n            }\n          }\n\n          this.assignFacadeName(requiredFacades.shift(), module);\n        }\n      }\n\n      for (const facadeName of requiredFacades) {\n        facades.push(Chunk$1.generateFacade(this.graph, module, facadeName));\n      }\n    }\n\n    return facades;\n  }\n\n  generateId(addons, options, existingNames, includeHash, outputPluginDriver) {\n    if (this.fileName !== null) {\n      return this.fileName;\n    }\n\n    const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint ? [options.entryFileNames || '[name].js', 'output.entryFileNames'] : [options.chunkFileNames || '[name]-[hash].js', 'output.chunkFileNames'];\n    return makeUnique(renderNamePattern(pattern, patternName, {\n      format: () => options.format === 'es' ? 'esm' : options.format,\n      hash: () => includeHash ? this.computeContentHashWithDependencies(addons, options, existingNames, outputPluginDriver) : '[hash]',\n      name: () => this.getChunkName()\n    }), existingNames);\n  }\n\n  generateIdPreserveModules(preserveModulesRelativeDir, options, existingNames) {\n    const id = this.orderedModules[0].id;\n    const sanitizedId = sanitizeFileName(id);\n    let path;\n\n    if (isAbsolute(id)) {\n      const extension = extname(id);\n      const name = renderNamePattern(options.entryFileNames || (NON_ASSET_EXTENSIONS.includes(extension) ? '[name].js' : '[name][extname].js'), 'output.entryFileNames', {\n        ext: () => extension.substr(1),\n        extname: () => extension,\n        format: () => options.format === 'es' ? 'esm' : options.format,\n        name: () => this.getChunkName()\n      });\n      path = relative(preserveModulesRelativeDir, `${dirname(sanitizedId)}/${name}`);\n    } else {\n      path = `_virtual/${basename(sanitizedId)}`;\n    }\n\n    return makeUnique(normalize(path), existingNames);\n  }\n\n  generateInternalExports(options) {\n    if (this.facadeModule !== null) return;\n    const mangle = options.format === 'system' || options.format === 'es' || options.compact;\n    let i = 0,\n        safeExportName;\n    this.exportNames = Object.create(null);\n    this.sortedExportNames = null;\n\n    if (mangle) {\n      for (const variable of this.exports) {\n        const suggestedName = variable.name[0];\n\n        if (!this.exportNames[suggestedName]) {\n          this.exportNames[suggestedName] = variable;\n        } else {\n          do {\n            safeExportName = toBase64(++i); // skip past leading number identifiers\n\n            if (safeExportName.charCodeAt(0) === 49\n            /* '1' */\n            ) {\n                i += 9 * Math.pow(64, safeExportName.length - 1);\n                safeExportName = toBase64(i);\n              }\n          } while (RESERVED_NAMES[safeExportName] || this.exportNames[safeExportName]);\n\n          this.exportNames[safeExportName] = variable;\n        }\n      }\n    } else {\n      for (const variable of this.exports) {\n        i = 0;\n        safeExportName = variable.name;\n\n        while (this.exportNames[safeExportName]) {\n          safeExportName = variable.name + '$' + ++i;\n        }\n\n        this.exportNames[safeExportName] = variable;\n      }\n    }\n  }\n\n  getChunkName() {\n    return this.name || (this.name = sanitizeFileName(this.getFallbackChunkName()));\n  }\n\n  getDynamicImportIds() {\n    return this.dynamicDependencies.map(chunk => chunk.id).filter(Boolean);\n  }\n\n  getExportNames() {\n    return this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportNames).sort());\n  }\n\n  getImportIds() {\n    return this.dependencies.map(chunk => chunk.id).filter(Boolean);\n  }\n\n  getRenderedHash(outputPluginDriver) {\n    if (this.renderedHash) return this.renderedHash;\n    if (!this.renderedSource) return '';\n    const hash = createHash();\n    const hashAugmentation = this.calculateHashAugmentation(outputPluginDriver);\n    hash.update(hashAugmentation);\n    hash.update(this.renderedSource.toString());\n    hash.update(this.getExportNames().map(exportName => {\n      const variable = this.exportNames[exportName];\n      return `${relativeId(variable.module.id).replace(/\\\\/g, '/')}:${variable.name}:${exportName}`;\n    }).join(','));\n    return this.renderedHash = hash.digest('hex');\n  }\n\n  getRenderedSourceLength() {\n    if (this.renderedSourceLength !== undefined) return this.renderedSourceLength;\n    return this.renderedSourceLength = this.renderedSource.length();\n  }\n\n  getVariableExportName(variable) {\n    if (this.graph.preserveModules && variable instanceof NamespaceVariable) {\n      return '*';\n    }\n\n    for (const exportName of Object.keys(this.exportNames)) {\n      if (this.exportNames[exportName] === variable) return exportName;\n    }\n\n    throw new Error(`Internal Error: Could not find export name for variable ${variable.name}.`);\n  }\n\n  link() {\n    const dependencies = new Set();\n    const dynamicDependencies = new Set();\n\n    for (const module of this.orderedModules) {\n      this.addDependenciesToChunk(module.getTransitiveDependencies(), dependencies);\n      this.addDependenciesToChunk(module.dynamicDependencies, dynamicDependencies);\n      this.setUpChunkImportsAndExportsForModule(module);\n    }\n\n    this.dependencies = Array.from(dependencies);\n    this.dynamicDependencies = Array.from(dynamicDependencies);\n  }\n  /*\n   * Performs a full merge of another chunk into this chunk\n   * chunkList allows updating references in other chunks for the merged chunk to this chunk\n   * A new facade will be added to chunkList if tainting exports of either as an entry point\n   */\n\n\n  merge(chunk, chunkList, options, inputBase) {\n    if (this.facadeModule !== null || chunk.facadeModule !== null) throw new Error('Internal error: Code splitting chunk merges not supported for facades');\n\n    for (const module of chunk.orderedModules) {\n      module.chunk = this;\n      this.orderedModules.push(module);\n    }\n\n    for (const variable of chunk.imports) {\n      if (!this.imports.has(variable) && variable.module.chunk !== this) {\n        this.imports.add(variable);\n      }\n    } // NB detect when exported variables are orphaned by the merge itself\n    // (involves reverse tracing dependents)\n\n\n    for (const variable of chunk.exports) {\n      if (!this.exports.has(variable)) {\n        this.exports.add(variable);\n      }\n    }\n\n    const thisOldExportNames = this.exportNames; // regenerate internal names\n\n    this.generateInternalExports(options);\n\n    const updateRenderedDeclaration = (dep, oldExportNames) => {\n      if (dep.imports) {\n        for (const impt of dep.imports) {\n          impt.imported = this.getVariableExportName(oldExportNames[impt.imported]);\n        }\n      }\n\n      if (dep.reexports) {\n        for (const reexport of dep.reexports) {\n          reexport.imported = this.getVariableExportName(oldExportNames[reexport.imported]);\n        }\n      }\n    };\n\n    const mergeRenderedDeclaration = (into, from) => {\n      if (from.imports) {\n        if (!into.imports) {\n          into.imports = from.imports;\n        } else {\n          into.imports = into.imports.concat(from.imports);\n        }\n      }\n\n      if (from.reexports) {\n        if (!into.reexports) {\n          into.reexports = from.reexports;\n        } else {\n          into.reexports = into.reexports.concat(from.reexports);\n        }\n      }\n\n      if (!into.exportsNames && from.exportsNames) {\n        into.exportsNames = true;\n      }\n\n      if (!into.exportsDefault && from.exportsDefault) {\n        into.exportsDefault = true;\n      }\n\n      into.name = this.variableName;\n    }; // go through the other chunks and update their dependencies\n    // also update their import and reexport names in the process\n\n\n    for (const c of chunkList) {\n      let includedDeclaration = undefined;\n\n      for (let i = 0; i < c.dependencies.length; i++) {\n        const dep = c.dependencies[i];\n\n        if ((dep === chunk || dep === this) && includedDeclaration) {\n          const duplicateDeclaration = c.renderedDeclarations.dependencies[i];\n          updateRenderedDeclaration(duplicateDeclaration, dep === chunk ? chunk.exportNames : thisOldExportNames);\n          mergeRenderedDeclaration(includedDeclaration, duplicateDeclaration);\n          c.renderedDeclarations.dependencies.splice(i, 1);\n          c.dependencies.splice(i--, 1);\n        } else if (dep === chunk) {\n          c.dependencies[i] = this;\n          includedDeclaration = c.renderedDeclarations.dependencies[i];\n          updateRenderedDeclaration(includedDeclaration, chunk.exportNames);\n        } else if (dep === this) {\n          includedDeclaration = c.renderedDeclarations.dependencies[i];\n          updateRenderedDeclaration(includedDeclaration, thisOldExportNames);\n        }\n      }\n    } // re-render the merged chunk\n\n\n    this.preRender(options, inputBase);\n  } // prerender allows chunk hashes and names to be generated before finalizing\n\n\n  preRender(options, inputBase) {\n    timeStart('render modules', 3);\n    const magicString = new Bundle({\n      separator: options.compact ? '' : '\\n\\n'\n    });\n    this.usedModules = [];\n    this.indentString = options.compact ? '' : getIndentString(this.orderedModules, options);\n    const n = options.compact ? '' : '\\n';\n\n    const _ = options.compact ? '' : ' ';\n\n    const renderOptions = {\n      compact: options.compact,\n      dynamicImportFunction: options.dynamicImportFunction,\n      format: options.format,\n      freeze: options.freeze !== false,\n      indent: this.indentString,\n      namespaceToStringTag: options.namespaceToStringTag === true,\n      varOrConst: options.preferConst ? 'const' : 'var'\n    }; // Make sure the direct dependencies of a chunk are present to maintain execution order\n\n    for (const {\n      module\n    } of this.imports) {\n      const chunkOrExternal = module instanceof Module ? module.chunk : module;\n\n      if (this.dependencies.indexOf(chunkOrExternal) === -1) {\n        this.dependencies.push(chunkOrExternal);\n      }\n    } // for static and dynamic entry points, inline the execution list to avoid loading latency\n\n\n    if (options.hoistTransitiveImports !== false && !this.graph.preserveModules && this.facadeModule !== null) {\n      for (const dep of this.dependencies) {\n        if (dep instanceof Chunk$1) this.inlineChunkDependencies(dep, true);\n      }\n    } // prune empty dependency chunks, inlining their side-effect dependencies\n\n\n    for (let i = 0; i < this.dependencies.length; i++) {\n      const dep = this.dependencies[i];\n\n      if (dep instanceof Chunk$1 && dep.isEmpty) {\n        this.dependencies.splice(i--, 1);\n        this.inlineChunkDependencies(dep, false);\n      }\n    }\n\n    sortByExecutionOrder(this.dependencies);\n    this.prepareDynamicImports();\n    this.setIdentifierRenderResolutions(options);\n    let hoistedSource = '';\n    const renderedModules = this.renderedModules = Object.create(null);\n\n    for (const module of this.orderedModules) {\n      let renderedLength = 0;\n\n      if (module.isIncluded()) {\n        const source = module.render(renderOptions).trim();\n        if (options.compact && source.lastLine().indexOf('//') !== -1) source.append('\\n');\n        const namespace = module.getOrCreateNamespace();\n\n        if (namespace.included || source.length() > 0) {\n          renderedLength = source.length();\n          this.renderedModuleSources.set(module, source);\n          magicString.addSource(source);\n          this.usedModules.push(module);\n\n          if (namespace.included && !this.graph.preserveModules) {\n            const rendered = namespace.renderBlock(renderOptions);\n            if (namespace.renderFirst()) hoistedSource += n + rendered;else magicString.addSource(new MagicString(rendered));\n          }\n        }\n      }\n\n      const {\n        renderedExports,\n        removedExports\n      } = module.getRenderedExports();\n      renderedModules[module.id] = {\n        originalLength: module.originalCode.length,\n        removedExports,\n        renderedExports,\n        renderedLength\n      };\n    }\n\n    if (hoistedSource) magicString.prepend(hoistedSource + n + n);\n\n    if (this.needsExportsShim) {\n      magicString.prepend(`${n}${renderOptions.varOrConst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);\n    }\n\n    if (options.compact) {\n      this.renderedSource = magicString;\n    } else {\n      this.renderedSource = magicString.trim();\n    }\n\n    this.renderedSourceLength = undefined;\n    this.renderedHash = undefined;\n\n    if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.length === 0) {\n      const chunkName = this.getChunkName();\n      this.graph.warn({\n        chunkName,\n        code: 'EMPTY_BUNDLE',\n        message: `Generated an empty chunk: \"${chunkName}\"`\n      });\n    }\n\n    this.setExternalRenderPaths(options, inputBase);\n    this.renderedDeclarations = {\n      dependencies: this.getChunkDependencyDeclarations(options),\n      exports: this.exportMode === 'none' ? [] : this.getChunkExportDeclarations()\n    };\n    timeEnd('render modules', 3);\n  }\n\n  render(options, addons, outputChunk, outputPluginDriver) {\n    timeStart('render format', 3);\n    const format = options.format;\n    const finalise = finalisers[format];\n\n    if (options.dynamicImportFunction && format !== 'es') {\n      this.graph.warn({\n        code: 'INVALID_OPTION',\n        message: '\"output.dynamicImportFunction\" is ignored for formats other than \"esm\".'\n      });\n    } // populate ids in the rendered declarations only here\n    // as chunk ids known only after prerender\n\n\n    for (let i = 0; i < this.dependencies.length; i++) {\n      const dep = this.dependencies[i];\n      if (dep instanceof ExternalModule && !dep.renormalizeRenderPath) continue;\n      const renderedDependency = this.renderedDeclarations.dependencies[i];\n      const depId = dep instanceof ExternalModule ? renderedDependency.id : dep.id;\n      if (dep instanceof Chunk$1) renderedDependency.namedExportsMode = dep.exportMode !== 'default';\n      renderedDependency.id = this.getRelativePath(depId);\n    }\n\n    this.finaliseDynamicImports(format);\n    this.finaliseImportMetas(format, outputPluginDriver);\n    const hasExports = this.renderedDeclarations.exports.length !== 0 || this.renderedDeclarations.dependencies.some(dep => dep.reexports && dep.reexports.length !== 0);\n    let usesTopLevelAwait = false;\n    const accessedGlobals = new Set();\n\n    for (const module of this.orderedModules) {\n      if (module.usesTopLevelAwait) {\n        usesTopLevelAwait = true;\n      }\n\n      const accessedGlobalVariablesByFormat = module.scope.accessedGlobalVariablesByFormat;\n      const accessedGlobalVariables = accessedGlobalVariablesByFormat && accessedGlobalVariablesByFormat.get(format);\n\n      if (accessedGlobalVariables) {\n        for (const name of accessedGlobalVariables) {\n          accessedGlobals.add(name);\n        }\n      }\n    }\n\n    if (usesTopLevelAwait && format !== 'es' && format !== 'system') {\n      return error({\n        code: 'INVALID_TLA_FORMAT',\n        message: `Module format ${format} does not support top-level await. Use the \"es\" or \"system\" output formats rather.`\n      });\n    }\n\n    const magicString = finalise(this.renderedSource, {\n      accessedGlobals,\n      dependencies: this.renderedDeclarations.dependencies,\n      exports: this.renderedDeclarations.exports,\n      hasExports,\n      indentString: this.indentString,\n      intro: addons.intro,\n      isEntryModuleFacade: this.graph.preserveModules || this.facadeModule !== null && this.facadeModule.isEntryPoint,\n      namedExportsMode: this.exportMode !== 'default',\n      outro: addons.outro,\n      usesTopLevelAwait,\n      varOrConst: options.preferConst ? 'const' : 'var',\n      warn: this.graph.warn.bind(this.graph)\n    }, options);\n    if (addons.banner) magicString.prepend(addons.banner);\n    if (addons.footer) magicString.append(addons.footer);\n    const prevCode = magicString.toString();\n    timeEnd('render format', 3);\n    let map = null;\n    const chunkSourcemapChain = [];\n    return renderChunk({\n      chunk: this,\n      code: prevCode,\n      options,\n      outputPluginDriver,\n      renderChunk: outputChunk,\n      sourcemapChain: chunkSourcemapChain\n    }).then(code => {\n      if (options.sourcemap) {\n        timeStart('sourcemap', 3);\n        let file;\n        if (options.file) file = resolve(options.sourcemapFile || options.file);else if (options.dir) file = resolve(options.dir, this.id);else file = resolve(this.id);\n        const decodedMap = magicString.generateDecodedMap({});\n        map = collapseSourcemaps(this, file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources);\n        map.sources = map.sources.map(sourcePath => normalize(options.sourcemapPathTransform ? options.sourcemapPathTransform(sourcePath) : sourcePath));\n        timeEnd('sourcemap', 3);\n      }\n\n      if (options.compact !== true && code[code.length - 1] !== '\\n') code += '\\n';\n      return {\n        code,\n        map\n      };\n    });\n  }\n\n  visitDependencies(handleDependency) {\n    const toBeVisited = [this];\n    const visited = new Set();\n\n    for (const current of toBeVisited) {\n      handleDependency(current);\n      if (current instanceof ExternalModule) continue;\n\n      for (const dependency of current.dependencies.concat(current.dynamicDependencies)) {\n        if (!visited.has(dependency)) {\n          visited.add(dependency);\n          toBeVisited.push(dependency);\n        }\n      }\n    }\n  }\n\n  visitStaticDependenciesUntilCondition(isConditionSatisfied) {\n    const seen = new Set();\n\n    function visitDep(dep) {\n      if (seen.has(dep)) return undefined;\n      seen.add(dep);\n\n      if (dep instanceof Chunk$1) {\n        for (const subDep of dep.dependencies) {\n          if (visitDep(subDep)) return true;\n        }\n      }\n\n      return isConditionSatisfied(dep) === true;\n    }\n\n    return visitDep(this);\n  }\n\n  addDependenciesToChunk(moduleDependencies, chunkDependencies) {\n    for (const depModule of moduleDependencies) {\n      if (depModule.chunk === this) {\n        continue;\n      }\n\n      let dependency;\n\n      if (depModule instanceof Module) {\n        dependency = depModule.chunk;\n      } else {\n        if (!(depModule.used || depModule.moduleSideEffects)) {\n          continue;\n        }\n\n        dependency = depModule;\n      }\n\n      chunkDependencies.add(dependency);\n    }\n  }\n\n  assignFacadeName({\n    fileName,\n    name\n  }, facadedModule) {\n    if (fileName) {\n      this.fileName = fileName;\n    } else {\n      this.name = sanitizeFileName(name || facadedModule.chunkName || getAliasName(facadedModule.id));\n    }\n  }\n\n  calculateHashAugmentation(outputPluginDriver) {\n    const facadeModule = this.facadeModule;\n    const getChunkName = this.getChunkName.bind(this);\n    const preRenderedChunk = {\n      dynamicImports: this.getDynamicImportIds(),\n      exports: this.getExportNames(),\n      facadeModuleId: facadeModule && facadeModule.id,\n      imports: this.getImportIds(),\n      isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,\n      isEntry: facadeModule !== null && facadeModule.isEntryPoint,\n      modules: this.renderedModules,\n\n      get name() {\n        return getChunkName();\n      }\n\n    };\n    return outputPluginDriver.hookReduceValueSync('augmentChunkHash', '', [preRenderedChunk], (hashAugmentation, pluginHash) => {\n      if (pluginHash) {\n        hashAugmentation += pluginHash;\n      }\n\n      return hashAugmentation;\n    });\n  }\n\n  computeContentHashWithDependencies(addons, options, existingNames, outputPluginDriver) {\n    const hash = createHash();\n    hash.update([addons.intro, addons.outro, addons.banner, addons.footer].map(addon => addon || '').join(':'));\n    hash.update(options.format);\n    this.visitDependencies(dep => {\n      if (dep instanceof ExternalModule) {\n        hash.update(':' + dep.renderPath);\n      } else {\n        hash.update(dep.getRenderedHash(outputPluginDriver));\n        hash.update(dep.generateId(addons, options, existingNames, false, outputPluginDriver));\n      }\n    });\n    return hash.digest('hex').substr(0, 8);\n  }\n\n  finaliseDynamicImports(format) {\n    for (const [module, code] of this.renderedModuleSources) {\n      for (const {\n        node,\n        resolution\n      } of module.dynamicImports) {\n        if (!resolution) continue;\n\n        if (resolution instanceof Module) {\n          if (resolution.chunk !== this && isChunkRendered(resolution.chunk)) {\n            const resolutionChunk = resolution.facadeChunk || resolution.chunk;\n            node.renderFinalResolution(code, `'${this.getRelativePath(resolutionChunk.id)}'`, format);\n          }\n        } else {\n          node.renderFinalResolution(code, resolution instanceof ExternalModule ? `'${resolution.renormalizeRenderPath ? this.getRelativePath(resolution.renderPath) : resolution.id}'` : resolution, format);\n        }\n      }\n    }\n  }\n\n  finaliseImportMetas(format, outputPluginDriver) {\n    for (const [module, code] of this.renderedModuleSources) {\n      for (const importMeta of module.importMetas) {\n        importMeta.renderFinalMechanism(code, this.id, format, outputPluginDriver);\n      }\n    }\n  }\n\n  getChunkDependencyDeclarations(options) {\n    const reexportDeclarations = new Map();\n\n    for (let exportName of this.getExportNames()) {\n      let exportChunk;\n      let importName;\n      let needsLiveBinding = false;\n\n      if (exportName[0] === '*') {\n        needsLiveBinding = options.externalLiveBindings !== false;\n        exportChunk = this.graph.moduleById.get(exportName.substr(1));\n        importName = exportName = '*';\n      } else {\n        const variable = this.exportNames[exportName];\n        const module = variable.module; // skip local exports\n\n        if (!module || module.chunk === this) continue;\n\n        if (module instanceof Module) {\n          exportChunk = module.chunk;\n          importName = exportChunk.getVariableExportName(variable);\n          needsLiveBinding = variable.isReassigned;\n        } else {\n          exportChunk = module;\n          importName = variable.name;\n          needsLiveBinding = options.externalLiveBindings !== false;\n        }\n      }\n\n      let reexportDeclaration = reexportDeclarations.get(exportChunk);\n      if (!reexportDeclaration) reexportDeclarations.set(exportChunk, reexportDeclaration = []);\n      reexportDeclaration.push({\n        imported: importName,\n        reexported: exportName,\n        needsLiveBinding\n      });\n    }\n\n    const renderedImports = new Set();\n    const dependencies = [];\n\n    for (const dep of this.dependencies) {\n      const imports = [];\n\n      for (const variable of this.imports) {\n        const renderedVariable = variable instanceof ExportDefaultVariable ? variable.getOriginalVariable() : variable;\n\n        if ((variable.module instanceof Module ? variable.module.chunk === dep : variable.module === dep) && !renderedImports.has(renderedVariable)) {\n          renderedImports.add(renderedVariable);\n          imports.push({\n            imported: variable.module instanceof ExternalModule ? variable.name : variable.module.chunk.getVariableExportName(variable),\n            local: variable.getName()\n          });\n        }\n      }\n\n      const reexports = reexportDeclarations.get(dep);\n      let exportsNames, exportsDefault;\n      let namedExportsMode = true;\n\n      if (dep instanceof ExternalModule) {\n        exportsNames = dep.exportsNames || dep.exportsNamespace;\n        exportsDefault = 'default' in dep.declarations;\n      } else {\n        exportsNames = true; // we don't want any interop patterns to trigger\n\n        exportsDefault = false;\n        namedExportsMode = dep.exportMode !== 'default';\n      }\n\n      let id = undefined;\n      let globalName = undefined;\n\n      if (dep instanceof ExternalModule) {\n        id = dep.renderPath;\n\n        if (options.format === 'umd' || options.format === 'iife') {\n          globalName = getGlobalName(dep, options.globals, this.graph, exportsNames || exportsDefault);\n        }\n      }\n\n      dependencies.push({\n        exportsDefault,\n        exportsNames,\n        globalName,\n        id,\n        imports: imports.length > 0 ? imports : null,\n        isChunk: dep instanceof Chunk$1,\n        name: dep.variableName,\n        namedExportsMode,\n        reexports\n      });\n    }\n\n    return dependencies;\n  }\n\n  getChunkExportDeclarations() {\n    const exports = [];\n\n    for (const exportName of this.getExportNames()) {\n      if (exportName[0] === '*') continue;\n      const variable = this.exportNames[exportName];\n      const module = variable.module;\n      if (module && module.chunk !== this) continue;\n      let hoisted = false;\n      let uninitialized = false;\n\n      if (variable instanceof LocalVariable) {\n        if (variable.init === UNDEFINED_EXPRESSION) {\n          uninitialized = true;\n        }\n\n        for (const declaration of variable.declarations) {\n          if (declaration.parent instanceof FunctionDeclaration || declaration instanceof ExportDefaultDeclaration && declaration.declaration instanceof FunctionDeclaration) {\n            hoisted = true;\n            break;\n          }\n        }\n      } else if (variable instanceof GlobalVariable) {\n        hoisted = true;\n      }\n\n      const localName = variable.getName();\n      exports.push({\n        exported: exportName === '*' ? localName : exportName,\n        hoisted,\n        local: localName,\n        uninitialized\n      });\n    }\n\n    return exports;\n  }\n\n  getFallbackChunkName() {\n    if (this.manualChunkAlias) {\n      return this.manualChunkAlias;\n    }\n\n    if (this.fileName) {\n      return getAliasName(this.fileName);\n    }\n\n    return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);\n  }\n\n  getRelativePath(targetPath) {\n    const relativePath = normalize(relative(dirname(this.id), targetPath));\n    return relativePath.startsWith('../') ? relativePath : './' + relativePath;\n  }\n\n  inlineChunkDependencies(chunk, deep) {\n    for (const dep of chunk.dependencies) {\n      if (dep instanceof ExternalModule) {\n        if (this.dependencies.indexOf(dep) === -1) this.dependencies.push(dep);\n      } else {\n        if (dep === this || this.dependencies.indexOf(dep) !== -1) continue;\n        if (!dep.isEmpty) this.dependencies.push(dep);\n        if (deep) this.inlineChunkDependencies(dep, true);\n      }\n    }\n  }\n\n  prepareDynamicImports() {\n    for (const module of this.orderedModules) {\n      for (const {\n        node,\n        resolution\n      } of module.dynamicImports) {\n        if (!node.included) continue;\n\n        if (resolution instanceof Module) {\n          if (resolution.chunk === this) {\n            const namespace = resolution.getOrCreateNamespace();\n            node.setResolution('named', namespace);\n          } else {\n            node.setResolution(resolution.chunk.exportMode);\n          }\n        } else {\n          node.setResolution('auto');\n        }\n      }\n    }\n  }\n\n  setExternalRenderPaths(options, inputBase) {\n    for (const dependency of this.dependencies.concat(this.dynamicDependencies)) {\n      if (dependency instanceof ExternalModule) {\n        dependency.setRenderPath(options, inputBase);\n      }\n    }\n  }\n\n  setIdentifierRenderResolutions(options) {\n    for (const exportName of this.getExportNames()) {\n      const exportVariable = this.exportNames[exportName];\n\n      if (exportVariable) {\n        if (exportVariable instanceof ExportShimVariable) {\n          this.needsExportsShim = true;\n        }\n\n        exportVariable.exportName = exportName;\n\n        if (options.format !== 'es' && options.format !== 'system' && exportVariable.isReassigned && !exportVariable.isId && !(exportVariable instanceof ExportDefaultVariable && exportVariable.hasId)) {\n          exportVariable.setRenderNames('exports', exportName);\n        } else {\n          exportVariable.setRenderNames(null, null);\n        }\n      }\n    }\n\n    const usedNames = new Set();\n\n    if (this.needsExportsShim) {\n      usedNames.add(MISSING_EXPORT_SHIM_VARIABLE);\n    }\n\n    if (options.format !== 'es') {\n      usedNames.add('exports');\n\n      if (options.format === 'cjs') {\n        usedNames.add(INTEROP_DEFAULT_VARIABLE).add('require').add('module').add('__filename').add('__dirname');\n      }\n    }\n\n    deconflictChunk(this.orderedModules, this.dependencies, this.imports, usedNames, options.format, options.interop !== false, this.graph.preserveModules);\n  }\n\n  setUpChunkImportsAndExportsForModule(module) {\n    for (const variable of module.imports) {\n      if (variable.module.chunk !== this) {\n        this.imports.add(variable);\n\n        if (variable.module instanceof Module) {\n          variable.module.chunk.exports.add(variable);\n        }\n      }\n    }\n\n    if (module.isEntryPoint || module.dynamicallyImportedBy.some(importer => importer.chunk !== this)) {\n      const map = module.getExportNamesByVariable();\n\n      for (const exportedVariable of map.keys()) {\n        this.exports.add(exportedVariable);\n        const exportingModule = exportedVariable.module;\n\n        if (exportingModule && exportingModule.chunk && exportingModule.chunk !== this) {\n          exportingModule.chunk.exports.add(exportedVariable);\n        }\n      }\n    }\n\n    if (module.getOrCreateNamespace().included) {\n      for (const reexportName of Object.keys(module.reexportDescriptions)) {\n        const reexport = module.reexportDescriptions[reexportName];\n        const variable = reexport.module.getVariableForExportName(reexport.localName);\n\n        if (variable.module.chunk !== this) {\n          this.imports.add(variable);\n\n          if (variable.module instanceof Module) {\n            variable.module.chunk.exports.add(variable);\n          }\n        }\n      }\n    }\n\n    const context = createInclusionContext();\n\n    for (const {\n      node,\n      resolution\n    } of module.dynamicImports) {\n      if (node.included && resolution instanceof Module && resolution.chunk === this) resolution.getOrCreateNamespace().include(context);\n    }\n  }\n\n}\n/*\n * Given a chunk list, perform optimizations on that chunk list\n * to reduce the mumber of chunks. Mutates the chunks array.\n *\n * Manual chunks (with chunk.chunkAlias already set) are preserved\n * Entry points are carefully preserved as well\n *\n */\n\n\nfunction optimizeChunks(chunks, options, CHUNK_GROUPING_SIZE, inputBase) {\n  for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n    const mainChunk = chunks[chunkIndex];\n    const execGroup = [];\n    mainChunk.visitStaticDependenciesUntilCondition(dep => {\n      if (dep instanceof Chunk$1) {\n        execGroup.push(dep);\n      }\n    });\n\n    if (execGroup.length < 2) {\n      continue;\n    }\n\n    let execGroupIndex = 1;\n    let seekingFirstMergeCandidate = true;\n    let lastChunk = undefined,\n        chunk = execGroup[0],\n        nextChunk = execGroup[1];\n\n    const isMergeCandidate = chunk => {\n      if (chunk.facadeModule !== null || chunk.manualChunkAlias !== null) {\n        return false;\n      }\n\n      if (!nextChunk || nextChunk.facadeModule !== null) {\n        return false;\n      }\n\n      if (chunk.getRenderedSourceLength() > CHUNK_GROUPING_SIZE) {\n        return false;\n      } // if (!chunk.isPure()) continue;\n\n\n      return true;\n    };\n\n    do {\n      if (seekingFirstMergeCandidate) {\n        if (isMergeCandidate(chunk)) {\n          seekingFirstMergeCandidate = false;\n        }\n\n        continue;\n      }\n\n      let remainingSize = CHUNK_GROUPING_SIZE - lastChunk.getRenderedSourceLength() - chunk.getRenderedSourceLength();\n\n      if (remainingSize <= 0) {\n        if (!isMergeCandidate(chunk)) {\n          seekingFirstMergeCandidate = true;\n        }\n\n        continue;\n      } // if (!chunk.isPure()) continue;\n\n\n      const chunkDependencies = new Set();\n      chunk.visitStaticDependenciesUntilCondition(dep => chunkDependencies.add(dep));\n      const ignoreSizeChunks = new Set([chunk, lastChunk]);\n\n      if (lastChunk.visitStaticDependenciesUntilCondition(dep => {\n        if (dep === chunk || dep === lastChunk) {\n          return false;\n        }\n\n        if (chunkDependencies.has(dep)) {\n          return false;\n        }\n\n        if (dep instanceof ExternalModule) {\n          return true;\n        }\n\n        remainingSize -= dep.getRenderedSourceLength();\n\n        if (remainingSize <= 0) {\n          return true;\n        }\n\n        ignoreSizeChunks.add(dep);\n      })) {\n        if (!isMergeCandidate(chunk)) {\n          seekingFirstMergeCandidate = true;\n        }\n\n        continue;\n      }\n\n      if (chunk.visitStaticDependenciesUntilCondition(dep => {\n        if (ignoreSizeChunks.has(dep)) {\n          return false;\n        }\n\n        if (dep instanceof ExternalModule) {\n          return true;\n        }\n\n        remainingSize -= dep.getRenderedSourceLength();\n\n        if (remainingSize <= 0) {\n          return true;\n        }\n      })) {\n        if (!isMergeCandidate(chunk)) {\n          seekingFirstMergeCandidate = true;\n        }\n\n        continue;\n      } // within the size limit -> merge!\n\n\n      const optimizedChunkIndex = chunks.indexOf(chunk);\n      if (optimizedChunkIndex <= chunkIndex) chunkIndex--;\n      chunks.splice(optimizedChunkIndex, 1);\n      lastChunk.merge(chunk, chunks, options, inputBase);\n      execGroup.splice(--execGroupIndex, 1);\n      chunk = lastChunk; // keep going to see if we can merge this with the next again\n\n      if (nextChunk && !isMergeCandidate(nextChunk)) {\n        seekingFirstMergeCandidate = true;\n      }\n    } while ((lastChunk = chunk, chunk = nextChunk, nextChunk = execGroup[++execGroupIndex], chunk));\n  }\n\n  return chunks;\n}\n\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst tt = acorn__default.tokTypes;\n\nvar acornExportNsFrom = function (Parser) {\n  return class extends Parser {\n    parseExport(node, exports) {\n      skipWhiteSpace.lastIndex = this.pos;\n      const skip = skipWhiteSpace.exec(this.input);\n      const next = this.input.charAt(this.pos + skip[0].length);\n      if (next !== \"*\") return super.parseExport(node, exports);\n      this.next();\n      const specifier = this.startNode();\n      this.expect(tt.star);\n\n      if (this.eatContextual(\"as\")) {\n        node.declaration = null;\n        specifier.exported = this.parseIdent(true);\n        this.checkExport(exports, specifier.exported.name, this.lastTokStart);\n        node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n      }\n\n      this.expectContextual(\"from\");\n      if (this.type !== tt.string) this.unexpected();\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, node.specifiers ? \"ExportNamedDeclaration\" : \"ExportAllDeclaration\");\n    }\n\n  };\n};\n\nconst tt$1 = acorn__default.tokTypes;\nconst skipWhiteSpace$1 = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nconst nextTokenIsDot = parser => {\n  skipWhiteSpace$1.lastIndex = parser.pos;\n  let skip = skipWhiteSpace$1.exec(parser.input);\n  let next = parser.pos + skip[0].length;\n  return parser.input.slice(next, next + 1) === \".\";\n};\n\nvar acornImportMeta = function (Parser) {\n  return class extends Parser {\n    parseExprAtom(refDestructuringErrors) {\n      if (this.type !== tt$1._import || !nextTokenIsDot(this)) return super.parseExprAtom(refDestructuringErrors);\n\n      if (!this.options.allowImportExportEverywhere && !this.inModule) {\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n      }\n\n      let node = this.startNode();\n      node.meta = this.parseIdent(true);\n      this.expect(tt$1.dot);\n      node.property = this.parseIdent(true);\n\n      if (node.property.name !== \"meta\") {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for import is import.meta\");\n      }\n\n      if (this.containsEsc) {\n        this.raiseRecoverable(node.property.start, \"\\\"meta\\\" in import.meta must not contain escape sequences\");\n      }\n\n      return this.finishNode(node, \"MetaProperty\");\n    }\n\n    parseStatement(context, topLevel, exports) {\n      if (this.type !== tt$1._import || !nextTokenIsDot(this)) {\n        return super.parseStatement(context, topLevel, exports);\n      }\n\n      let node = this.startNode();\n      let expr = this.parseExpression();\n      return this.parseExpressionStatement(node, expr);\n    }\n\n  };\n};\n\nclass UndefinedVariable extends Variable {\n  constructor() {\n    super('undefined');\n  }\n\n  getLiteralValueAtPath() {\n    return undefined;\n  }\n\n}\n\nclass GlobalScope extends Scope {\n  constructor() {\n    super();\n    this.variables.set('undefined', new UndefinedVariable());\n  }\n\n  findVariable(name) {\n    let variable = this.variables.get(name);\n\n    if (!variable) {\n      variable = new GlobalVariable(name);\n      this.variables.set(name, variable);\n    }\n\n    return variable;\n  }\n\n}\n\nconst ANONYMOUS_PLUGIN_PREFIX = 'at position ';\nconst ANONYMOUS_OUTPUT_PLUGIN_PREFIX = 'at output position ';\n\nfunction throwPluginError(err, plugin, {\n  hook,\n  id\n} = {}) {\n  if (typeof err === 'string') err = {\n    message: err\n  };\n\n  if (err.code && err.code !== Errors.PLUGIN_ERROR) {\n    err.pluginCode = err.code;\n  }\n\n  err.code = Errors.PLUGIN_ERROR;\n  err.plugin = plugin;\n\n  if (hook) {\n    err.hook = hook;\n  }\n\n  if (id) {\n    err.id = id;\n  }\n\n  return error(err);\n}\n\nconst deprecatedHooks = [{\n  active: true,\n  deprecated: 'ongenerate',\n  replacement: 'generateBundle'\n}, {\n  active: true,\n  deprecated: 'onwrite',\n  replacement: 'generateBundle/writeBundle'\n}, {\n  active: true,\n  deprecated: 'transformBundle',\n  replacement: 'renderChunk'\n}, {\n  active: true,\n  deprecated: 'transformChunk',\n  replacement: 'renderChunk'\n}, {\n  active: false,\n  deprecated: 'resolveAssetUrl',\n  replacement: 'resolveFileUrl'\n}];\n\nfunction warnDeprecatedHooks(plugins, graph) {\n  for (const {\n    active,\n    deprecated,\n    replacement\n  } of deprecatedHooks) {\n    for (const plugin of plugins) {\n      if (deprecated in plugin) {\n        graph.warnDeprecation({\n          message: `The \"${deprecated}\" hook used by plugin ${plugin.name} is deprecated. The \"${replacement}\" hook should be used instead.`,\n          plugin: plugin.name\n        }, active);\n      }\n    }\n  }\n}\n\nfunction createPluginCache(cache) {\n  return {\n    has(id) {\n      const item = cache[id];\n      if (!item) return false;\n      item[0] = 0;\n      return true;\n    },\n\n    get(id) {\n      const item = cache[id];\n      if (!item) return undefined;\n      item[0] = 0;\n      return item[1];\n    },\n\n    set(id, value) {\n      cache[id] = [0, value];\n    },\n\n    delete(id) {\n      return delete cache[id];\n    }\n\n  };\n}\n\nfunction getTrackedPluginCache(pluginCache) {\n  const trackedCache = {\n    cache: {\n      has(id) {\n        trackedCache.used = true;\n        return pluginCache.has(id);\n      },\n\n      get(id) {\n        trackedCache.used = true;\n        return pluginCache.get(id);\n      },\n\n      set(id, value) {\n        trackedCache.used = true;\n        return pluginCache.set(id, value);\n      },\n\n      delete(id) {\n        trackedCache.used = true;\n        return pluginCache.delete(id);\n      }\n\n    },\n    used: false\n  };\n  return trackedCache;\n}\n\nconst NO_CACHE = {\n  has() {\n    return false;\n  },\n\n  get() {\n    return undefined;\n  },\n\n  set() {},\n\n  delete() {\n    return false;\n  }\n\n};\n\nfunction uncacheablePluginError(pluginName) {\n  if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) || pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {\n    return error({\n      code: 'ANONYMOUS_PLUGIN_CACHE',\n      message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'\n    });\n  }\n\n  return error({\n    code: 'DUPLICATE_PLUGIN_NAME',\n    message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`\n  });\n}\n\nfunction getCacheForUncacheablePlugin(pluginName) {\n  return {\n    has() {\n      return uncacheablePluginError(pluginName);\n    },\n\n    get() {\n      return uncacheablePluginError(pluginName);\n    },\n\n    set() {\n      return uncacheablePluginError(pluginName);\n    },\n\n    delete() {\n      return uncacheablePluginError(pluginName);\n    }\n\n  };\n}\n\nfunction transform(graph, source, module) {\n  const id = module.id;\n  const sourcemapChain = [];\n  let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);\n  const originalCode = source.code;\n  let ast = source.ast;\n  const transformDependencies = [];\n  const emittedFiles = [];\n  let customTransformCache = false;\n  let moduleSideEffects = null;\n  let syntheticNamedExports = null;\n  let trackedPluginCache;\n  let curPlugin;\n  const curSource = source.code;\n\n  function transformReducer(code, result, plugin) {\n    // track which plugins use the custom this.cache to opt-out of transform caching\n    if (!customTransformCache && trackedPluginCache.used) customTransformCache = true;\n\n    if (customTransformCache) {\n      if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {\n        for (const dep of result.dependencies) {\n          graph.watchFiles[resolve(dirname(id), dep)] = true;\n        }\n      }\n    } else {\n      // files emitted by a transform hook need to be emitted again if the hook is skipped\n      if (emittedFiles.length) module.transformFiles = emittedFiles;\n\n      if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {\n        // not great, but a useful way to track this without assuming WeakMap\n        if (!curPlugin.warnedTransformDependencies) graph.warnDeprecation(`Returning \"dependencies\" from the \"transform\" hook as done by plugin ${plugin.name} is deprecated. The \"this.addWatchFile\" plugin context function should be used instead.`, true);\n        curPlugin.warnedTransformDependencies = true;\n\n        for (const dep of result.dependencies) transformDependencies.push(resolve(dirname(id), dep));\n      }\n    }\n\n    if (typeof result === 'string') {\n      result = {\n        ast: undefined,\n        code: result,\n        map: undefined\n      };\n    } else if (result && typeof result === 'object') {\n      if (typeof result.map === 'string') {\n        result.map = JSON.parse(result.map);\n      }\n\n      if (typeof result.moduleSideEffects === 'boolean') {\n        moduleSideEffects = result.moduleSideEffects;\n      }\n\n      if (typeof result.syntheticNamedExports === 'boolean') {\n        syntheticNamedExports = result.syntheticNamedExports;\n      }\n    } else {\n      return code;\n    } // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning\n\n\n    if (result.map !== null) {\n      const map = decodedSourcemap(result.map);\n      sourcemapChain.push(map || {\n        missing: true,\n        plugin: plugin.name\n      });\n    }\n\n    ast = result.ast;\n    return result.code;\n  }\n\n  let setAssetSourceErr;\n  return graph.pluginDriver.hookReduceArg0('transform', [curSource, id], transformReducer, (pluginContext, plugin) => {\n    curPlugin = plugin;\n    if (curPlugin.cacheKey) customTransformCache = true;else trackedPluginCache = getTrackedPluginCache(pluginContext.cache);\n    return Object.assign(Object.assign({}, pluginContext), {\n      cache: trackedPluginCache ? trackedPluginCache.cache : pluginContext.cache,\n\n      warn(warning, pos) {\n        if (typeof warning === 'string') warning = {\n          message: warning\n        };\n        if (pos) augmentCodeLocation(warning, pos, curSource, id);\n        warning.id = id;\n        warning.hook = 'transform';\n        pluginContext.warn(warning);\n      },\n\n      error(err, pos) {\n        if (typeof err === 'string') err = {\n          message: err\n        };\n        if (pos) augmentCodeLocation(err, pos, curSource, id);\n        err.id = id;\n        err.hook = 'transform';\n        return pluginContext.error(err);\n      },\n\n      emitAsset(name, source) {\n        const emittedFile = {\n          type: 'asset',\n          name,\n          source\n        };\n        emittedFiles.push(Object.assign({}, emittedFile));\n        return graph.pluginDriver.emitFile(emittedFile);\n      },\n\n      emitChunk(id, options) {\n        const emittedFile = {\n          type: 'chunk',\n          id,\n          name: options && options.name\n        };\n        emittedFiles.push(Object.assign({}, emittedFile));\n        return graph.pluginDriver.emitFile(emittedFile);\n      },\n\n      emitFile(emittedFile) {\n        emittedFiles.push(emittedFile);\n        return graph.pluginDriver.emitFile(emittedFile);\n      },\n\n      addWatchFile(id) {\n        transformDependencies.push(id);\n        pluginContext.addWatchFile(id);\n      },\n\n      setAssetSource(assetReferenceId, source) {\n        pluginContext.setAssetSource(assetReferenceId, source);\n\n        if (!customTransformCache && !setAssetSourceErr) {\n          try {\n            return this.error({\n              code: 'INVALID_SETASSETSOURCE',\n              message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`\n            });\n          } catch (err) {\n            setAssetSourceErr = err;\n          }\n        }\n      },\n\n      getCombinedSourcemap() {\n        const combinedMap = collapseSourcemap(graph, id, originalCode, originalSourcemap, sourcemapChain);\n\n        if (!combinedMap) {\n          const magicString = new MagicString(originalCode);\n          return magicString.generateMap({\n            includeContent: true,\n            hires: true,\n            source: id\n          });\n        }\n\n        if (originalSourcemap !== combinedMap) {\n          originalSourcemap = combinedMap;\n          sourcemapChain.length = 0;\n        }\n\n        return new SourceMap(Object.assign(Object.assign({}, combinedMap), {\n          file: null,\n          sourcesContent: combinedMap.sourcesContent\n        }));\n      }\n\n    });\n  }).catch(err => throwPluginError(err, curPlugin.name, {\n    hook: 'transform',\n    id\n  })).then(code => {\n    if (!customTransformCache && setAssetSourceErr) throw setAssetSourceErr;\n    return {\n      ast: ast,\n      code,\n      customTransformCache,\n      moduleSideEffects,\n      originalCode,\n      originalSourcemap,\n      sourcemapChain,\n      syntheticNamedExports,\n      transformDependencies\n    };\n  });\n}\n\nfunction normalizeRelativeExternalId(importer, source) {\n  return isRelative(source) ? resolve(importer, '..', source) : source;\n}\n\nfunction getIdMatcher(option) {\n  if (option === true) {\n    return () => true;\n  }\n\n  if (typeof option === 'function') {\n    return (id, ...args) => !id.startsWith('\\0') && option(id, ...args) || false;\n  }\n\n  if (option) {\n    const ids = new Set(Array.isArray(option) ? option : option ? [option] : []);\n    return id => ids.has(id);\n  }\n\n  return () => false;\n}\n\nfunction getHasModuleSideEffects(moduleSideEffectsOption, pureExternalModules, graph) {\n  if (typeof moduleSideEffectsOption === 'boolean') {\n    return () => moduleSideEffectsOption;\n  }\n\n  if (moduleSideEffectsOption === 'no-external') {\n    return (_id, external) => !external;\n  }\n\n  if (typeof moduleSideEffectsOption === 'function') {\n    return (id, external) => !id.startsWith('\\0') ? moduleSideEffectsOption(id, external) !== false : true;\n  }\n\n  if (Array.isArray(moduleSideEffectsOption)) {\n    const ids = new Set(moduleSideEffectsOption);\n    return id => ids.has(id);\n  }\n\n  if (moduleSideEffectsOption) {\n    graph.warn(errInvalidOption('treeshake.moduleSideEffects', 'please use one of false, \"no-external\", a function or an array'));\n  }\n\n  const isPureExternalModule = getIdMatcher(pureExternalModules);\n  return (id, external) => !(external && isPureExternalModule(id));\n}\n\nclass ModuleLoader {\n  constructor(graph, modulesById, pluginDriver, external, getManualChunk, moduleSideEffects, pureExternalModules) {\n    this.indexedEntryModules = [];\n    this.latestLoadModulesPromise = Promise.resolve();\n    this.manualChunkModules = {};\n    this.nextEntryModuleIndex = 0;\n\n    this.loadEntryModule = (unresolvedId, isEntry) => this.pluginDriver.hookFirst('resolveId', [unresolvedId, undefined]).then(resolveIdResult => {\n      if (resolveIdResult === false || resolveIdResult && typeof resolveIdResult === 'object' && resolveIdResult.external) {\n        return error(errEntryCannotBeExternal(unresolvedId));\n      }\n\n      const id = resolveIdResult && typeof resolveIdResult === 'object' ? resolveIdResult.id : resolveIdResult;\n\n      if (typeof id === 'string') {\n        return this.fetchModule(id, undefined, true, false, isEntry);\n      }\n\n      return error(errUnresolvedEntry(unresolvedId));\n    });\n\n    this.graph = graph;\n    this.modulesById = modulesById;\n    this.pluginDriver = pluginDriver;\n    this.isExternal = getIdMatcher(external);\n    this.hasModuleSideEffects = getHasModuleSideEffects(moduleSideEffects, pureExternalModules, graph);\n    this.getManualChunk = typeof getManualChunk === 'function' ? getManualChunk : () => null;\n  }\n\n  addEntryModules(unresolvedEntryModules, isUserDefined) {\n    const firstEntryModuleIndex = this.nextEntryModuleIndex;\n    this.nextEntryModuleIndex += unresolvedEntryModules.length;\n    const loadNewEntryModulesPromise = Promise.all(unresolvedEntryModules.map(({\n      fileName,\n      id,\n      name\n    }) => this.loadEntryModule(id, true).then(module => {\n      if (fileName !== null) {\n        module.chunkFileNames.add(fileName);\n      } else if (name !== null) {\n        if (module.chunkName === null) {\n          module.chunkName = name;\n        }\n\n        if (isUserDefined) {\n          module.userChunkNames.add(name);\n        }\n      }\n\n      return module;\n    }))).then(entryModules => {\n      let moduleIndex = firstEntryModuleIndex;\n\n      for (const entryModule of entryModules) {\n        entryModule.isUserDefinedEntryPoint = entryModule.isUserDefinedEntryPoint || isUserDefined;\n        const existingIndexModule = this.indexedEntryModules.find(indexedModule => indexedModule.module.id === entryModule.id);\n\n        if (!existingIndexModule) {\n          this.indexedEntryModules.push({\n            module: entryModule,\n            index: moduleIndex\n          });\n        } else {\n          existingIndexModule.index = Math.min(existingIndexModule.index, moduleIndex);\n        }\n\n        moduleIndex++;\n      }\n\n      this.indexedEntryModules.sort(({\n        index: indexA\n      }, {\n        index: indexB\n      }) => indexA > indexB ? 1 : -1);\n      return entryModules;\n    });\n    return this.awaitLoadModulesPromise(loadNewEntryModulesPromise).then(newEntryModules => ({\n      entryModules: this.indexedEntryModules.map(({\n        module\n      }) => module),\n      manualChunkModulesByAlias: this.manualChunkModules,\n      newEntryModules\n    }));\n  }\n\n  addManualChunks(manualChunks) {\n    const unresolvedManualChunks = [];\n\n    for (const alias of Object.keys(manualChunks)) {\n      const manualChunkIds = manualChunks[alias];\n\n      for (const id of manualChunkIds) {\n        unresolvedManualChunks.push({\n          id,\n          alias\n        });\n      }\n    }\n\n    const loadNewManualChunkModulesPromise = Promise.all(unresolvedManualChunks.map(({\n      id\n    }) => this.loadEntryModule(id, false))).then(manualChunkModules => {\n      for (let index = 0; index < manualChunkModules.length; index++) {\n        this.addModuleToManualChunk(unresolvedManualChunks[index].alias, manualChunkModules[index]);\n      }\n    });\n    return this.awaitLoadModulesPromise(loadNewManualChunkModulesPromise);\n  }\n\n  resolveId(source, importer, skip) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.normalizeResolveIdResult(this.isExternal(source, importer, false) ? false : yield this.pluginDriver.hookFirst('resolveId', [source, importer], null, skip), importer, source);\n    });\n  }\n\n  addModuleToManualChunk(alias, module) {\n    if (module.manualChunkAlias !== null && module.manualChunkAlias !== alias) {\n      return error(errCannotAssignModuleToChunk(module.id, alias, module.manualChunkAlias));\n    }\n\n    module.manualChunkAlias = alias;\n\n    if (!this.manualChunkModules[alias]) {\n      this.manualChunkModules[alias] = [];\n    }\n\n    this.manualChunkModules[alias].push(module);\n  }\n\n  awaitLoadModulesPromise(loadNewModulesPromise) {\n    this.latestLoadModulesPromise = Promise.all([loadNewModulesPromise, this.latestLoadModulesPromise]);\n\n    const getCombinedPromise = () => {\n      const startingPromise = this.latestLoadModulesPromise;\n      return startingPromise.then(() => {\n        if (this.latestLoadModulesPromise !== startingPromise) {\n          return getCombinedPromise();\n        }\n      });\n    };\n\n    return getCombinedPromise().then(() => loadNewModulesPromise);\n  }\n\n  fetchAllDependencies(module) {\n    return Promise.all([...Array.from(module.sources).map(source => __awaiter(this, void 0, void 0, function* () {\n      return this.fetchResolvedDependency(source, module.id, module.resolvedIds[source] = module.resolvedIds[source] || this.handleResolveId(yield this.resolveId(source, module.id), source, module.id));\n    })), ...module.getDynamicImportExpressions().map((specifier, index) => this.resolveDynamicImport(module, specifier, module.id).then(resolvedId => {\n      if (resolvedId === null) return;\n      const dynamicImport = module.dynamicImports[index];\n\n      if (typeof resolvedId === 'string') {\n        dynamicImport.resolution = resolvedId;\n        return;\n      }\n\n      return this.fetchResolvedDependency(relativeId(resolvedId.id), module.id, resolvedId).then(module => {\n        dynamicImport.resolution = module;\n      });\n    }))]);\n  }\n\n  fetchModule(id, importer, moduleSideEffects, syntheticNamedExports, isEntry) {\n    const existingModule = this.modulesById.get(id);\n\n    if (existingModule instanceof Module) {\n      existingModule.isEntryPoint = existingModule.isEntryPoint || isEntry;\n      return Promise.resolve(existingModule);\n    }\n\n    const module = new Module(this.graph, id, moduleSideEffects, syntheticNamedExports, isEntry);\n    this.modulesById.set(id, module);\n    this.graph.watchFiles[id] = true;\n    const manualChunkAlias = this.getManualChunk(id);\n\n    if (typeof manualChunkAlias === 'string') {\n      this.addModuleToManualChunk(manualChunkAlias, module);\n    }\n\n    timeStart('load modules', 3);\n    return Promise.resolve(this.pluginDriver.hookFirst('load', [id])).catch(err => {\n      timeEnd('load modules', 3);\n      let msg = `Could not load ${id}`;\n      if (importer) msg += ` (imported by ${importer})`;\n      msg += `: ${err.message}`;\n      err.message = msg;\n      throw err;\n    }).then(source => {\n      timeEnd('load modules', 3);\n      if (typeof source === 'string') return {\n        code: source\n      };\n      if (source && typeof source === 'object' && typeof source.code === 'string') return source;\n      return error(errBadLoader(id));\n    }).then(sourceDescription => {\n      const cachedModule = this.graph.cachedModules.get(id);\n\n      if (cachedModule && !cachedModule.customTransformCache && cachedModule.originalCode === sourceDescription.code) {\n        if (cachedModule.transformFiles) {\n          for (const emittedFile of cachedModule.transformFiles) this.pluginDriver.emitFile(emittedFile);\n        }\n\n        return cachedModule;\n      }\n\n      if (typeof sourceDescription.moduleSideEffects === 'boolean') {\n        module.moduleSideEffects = sourceDescription.moduleSideEffects;\n      }\n\n      if (typeof sourceDescription.syntheticNamedExports === 'boolean') {\n        module.syntheticNamedExports = sourceDescription.syntheticNamedExports;\n      }\n\n      return transform(this.graph, sourceDescription, module);\n    }).then(source => {\n      module.setSource(source);\n      this.modulesById.set(id, module);\n      return this.fetchAllDependencies(module).then(() => {\n        for (const name in module.exports) {\n          if (name !== 'default') {\n            module.exportsAll[name] = module.id;\n          }\n        }\n\n        for (const source of module.exportAllSources) {\n          const id = module.resolvedIds[source].id;\n          const exportAllModule = this.modulesById.get(id);\n          if (exportAllModule instanceof ExternalModule) continue;\n\n          for (const name in exportAllModule.exportsAll) {\n            if (name in module.exportsAll) {\n              this.graph.warn(errNamespaceConflict(name, module, exportAllModule));\n            } else {\n              module.exportsAll[name] = exportAllModule.exportsAll[name];\n            }\n          }\n        }\n\n        return module;\n      });\n    });\n  }\n\n  fetchResolvedDependency(source, importer, resolvedId) {\n    if (resolvedId.external) {\n      if (!this.modulesById.has(resolvedId.id)) {\n        this.modulesById.set(resolvedId.id, new ExternalModule(this.graph, resolvedId.id, resolvedId.moduleSideEffects));\n      }\n\n      const externalModule = this.modulesById.get(resolvedId.id);\n\n      if (!(externalModule instanceof ExternalModule)) {\n        return error(errInternalIdCannotBeExternal(source, importer));\n      }\n\n      return Promise.resolve(externalModule);\n    } else {\n      return this.fetchModule(resolvedId.id, importer, resolvedId.moduleSideEffects, resolvedId.syntheticNamedExports, false);\n    }\n  }\n\n  handleResolveId(resolvedId, source, importer) {\n    if (resolvedId === null) {\n      if (isRelative(source)) {\n        return error(errUnresolvedImport(source, importer));\n      }\n\n      this.graph.warn(errUnresolvedImportTreatedAsExternal(source, importer));\n      return {\n        external: true,\n        id: source,\n        moduleSideEffects: this.hasModuleSideEffects(source, true),\n        syntheticNamedExports: false\n      };\n    } else {\n      if (resolvedId.external && resolvedId.syntheticNamedExports) {\n        this.graph.warn(errExternalSyntheticExports(source, importer));\n      }\n    }\n\n    return resolvedId;\n  }\n\n  normalizeResolveIdResult(resolveIdResult, importer, source) {\n    let id = '';\n    let external = false;\n    let moduleSideEffects = null;\n    let syntheticNamedExports = false;\n\n    if (resolveIdResult) {\n      if (typeof resolveIdResult === 'object') {\n        id = resolveIdResult.id;\n\n        if (resolveIdResult.external) {\n          external = true;\n        }\n\n        if (typeof resolveIdResult.moduleSideEffects === 'boolean') {\n          moduleSideEffects = resolveIdResult.moduleSideEffects;\n        }\n\n        if (typeof resolveIdResult.syntheticNamedExports === 'boolean') {\n          syntheticNamedExports = resolveIdResult.syntheticNamedExports;\n        }\n      } else {\n        if (this.isExternal(resolveIdResult, importer, true)) {\n          external = true;\n        }\n\n        id = external ? normalizeRelativeExternalId(importer, resolveIdResult) : resolveIdResult;\n      }\n    } else {\n      id = normalizeRelativeExternalId(importer, source);\n\n      if (resolveIdResult !== false && !this.isExternal(id, importer, true)) {\n        return null;\n      }\n\n      external = true;\n    }\n\n    return {\n      external,\n      id,\n      moduleSideEffects: typeof moduleSideEffects === 'boolean' ? moduleSideEffects : this.hasModuleSideEffects(id, external),\n      syntheticNamedExports\n    };\n  }\n\n  resolveDynamicImport(module, specifier, importer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO we only should expose the acorn AST here\n      const resolution = yield this.pluginDriver.hookFirst('resolveDynamicImport', [specifier, importer]);\n\n      if (typeof specifier !== 'string') {\n        if (typeof resolution === 'string') {\n          return resolution;\n        }\n\n        if (!resolution) {\n          return null;\n        }\n\n        return Object.assign({\n          external: false,\n          moduleSideEffects: true\n        }, resolution);\n      }\n\n      if (resolution == null) {\n        return module.resolvedIds[specifier] = module.resolvedIds[specifier] || this.handleResolveId(yield this.resolveId(specifier, module.id), specifier, module.id);\n      }\n\n      return this.handleResolveId(this.normalizeResolveIdResult(resolution, importer, specifier), specifier, importer);\n    });\n  }\n\n}\n\nvar BuildPhase;\n\n(function (BuildPhase) {\n  BuildPhase[BuildPhase[\"LOAD_AND_PARSE\"] = 0] = \"LOAD_AND_PARSE\";\n  BuildPhase[BuildPhase[\"ANALYSE\"] = 1] = \"ANALYSE\";\n  BuildPhase[BuildPhase[\"GENERATE\"] = 2] = \"GENERATE\";\n})(BuildPhase || (BuildPhase = {}));\n\nconst CHAR_CODE_A = 97;\nconst CHAR_CODE_0 = 48;\n\nfunction intToHex(num) {\n  if (num < 10) return String.fromCharCode(CHAR_CODE_0 + num);else return String.fromCharCode(CHAR_CODE_A + (num - 10));\n}\n\nfunction Uint8ArrayToHexString(buffer) {\n  let str = ''; // hex conversion - 2 chars per 8 bit component\n\n  for (let i = 0; i < buffer.length; i++) {\n    const num = buffer[i]; // big endian conversion, but whatever\n\n    str += intToHex(num >> 4);\n    str += intToHex(num & 0xf);\n  }\n\n  return str;\n}\n\nfunction randomUint8Array(len) {\n  const buffer = new Uint8Array(len);\n\n  for (let i = 0; i < buffer.length; i++) buffer[i] = Math.random() * (2 << 8);\n\n  return buffer;\n}\n\nfunction Uint8ArrayXor(to, from) {\n  for (let i = 0; i < to.length; i++) to[i] = to[i] ^ from[i];\n\n  return to;\n}\n\nfunction assignChunkColouringHashes(entryModules, manualChunkModules) {\n  const {\n    dependentEntryPointsByModule,\n    dynamicImportersByModule\n  } = analyzeModuleGraph(entryModules);\n  const dynamicDependentEntryPointsByDynamicEntry = getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicImportersByModule);\n  const staticEntries = new Set(entryModules);\n\n  function addColourToModuleDependencies(entry, colour, dynamicDependentEntryPoints) {\n    const manualChunkAlias = entry.manualChunkAlias;\n    const modulesToHandle = new Set([entry]);\n\n    for (const module of modulesToHandle) {\n      if (manualChunkAlias) {\n        module.manualChunkAlias = manualChunkAlias;\n        module.entryPointsHash = colour;\n      } else if (dynamicDependentEntryPoints && areEntryPointsContainedOrDynamicallyDependent(dynamicDependentEntryPoints, dependentEntryPointsByModule.get(module))) {\n        continue;\n      } else {\n        Uint8ArrayXor(module.entryPointsHash, colour);\n      }\n\n      for (const dependency of module.dependencies) {\n        if (!(dependency instanceof ExternalModule || dependency.manualChunkAlias)) {\n          modulesToHandle.add(dependency);\n        }\n      }\n    }\n  }\n\n  function areEntryPointsContainedOrDynamicallyDependent(entryPoints, superSet) {\n    const entriesToCheck = new Set(entryPoints);\n\n    for (const entry of entriesToCheck) {\n      if (!superSet.has(entry)) {\n        if (staticEntries.has(entry)) return false;\n        const dynamicDependentEntryPoints = dynamicDependentEntryPointsByDynamicEntry.get(entry);\n\n        for (const dependentEntry of dynamicDependentEntryPoints) {\n          entriesToCheck.add(dependentEntry);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  if (manualChunkModules) {\n    for (const chunkName of Object.keys(manualChunkModules)) {\n      const entryHash = randomUint8Array(10);\n\n      for (const entry of manualChunkModules[chunkName]) {\n        addColourToModuleDependencies(entry, entryHash, null);\n      }\n    }\n  }\n\n  for (const entry of entryModules) {\n    if (!entry.manualChunkAlias) {\n      const entryHash = randomUint8Array(10);\n      addColourToModuleDependencies(entry, entryHash, null);\n    }\n  }\n\n  for (const entry of dynamicImportersByModule.keys()) {\n    if (!entry.manualChunkAlias) {\n      const entryHash = randomUint8Array(10);\n      addColourToModuleDependencies(entry, entryHash, dynamicDependentEntryPointsByDynamicEntry.get(entry));\n    }\n  }\n}\n\nfunction analyzeModuleGraph(entryModules) {\n  const dynamicImportersByModule = new Map();\n  const dependentEntryPointsByModule = new Map();\n  const entriesToHandle = new Set(entryModules);\n\n  for (const currentEntry of entriesToHandle) {\n    const modulesToHandle = new Set([currentEntry]);\n\n    for (const module of modulesToHandle) {\n      getDependentModules(dependentEntryPointsByModule, module).add(currentEntry);\n\n      for (const dependency of module.dependencies) {\n        if (!(dependency instanceof ExternalModule)) {\n          modulesToHandle.add(dependency);\n        }\n      }\n\n      for (const {\n        resolution\n      } of module.dynamicImports) {\n        if (resolution instanceof Module && resolution.dynamicallyImportedBy.length > 0 && !resolution.manualChunkAlias) {\n          getDependentModules(dynamicImportersByModule, resolution).add(module);\n          entriesToHandle.add(resolution);\n        }\n      }\n    }\n  }\n\n  return {\n    dependentEntryPointsByModule,\n    dynamicImportersByModule\n  };\n}\n\nfunction getDependentModules(moduleMap, module) {\n  const dependentModules = moduleMap.get(module) || new Set();\n  moduleMap.set(module, dependentModules);\n  return dependentModules;\n}\n\nfunction getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicImportersByModule) {\n  const dynamicDependentEntryPointsByDynamicEntry = new Map();\n\n  for (const [dynamicEntry, importers] of dynamicImportersByModule.entries()) {\n    const dynamicDependentEntryPoints = getDependentModules(dynamicDependentEntryPointsByDynamicEntry, dynamicEntry);\n\n    for (const importer of importers) {\n      for (const entryPoint of dependentEntryPointsByModule.get(importer)) {\n        dynamicDependentEntryPoints.add(entryPoint);\n      }\n    }\n  }\n\n  return dynamicDependentEntryPointsByDynamicEntry;\n}\n\nconst createHash$1 = () => createHash$2('sha256');\n\nfunction generateAssetFileName(name, source, output) {\n  const emittedName = name || 'asset';\n  return makeUnique(renderNamePattern(output.assetFileNames, 'output.assetFileNames', {\n    hash() {\n      const hash = createHash$1();\n      hash.update(emittedName);\n      hash.update(':');\n      hash.update(source);\n      return hash.digest('hex').substr(0, 8);\n    },\n\n    ext: () => extname(emittedName).substr(1),\n    extname: () => extname(emittedName),\n    name: () => emittedName.substr(0, emittedName.length - extname(emittedName).length)\n  }), output.bundle);\n}\n\nfunction reserveFileNameInBundle(fileName, bundle, graph) {\n  if (fileName in bundle) {\n    graph.warn(errFileNameConflict(fileName));\n  }\n\n  bundle[fileName] = FILE_PLACEHOLDER;\n}\n\nconst FILE_PLACEHOLDER = {\n  type: 'placeholder'\n};\n\nfunction hasValidType(emittedFile) {\n  return emittedFile && (emittedFile.type === 'asset' || emittedFile.type === 'chunk');\n}\n\nfunction hasValidName(emittedFile) {\n  const validatedName = emittedFile.fileName || emittedFile.name;\n  return !validatedName || typeof validatedName === 'string' && isPlainPathFragment(validatedName);\n}\n\nfunction getValidSource(source, emittedFile, fileReferenceId) {\n  if (typeof source !== 'string' && !Buffer.isBuffer(source)) {\n    const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;\n    return error(errFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset \"${assetName}\"` : 'unnamed asset'}, asset source needs to be a string of Buffer.`));\n  }\n\n  return source;\n}\n\nfunction getAssetFileName(file, referenceId) {\n  if (typeof file.fileName !== 'string') {\n    return error(errAssetNotFinalisedForFileName(file.name || referenceId));\n  }\n\n  return file.fileName;\n}\n\nfunction getChunkFileName(file) {\n  const fileName = file.fileName || file.module && file.module.facadeChunk.id;\n  if (!fileName) return error(errChunkNotGeneratedForFileName(file.fileName || file.name));\n  return fileName;\n}\n\nclass FileEmitter {\n  constructor(graph, baseFileEmitter) {\n    this.output = null;\n\n    this.assertAssetsFinalized = () => {\n      for (const [referenceId, emittedFile] of this.filesByReferenceId.entries()) {\n        if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string') return error(errNoAssetSourceSet(emittedFile.name || referenceId));\n      }\n    };\n\n    this.emitFile = emittedFile => {\n      if (!hasValidType(emittedFile)) {\n        return error(errFailedValidation(`Emitted files must be of type \"asset\" or \"chunk\", received \"${emittedFile && emittedFile.type}\".`));\n      }\n\n      if (!hasValidName(emittedFile)) {\n        return error(errFailedValidation(`The \"fileName\" or \"name\" properties of emitted files must be strings that are neither absolute nor relative paths and do not contain invalid characters, received \"${emittedFile.fileName || emittedFile.name}\".`));\n      }\n\n      if (emittedFile.type === 'chunk') {\n        return this.emitChunk(emittedFile);\n      } else {\n        return this.emitAsset(emittedFile);\n      }\n    };\n\n    this.getFileName = fileReferenceId => {\n      const emittedFile = this.filesByReferenceId.get(fileReferenceId);\n      if (!emittedFile) return error(errFileReferenceIdNotFoundForFilename(fileReferenceId));\n\n      if (emittedFile.type === 'chunk') {\n        return getChunkFileName(emittedFile);\n      } else {\n        return getAssetFileName(emittedFile, fileReferenceId);\n      }\n    };\n\n    this.setAssetSource = (referenceId, requestedSource) => {\n      const consumedFile = this.filesByReferenceId.get(referenceId);\n      if (!consumedFile) return error(errAssetReferenceIdNotFoundForSetSource(referenceId));\n\n      if (consumedFile.type !== 'asset') {\n        return error(errFailedValidation(`Asset sources can only be set for emitted assets but \"${referenceId}\" is an emitted chunk.`));\n      }\n\n      if (consumedFile.source !== undefined) {\n        return error(errAssetSourceAlreadySet(consumedFile.name || referenceId));\n      }\n\n      const source = getValidSource(requestedSource, consumedFile, referenceId);\n\n      if (this.output) {\n        this.finalizeAsset(consumedFile, source, referenceId, this.output);\n      } else {\n        consumedFile.source = source;\n      }\n    };\n\n    this.setOutputBundle = (outputBundle, assetFileNames) => {\n      this.output = {\n        assetFileNames,\n        bundle: outputBundle\n      };\n\n      for (const emittedFile of this.filesByReferenceId.values()) {\n        if (emittedFile.fileName) {\n          reserveFileNameInBundle(emittedFile.fileName, this.output.bundle, this.graph);\n        }\n      }\n\n      for (const [referenceId, consumedFile] of this.filesByReferenceId.entries()) {\n        if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {\n          this.finalizeAsset(consumedFile, consumedFile.source, referenceId, this.output);\n        }\n      }\n    };\n\n    this.graph = graph;\n    this.filesByReferenceId = baseFileEmitter ? new Map(baseFileEmitter.filesByReferenceId) : new Map();\n  }\n\n  assignReferenceId(file, idBase) {\n    let referenceId;\n\n    do {\n      const hash = createHash$1();\n\n      if (referenceId) {\n        hash.update(referenceId);\n      } else {\n        hash.update(idBase);\n      }\n\n      referenceId = hash.digest('hex').substr(0, 8);\n    } while (this.filesByReferenceId.has(referenceId));\n\n    this.filesByReferenceId.set(referenceId, file);\n    return referenceId;\n  }\n\n  emitAsset(emittedAsset) {\n    const source = typeof emittedAsset.source !== 'undefined' ? getValidSource(emittedAsset.source, emittedAsset, null) : undefined;\n    const consumedAsset = {\n      fileName: emittedAsset.fileName,\n      name: emittedAsset.name,\n      source,\n      type: 'asset'\n    };\n    const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || emittedAsset.type);\n\n    if (this.output) {\n      if (emittedAsset.fileName) {\n        reserveFileNameInBundle(emittedAsset.fileName, this.output.bundle, this.graph);\n      }\n\n      if (source !== undefined) {\n        this.finalizeAsset(consumedAsset, source, referenceId, this.output);\n      }\n    }\n\n    return referenceId;\n  }\n\n  emitChunk(emittedChunk) {\n    if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {\n      return error(errInvalidRollupPhaseForChunkEmission());\n    }\n\n    if (typeof emittedChunk.id !== 'string') {\n      return error(errFailedValidation(`Emitted chunks need to have a valid string id, received \"${emittedChunk.id}\"`));\n    }\n\n    const consumedChunk = {\n      fileName: emittedChunk.fileName,\n      module: null,\n      name: emittedChunk.name || emittedChunk.id,\n      type: 'chunk'\n    };\n    this.graph.moduleLoader.addEntryModules([{\n      fileName: emittedChunk.fileName || null,\n      id: emittedChunk.id,\n      name: emittedChunk.name || null\n    }], false).then(({\n      newEntryModules: [module]\n    }) => {\n      consumedChunk.module = module;\n    }).catch(() => {// Avoid unhandled Promise rejection as the error will be thrown later\n      // once module loading has finished\n    });\n    return this.assignReferenceId(consumedChunk, emittedChunk.id);\n  }\n\n  finalizeAsset(consumedFile, source, referenceId, output) {\n    const fileName = consumedFile.fileName || this.findExistingAssetFileNameWithSource(output.bundle, source) || generateAssetFileName(consumedFile.name, source, output); // We must not modify the original assets to avoid interaction between outputs\n\n    const assetWithFileName = Object.assign(Object.assign({}, consumedFile), {\n      source,\n      fileName\n    });\n    this.filesByReferenceId.set(referenceId, assetWithFileName);\n    const graph = this.graph;\n    output.bundle[fileName] = {\n      fileName,\n\n      get isAsset() {\n        graph.warnDeprecation('Accessing \"isAsset\" on files in the bundle is deprecated, please use \"type === \\'asset\\'\" instead', false);\n        return true;\n      },\n\n      source,\n      type: 'asset'\n    };\n  }\n\n  findExistingAssetFileNameWithSource(bundle, source) {\n    for (const fileName of Object.keys(bundle)) {\n      const outputFile = bundle[fileName];\n      if (outputFile.type === 'asset' && (Buffer.isBuffer(source) && Buffer.isBuffer(outputFile.source) ? source.equals(outputFile.source) : source === outputFile.source)) return fileName;\n    }\n\n    return null;\n  }\n\n}\n\nfunction getDeprecatedContextHandler(handler, handlerName, newHandlerName, pluginName, activeDeprecation, graph) {\n  let deprecationWarningShown = false;\n  return (...args) => {\n    if (!deprecationWarningShown) {\n      deprecationWarningShown = true;\n      graph.warnDeprecation({\n        message: `The \"this.${handlerName}\" plugin context function used by plugin ${pluginName} is deprecated. The \"this.${newHandlerName}\" plugin context function should be used instead.`,\n        plugin: pluginName\n      }, activeDeprecation);\n    }\n\n    return handler(...args);\n  };\n}\n\nfunction getPluginContexts(pluginCache, graph, fileEmitter, watcher) {\n  const existingPluginNames = new Set();\n  return (plugin, pidx) => {\n    let cacheable = true;\n\n    if (typeof plugin.cacheKey !== 'string') {\n      if (plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) || plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) || existingPluginNames.has(plugin.name)) {\n        cacheable = false;\n      } else {\n        existingPluginNames.add(plugin.name);\n      }\n    }\n\n    let cacheInstance;\n\n    if (!pluginCache) {\n      cacheInstance = NO_CACHE;\n    } else if (cacheable) {\n      const cacheKey = plugin.cacheKey || plugin.name;\n      cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = Object.create(null)));\n    } else {\n      cacheInstance = getCacheForUncacheablePlugin(plugin.name);\n    }\n\n    const context = {\n      addWatchFile(id) {\n        if (graph.phase >= BuildPhase.GENERATE) {\n          return this.error(errInvalidRollupPhaseForAddWatchFile());\n        }\n\n        graph.watchFiles[id] = true;\n      },\n\n      cache: cacheInstance,\n      emitAsset: getDeprecatedContextHandler((name, source) => fileEmitter.emitFile({\n        type: 'asset',\n        name,\n        source\n      }), 'emitAsset', 'emitFile', plugin.name, false, graph),\n      emitChunk: getDeprecatedContextHandler((id, options) => fileEmitter.emitFile({\n        type: 'chunk',\n        id,\n        name: options && options.name\n      }), 'emitChunk', 'emitFile', plugin.name, false, graph),\n      emitFile: fileEmitter.emitFile,\n\n      error(err) {\n        return throwPluginError(err, plugin.name);\n      },\n\n      getAssetFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getAssetFileName', 'getFileName', plugin.name, false, graph),\n      getChunkFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getChunkFileName', 'getFileName', plugin.name, false, graph),\n      getFileName: fileEmitter.getFileName,\n\n      getModuleInfo(moduleId) {\n        const foundModule = graph.moduleById.get(moduleId);\n\n        if (foundModule == null) {\n          throw new Error(`Unable to find module ${moduleId}`);\n        }\n\n        return {\n          hasModuleSideEffects: foundModule.moduleSideEffects,\n          id: foundModule.id,\n          importedIds: foundModule instanceof ExternalModule ? [] : Array.from(foundModule.sources).map(id => foundModule.resolvedIds[id].id),\n          isEntry: foundModule instanceof Module && foundModule.isEntryPoint,\n          isExternal: foundModule instanceof ExternalModule\n        };\n      },\n\n      isExternal: getDeprecatedContextHandler((id, parentId, isResolved = false) => graph.moduleLoader.isExternal(id, parentId, isResolved), 'isExternal', 'resolve', plugin.name, false, graph),\n      meta: {\n        rollupVersion: version\n      },\n\n      get moduleIds() {\n        return graph.moduleById.keys();\n      },\n\n      parse: graph.contextParse,\n\n      resolve(source, importer, options) {\n        return graph.moduleLoader.resolveId(source, importer, options && options.skipSelf ? pidx : null);\n      },\n\n      resolveId: getDeprecatedContextHandler((source, importer) => graph.moduleLoader.resolveId(source, importer).then(resolveId => resolveId && resolveId.id), 'resolveId', 'resolve', plugin.name, false, graph),\n      setAssetSource: fileEmitter.setAssetSource,\n\n      warn(warning) {\n        if (typeof warning === 'string') warning = {\n          message: warning\n        };\n        if (warning.code) warning.pluginCode = warning.code;\n        warning.code = 'PLUGIN_WARNING';\n        warning.plugin = plugin.name;\n        graph.warn(warning);\n      },\n\n      watcher: watcher ? (() => {\n        let deprecationWarningShown = false;\n\n        function deprecatedWatchListener(event, handler) {\n          if (!deprecationWarningShown) {\n            context.warn({\n              code: 'PLUGIN_WATCHER_DEPRECATED',\n              message: `this.watcher usage is deprecated in plugins. Use the watchChange plugin hook and this.addWatchFile() instead.`\n            });\n            deprecationWarningShown = true;\n          }\n\n          return watcher.on(event, handler);\n        }\n\n        return Object.assign(Object.assign({}, watcher), {\n          addListener: deprecatedWatchListener,\n          on: deprecatedWatchListener\n        });\n      })() : undefined\n    };\n    return context;\n  };\n}\n\nclass PluginDriver {\n  constructor(graph, userPlugins, pluginCache, preserveSymlinks, watcher, basePluginDriver) {\n    this.previousHooks = new Set(['options']);\n    warnDeprecatedHooks(userPlugins, graph);\n    this.graph = graph;\n    this.pluginCache = pluginCache;\n    this.preserveSymlinks = preserveSymlinks;\n    this.watcher = watcher;\n    this.fileEmitter = new FileEmitter(graph, basePluginDriver && basePluginDriver.fileEmitter);\n    this.emitFile = this.fileEmitter.emitFile;\n    this.getFileName = this.fileEmitter.getFileName;\n    this.finaliseAssets = this.fileEmitter.assertAssetsFinalized;\n    this.setOutputBundle = this.fileEmitter.setOutputBundle;\n    this.plugins = userPlugins.concat(basePluginDriver ? basePluginDriver.plugins : [getRollupDefaultPlugin(preserveSymlinks)]);\n    this.pluginContexts = this.plugins.map(getPluginContexts(pluginCache, graph, this.fileEmitter, watcher));\n\n    if (basePluginDriver) {\n      for (const plugin of userPlugins) {\n        for (const hook of basePluginDriver.previousHooks) {\n          if (hook in plugin) {\n            graph.warn(errInputHookInOutputPlugin(plugin.name, hook));\n          }\n        }\n      }\n    }\n  }\n\n  createOutputPluginDriver(plugins) {\n    return new PluginDriver(this.graph, plugins, this.pluginCache, this.preserveSymlinks, this.watcher, this);\n  } // chains, first non-null result stops and returns\n\n\n  hookFirst(hookName, args, replaceContext, skip) {\n    let promise = Promise.resolve();\n\n    for (let i = 0; i < this.plugins.length; i++) {\n      if (skip === i) continue;\n      promise = promise.then(result => {\n        if (result != null) return result;\n        return this.runHook(hookName, args, i, false, replaceContext);\n      });\n    }\n\n    return promise;\n  } // chains synchronously, first non-null result stops and returns\n\n\n  hookFirstSync(hookName, args, replaceContext) {\n    for (let i = 0; i < this.plugins.length; i++) {\n      const result = this.runHookSync(hookName, args, i, replaceContext);\n      if (result != null) return result;\n    }\n\n    return null;\n  } // parallel, ignores returns\n\n\n  hookParallel(hookName, args, replaceContext) {\n    const promises = [];\n\n    for (let i = 0; i < this.plugins.length; i++) {\n      const hookPromise = this.runHook(hookName, args, i, false, replaceContext);\n      if (!hookPromise) continue;\n      promises.push(hookPromise);\n    }\n\n    return Promise.all(promises).then(() => {});\n  } // chains, reduces returns of type R, to type T, handling the reduced value as the first hook argument\n\n\n  hookReduceArg0(hookName, [arg0, ...args], reduce, replaceContext) {\n    let promise = Promise.resolve(arg0);\n\n    for (let i = 0; i < this.plugins.length; i++) {\n      promise = promise.then(arg0 => {\n        const hookPromise = this.runHook(hookName, [arg0, ...args], i, false, replaceContext);\n        if (!hookPromise) return arg0;\n        return hookPromise.then(result => reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i]));\n      });\n    }\n\n    return promise;\n  } // chains synchronously, reduces returns of type R, to type T, handling the reduced value as the first hook argument\n\n\n  hookReduceArg0Sync(hookName, [arg0, ...args], reduce, replaceContext) {\n    for (let i = 0; i < this.plugins.length; i++) {\n      const result = this.runHookSync(hookName, [arg0, ...args], i, replaceContext);\n      arg0 = reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i]);\n    }\n\n    return arg0;\n  } // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.\n\n\n  hookReduceValue(hookName, initialValue, args, reduce, replaceContext) {\n    let promise = Promise.resolve(initialValue);\n\n    for (let i = 0; i < this.plugins.length; i++) {\n      promise = promise.then(value => {\n        const hookPromise = this.runHook(hookName, args, i, true, replaceContext);\n        if (!hookPromise) return value;\n        return hookPromise.then(result => reduce.call(this.pluginContexts[i], value, result, this.plugins[i]));\n      });\n    }\n\n    return promise;\n  } // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.\n\n\n  hookReduceValueSync(hookName, initialValue, args, reduce, replaceContext) {\n    let acc = initialValue;\n\n    for (let i = 0; i < this.plugins.length; i++) {\n      const result = this.runHookSync(hookName, args, i, replaceContext);\n      acc = reduce.call(this.pluginContexts[i], acc, result, this.plugins[i]);\n    }\n\n    return acc;\n  } // chains, ignores returns\n\n\n  hookSeq(hookName, args, replaceContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let promise = Promise.resolve();\n\n      for (let i = 0; i < this.plugins.length; i++) promise = promise.then(() => this.runHook(hookName, args, i, false, replaceContext));\n\n      return promise;\n    });\n  } // chains, ignores returns\n\n\n  hookSeqSync(hookName, args, replaceContext) {\n    for (let i = 0; i < this.plugins.length; i++) this.runHookSync(hookName, args, i, replaceContext);\n  }\n\n  runHook(hookName, args, pluginIndex, permitValues, hookContext) {\n    this.previousHooks.add(hookName);\n    const plugin = this.plugins[pluginIndex];\n    const hook = plugin[hookName];\n    if (!hook) return undefined;\n    let context = this.pluginContexts[pluginIndex];\n\n    if (hookContext) {\n      context = hookContext(context, plugin);\n    }\n\n    return Promise.resolve().then(() => {\n      // permit values allows values to be returned instead of a functional hook\n      if (typeof hook !== 'function') {\n        if (permitValues) return hook;\n        return error({\n          code: 'INVALID_PLUGIN_HOOK',\n          message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`\n        });\n      }\n\n      return hook.apply(context, args);\n    }).catch(err => throwPluginError(err, plugin.name, {\n      hook: hookName\n    }));\n  }\n\n  runHookSync(hookName, args, pluginIndex, hookContext) {\n    this.previousHooks.add(hookName);\n    const plugin = this.plugins[pluginIndex];\n    let context = this.pluginContexts[pluginIndex];\n    const hook = plugin[hookName];\n    if (!hook) return undefined;\n\n    if (hookContext) {\n      context = hookContext(context, plugin);\n    }\n\n    try {\n      // permit values allows values to be returned instead of a functional hook\n      if (typeof hook !== 'function') {\n        return error({\n          code: 'INVALID_PLUGIN_HOOK',\n          message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`\n        });\n      }\n\n      return hook.apply(context, args);\n    } catch (err) {\n      return throwPluginError(err, plugin.name, {\n        hook: hookName\n      });\n    }\n  }\n\n}\n\nfunction makeOnwarn() {\n  const warned = Object.create(null);\n  return warning => {\n    const str = warning.toString();\n    if (str in warned) return;\n    console.error(str);\n    warned[str] = true;\n  };\n}\n\nfunction normalizeEntryModules(entryModules) {\n  if (typeof entryModules === 'string') {\n    return [{\n      fileName: null,\n      name: null,\n      id: entryModules\n    }];\n  }\n\n  if (Array.isArray(entryModules)) {\n    return entryModules.map(id => ({\n      fileName: null,\n      name: null,\n      id\n    }));\n  }\n\n  return Object.keys(entryModules).map(name => ({\n    fileName: null,\n    id: entryModules[name],\n    name\n  }));\n}\n\nclass Graph {\n  constructor(options, watcher) {\n    this.moduleById = new Map();\n    this.needsTreeshakingPass = false;\n    this.phase = BuildPhase.LOAD_AND_PARSE;\n    this.watchFiles = Object.create(null);\n    this.externalModules = [];\n    this.modules = [];\n    this.onwarn = options.onwarn || makeOnwarn();\n    this.deoptimizationTracker = new PathTracker();\n    this.cachedModules = new Map();\n\n    if (options.cache) {\n      if (options.cache.modules) for (const module of options.cache.modules) this.cachedModules.set(module.id, module);\n    }\n\n    if (options.cache !== false) {\n      this.pluginCache = options.cache && options.cache.plugins || Object.create(null); // increment access counter\n\n      for (const name in this.pluginCache) {\n        const cache = this.pluginCache[name];\n\n        for (const key of Object.keys(cache)) cache[key][0]++;\n      }\n    }\n\n    this.preserveModules = options.preserveModules;\n    this.strictDeprecations = options.strictDeprecations;\n    this.cacheExpiry = options.experimentalCacheExpiry;\n\n    if (options.treeshake !== false) {\n      this.treeshakingOptions = options.treeshake && options.treeshake !== true ? {\n        annotations: options.treeshake.annotations !== false,\n        moduleSideEffects: options.treeshake.moduleSideEffects,\n        propertyReadSideEffects: options.treeshake.propertyReadSideEffects !== false,\n        pureExternalModules: options.treeshake.pureExternalModules,\n        tryCatchDeoptimization: options.treeshake.tryCatchDeoptimization !== false,\n        unknownGlobalSideEffects: options.treeshake.unknownGlobalSideEffects !== false\n      } : {\n        annotations: true,\n        moduleSideEffects: true,\n        propertyReadSideEffects: true,\n        tryCatchDeoptimization: true,\n        unknownGlobalSideEffects: true\n      };\n\n      if (typeof this.treeshakingOptions.pureExternalModules !== 'undefined') {\n        this.warnDeprecation(`The \"treeshake.pureExternalModules\" option is deprecated. The \"treeshake.moduleSideEffects\" option should be used instead. \"treeshake.pureExternalModules: true\" is equivalent to \"treeshake.moduleSideEffects: 'no-external'\"`, false);\n      }\n    }\n\n    this.contextParse = (code, options = {}) => this.acornParser.parse(code, Object.assign(Object.assign(Object.assign({}, defaultAcornOptions), options), this.acornOptions));\n\n    this.pluginDriver = new PluginDriver(this, options.plugins, this.pluginCache, options.preserveSymlinks === true, watcher);\n\n    if (watcher) {\n      const handleChange = id => this.pluginDriver.hookSeqSync('watchChange', [id]);\n\n      watcher.on('change', handleChange);\n      watcher.once('restart', () => {\n        watcher.removeListener('change', handleChange);\n      });\n    }\n\n    this.shimMissingExports = options.shimMissingExports;\n    this.scope = new GlobalScope();\n    this.context = String(options.context);\n    const optionsModuleContext = options.moduleContext;\n\n    if (typeof optionsModuleContext === 'function') {\n      this.getModuleContext = id => optionsModuleContext(id) || this.context;\n    } else if (typeof optionsModuleContext === 'object') {\n      const moduleContext = new Map();\n\n      for (const key in optionsModuleContext) {\n        moduleContext.set(resolve(key), optionsModuleContext[key]);\n      }\n\n      this.getModuleContext = id => moduleContext.get(id) || this.context;\n    } else {\n      this.getModuleContext = () => this.context;\n    }\n\n    this.acornOptions = options.acorn ? Object.assign({}, options.acorn) : {};\n    const acornPluginsToInject = [];\n    acornPluginsToInject.push(acornImportMeta, acornExportNsFrom);\n    this.acornOptions.allowAwaitOutsideFunction = true;\n    const acornInjectPlugins = options.acornInjectPlugins;\n    acornPluginsToInject.push(...(Array.isArray(acornInjectPlugins) ? acornInjectPlugins : acornInjectPlugins ? [acornInjectPlugins] : []));\n    this.acornParser = Parser.extend(...acornPluginsToInject);\n    this.moduleLoader = new ModuleLoader(this, this.moduleById, this.pluginDriver, options.external, typeof options.manualChunks === 'function' && options.manualChunks, this.treeshakingOptions ? this.treeshakingOptions.moduleSideEffects : null, this.treeshakingOptions ? this.treeshakingOptions.pureExternalModules : false);\n  }\n\n  build(entryModules, manualChunks, inlineDynamicImports) {\n    // Phase 1 – discovery. We load the entry module and find which\n    // modules it imports, and import those, until we have all\n    // of the entry module's dependencies\n    timeStart('parse modules', 2);\n    return Promise.all([this.moduleLoader.addEntryModules(normalizeEntryModules(entryModules), true), manualChunks && typeof manualChunks === 'object' && this.moduleLoader.addManualChunks(manualChunks)]).then(([{\n      entryModules,\n      manualChunkModulesByAlias\n    }]) => {\n      if (entryModules.length === 0) {\n        throw new Error('You must supply options.input to rollup');\n      }\n\n      for (const module of this.moduleById.values()) {\n        if (module instanceof Module) {\n          this.modules.push(module);\n        } else {\n          this.externalModules.push(module);\n        }\n      }\n\n      timeEnd('parse modules', 2);\n      this.phase = BuildPhase.ANALYSE; // Phase 2 - linking. We populate the module dependency links and\n      // determine the topological execution order for the bundle\n\n      timeStart('analyse dependency graph', 2);\n      this.link(entryModules);\n      timeEnd('analyse dependency graph', 2); // Phase 3 – marking. We include all statements that should be included\n\n      timeStart('mark included statements', 2);\n\n      if (inlineDynamicImports) {\n        if (entryModules.length > 1) {\n          throw new Error('Internal Error: can only inline dynamic imports for single-file builds.');\n        }\n      }\n\n      for (const module of entryModules) {\n        module.includeAllExports();\n      }\n\n      this.includeMarked(this.modules); // check for unused external imports\n\n      for (const externalModule of this.externalModules) externalModule.warnUnusedImports();\n\n      timeEnd('mark included statements', 2); // Phase 4 – we construct the chunks, working out the optimal chunking using\n      // entry point graph colouring, before generating the import and export facades\n\n      timeStart('generate chunks', 2);\n\n      if (!this.preserveModules && !inlineDynamicImports) {\n        assignChunkColouringHashes(entryModules, manualChunkModulesByAlias);\n      } // TODO: there is one special edge case unhandled here and that is that any module\n      //       exposed as an unresolvable export * (to a graph external export *,\n      //       either as a namespace import reexported or top-level export *)\n      //       should be made to be its own entry point module before chunking\n\n\n      let chunks = [];\n\n      if (this.preserveModules) {\n        for (const module of this.modules) {\n          const chunk = new Chunk$1(this, [module]);\n\n          if (module.isEntryPoint || !chunk.isEmpty) {\n            chunk.entryModules = [module];\n          }\n\n          chunks.push(chunk);\n        }\n      } else {\n        const chunkModules = {};\n\n        for (const module of this.modules) {\n          const entryPointsHashStr = Uint8ArrayToHexString(module.entryPointsHash);\n          const curChunk = chunkModules[entryPointsHashStr];\n\n          if (curChunk) {\n            curChunk.push(module);\n          } else {\n            chunkModules[entryPointsHashStr] = [module];\n          }\n        }\n\n        for (const entryHashSum in chunkModules) {\n          const chunkModulesOrdered = chunkModules[entryHashSum];\n          sortByExecutionOrder(chunkModulesOrdered);\n          const chunk = new Chunk$1(this, chunkModulesOrdered);\n          chunks.push(chunk);\n        }\n      }\n\n      for (const chunk of chunks) {\n        chunk.link();\n      }\n\n      chunks = chunks.filter(isChunkRendered);\n      const facades = [];\n\n      for (const chunk of chunks) {\n        facades.push(...chunk.generateFacades());\n      }\n\n      timeEnd('generate chunks', 2);\n      this.phase = BuildPhase.GENERATE;\n      return chunks.concat(facades);\n    });\n  }\n\n  getCache() {\n    // handle plugin cache eviction\n    for (const name in this.pluginCache) {\n      const cache = this.pluginCache[name];\n      let allDeleted = true;\n\n      for (const key of Object.keys(cache)) {\n        if (cache[key][0] >= this.cacheExpiry) delete cache[key];else allDeleted = false;\n      }\n\n      if (allDeleted) delete this.pluginCache[name];\n    }\n\n    return {\n      modules: this.modules.map(module => module.toJSON()),\n      plugins: this.pluginCache\n    };\n  }\n\n  includeMarked(modules) {\n    if (this.treeshakingOptions) {\n      let treeshakingPass = 1;\n\n      do {\n        timeStart(`treeshaking pass ${treeshakingPass}`, 3);\n        this.needsTreeshakingPass = false;\n\n        for (const module of modules) {\n          if (module.isExecuted) module.include();\n        }\n\n        timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);\n      } while (this.needsTreeshakingPass);\n    } else {\n      // Necessary to properly replace namespace imports\n      for (const module of modules) module.includeAllInBundle();\n    }\n  }\n\n  warn(warning) {\n    warning.toString = () => {\n      let str = '';\n      if (warning.plugin) str += `(${warning.plugin} plugin) `;\n      if (warning.loc) str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;\n      str += warning.message;\n      return str;\n    };\n\n    this.onwarn(warning);\n  }\n\n  warnDeprecation(deprecation, activeDeprecation) {\n    if (activeDeprecation || this.strictDeprecations) {\n      const warning = errDeprecation(deprecation);\n\n      if (this.strictDeprecations) {\n        return error(warning);\n      }\n\n      this.warn(warning);\n    }\n  }\n\n  link(entryModules) {\n    for (const module of this.modules) {\n      module.linkDependencies();\n    }\n\n    const {\n      orderedModules,\n      cyclePaths\n    } = analyseModuleExecution(entryModules);\n\n    for (const cyclePath of cyclePaths) {\n      this.warn({\n        code: 'CIRCULAR_DEPENDENCY',\n        cycle: cyclePath,\n        importer: cyclePath[0],\n        message: `Circular dependency: ${cyclePath.join(' -> ')}`\n      });\n    }\n\n    this.modules = orderedModules;\n\n    for (const module of this.modules) {\n      module.bindReferences();\n    }\n\n    this.warnForMissingExports();\n  }\n\n  warnForMissingExports() {\n    for (const module of this.modules) {\n      for (const importName of Object.keys(module.importDescriptions)) {\n        const importDescription = module.importDescriptions[importName];\n\n        if (importDescription.name !== '*' && !importDescription.module.getVariableForExportName(importDescription.name)) {\n          module.warn({\n            code: 'NON_EXISTENT_EXPORT',\n            message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,\n            name: importDescription.name,\n            source: importDescription.module.id\n          }, importDescription.start);\n        }\n      }\n    }\n  }\n\n}\n\nfunction evalIfFn(strOrFn) {\n  switch (typeof strOrFn) {\n    case 'function':\n      return strOrFn();\n\n    case 'string':\n      return strOrFn;\n\n    default:\n      return '';\n  }\n}\n\nconst concatSep = (out, next) => next ? `${out}\\n${next}` : out;\n\nconst concatDblSep = (out, next) => next ? `${out}\\n\\n${next}` : out;\n\nfunction createAddons(options, outputPluginDriver) {\n  return Promise.all([outputPluginDriver.hookReduceValue('banner', evalIfFn(options.banner), [], concatSep), outputPluginDriver.hookReduceValue('footer', evalIfFn(options.footer), [], concatSep), outputPluginDriver.hookReduceValue('intro', evalIfFn(options.intro), [], concatDblSep), outputPluginDriver.hookReduceValue('outro', evalIfFn(options.outro), [], concatDblSep)]).then(([banner, footer, intro, outro]) => {\n    if (intro) intro += '\\n\\n';\n    if (outro) outro = `\\n\\n${outro}`;\n    if (banner.length) banner += '\\n';\n    if (footer.length) footer = '\\n' + footer;\n    return {\n      intro,\n      outro,\n      banner,\n      footer\n    };\n  }).catch(err => {\n    return error({\n      code: 'ADDON_ERROR',\n      message: `Could not retrieve ${err.hook}. Check configuration of plugin ${err.plugin}.\n\\tError Message: ${err.message}`\n    });\n  });\n}\n\nfunction assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons, bundle, outputPluginDriver) {\n  const entryChunks = [];\n  const otherChunks = [];\n\n  for (const chunk of chunks) {\n    (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint ? entryChunks : otherChunks).push(chunk);\n  } // make sure entry chunk names take precedence with regard to deconflicting\n\n\n  const chunksForNaming = entryChunks.concat(otherChunks);\n\n  for (const chunk of chunksForNaming) {\n    if (outputOptions.file) {\n      chunk.id = basename(outputOptions.file);\n    } else if (inputOptions.preserveModules) {\n      chunk.id = chunk.generateIdPreserveModules(inputBase, outputOptions, bundle);\n    } else {\n      chunk.id = chunk.generateId(addons, outputOptions, bundle, true, outputPluginDriver);\n    }\n\n    bundle[chunk.id] = FILE_PLACEHOLDER;\n  }\n} // ported from https://github.com/substack/node-commondir\n\n\nfunction commondir(files) {\n  if (files.length === 0) return '/';\n  if (files.length === 1) return dirname(files[0]);\n  const commonSegments = files.slice(1).reduce((commonSegments, file) => {\n    const pathSegements = file.split(/\\/+|\\\\+/);\n    let i;\n\n    for (i = 0; commonSegments[i] === pathSegements[i] && i < Math.min(commonSegments.length, pathSegements.length); i++);\n\n    return commonSegments.slice(0, i);\n  }, files[0].split(/\\/+|\\\\+/)); // Windows correctly handles paths with forward-slashes\n\n  return commonSegments.length > 1 ? commonSegments.join('/') : '/';\n}\n\nfunction getExportMode(chunk, {\n  exports: exportMode,\n  name,\n  format\n}, facadeModuleId) {\n  const exportKeys = chunk.getExportNames();\n\n  if (exportMode === 'default') {\n    if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {\n      return error(errIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));\n    }\n  } else if (exportMode === 'none' && exportKeys.length) {\n    return error(errIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));\n  }\n\n  if (!exportMode || exportMode === 'auto') {\n    if (exportKeys.length === 0) {\n      exportMode = 'none';\n    } else if (exportKeys.length === 1 && exportKeys[0] === 'default') {\n      exportMode = 'default';\n    } else {\n      if (format !== 'es' && exportKeys.indexOf('default') !== -1) {\n        chunk.graph.warn(errMixedExport(facadeModuleId, name));\n      }\n\n      exportMode = 'named';\n    }\n  }\n\n  return exportMode;\n}\n\nconst createGetOption = (config, command) => (name, defaultValue) => command[name] !== undefined ? command[name] : config[name] !== undefined ? config[name] : defaultValue;\n\nconst normalizeObjectOptionValue = optionValue => {\n  if (!optionValue) {\n    return optionValue;\n  }\n\n  if (typeof optionValue !== 'object') {\n    return {};\n  }\n\n  return optionValue;\n};\n\nconst getObjectOption = (config, command, name) => {\n  const commandOption = normalizeObjectOptionValue(command[name]);\n  const configOption = normalizeObjectOptionValue(config[name]);\n\n  if (commandOption !== undefined) {\n    return commandOption && configOption ? Object.assign(Object.assign({}, configOption), commandOption) : commandOption;\n  }\n\n  return configOption;\n};\n\nfunction ensureArray(items) {\n  if (Array.isArray(items)) {\n    return items.filter(Boolean);\n  }\n\n  if (items) {\n    return [items];\n  }\n\n  return [];\n}\n\nconst defaultOnWarn = warning => {\n  if (typeof warning === 'string') {\n    console.warn(warning);\n  } else {\n    console.warn(warning.message);\n  }\n};\n\nconst getOnWarn = (config, defaultOnWarnHandler = defaultOnWarn) => config.onwarn ? warning => config.onwarn(warning, defaultOnWarnHandler) : defaultOnWarnHandler;\n\nconst getExternal = (config, command) => {\n  const configExternal = config.external;\n  return typeof configExternal === 'function' ? (id, ...rest) => configExternal(id, ...rest) || command.external.indexOf(id) !== -1 : (typeof config.external === 'string' ? [configExternal] : Array.isArray(configExternal) ? configExternal : []).concat(command.external);\n};\n\nconst commandAliases = {\n  c: 'config',\n  d: 'dir',\n  e: 'external',\n  f: 'format',\n  g: 'globals',\n  h: 'help',\n  i: 'input',\n  m: 'sourcemap',\n  n: 'name',\n  o: 'file',\n  p: 'plugin',\n  v: 'version',\n  w: 'watch'\n};\n\nfunction mergeOptions({\n  config = {},\n  command: rawCommandOptions = {},\n  defaultOnWarnHandler\n}) {\n  const command = getCommandOptions(rawCommandOptions);\n  const inputOptions = getInputOptions(config, command, defaultOnWarnHandler);\n\n  if (command.output) {\n    Object.assign(command, command.output);\n  }\n\n  const output = config.output;\n  const normalizedOutputOptions = Array.isArray(output) ? output : output ? [output] : [];\n  if (normalizedOutputOptions.length === 0) normalizedOutputOptions.push({});\n  const outputOptions = normalizedOutputOptions.map(singleOutputOptions => getOutputOptions(singleOutputOptions, command));\n  const unknownOptionErrors = [];\n  const validInputOptions = Object.keys(inputOptions);\n  addUnknownOptionErrors(unknownOptionErrors, Object.keys(config), validInputOptions, 'input option', /^output$/);\n  const validOutputOptions = Object.keys(outputOptions[0]);\n  addUnknownOptionErrors(unknownOptionErrors, outputOptions.reduce((allKeys, options) => allKeys.concat(Object.keys(options)), []), validOutputOptions, 'output option');\n  const validCliOutputOptions = validOutputOptions.filter(option => option !== 'sourcemapPathTransform');\n  addUnknownOptionErrors(unknownOptionErrors, Object.keys(command), validInputOptions.concat(validCliOutputOptions, Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'stdin'), 'CLI flag', /^_|output|(config.*)$/);\n  return {\n    inputOptions,\n    optionError: unknownOptionErrors.length > 0 ? unknownOptionErrors.join('\\n') : null,\n    outputOptions\n  };\n}\n\nfunction addUnknownOptionErrors(errors, options, validOptions, optionType, ignoredKeys = /$./) {\n  const validOptionSet = new Set(validOptions);\n  const unknownOptions = options.filter(key => !validOptionSet.has(key) && !ignoredKeys.test(key));\n  if (unknownOptions.length > 0) errors.push(`Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${Array.from(validOptionSet).sort().join(', ')}`);\n}\n\nfunction getCommandOptions(rawCommandOptions) {\n  const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string' ? rawCommandOptions.external.split(',') : [];\n  return Object.assign(Object.assign({}, rawCommandOptions), {\n    external,\n    globals: typeof rawCommandOptions.globals === 'string' ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {\n      const [id, variableName] = globalDefinition.split(':');\n      globals[id] = variableName;\n\n      if (external.indexOf(id) === -1) {\n        external.push(id);\n      }\n\n      return globals;\n    }, Object.create(null)) : undefined\n  });\n}\n\nfunction getInputOptions(config, command = {\n  external: [],\n  globals: undefined\n}, defaultOnWarnHandler) {\n  const getOption = createGetOption(config, command);\n  const inputOptions = {\n    acorn: config.acorn,\n    acornInjectPlugins: config.acornInjectPlugins,\n    cache: getOption('cache'),\n    chunkGroupingSize: getOption('chunkGroupingSize', 5000),\n    context: getOption('context'),\n    experimentalCacheExpiry: getOption('experimentalCacheExpiry', 10),\n    experimentalOptimizeChunks: getOption('experimentalOptimizeChunks'),\n    external: getExternal(config, command),\n    inlineDynamicImports: getOption('inlineDynamicImports', false),\n    input: getOption('input', []),\n    manualChunks: getOption('manualChunks'),\n    moduleContext: config.moduleContext,\n    onwarn: getOnWarn(config, defaultOnWarnHandler),\n    perf: getOption('perf', false),\n    plugins: ensureArray(config.plugins),\n    preserveModules: getOption('preserveModules'),\n    preserveSymlinks: getOption('preserveSymlinks'),\n    shimMissingExports: getOption('shimMissingExports'),\n    strictDeprecations: getOption('strictDeprecations', false),\n    treeshake: getObjectOption(config, command, 'treeshake'),\n    watch: config.watch\n  }; // support rollup({ cache: prevBuildObject })\n\n  if (inputOptions.cache && inputOptions.cache.cache) inputOptions.cache = inputOptions.cache.cache;\n  return inputOptions;\n}\n\nfunction getOutputOptions(config, command = {}) {\n  const getOption = createGetOption(config, command);\n  let format = getOption('format'); // Handle format aliases\n\n  switch (format) {\n    case undefined:\n    case 'esm':\n    case 'module':\n      format = 'es';\n      break;\n\n    case 'commonjs':\n      format = 'cjs';\n  }\n\n  return {\n    amd: Object.assign(Object.assign({}, config.amd), command.amd),\n    assetFileNames: getOption('assetFileNames'),\n    banner: getOption('banner'),\n    chunkFileNames: getOption('chunkFileNames'),\n    compact: getOption('compact', false),\n    dir: getOption('dir'),\n    dynamicImportFunction: getOption('dynamicImportFunction'),\n    entryFileNames: getOption('entryFileNames'),\n    esModule: getOption('esModule', true),\n    exports: getOption('exports'),\n    extend: getOption('extend'),\n    externalLiveBindings: getOption('externalLiveBindings', true),\n    file: getOption('file'),\n    footer: getOption('footer'),\n    format,\n    freeze: getOption('freeze', true),\n    globals: getOption('globals'),\n    hoistTransitiveImports: getOption('hoistTransitiveImports', true),\n    indent: getOption('indent', true),\n    interop: getOption('interop', true),\n    intro: getOption('intro'),\n    name: getOption('name'),\n    namespaceToStringTag: getOption('namespaceToStringTag', false),\n    noConflict: getOption('noConflict'),\n    outro: getOption('outro'),\n    paths: getOption('paths'),\n    plugins: ensureArray(config.plugins),\n    preferConst: getOption('preferConst'),\n    sourcemap: getOption('sourcemap'),\n    sourcemapExcludeSources: getOption('sourcemapExcludeSources'),\n    sourcemapFile: getOption('sourcemapFile'),\n    sourcemapPathTransform: getOption('sourcemapPathTransform'),\n    strict: getOption('strict', true)\n  };\n}\n\nfunction checkOutputOptions(options) {\n  if (options.format === 'es6') {\n    return error(errDeprecation({\n      message: 'The \"es6\" output format is deprecated – use \"esm\" instead',\n      url: `https://rollupjs.org/guide/en/#output-format`\n    }));\n  }\n\n  if (['amd', 'cjs', 'system', 'es', 'iife', 'umd'].indexOf(options.format) < 0) {\n    return error({\n      message: `You must specify \"output.format\", which can be one of \"amd\", \"cjs\", \"system\", \"esm\", \"iife\" or \"umd\".`,\n      url: `https://rollupjs.org/guide/en/#output-format`\n    });\n  }\n\n  if (options.exports && !['default', 'named', 'none', 'auto'].includes(options.exports)) {\n    return error(errInvalidExportOptionValue(options.exports));\n  }\n}\n\nfunction getAbsoluteEntryModulePaths(chunks) {\n  const absoluteEntryModulePaths = [];\n\n  for (const chunk of chunks) {\n    for (const entryModule of chunk.entryModules) {\n      if (isAbsolute(entryModule.id)) {\n        absoluteEntryModulePaths.push(entryModule.id);\n      }\n    }\n  }\n\n  return absoluteEntryModulePaths;\n}\n\nconst throwAsyncGenerateError = {\n  get() {\n    throw new Error(`bundle.generate(...) now returns a Promise instead of a { code, map } object`);\n  }\n\n};\n\nfunction applyOptionHook(inputOptions, plugin) {\n  if (plugin.options) return plugin.options.call({\n    meta: {\n      rollupVersion: version\n    }\n  }, inputOptions) || inputOptions;\n  return inputOptions;\n}\n\nfunction normalizePlugins(rawPlugins, anonymousPrefix) {\n  const plugins = ensureArray(rawPlugins);\n\n  for (let pluginIndex = 0; pluginIndex < plugins.length; pluginIndex++) {\n    const plugin = plugins[pluginIndex];\n\n    if (!plugin.name) {\n      plugin.name = `${anonymousPrefix}${pluginIndex + 1}`;\n    }\n  }\n\n  return plugins;\n}\n\nfunction getInputOptions$1(rawInputOptions) {\n  if (!rawInputOptions) {\n    throw new Error('You must supply an options object to rollup');\n  }\n\n  let {\n    inputOptions,\n    optionError\n  } = mergeOptions({\n    config: rawInputOptions\n  });\n  if (optionError) inputOptions.onwarn({\n    message: optionError,\n    code: 'UNKNOWN_OPTION'\n  });\n  inputOptions = inputOptions.plugins.reduce(applyOptionHook, inputOptions);\n  inputOptions.plugins = normalizePlugins(inputOptions.plugins, ANONYMOUS_PLUGIN_PREFIX);\n\n  if (inputOptions.inlineDynamicImports) {\n    if (inputOptions.preserveModules) return error({\n      code: 'INVALID_OPTION',\n      message: `\"preserveModules\" does not support the \"inlineDynamicImports\" option.`\n    });\n    if (inputOptions.manualChunks) return error({\n      code: 'INVALID_OPTION',\n      message: '\"manualChunks\" option is not supported for \"inlineDynamicImports\".'\n    });\n    if (inputOptions.experimentalOptimizeChunks) return error({\n      code: 'INVALID_OPTION',\n      message: '\"experimentalOptimizeChunks\" option is not supported for \"inlineDynamicImports\".'\n    });\n    if (inputOptions.input instanceof Array && inputOptions.input.length > 1 || typeof inputOptions.input === 'object' && Object.keys(inputOptions.input).length > 1) return error({\n      code: 'INVALID_OPTION',\n      message: 'Multiple inputs are not supported for \"inlineDynamicImports\".'\n    });\n  } else if (inputOptions.preserveModules) {\n    if (inputOptions.manualChunks) return error({\n      code: 'INVALID_OPTION',\n      message: '\"preserveModules\" does not support the \"manualChunks\" option.'\n    });\n    if (inputOptions.experimentalOptimizeChunks) return error({\n      code: 'INVALID_OPTION',\n      message: '\"preserveModules\" does not support the \"experimentalOptimizeChunks\" option.'\n    });\n  }\n\n  return inputOptions;\n}\n\nlet curWatcher;\n\nfunction setWatcher(watcher) {\n  curWatcher = watcher;\n}\n\nfunction assignChunksToBundle(chunks, outputBundle) {\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    const facadeModule = chunk.facadeModule;\n    outputBundle[chunk.id] = {\n      code: undefined,\n      dynamicImports: chunk.getDynamicImportIds(),\n      exports: chunk.getExportNames(),\n      facadeModuleId: facadeModule && facadeModule.id,\n      fileName: chunk.id,\n      imports: chunk.getImportIds(),\n      isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,\n      isEntry: facadeModule !== null && facadeModule.isEntryPoint,\n      map: undefined,\n      modules: chunk.renderedModules,\n\n      get name() {\n        return chunk.getChunkName();\n      },\n\n      type: 'chunk'\n    };\n  }\n\n  return outputBundle;\n}\n\nfunction rollup(rawInputOptions) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const inputOptions = getInputOptions$1(rawInputOptions);\n    initialiseTimers(inputOptions);\n    const graph = new Graph(inputOptions, curWatcher);\n    curWatcher = undefined; // remove the cache option from the memory after graph creation (cache is not used anymore)\n\n    const useCache = rawInputOptions.cache !== false;\n    delete inputOptions.cache;\n    delete rawInputOptions.cache;\n    timeStart('BUILD', 1);\n    let chunks;\n\n    try {\n      yield graph.pluginDriver.hookParallel('buildStart', [inputOptions]);\n      chunks = yield graph.build(inputOptions.input, inputOptions.manualChunks, inputOptions.inlineDynamicImports);\n    } catch (err) {\n      const watchFiles = Object.keys(graph.watchFiles);\n\n      if (watchFiles.length > 0) {\n        err.watchFiles = watchFiles;\n      }\n\n      yield graph.pluginDriver.hookParallel('buildEnd', [err]);\n      throw err;\n    }\n\n    yield graph.pluginDriver.hookParallel('buildEnd', []);\n    timeEnd('BUILD', 1); // ensure we only do one optimization pass per build\n\n    let optimized = false;\n\n    function getOutputOptionsAndPluginDriver(rawOutputOptions) {\n      if (!rawOutputOptions) {\n        throw new Error('You must supply an options object');\n      }\n\n      const outputPluginDriver = graph.pluginDriver.createOutputPluginDriver(normalizePlugins(rawOutputOptions.plugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX));\n      return {\n        outputOptions: normalizeOutputOptions(inputOptions, rawOutputOptions, chunks.length > 1, outputPluginDriver),\n        outputPluginDriver\n      };\n    }\n\n    function generate(outputOptions, isWrite, outputPluginDriver) {\n      return __awaiter(this, void 0, void 0, function* () {\n        timeStart('GENERATE', 1);\n        const assetFileNames = outputOptions.assetFileNames || 'assets/[name]-[hash][extname]';\n        const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));\n        const outputBundleWithPlaceholders = Object.create(null);\n        outputPluginDriver.setOutputBundle(outputBundleWithPlaceholders, assetFileNames);\n        let outputBundle;\n\n        try {\n          yield outputPluginDriver.hookParallel('renderStart', [outputOptions, inputOptions]);\n          const addons = yield createAddons(outputOptions, outputPluginDriver);\n\n          for (const chunk of chunks) {\n            if (!inputOptions.preserveModules) chunk.generateInternalExports(outputOptions);\n            if (inputOptions.preserveModules || chunk.facadeModule && chunk.facadeModule.isEntryPoint) chunk.exportMode = getExportMode(chunk, outputOptions, chunk.facadeModule.id);\n          }\n\n          for (const chunk of chunks) {\n            chunk.preRender(outputOptions, inputBase);\n          }\n\n          if (!optimized && inputOptions.experimentalOptimizeChunks) {\n            optimizeChunks(chunks, outputOptions, inputOptions.chunkGroupingSize, inputBase);\n            optimized = true;\n          }\n\n          assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons, outputBundleWithPlaceholders, outputPluginDriver);\n          outputBundle = assignChunksToBundle(chunks, outputBundleWithPlaceholders);\n          yield Promise.all(chunks.map(chunk => {\n            const outputChunk = outputBundleWithPlaceholders[chunk.id];\n            return chunk.render(outputOptions, addons, outputChunk, outputPluginDriver).then(rendered => {\n              outputChunk.code = rendered.code;\n              outputChunk.map = rendered.map;\n              return outputPluginDriver.hookParallel('ongenerate', [Object.assign({\n                bundle: outputChunk\n              }, outputOptions), outputChunk]);\n            });\n          }));\n        } catch (error) {\n          yield outputPluginDriver.hookParallel('renderError', [error]);\n          throw error;\n        }\n\n        yield outputPluginDriver.hookSeq('generateBundle', [outputOptions, outputBundle, isWrite]);\n\n        for (const key of Object.keys(outputBundle)) {\n          const file = outputBundle[key];\n\n          if (!file.type) {\n            graph.warnDeprecation('A plugin is directly adding properties to the bundle object in the \"generateBundle\" hook. This is deprecated and will be removed in a future Rollup version, please use \"this.emitFile\" instead.', false);\n            file.type = 'asset';\n          }\n        }\n\n        outputPluginDriver.finaliseAssets();\n        timeEnd('GENERATE', 1);\n        return outputBundle;\n      });\n    }\n\n    const cache = useCache ? graph.getCache() : undefined;\n    const result = {\n      cache: cache,\n      generate: rawOutputOptions => {\n        const {\n          outputOptions,\n          outputPluginDriver\n        } = getOutputOptionsAndPluginDriver(rawOutputOptions);\n        const promise = generate(outputOptions, false, outputPluginDriver).then(result => createOutput(result));\n        Object.defineProperty(promise, 'code', throwAsyncGenerateError);\n        Object.defineProperty(promise, 'map', throwAsyncGenerateError);\n        return promise;\n      },\n      watchFiles: Object.keys(graph.watchFiles),\n      write: rawOutputOptions => {\n        const {\n          outputOptions,\n          outputPluginDriver\n        } = getOutputOptionsAndPluginDriver(rawOutputOptions);\n\n        if (!outputOptions.dir && !outputOptions.file) {\n          return error({\n            code: 'MISSING_OPTION',\n            message: 'You must specify \"output.file\" or \"output.dir\" for the build.'\n          });\n        }\n\n        return generate(outputOptions, true, outputPluginDriver).then(bundle => __awaiter(this, void 0, void 0, function* () {\n          let chunkCount = 0;\n\n          for (const fileName of Object.keys(bundle)) {\n            const file = bundle[fileName];\n            if (file.type === 'asset') continue;\n            chunkCount++;\n            if (chunkCount > 1) break;\n          }\n\n          if (chunkCount > 1) {\n            if (outputOptions.sourcemapFile) return error({\n              code: 'INVALID_OPTION',\n              message: '\"output.sourcemapFile\" is only supported for single-file builds.'\n            });\n            if (typeof outputOptions.file === 'string') return error({\n              code: 'INVALID_OPTION',\n              message: 'When building multiple chunks, the \"output.dir\" option must be used, not \"output.file\".' + (typeof inputOptions.input !== 'string' || inputOptions.inlineDynamicImports === true ? '' : ' To inline dynamic imports, set the \"inlineDynamicImports\" option.')\n            });\n          }\n\n          yield Promise.all(Object.keys(bundle).map(chunkId => writeOutputFile(result, bundle[chunkId], outputOptions, outputPluginDriver)));\n          yield outputPluginDriver.hookParallel('writeBundle', [bundle]);\n          return createOutput(bundle);\n        }));\n      }\n    };\n    if (inputOptions.perf === true) result.getTimings = getTimings;\n    return result;\n  });\n}\n\nvar SortingFileType;\n\n(function (SortingFileType) {\n  SortingFileType[SortingFileType[\"ENTRY_CHUNK\"] = 0] = \"ENTRY_CHUNK\";\n  SortingFileType[SortingFileType[\"SECONDARY_CHUNK\"] = 1] = \"SECONDARY_CHUNK\";\n  SortingFileType[SortingFileType[\"ASSET\"] = 2] = \"ASSET\";\n})(SortingFileType || (SortingFileType = {}));\n\nfunction getSortingFileType(file) {\n  if (file.type === 'asset') {\n    return SortingFileType.ASSET;\n  }\n\n  if (file.isEntry) {\n    return SortingFileType.ENTRY_CHUNK;\n  }\n\n  return SortingFileType.SECONDARY_CHUNK;\n}\n\nfunction createOutput(outputBundle) {\n  return {\n    output: Object.keys(outputBundle).map(fileName => outputBundle[fileName]).filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {\n      const fileTypeA = getSortingFileType(outputFileA);\n      const fileTypeB = getSortingFileType(outputFileB);\n      if (fileTypeA === fileTypeB) return 0;\n      return fileTypeA < fileTypeB ? -1 : 1;\n    })\n  };\n}\n\nfunction writeOutputFile(build, outputFile, outputOptions, outputPluginDriver) {\n  const fileName = resolve(outputOptions.dir || dirname(outputOptions.file), outputFile.fileName);\n  let writeSourceMapPromise;\n  let source;\n\n  if (outputFile.type === 'asset') {\n    source = outputFile.source;\n  } else {\n    source = outputFile.code;\n\n    if (outputOptions.sourcemap && outputFile.map) {\n      let url;\n\n      if (outputOptions.sourcemap === 'inline') {\n        url = outputFile.map.toUrl();\n      } else {\n        url = `${basename(outputFile.fileName)}.map`;\n        writeSourceMapPromise = writeFile(`${fileName}.map`, outputFile.map.toString());\n      }\n\n      if (outputOptions.sourcemap !== 'hidden') {\n        source += `//# ${SOURCEMAPPING_URL}=${url}\\n`;\n      }\n    }\n  }\n\n  return writeFile(fileName, source).then(() => writeSourceMapPromise).then(() => outputFile.type === 'chunk' && outputPluginDriver.hookSeq('onwrite', [Object.assign({\n    bundle: build\n  }, outputOptions), outputFile])).then(() => {});\n}\n\nfunction normalizeOutputOptions(inputOptions, rawOutputOptions, hasMultipleChunks, outputPluginDriver) {\n  const mergedOptions = mergeOptions({\n    config: {\n      output: Object.assign(Object.assign(Object.assign({}, rawOutputOptions), rawOutputOptions.output), inputOptions.output)\n    }\n  });\n  if (mergedOptions.optionError) throw new Error(mergedOptions.optionError); // now outputOptions is an array, but rollup.rollup API doesn't support arrays\n\n  const mergedOutputOptions = mergedOptions.outputOptions[0];\n\n  const outputOptionsReducer = (outputOptions, result) => result || outputOptions;\n\n  const outputOptions = outputPluginDriver.hookReduceArg0Sync('outputOptions', [mergedOutputOptions], outputOptionsReducer, pluginContext => {\n    const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());\n\n    return Object.assign(Object.assign({}, pluginContext), {\n      emitFile: emitError,\n      setAssetSource: emitError\n    });\n  });\n  checkOutputOptions(outputOptions);\n\n  if (typeof outputOptions.file === 'string') {\n    if (typeof outputOptions.dir === 'string') return error({\n      code: 'INVALID_OPTION',\n      message: 'You must set either \"output.file\" for a single-file build or \"output.dir\" when generating multiple chunks.'\n    });\n\n    if (inputOptions.preserveModules) {\n      return error({\n        code: 'INVALID_OPTION',\n        message: 'You must set \"output.dir\" instead of \"output.file\" when using the \"preserveModules\" option.'\n      });\n    }\n\n    if (typeof inputOptions.input === 'object' && !Array.isArray(inputOptions.input)) return error({\n      code: 'INVALID_OPTION',\n      message: 'You must set \"output.dir\" instead of \"output.file\" when providing named inputs.'\n    });\n  }\n\n  if (hasMultipleChunks) {\n    if (outputOptions.format === 'umd' || outputOptions.format === 'iife') return error({\n      code: 'INVALID_OPTION',\n      message: 'UMD and IIFE output formats are not supported for code-splitting builds.'\n    });\n    if (typeof outputOptions.file === 'string') return error({\n      code: 'INVALID_OPTION',\n      message: 'You must set \"output.dir\" instead of \"output.file\" when generating multiple chunks.'\n    });\n  }\n\n  return outputOptions;\n}\n\nvar utils$1 = createCommonjsModule(function (module, exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n\n    return false;\n  };\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.exceedsLimit = (min, max, step = 1, limit) => {\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n\n  exports.escapeNode = (block, n = 0, type) => {\n    let node = block.nodes[n];\n    if (!node) return;\n\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n\n    return node.open === true || node.close === true;\n  };\n  /**\n   * Reduce an array of text nodes.\n   */\n\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n  /**\n   * Flatten an array\n   */\n\n\n  exports.flatten = (...args) => {\n    const result = [];\n\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n\n      return result;\n    };\n\n    flat(args);\n    return result;\n  };\n});\n\nvar stringify = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$1.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n\n    return output;\n  };\n\n  return stringify(ast);\n};\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isNumber = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n\n  return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = Object.assign({\n    relaxZeros: true\n  }, options);\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange.cache = {};\n\ntoRegexRange.clearCache = () => toRegexRange.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject$1 = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform$1 = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber$1 = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify$1 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange_1(a, b, Object.assign({\n      wrap: false\n    }, options));\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange_1(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$1(start, end, options) === false;\n  let format = options.transform || transform$1(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, Object.assign({\n      wrap: false\n    }, options));\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if (!isNumber$1(start) && start.length > 1 || !isNumber$1(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject$1(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = Object.assign({}, options);\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber$1(step)) {\n    if (step != null && !isObject$1(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber$1(start) && isNumber$1(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fillRange(...args, Object.assign(Object.assign({}, options), {\n        wrap: false,\n        toRegex: true\n      }));\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils$1.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n\n  return utils$1.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n\n      if (utils$1.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fillRange(...args, options);\n\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils$1.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils$1.flatten(walk(ast));\n};\n\nvar expand_1 = expand;\nvar constants = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n  CHAR_9: '9',\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n  CHAR_LOWERCASE_A: 'a',\n  CHAR_UPPERCASE_Z: 'Z',\n  CHAR_LOWERCASE_Z: 'z',\n  CHAR_LEFT_PARENTHESES: '(',\n  CHAR_RIGHT_PARENTHESES: ')',\n  CHAR_ASTERISK: '*',\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n  CHAR_AT: '@',\n  CHAR_BACKSLASH: '\\\\',\n  CHAR_BACKTICK: '`',\n  CHAR_CARRIAGE_RETURN: '\\r',\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n  CHAR_COLON: ':',\n  CHAR_COMMA: ',',\n  CHAR_DOLLAR: '$',\n  CHAR_DOT: '.',\n  CHAR_DOUBLE_QUOTE: '\"',\n  CHAR_EQUAL: '=',\n  CHAR_EXCLAMATION_MARK: '!',\n  CHAR_FORM_FEED: '\\f',\n  CHAR_FORWARD_SLASH: '/',\n  CHAR_HASH: '#',\n  CHAR_HYPHEN_MINUS: '-',\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n  CHAR_LEFT_CURLY_BRACE: '{',\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n  CHAR_LINE_FEED: '\\n',\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n  CHAR_PERCENT: '%',\n  CHAR_PLUS: '+',\n  CHAR_QUESTION_MARK: '?',\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n  CHAR_RIGHT_CURLY_BRACE: '}',\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n  CHAR_SEMICOLON: ';',\n  CHAR_SINGLE_QUOTE: '\\'',\n  CHAR_SPACE: ' ',\n  CHAR_TAB: '\\t',\n  CHAR_UNDERSCORE: '_',\n  CHAR_VERTICAL_LINE: '|',\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF'\n  /* \\uFEFF */\n\n};\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants;\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\n     * Escaped chars\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\n     * Left square bracket: '['\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Quotes: '|\"|`\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Left curly brace: '{'\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\n     * Right curly brace: '}'\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Comma: ','\n     */\n\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\n     * Dot: '.'\n     */\n\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\n     * Text\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nvar parse_1 = parse;\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n\n  return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nbraces.parse = (input, options = {}) => parse_1(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n\n  return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  return compile_1(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand_1(input, options); // filter out empty strings if specified\n\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  } // filter out duplicates if specified\n\n\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\n\n\nvar braces_1 = braces;\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = Object.assign(Object.assign({}, POSIX_CHARS), {\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n});\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHAR: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n  // Digits\n  CHAR_0: 48,\n  CHAR_9: 57,\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65,\n  CHAR_LOWERCASE_A: 97,\n  CHAR_UPPERCASE_Z: 90,\n  CHAR_LOWERCASE_Z: 122,\n  CHAR_LEFT_PARENTHESES: 40,\n  CHAR_RIGHT_PARENTHESES: 41,\n  CHAR_ASTERISK: 42,\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38,\n  CHAR_AT: 64,\n  CHAR_BACKWARD_SLASH: 92,\n  CHAR_CARRIAGE_RETURN: 13,\n  CHAR_CIRCUMFLEX_ACCENT: 94,\n  CHAR_COLON: 58,\n  CHAR_COMMA: 44,\n  CHAR_DOT: 46,\n  CHAR_DOUBLE_QUOTE: 34,\n  CHAR_EQUAL: 61,\n  CHAR_EXCLAMATION_MARK: 33,\n  CHAR_FORM_FEED: 12,\n  CHAR_FORWARD_SLASH: 47,\n  CHAR_GRAVE_ACCENT: 96,\n  CHAR_HASH: 35,\n  CHAR_HYPHEN_MINUS: 45,\n  CHAR_LEFT_ANGLE_BRACKET: 60,\n  CHAR_LEFT_CURLY_BRACE: 123,\n  CHAR_LEFT_SQUARE_BRACKET: 91,\n  CHAR_LINE_FEED: 10,\n  CHAR_NO_BREAK_SPACE: 160,\n  CHAR_PERCENT: 37,\n  CHAR_PLUS: 43,\n  CHAR_QUESTION_MARK: 63,\n  CHAR_RIGHT_ANGLE_BRACKET: 62,\n  CHAR_RIGHT_CURLY_BRACE: 125,\n  CHAR_RIGHT_SQUARE_BRACKET: 93,\n  CHAR_SEMICOLON: 59,\n  CHAR_SINGLE_QUOTE: 39,\n  CHAR_SPACE: 32,\n  CHAR_TAB: 9,\n  CHAR_UNDERSCORE: 95,\n  CHAR_VERTICAL_LINE: 124,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n  extglobChars(chars) {\n    return {\n      '!': {\n        type: 'negate',\n        open: '(?:(?!(?:',\n        close: `))${chars.STAR})`\n      },\n      '?': {\n        type: 'qmark',\n        open: '(?:',\n        close: ')?'\n      },\n      '+': {\n        type: 'plus',\n        open: '(?:',\n        close: ')+'\n      },\n      '*': {\n        type: 'star',\n        open: '(?:',\n        close: ')*'\n      },\n      '@': {\n        type: 'at',\n        open: '(?:',\n        close: ')'\n      }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n\n};\nvar utils$2 = createCommonjsModule(function (module, exports) {\n  const win32 = process.platform === 'win32';\n  const {\n    REGEX_SPECIAL_CHARS,\n    REGEX_SPECIAL_CHARS_GLOBAL,\n    REGEX_REMOVE_BACKSLASH\n  } = constants$1;\n\n  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\n  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n\n  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n\n  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n\n  exports.toPosixSlashes = str => str.replace(/\\\\/g, '/');\n\n  exports.removeBackslashes = str => {\n    return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n      return match === '\\\\' ? '' : match;\n    });\n  };\n\n  exports.supportsLookbehinds = () => {\n    let segs = process.version.slice(1).split('.');\n\n    if (segs.length === 3 && +segs[0] >= 9 || +segs[0] === 8 && +segs[1] >= 10) {\n      return true;\n    }\n\n    return false;\n  };\n\n  exports.isWindows = options => {\n    if (options && typeof options.windows === 'boolean') {\n      return options.windows;\n    }\n\n    return win32 === true || path.sep === '\\\\';\n  };\n\n  exports.escapeLast = (input, char, lastIdx) => {\n    let idx = input.lastIndexOf(char, lastIdx);\n    if (idx === -1) return input;\n    if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n    return input.slice(0, idx) + '\\\\' + input.slice(idx);\n  };\n});\nconst {\n  CHAR_ASTERISK,\n\n  /* * */\n  CHAR_AT,\n\n  /* @ */\n  CHAR_BACKWARD_SLASH,\n\n  /* \\ */\n  CHAR_COMMA: CHAR_COMMA$1,\n\n  /* , */\n  CHAR_DOT: CHAR_DOT$1,\n\n  /* . */\n  CHAR_EXCLAMATION_MARK,\n\n  /* ! */\n  CHAR_FORWARD_SLASH,\n\n  /* / */\n  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,\n\n  /* { */\n  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,\n\n  /* ( */\n  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,\n\n  /* [ */\n  CHAR_PLUS,\n\n  /* + */\n  CHAR_QUESTION_MARK,\n\n  /* ? */\n  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,\n\n  /* } */\n  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,\n\n  /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1\n  /* ] */\n\n} = constants$1;\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\n\nvar scan = (input, options) => {\n  let opts = options || {};\n  let length = input.length - 1;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isGlob = false;\n  let backslashes = false;\n  let negated = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let braceEscaped = false;\n\n  let eos = () => index >= length;\n\n  let advance = () => {\n    prev = code;\n    return input.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = true;\n      next = advance();\n\n      if (next === CHAR_LEFT_CURLY_BRACE$1) {\n        braceEscaped = true;\n      }\n\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {\n      braces++;\n\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_LEFT_CURLY_BRACE$1) {\n          braces++;\n          continue;\n        }\n\n        if (!braceEscaped && next === CHAR_DOT$1 && (next = advance()) === CHAR_DOT$1) {\n          isGlob = true;\n          break;\n        }\n\n        if (!braceEscaped && next === CHAR_COMMA$1) {\n          isGlob = true;\n          break;\n        }\n\n        if (next === CHAR_RIGHT_CURLY_BRACE$1) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            break;\n          }\n        }\n      }\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      if (prev === CHAR_DOT$1 && index === start + 1) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (code === CHAR_ASTERISK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET$1) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    let isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_EXCLAMATION_MARK;\n\n    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES$1) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = true;\n      start++;\n      continue;\n    }\n\n    if (code === CHAR_LEFT_PARENTHESES$1) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_PARENTHESES$1) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    if (isGlob) {\n      break;\n    }\n  }\n\n  let prefix = '';\n  let orig = input;\n  let base = input;\n  let glob = '';\n\n  if (start > 0) {\n    prefix = input.slice(0, start);\n    input = input.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = input.slice(0, lastIndex);\n    glob = input.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = input;\n  } else {\n    base = input;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== input) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils$2.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils$2.removeBackslashes(base);\n    }\n  }\n\n  return {\n    prefix,\n    input: orig,\n    base,\n    glob,\n    negated,\n    isGlob\n  };\n};\n/**\n * Constants\n */\n\n\nconst {\n  MAX_LENGTH: MAX_LENGTH$1,\n  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,\n  REGEX_NON_SPECIAL_CHAR,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants$1;\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  let value = `[${args.join('-')}]`;\n  return value;\n};\n\nconst negate = state => {\n  let count = 1;\n\n  while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {\n    state.advance();\n    state.start++;\n    count++;\n  }\n\n  if (count % 2 === 0) {\n    return false;\n  }\n\n  state.negated = true;\n  state.start++;\n  return true;\n};\n/**\n * Create the message for a syntax error\n */\n\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\n\nconst parse$1 = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n  let opts = Object.assign({}, options);\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  let bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  let tokens = [bos];\n  let capture = opts.capture ? '' : '?:';\n  let win32 = utils$2.isWindows(options); // create constants based on platform, for windows or posix\n\n  const PLATFORM_CHARS = constants$1.globChars(win32);\n  const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  let nodot = opts.dot ? '' : NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n  let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  } // minimatch options support\n\n\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  let state = {\n    index: -1,\n    start: 0,\n    consumed: '',\n    output: '',\n    backtrack: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    tokens\n  };\n  let extglobs = [];\n  let stack = [];\n  let prev = bos;\n  let value;\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n\n  const peek = state.peek = (n = 1) => input[state.index + n];\n\n  const advance = state.advance = () => input[++state.index];\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    state.consumed += token.value || '';\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    let token = Object.assign(Object.assign({}, EXTGLOB_CHARS[value]), {\n      conditions: 1,\n      inner: ''\n    });\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    let output = (opts.capture ? '(' : '') + token.open;\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    increment('parens');\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(input.slice(state.index + 1))) {\n        output = token.close = ')$))' + extglobStar;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/{[()\\]}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n\n        return star;\n      }\n\n      return esc ? m : '\\\\' + m;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n\n    state.output = output;\n    return state;\n  }\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n    /**\n     * Escaped characters\n     */\n\n\n    if (value === '\\\\') {\n      let next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      } // collapse slashes to reduce potential for exploits\n\n\n      let match = /^\\\\+/.exec(input.slice(state.index + 1));\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        let inner = prev.value.slice(1);\n\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            let idx = prev.value.lastIndexOf('[');\n            let pre = prev.value.slice(0, idx);\n            let rest = prev.value.slice(idx + 2);\n            let posix = POSIX_REGEX_SOURCE$1[rest];\n\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n\n              continue;\n            }\n          }\n        }\n      }\n\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = '\\\\' + value;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = '\\\\' + value;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils$2.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * Double quotes\n     */\n\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === '(') {\n      push({\n        type: 'paren',\n        value\n      });\n      increment('parens');\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      let extglob = extglobs[extglobs.length - 1];\n\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n    /**\n     * Brackets\n     */\n\n\n    if (value === '[') {\n      if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = '\\\\' + value;\n      } else {\n        increment('brackets');\n      }\n\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: '\\\\' + value\n        });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({\n          type: 'text',\n          value,\n          output: '\\\\' + value\n        });\n        continue;\n      }\n\n      decrement('brackets');\n      let prevValue = prev.value.slice(1);\n\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = '/' + value;\n      }\n\n      prev.value += value;\n      append({\n        value\n      }); // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n\n      if (opts.literalBrackets === false || utils$2.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      let escaped = utils$2.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      } // when the user specifies nothing, try to match both\n\n\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n    /**\n     * Braces\n     */\n\n\n    if (value === '{' && opts.nobrace !== true) {\n      push({\n        type: 'brace',\n        value,\n        output: '('\n      });\n      increment('braces');\n      continue;\n    }\n\n    if (value === '}') {\n      if (opts.nobrace === true || state.braces === 0) {\n        push({\n          type: 'text',\n          value,\n          output: '\\\\' + value\n        });\n        continue;\n      }\n\n      let output = ')';\n\n      if (state.dots === true) {\n        let arr = tokens.slice();\n        let range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n\n          if (arr[i].type === 'brace') {\n            break;\n          }\n\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      continue;\n    }\n    /**\n     * Pipes\n     */\n\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Commas\n     */\n\n\n    if (value === ',') {\n      let output = value;\n\n      if (state.braces > 0 && stack[stack.length - 1] === 'braces') {\n        output = '|';\n      }\n\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n    /**\n     * Slashes\n     */\n\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n\n        continue;\n      }\n\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Dots\n     */\n\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        state.dots = true;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Question marks\n     */\n\n\n    if (value === '?') {\n      if (prev && prev.type === 'paren') {\n        let next = peek();\n        let output = value;\n\n        if (next === '<' && !utils$2.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/[!=]/.test(peek(2))) {\n          output = '\\\\' + value;\n        }\n\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n    /**\n     * Exclamation\n     */\n\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate(state);\n        continue;\n      }\n    }\n    /**\n     * Plus\n     */\n\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {\n        let output = prev.extglob === true ? '\\\\' + value : value;\n        push({\n          type: 'plus',\n          value,\n          output\n        });\n        continue;\n      } // use regex behavior inside parens\n\n\n      if (state.parens > 0 && opts.regex !== false) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = '\\\\' + value;\n      }\n\n      let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));\n\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Stars\n     */\n\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.consumed += value;\n      continue;\n    }\n\n    if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        state.consumed += value;\n        continue;\n      }\n\n      let prior = prev.prev;\n      let before = prior.prev;\n      let isStart = prior.type === 'slash' || prior.type === 'bos';\n      let afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || !eos() && peek() !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      } // strip consecutive `/**/`\n\n\n      while (input.slice(state.index + 1, state.index + 4) === '/**') {\n        let after = input[state.index + 4];\n\n        if (after && after !== '/') {\n          break;\n        }\n\n        state.consumed += '/**';\n        state.index += 3;\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.consumed += value;\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = '(?:' + prior.output;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + '|$)';\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.consumed += value;\n        continue;\n      }\n\n      let next = peek();\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {\n        let end = peek(2) !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = '(?:' + prior.output;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.consumed += value + advance();\n        push({\n          type: 'slash',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      if (prior.type === 'bos' && next === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.consumed += value + advance();\n        push({\n          type: 'slash',\n          value,\n          output: ''\n        });\n        continue;\n      } // remove single star from output\n\n\n      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar\n\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value; // reset output with globstar\n\n      state.output += prev.output;\n      state.consumed += value;\n      continue;\n    }\n\n    let token = {\n      type: 'star',\n      value,\n      output: star\n    };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils$2.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils$2.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils$2.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  } // rebuild the output if we had to backtrack at any point\n\n\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (let token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\n\nparse$1.fastpaths = (input, options) => {\n  let opts = Object.assign({}, options);\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  let win32 = utils$2.isWindows(options); // create constants based on platform, for windows or posix\n\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants$1.globChars(win32);\n  let capture = opts.capture ? '' : '?:';\n  let star = opts.bash === true ? '.*?' : STAR;\n  let nodot = opts.dot ? NO_DOTS : NO_DOT;\n  let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default:\n        {\n          let match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          let source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n\n  let output = create(input);\n\n  if (output && opts.strictSlashes !== true) {\n    output += `${SLASH_LITERAL}?`;\n  }\n\n  return output;\n};\n\nvar parse_1$1 = parse$1;\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    let fns = glob.map(input => picomatch(input, options, returnState));\n    return str => {\n      for (let isMatch of fns) {\n        let state = isMatch(str);\n        if (state) return state;\n      }\n\n      return false;\n    };\n  }\n\n  if (typeof glob !== 'string' || glob === '') {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  let opts = options || {};\n  let posix = utils$2.isWindows(options);\n  let regex = picomatch.makeRe(glob, options, false, true);\n  let state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n\n  if (opts.ignore) {\n    let ignoreOpts = Object.assign(Object.assign({}, options), {\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    });\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    let {\n      isMatch,\n      match,\n      output\n    } = picomatch.test(input, regex, options, {\n      glob,\n      posix\n    });\n    let result = {\n      glob,\n      state,\n      regex,\n      posix,\n      input,\n      output,\n      match,\n      isMatch\n    };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\n\npicomatch.test = (input, regex, options, {\n  glob,\n  posix\n} = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n\n  let opts = options || {};\n  let format = opts.format || (posix ? utils$2.toPosixSlashes : null);\n  let match = input === glob;\n  let output = match && format ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return {\n    isMatch: !!match,\n    match,\n    output\n  };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\n\npicomatch.matchBase = (input, glob, options, posix = utils$2.isWindows(options)) => {\n  let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\n\npicomatch.parse = (glob, options) => parse_1$1(glob, options);\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\npicomatch.scan = (input, options) => scan(input, options);\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let opts = options || {};\n  let prepend = opts.contains ? '' : '^';\n  let append = opts.contains ? '' : '$';\n  let state = {\n    negated: false,\n    fastpaths: true\n  };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = state.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse_1$1.fastpaths(input, options);\n  }\n\n  if (output === void 0) {\n    state = picomatch.parse(input, options);\n    state.prefix = prefix + (state.prefix || '');\n    output = state.output;\n  }\n\n  if (returnOutput === true) {\n    return output;\n  }\n\n  let source = `${prepend}(?:${output})${append}`;\n\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  let regex = picomatch.toRegex(source, options);\n\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\n\npicomatch.toRegex = (source, options) => {\n  try {\n    let opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\n\npicomatch.constants = constants$1;\n/**\n * Expose \"picomatch\"\n */\n\nvar picomatch_1 = picomatch;\nvar picomatch$1 = picomatch_1;\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch$1(String(patterns[i]), Object.assign(Object.assign({}, options), {\n      onResult\n    }), true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch$1(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, Object.assign(Object.assign({}, options), {\n    onResult\n  }));\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n\n  return [...result];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, Object.assign(Object.assign({}, options), {\n    contains: true\n  }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils$2.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n\n  for (let key of keys) res[key] = obj[key];\n\n  return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch$1(String(pattern), options);\n\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch$1(String(pattern), options);\n\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch$1(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils$2.isWindows(options);\n  let regex = picomatch$1.makeRe(String(glob), Object.assign(Object.assign({}, options), {\n    capture: true\n  }));\n  let match = regex.exec(posix ? utils$2.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = (...args) => picomatch$1.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\nmicromatch.scan = (...args) => picomatch$1.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces_1(String(pattern), options)) {\n      res.push(picomatch$1.parse(str, options));\n    }\n  }\n\n  return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n\n  return braces_1(pattern, options);\n};\n/**\n * Expand braces\n */\n\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, Object.assign(Object.assign({}, options), {\n    expand: true\n  }));\n};\n/**\n * Expose micromatch\n */\n\n\nvar micromatch_1 = micromatch;\n\nfunction ensureArray$1(thing) {\n  if (Array.isArray(thing)) return thing;\n  if (thing == undefined) return [];\n  return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n  if (resolutionBase === false) {\n    return id;\n  }\n\n  return resolve(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));\n}\n\nconst createFilter = function createFilter(include, exclude, options) {\n  const resolutionBase = options && options.resolve;\n\n  const getMatcher = id => {\n    return id instanceof RegExp ? id : {\n      test: micromatch_1.matcher(getMatcherString(id, resolutionBase).split(sep).join('/'), {\n        dot: true\n      })\n    };\n  };\n\n  const includeMatchers = ensureArray$1(include).map(getMatcher);\n  const excludeMatchers = ensureArray$1(exclude).map(getMatcher);\n  return function (id) {\n    if (typeof id !== 'string') return false;\n    if (/\\0/.test(id)) return false;\n    id = id.split(sep).join('/');\n\n    for (let i = 0; i < excludeMatchers.length; ++i) {\n      const matcher = excludeMatchers[i];\n      if (matcher.test(id)) return false;\n    }\n\n    for (let i = 0; i < includeMatchers.length; ++i) {\n      const matcher = includeMatchers[i];\n      if (matcher.test(id)) return true;\n    }\n\n    return !includeMatchers.length;\n  };\n};\n\nvar modules = {};\n\nvar getModule = function (dir) {\n  var rootPath = dir ? path.resolve(dir) : process.cwd();\n  var rootName = path.join(rootPath, '@root');\n  var root = modules[rootName];\n\n  if (!root) {\n    root = new module(rootName);\n    root.filename = rootName;\n    root.paths = module._nodeModulePaths(rootPath);\n    modules[rootName] = root;\n  }\n\n  return root;\n};\n\nvar requireRelative = function (requested, relativeTo) {\n  var root = getModule(relativeTo);\n  return root.require(requested);\n};\n\nrequireRelative.resolve = function (requested, relativeTo) {\n  var root = getModule(relativeTo);\n  return module._resolveFilename(requested, root);\n};\n\nvar requireRelative_1 = requireRelative;\nlet chokidar;\n\ntry {\n  chokidar = requireRelative_1('chokidar', process.cwd());\n} catch (err) {\n  chokidar = null;\n}\n\nvar chokidar$1 = chokidar;\nconst opts = {\n  encoding: 'utf-8',\n  persistent: true\n};\nconst watchers = new Map();\n\nfunction addTask(id, task, chokidarOptions, chokidarOptionsHash, isTransformDependency) {\n  if (!watchers.has(chokidarOptionsHash)) watchers.set(chokidarOptionsHash, new Map());\n  const group = watchers.get(chokidarOptionsHash);\n  const watcher = group.get(id) || new FileWatcher(id, chokidarOptions, group);\n\n  if (!watcher.fsWatcher) {\n    if (isTransformDependency) throw new Error(`Transform dependency ${id} does not exist.`);\n  } else {\n    watcher.addTask(task, isTransformDependency);\n  }\n}\n\nfunction deleteTask(id, target, chokidarOptionsHash) {\n  const group = watchers.get(chokidarOptionsHash);\n  const watcher = group.get(id);\n  if (watcher) watcher.deleteTask(target, group);\n}\n\nclass FileWatcher {\n  constructor(id, chokidarOptions, group) {\n    this.id = id;\n    this.tasks = new Set();\n    this.transformDependencyTasks = new Set();\n    let modifiedTime;\n\n    try {\n      const stats = statSync(id);\n      modifiedTime = +stats.mtime;\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        // can't watch files that don't exist (e.g. injected\n        // by plugins somehow)\n        return;\n      }\n\n      throw err;\n    }\n\n    const handleWatchEvent = event => {\n      if (event === 'rename' || event === 'unlink') {\n        this.close();\n        group.delete(id);\n        this.trigger(id);\n        return;\n      } else {\n        let stats;\n\n        try {\n          stats = statSync(id);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            modifiedTime = -1;\n            this.trigger(id);\n            return;\n          }\n\n          throw err;\n        } // debounce\n\n\n        if (+stats.mtime - modifiedTime > 15) this.trigger(id);\n      }\n    };\n\n    this.fsWatcher = chokidarOptions ? chokidar$1.watch(id, chokidarOptions).on('all', handleWatchEvent) : watch$1(id, opts, handleWatchEvent);\n    group.set(id, this);\n  }\n\n  addTask(task, isTransformDependency) {\n    if (isTransformDependency) this.transformDependencyTasks.add(task);else this.tasks.add(task);\n  }\n\n  close() {\n    if (this.fsWatcher) this.fsWatcher.close();\n  }\n\n  deleteTask(task, group) {\n    let deleted = this.tasks.delete(task);\n    deleted = this.transformDependencyTasks.delete(task) || deleted;\n\n    if (deleted && this.tasks.size === 0 && this.transformDependencyTasks.size === 0) {\n      group.delete(this.id);\n      this.close();\n    }\n  }\n\n  trigger(id) {\n    for (const task of this.tasks) {\n      task.invalidate(id, false);\n    }\n\n    for (const task of this.transformDependencyTasks) {\n      task.invalidate(id, true);\n    }\n  }\n\n}\n\nconst DELAY = 200;\n\nclass Watcher {\n  constructor(configs) {\n    this.buildTimeout = null;\n    this.invalidatedIds = new Set();\n    this.rerun = false;\n    this.emitter = new class extends EventEmitter {\n      constructor(close) {\n        super();\n        this.close = close; // Allows more than 10 bundles to be watched without\n        // showing the `MaxListenersExceededWarning` to the user.\n\n        this.setMaxListeners(Infinity);\n      }\n\n    }(this.close.bind(this));\n    this.tasks = (Array.isArray(configs) ? configs : configs ? [configs] : []).map(config => new Task(this, config));\n    this.running = true;\n    process.nextTick(() => this.run());\n  }\n\n  close() {\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n\n    for (const task of this.tasks) {\n      task.close();\n    }\n\n    this.emitter.removeAllListeners();\n  }\n\n  emit(event, value) {\n    this.emitter.emit(event, value);\n  }\n\n  invalidate(id) {\n    if (id) {\n      this.invalidatedIds.add(id);\n    }\n\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(() => {\n      this.buildTimeout = null;\n\n      for (const id of this.invalidatedIds) {\n        this.emit('change', id);\n      }\n\n      this.invalidatedIds.clear();\n      this.emit('restart');\n      this.run();\n    }, DELAY);\n  }\n\n  run() {\n    this.running = true;\n    this.emit('event', {\n      code: 'START'\n    });\n    let taskPromise = Promise.resolve();\n\n    for (const task of this.tasks) taskPromise = taskPromise.then(() => task.run());\n\n    return taskPromise.then(() => {\n      this.running = false;\n      this.emit('event', {\n        code: 'END'\n      });\n    }).catch(error => {\n      this.running = false;\n      this.emit('event', {\n        code: 'ERROR',\n        error\n      });\n    }).then(() => {\n      if (this.rerun) {\n        this.rerun = false;\n        this.invalidate();\n      }\n    });\n  }\n\n}\n\nclass Task {\n  constructor(watcher, config) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.invalidated = true;\n    this.watcher = watcher;\n    this.closed = false;\n    this.watched = new Set();\n    const {\n      inputOptions,\n      outputOptions\n    } = mergeOptions({\n      config\n    });\n    this.inputOptions = inputOptions;\n    this.outputs = outputOptions;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return path.resolve(output.file || output.dir);\n      return undefined;\n    });\n    const watchOptions = inputOptions.watch || {};\n    if ('useChokidar' in watchOptions) watchOptions.chokidar = watchOptions.useChokidar;\n    let chokidarOptions = 'chokidar' in watchOptions ? watchOptions.chokidar : !!chokidar$1;\n\n    if (chokidarOptions) {\n      chokidarOptions = Object.assign(Object.assign({}, chokidarOptions === true ? {} : chokidarOptions), {\n        disableGlobbing: true,\n        ignoreInitial: true\n      });\n    }\n\n    if (chokidarOptions && !chokidar$1) {\n      throw new Error(`watch.chokidar was provided, but chokidar could not be found. Have you installed it?`);\n    }\n\n    this.chokidarOptions = chokidarOptions;\n    this.chokidarOptionsHash = JSON.stringify(chokidarOptions);\n    this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n  }\n\n  close() {\n    this.closed = true;\n\n    for (const id of this.watched) {\n      deleteTask(id, this, this.chokidarOptionsHash);\n    }\n  }\n\n  invalidate(id, isTransformDependency) {\n    this.invalidated = true;\n\n    if (isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (module.transformDependencies.indexOf(id) === -1) continue; // effective invalidation\n\n        module.originalCode = null;\n      }\n    }\n\n    this.watcher.invalidate(id);\n  }\n\n  run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = Object.assign(Object.assign({}, this.inputOptions), {\n      cache: this.cache\n    });\n    const start = Date.now();\n    this.watcher.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.inputOptions.input,\n      output: this.outputFiles\n    });\n    setWatcher(this.watcher.emitter);\n    return rollup(options).then(result => {\n      if (this.closed) return undefined;\n      this.updateWatchedFiles(result);\n      return Promise.all(this.outputs.map(output => result.write(output))).then(() => result);\n    }).then(result => {\n      this.watcher.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.inputOptions.input,\n        output: this.outputFiles,\n        result\n      });\n    }).catch(error => {\n      if (this.closed) return;\n\n      if (Array.isArray(error.watchFiles)) {\n        for (const id of error.watchFiles) {\n          this.watchFile(id);\n        }\n      }\n\n      if (error.id) {\n        this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n      }\n\n      throw error;\n    });\n  }\n\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) deleteTask(id, this, this.chokidarOptionsHash);\n    }\n  }\n\n  watchFile(id, isTransformDependency = false) {\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n\n    if (this.outputFiles.some(file => file === id)) {\n      throw new Error('Cannot import the generated bundle');\n    } // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n\n\n    addTask(id, this, this.chokidarOptions, this.chokidarOptionsHash, isTransformDependency);\n  }\n\n}\n\nfunction watch(configs) {\n  return new Watcher(configs).emitter;\n}\n\nexport { version as VERSION, rollup, watch };","map":{"version":3,"sources":["/home/agatha/open/node_modules/rollup/dist/rollup.es.js"],"names":["util","path","relative","relative$1","extname","basename","dirname","resolve","sep","readFile","readFile$1","writeFile","writeFile$1","readdirSync","mkdirSync","lstatSync","realpathSync","statSync","watch","watch$1","acorn__default","Parser","createHash","createHash$2","EventEmitter","module","__awaiter","thisArg","_arguments","P","generator","Promise","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","version","charToInteger","chars","i","length","charCodeAt","decode","mappings","decoded","line","segment","j","shift","c","segmentify","push","integer","undefined","Error","String","fromCharCode","hasContinuationBit","shouldNegate","encode","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","line_1","segmentMappings","encodeInteger","join","num","clamped","BitSet","arg","bits","slice","prototype","add","n","has","Chunk","start","end","content","original","intro","outro","storeName","edited","Object","defineProperties","previous","writable","appendLeft","appendRight","clone","chunk","contains","index","eachNext","fn","eachPrevious","edit","contentOnly","prependLeft","prependRight","split","sliceIndex","originalBefore","originalAfter","newChunk","toString","trimEnd","rx","replace","trimmed","trimStart","btoa","window","str","unescape","encodeURIComponent","Buffer","from","SourceMap","properties","file","sources","sourcesContent","names","JSON","stringify","toUrl","guessIndent","code","lines","tabbed","filter","test","spaced","min","reduce","current","numSpaces","exec","Math","Infinity","Array","getRelativePath","to","fromParts","toParts","pop","concat","isObject","thing","call","getLocator","source","originalLines","lineOffsets","pos","locate","m","column","Mappings","hires","generatedCodeLine","raw","rawSegments","pending","addEdit","sourceIndex","loc","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","warned","insertLeft","insertRight","MagicString","string","options","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","filename","indentExclusionRanges","storedNames","indentStr","addSourcemapLocation","char","append","TypeError","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","this$1","keys","indexOf","includeContent","generateMap","getIndentString","indent","pattern","isExcluded","exclude","exclusions","forEach","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","console","warn","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","prepend","remove","lastChar","lastLine","lineIndex","lastIndexOf","substr","lineStr","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trim","trimLines","charType","trimEndAborted","RegExp","aborted","trimStartAborted","hasOwnProp","hasOwnProperty","Bundle","separator","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","name","magicString","map","indentStringCounts","sort","a","b","arguments","trailingNewline","body","some","minimalisticAssert","assert","val","msg","equal","assertEqual","l","r","createCommonjsModule","exports","inherits_browser","create","inherits","ctor","superCtor","super_","constructor","enumerable","configurable","TempCtor","util$1","inherits_1","isSurrogatePair","toArray","enc","isArray","res","p","parseInt","toArray_1","toHex","zero2","toHex_1","htonl","w","htonl_1","toHex32","endian","zero8","toHex32_1","word","zero2_1","zero8_1","join32","len","k","join32_1","split32","split32_1","rotr32","rotr32_1","rotl32","rotl32_1","sum32","sum32_1","sum32_3","sum32_3_1","sum32_4","d","sum32_4_1","sum32_5","sum32_5_1","sum64","buf","ah","al","bh","bl","lo","hi","sum64_1","sum64_hi","sum64_hi_1","sum64_lo","sum64_lo_1","sum64_4_hi","ch","cl","dh","dl","carry","sum64_4_hi_1","sum64_4_lo","sum64_4_lo_1","sum64_5_hi","eh","el","sum64_5_hi_1","sum64_5_lo","sum64_5_lo_1","rotr64_hi","rotr64_hi_1","rotr64_lo","rotr64_lo_1","shr64_hi","shr64_hi_1","shr64_lo","shr64_lo_1","utils","BlockHash","pendingTotal","blockSize","outSize","hmacStrength","padLength","_delta8","_delta32","BlockHash_1","update","_update","digest","_pad","_digest","pad","bytes","t","common","rotr32$1","ft_1","s","x","y","z","ch32","p32","maj32","ft_1_1","ch32_1","maj32_1","p32_1","s0_256","s0_256_1","s1_256","s1_256_1","g0_256","g0_256_1","g1_256","g1_256_1","common$1","sum32$1","sum32_4$1","sum32_5$1","ch32$1","maj32$1","s0_256$1","s1_256$1","g0_256$1","g1_256$1","BlockHash$1","sha256_K","SHA256","h","W","_256","f","g","T1","T2","Boolean","unshift","UnknownKey","Symbol","EMPTY_PATH","UNKNOWN_PATH","EntitiesKey","PathTracker","entityPaths","Set","getEntities","currentPaths","pathSegment","SHARED_RECURSION_TRACKER","BROKEN_FLOW_NONE","BROKEN_FLOW_BREAK_CONTINUE","BROKEN_FLOW_ERROR_RETURN_LABEL","createInclusionContext","brokenFlow","includedLabels","createHasEffectsContext","accessed","assigned","called","ignore","breaks","continues","labels","returnAwaitYield","instantiated","replacedVariableInits","Map","BlockStatement","CallExpression","ExportNamespaceSpecifier","ExpressionStatement","FunctionExpression","Identifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Program","Property","ReturnStatement","treeshakeNode","node","annotations","annotation","removeAnnotations","parent","type","NO_SEMICOLON","isNoStatement","findFirstOccurrenceOutsideComment","searchString","searchPos","charCodeAfterSlash","findFirstLineBreakOutsideComment","lineBreakPos","renderStatementList","statements","currentNode","currentNodeStart","currentNodeNeedsBoundaries","nextNodeStart","nextNode","nextNodeNeedsBoundaries","included","needsBoundaries","nextIndex","render","getCommaSeparatedNodesWithBoundaries","nodes","splitUpNodes","contentEnd","removeLineBreaks","chars$1","base","toBase64","outStr","curDigit","floor","RESERVED_NAMES","assign","await","break","case","catch","class","const","continue","debugger","default","delete","do","else","enum","eval","export","extends","false","finally","for","function","if","implements","import","in","instanceof","interface","let","new","null","package","private","protected","public","return","static","super","switch","this","throw","true","try","typeof","var","void","while","with","yield","getSafeName","baseName","usedNames","safeName","count","NO_ARGS","assembleMemberDescriptions","memberDescriptions","inheritedDescriptions","UnknownValue","UNKNOWN_EXPRESSION","deoptimizePath","getLiteralValueAtPath","getReturnExpressionWhenCalledAtPath","hasEffectsWhenAccessedAtPath","hasEffectsWhenAssignedAtPath","hasEffectsWhenCalledAtPath","include","includeCallArguments","context","args","UNDEFINED_EXPRESSION","returnsUnknown","callsArgs","mutatesSelf","returns","returnsPrimitive","mutatesSelfReturnsUnknown","callsArgReturnsUnknown","UnknownArrayExpression","getMemberReturnExpressionWhenCalled","arrayMembers","callOptions","hasMemberEffectWhenCalled","returnsArray","mutatesSelfReturnsArray","callsArgReturnsArray","callsArgMutatesSelfReturnsArray","UNKNOWN_LITERAL_BOOLEAN","literalBooleanMembers","subPath","returnsBoolean","callsArgReturnsBoolean","UNKNOWN_LITERAL_NUMBER","literalNumberMembers","returnsNumber","mutatesSelfReturnsNumber","callsArgReturnsNumber","UNKNOWN_LITERAL_STRING","literalStringMembers","returnsString","UnknownObjectExpression","objectMembers","isPrototypeOf","propertyIsEnumerable","toLocaleString","valueOf","copyWithin","every","fill","find","findIndex","includes","reduceRight","reverse","splice","toExponential","toFixed","toPrecision","charAt","codePointAt","endsWith","localeCompare","normalize","padEnd","padStart","repeat","search","startsWith","substring","toLocaleLowerCase","toLocaleUpperCase","toLowerCase","toUpperCase","getLiteralMembersForValue","members","memberName","parentIncluded","argIndex","withNew","Variable","alwaysRendered","exportName","isId","isReassigned","renderBaseName","renderName","safeExportName","addReference","_identifier","_path","getBaseVariableName","_recursionTracker","_origin","getName","getPropertyAccess","_context","_callOptions","markCalledFromTryStatement","setRenderNames","setSafeName","ExternalVariable","isNamespace","referenced","identifier","suggestName","used","reservedWords","builtins","blacklisted","illegalCharacters","startsWithDigit","isLegal","makeLegal","_","letter","absolutePath","relativePath","isAbsolute","isRelative","ExternalModule","graph","id","moduleSideEffects","exportsNames","exportsNamespace","mostCommonSuggestion","reexported","renderPath","renormalizeRenderPath","execIndex","parts","variableName","nameSuggestions","declarations","exportedVariables","getVariableForExportName","declaration","set","setRenderPath","inputBase","paths","warnUnusedImports","unused","message","markModuleAndImpureDependenciesAsExecuted","baseModule","isExecuted","modules","visitedModules","dependency","dependencies","MAX_PATH_DEPTH","LocalVariable","declarator","init","additionalInitializers","calledFromTryStatement","expressionsToBeDeoptimized","deoptimizationTracker","addDeclaration","consolidateInitializers","initializer","trackedEntities","expression","deoptimizeCache","recursionTracker","origin","trackedExpressions","Scope","children","variables","_isHoisted","variable","get","findVariable","_name","ChildScope","accessedOutsideVariables","addAccessedDynamicImport","importExpression","accessedDynamicImports","addAccessedGlobalsByFormat","globalsByFormat","accessedGlobalVariablesByFormat","format","accessedGlobalVariables","addNamespaceMemberAccess","addReturnExpression","addUsedOutsideNames","values","deconflict","inlineNamespace","scope","findLexicalBoundary","knownVariable","getLocator$1","offsetLine","offsetColumn","lineRanges","range","rangeContains","getLocation","character","startIndex","Literal","getAndCreateKeys","esTreeNode","key","INCLUDE_PARAMETERS","NodeBase","parentScope","createScope","parseNode","initialise","bind","child","declare","_kind","_init","hasEffects","includeChildrenRecursively","includeWithAllDeclaredVariables","insertSemicolon","location","fileName","nodeConstructors","UnknownNode","shouldBeIncluded","ClassNode","superClass","ClassDeclaration","ArgumentsVariable","ThisVariable","getInit","ParameterScope","parameters","hasRest","hoistedBodyVarScope","addParameterDeclaration","addParameterVariables","parameterList","parameter","argIncluded","restParam","paramVars","ReturnValueScope","returnExpression","returnExpressions","getReturnExpression","updateReturnExpression","FunctionScope","argumentsVariable","thisVariable","isReference","computed","object","local","BLANK","ValueProperties","PURE","pure","IMPURE","O","__proto__","PF","C","PC","ARRAY_TYPE","of","INTL_MEMBER","supportedLocalesOf","knownGlobals","global","globalThis","self","ArrayBuffer","isView","Atomics","BigInt","BigInt64Array","BigUint64Array","DataView","Date","now","parse","UTC","decodeURI","decodeURIComponent","encodeURI","escape","EvalError","Float32Array","Float64Array","Function","Int16Array","Int32Array","Int8Array","isFinite","isNaN","abs","acos","acosh","asin","asinh","atan","atan2","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","fround","hypot","imul","log","log10","log1p","log2","max","pow","random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","NaN","Number","isInteger","isSafeInteger","parseFloat","getNotifier","getOwn","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","is","isExtensible","isFrozen","isSealed","all","race","Proxy","RangeError","ReferenceError","Reflect","SharedArrayBuffer","fromCodePoint","keyFor","SyntaxError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakMap","WeakSet","clearInterval","clearTimeout","Intl","Collator","DateTimeFormat","ListFormat","NumberFormat","PluralRules","RelativeTimeFormat","setInterval","setTimeout","TextDecoder","TextEncoder","URL","URLSearchParams","AbortController","AbortSignal","addEventListener","alert","AnalyserNode","Animation","AnimationEvent","applicationCache","ApplicationCache","ApplicationCacheErrorEvent","atob","Attr","Audio","AudioBuffer","AudioBufferSourceNode","AudioContext","AudioDestinationNode","AudioListener","AudioNode","AudioParam","AudioProcessingEvent","AudioScheduledSourceNode","AudioWorkletNode","BarProp","BaseAudioContext","BatteryManager","BeforeUnloadEvent","BiquadFilterNode","Blob","BlobEvent","blur","BroadcastChannel","ByteLengthQueuingStrategy","Cache","caches","CacheStorage","cancelAnimationFrame","cancelIdleCallback","CanvasCaptureMediaStreamTrack","CanvasGradient","CanvasPattern","CanvasRenderingContext2D","ChannelMergerNode","ChannelSplitterNode","CharacterData","clientInformation","ClipboardEvent","close","closed","CloseEvent","Comment","CompositionEvent","confirm","ConstantSourceNode","ConvolverNode","CountQueuingStrategy","createImageBitmap","Credential","CredentialsContainer","crypto","Crypto","CryptoKey","CSS","CSSConditionRule","CSSFontFaceRule","CSSGroupingRule","CSSImportRule","CSSKeyframeRule","CSSKeyframesRule","CSSMediaRule","CSSNamespaceRule","CSSPageRule","CSSRule","CSSRuleList","CSSStyleDeclaration","CSSStyleRule","CSSStyleSheet","CSSSupportsRule","CustomElementRegistry","customElements","CustomEvent","DataTransfer","DataTransferItem","DataTransferItemList","defaultstatus","defaultStatus","DelayNode","DeviceMotionEvent","DeviceOrientationEvent","devicePixelRatio","dispatchEvent","document","Document","DocumentFragment","DocumentType","DOMError","DOMException","DOMImplementation","DOMMatrix","DOMMatrixReadOnly","DOMParser","DOMPoint","DOMPointReadOnly","DOMQuad","DOMRect","DOMRectReadOnly","DOMStringList","DOMStringMap","DOMTokenList","DragEvent","DynamicsCompressorNode","Element","ErrorEvent","Event","EventSource","EventTarget","external","fetch","File","FileList","FileReader","focus","FocusEvent","FontFace","FontFaceSetLoadEvent","FormData","frames","GainNode","Gamepad","GamepadButton","GamepadEvent","getComputedStyle","getSelection","HashChangeEvent","Headers","history","History","HTMLAllCollection","HTMLAnchorElement","HTMLAreaElement","HTMLAudioElement","HTMLBaseElement","HTMLBodyElement","HTMLBRElement","HTMLButtonElement","HTMLCanvasElement","HTMLCollection","HTMLContentElement","HTMLDataElement","HTMLDataListElement","HTMLDetailsElement","HTMLDialogElement","HTMLDirectoryElement","HTMLDivElement","HTMLDListElement","HTMLDocument","HTMLElement","HTMLEmbedElement","HTMLFieldSetElement","HTMLFontElement","HTMLFormControlsCollection","HTMLFormElement","HTMLFrameElement","HTMLFrameSetElement","HTMLHeadElement","HTMLHeadingElement","HTMLHRElement","HTMLHtmlElement","HTMLIFrameElement","HTMLImageElement","HTMLInputElement","HTMLLabelElement","HTMLLegendElement","HTMLLIElement","HTMLLinkElement","HTMLMapElement","HTMLMarqueeElement","HTMLMediaElement","HTMLMenuElement","HTMLMetaElement","HTMLMeterElement","HTMLModElement","HTMLObjectElement","HTMLOListElement","HTMLOptGroupElement","HTMLOptionElement","HTMLOptionsCollection","HTMLOutputElement","HTMLParagraphElement","HTMLParamElement","HTMLPictureElement","HTMLPreElement","HTMLProgressElement","HTMLQuoteElement","HTMLScriptElement","HTMLSelectElement","HTMLShadowElement","HTMLSlotElement","HTMLSourceElement","HTMLSpanElement","HTMLStyleElement","HTMLTableCaptionElement","HTMLTableCellElement","HTMLTableColElement","HTMLTableElement","HTMLTableRowElement","HTMLTableSectionElement","HTMLTemplateElement","HTMLTextAreaElement","HTMLTimeElement","HTMLTitleElement","HTMLTrackElement","HTMLUListElement","HTMLUnknownElement","HTMLVideoElement","IDBCursor","IDBCursorWithValue","IDBDatabase","IDBFactory","IDBIndex","IDBKeyRange","IDBObjectStore","IDBOpenDBRequest","IDBRequest","IDBTransaction","IDBVersionChangeEvent","IdleDeadline","IIRFilterNode","Image","ImageBitmap","ImageBitmapRenderingContext","ImageCapture","ImageData","indexedDB","innerHeight","innerWidth","InputEvent","IntersectionObserver","IntersectionObserverEntry","isSecureContext","KeyboardEvent","KeyframeEffect","localStorage","Location","locationbar","matchMedia","MediaDeviceInfo","MediaDevices","MediaElementAudioSourceNode","MediaEncryptedEvent","MediaError","MediaKeyMessageEvent","MediaKeySession","MediaKeyStatusMap","MediaKeySystemAccess","MediaList","MediaQueryList","MediaQueryListEvent","MediaRecorder","MediaSettingsRange","MediaSource","MediaStream","MediaStreamAudioDestinationNode","MediaStreamAudioSourceNode","MediaStreamEvent","MediaStreamTrack","MediaStreamTrackEvent","menubar","MessageChannel","MessageEvent","MessagePort","MIDIAccess","MIDIConnectionEvent","MIDIInput","MIDIInputMap","MIDIMessageEvent","MIDIOutput","MIDIOutputMap","MIDIPort","MimeType","MimeTypeArray","MouseEvent","moveBy","moveTo","MutationEvent","MutationObserver","MutationRecord","NamedNodeMap","NavigationPreloadManager","navigator","Navigator","NetworkInformation","Node","NodeFilter","NodeIterator","NodeList","Notification","OfflineAudioCompletionEvent","OfflineAudioContext","offscreenBuffering","OffscreenCanvas","open","openDatabase","Option","OscillatorNode","outerHeight","outerWidth","PageTransitionEvent","pageXOffset","pageYOffset","PannerNode","Path2D","PaymentAddress","PaymentRequest","PaymentRequestUpdateEvent","PaymentResponse","performance","Performance","PerformanceEntry","PerformanceLongTaskTiming","PerformanceMark","PerformanceMeasure","PerformanceNavigation","PerformanceNavigationTiming","PerformanceObserver","PerformanceObserverEntryList","PerformancePaintTiming","PerformanceResourceTiming","PerformanceTiming","PeriodicWave","Permissions","PermissionStatus","personalbar","PhotoCapabilities","Plugin","PluginArray","PointerEvent","PopStateEvent","postMessage","Presentation","PresentationAvailability","PresentationConnection","PresentationConnectionAvailableEvent","PresentationConnectionCloseEvent","PresentationConnectionList","PresentationReceiver","PresentationRequest","print","ProcessingInstruction","ProgressEvent","PromiseRejectionEvent","prompt","PushManager","PushSubscription","PushSubscriptionOptions","queueMicrotask","RadioNodeList","Range","ReadableStream","RemotePlayback","removeEventListener","Request","requestAnimationFrame","requestIdleCallback","resizeBy","ResizeObserver","ResizeObserverEntry","resizeTo","Response","RTCCertificate","RTCDataChannel","RTCDataChannelEvent","RTCDtlsTransport","RTCIceCandidate","RTCIceTransport","RTCPeerConnection","RTCPeerConnectionIceEvent","RTCRtpReceiver","RTCRtpSender","RTCSctpTransport","RTCSessionDescription","RTCStatsReport","RTCTrackEvent","screen","Screen","screenLeft","ScreenOrientation","screenTop","screenX","screenY","ScriptProcessorNode","scroll","scrollbars","scrollBy","scrollTo","scrollX","scrollY","SecurityPolicyViolationEvent","Selection","ServiceWorker","ServiceWorkerContainer","ServiceWorkerRegistration","sessionStorage","ShadowRoot","SharedWorker","SourceBuffer","SourceBufferList","speechSynthesis","SpeechSynthesisEvent","SpeechSynthesisUtterance","StaticRange","status","statusbar","StereoPannerNode","stop","Storage","StorageEvent","StorageManager","styleMedia","StyleSheet","StyleSheetList","SubtleCrypto","SVGAElement","SVGAngle","SVGAnimatedAngle","SVGAnimatedBoolean","SVGAnimatedEnumeration","SVGAnimatedInteger","SVGAnimatedLength","SVGAnimatedLengthList","SVGAnimatedNumber","SVGAnimatedNumberList","SVGAnimatedPreserveAspectRatio","SVGAnimatedRect","SVGAnimatedString","SVGAnimatedTransformList","SVGAnimateElement","SVGAnimateMotionElement","SVGAnimateTransformElement","SVGAnimationElement","SVGCircleElement","SVGClipPathElement","SVGComponentTransferFunctionElement","SVGDefsElement","SVGDescElement","SVGDiscardElement","SVGElement","SVGEllipseElement","SVGFEBlendElement","SVGFEColorMatrixElement","SVGFEComponentTransferElement","SVGFECompositeElement","SVGFEConvolveMatrixElement","SVGFEDiffuseLightingElement","SVGFEDisplacementMapElement","SVGFEDistantLightElement","SVGFEDropShadowElement","SVGFEFloodElement","SVGFEFuncAElement","SVGFEFuncBElement","SVGFEFuncGElement","SVGFEFuncRElement","SVGFEGaussianBlurElement","SVGFEImageElement","SVGFEMergeElement","SVGFEMergeNodeElement","SVGFEMorphologyElement","SVGFEOffsetElement","SVGFEPointLightElement","SVGFESpecularLightingElement","SVGFESpotLightElement","SVGFETileElement","SVGFETurbulenceElement","SVGFilterElement","SVGForeignObjectElement","SVGGElement","SVGGeometryElement","SVGGradientElement","SVGGraphicsElement","SVGImageElement","SVGLength","SVGLengthList","SVGLinearGradientElement","SVGLineElement","SVGMarkerElement","SVGMaskElement","SVGMatrix","SVGMetadataElement","SVGMPathElement","SVGNumber","SVGNumberList","SVGPathElement","SVGPatternElement","SVGPoint","SVGPointList","SVGPolygonElement","SVGPolylineElement","SVGPreserveAspectRatio","SVGRadialGradientElement","SVGRect","SVGRectElement","SVGScriptElement","SVGSetElement","SVGStopElement","SVGStringList","SVGStyleElement","SVGSVGElement","SVGSwitchElement","SVGSymbolElement","SVGTextContentElement","SVGTextElement","SVGTextPathElement","SVGTextPositioningElement","SVGTitleElement","SVGTransform","SVGTransformList","SVGTSpanElement","SVGUnitTypes","SVGUseElement","SVGViewElement","TaskAttributionTiming","Text","TextEvent","TextMetrics","TextTrack","TextTrackCue","TextTrackCueList","TextTrackList","TimeRanges","toolbar","top","Touch","TouchEvent","TouchList","TrackEvent","TransitionEvent","TreeWalker","UIEvent","ValidityState","visualViewport","VisualViewport","VTTCue","WaveShaperNode","WebAssembly","WebGL2RenderingContext","WebGLActiveInfo","WebGLBuffer","WebGLContextEvent","WebGLFramebuffer","WebGLProgram","WebGLQuery","WebGLRenderbuffer","WebGLRenderingContext","WebGLSampler","WebGLShader","WebGLShaderPrecisionFormat","WebGLSync","WebGLTexture","WebGLTransformFeedback","WebGLUniformLocation","WebGLVertexArrayObject","WebSocket","WheelEvent","Window","Worker","WritableStream","XMLDocument","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestUpload","XMLSerializer","XPathEvaluator","XPathExpression","XPathResult","XSLTProcessor","getGlobalAtPath","currentGlobal","isPureGlobal","globalAtPath","isGlobalMember","GlobalVariable","Identifier$1","bound","addExportedVariables","kind","disallowImportReassignment","unknownGlobalSideEffects","includeVariable","_options","renderedParentType","isCalleeOfRenderedParent","isShorthandProperty","error","RestElement","declarationInit","argument","FunctionNode","isPrototypeDeoptimized","param","params","thisInit","hasArguments","addImplicitReturnExpressionToScope","preventChildBlockScope","FunctionDeclaration","WHITESPACE","getDeclarationStart","getIdInsertPosition","declarationKeyword","declarationEnd","generatorStarPos","ExportDefaultDeclaration","declarationName","addExportDefaultDeclaration","getModuleName","addExport","nodeRenderOptions","declarationStart","renderNamedDeclaration","getOriginalVariable","renderVariableDeclaration","needsId","systemBinding","varOrConst","hasTrailingSemicolon","ExportDefaultVariable","exportDefaultDeclaration","hasId","originalId","originalVariable","getAssignedVariableName","assignedOriginal","MISSING_EXPORT_SHIM_VARIABLE","INTEROP_DEFAULT_VARIABLE","INTEROP_NAMESPACE_VARIABLE","ExportShimVariable","NamespaceVariable","syntheticNamedExports","memberVariables","containsExternalNamespace","referencedEarly","references","getModuleExecIndex","preserveModules","getExports","getReexports","traceExport","renderBlock","compact","namespaceToStringTag","output","getDefaultExport","freeze","renderFirst","esModuleExport","compactEsModuleExport","getExportBlock","namedExportsMode","interop","mechanism","dep","reexports","expt","imported","exportBlock","specifier","needsLiveBinding","imports","isChunk","depNamedExportsMode","importName","lhs","exported","rhs","getInteropBlock","exportsDefault","copyPropertyLiveBinding","copyPropertyStatic","_t","getInteropNamespace","liveBindings","builtins$1","buffer","constants","domain","events","http","https","os","process","punycode","querystring","stream","string_decoder","timers","tty","url","vm","zlib","warnOnBuiltins","externalBuiltins","detail","removeExtensionFromRelativeAmdId","amd","accessedGlobals","hasExports","indentString","isEntryModuleFacade","deps","amdOptions","useStrict","strict","define","wrapperStart","interopBlock","externalLiveBindings","esModule","cjs","needsInterop","importBlock","definingVariable","ex","esm","getImportBlock","getExportBlock$1","defaultImport","starImport","importedNames","starExport","namespaceReexports","namedReexports","exportDeclaration","spaces","tabsToSpaces","getCodeFrame","frameStart","frameEnd","digits","isErrorLine","lineNum","indicator","sanitizeFileName","getAliasName","relativeId","cwd","isPlainPathFragment","props","augmentCodeLocation","frame","Errors","errAssetNotFinalisedForFileName","ASSET_NOT_FINALISED","errCannotEmitFromOptionsHook","CANNOT_EMIT_FROM_OPTIONS_HOOK","errChunkNotGeneratedForFileName","CHUNK_NOT_GENERATED","errAssetReferenceIdNotFoundForSetSource","assetReferenceId","ASSET_NOT_FOUND","errAssetSourceAlreadySet","ASSET_SOURCE_ALREADY_SET","errNoAssetSourceSet","assetName","ASSET_SOURCE_MISSING","errBadLoader","BAD_LOADER","errDeprecation","deprecation","DEPRECATED_FEATURE","errFileReferenceIdNotFoundForFilename","FILE_NOT_FOUND","errFileNameConflict","FILE_NAME_CONFLICT","errInputHookInOutputPlugin","pluginName","hookName","INPUT_HOOK_IN_OUTPUT_PLUGIN","errCannotAssignModuleToChunk","moduleId","assignToAlias","currentAlias","INVALID_CHUNK","errInvalidExportOptionValue","optionValue","INVALID_EXPORT_OPTION","errIncompatibleExportOptionValue","entryModule","errInternalIdCannotBeExternal","importer","INVALID_EXTERNAL_ID","errInvalidOption","explanation","INVALID_OPTION","errInvalidRollupPhaseForAddWatchFile","INVALID_ROLLUP_PHASE","errInvalidRollupPhaseForChunkEmission","errMixedExport","facadeModuleId","MIXED_EXPORTS","errNamespaceConflict","reexportingModule","additionalExportAllModule","NAMESPACE_CONFLICT","exportsAll","reexporter","errEntryCannotBeExternal","unresolvedId","UNRESOLVED_ENTRY","errUnresolvedEntry","errUnresolvedImport","UNRESOLVED_IMPORT","errUnresolvedImportTreatedAsExternal","errExternalSyntheticExports","EXTERNAL_SYNTHETIC_EXPORTS","errFailedValidation","VALIDATION_ERROR","shouldUseDot","property","prop","keypath","setupNamespace","root","globals","acc","part","assignToDeepVariable","deepName","assignment","deepAssignment","trimEmptyImports","thisProp","iife","extend","isNamespaced","useVariableAssignment","globalName","wrapperIntro","wrapperOutro","getStarExcludes","starExcludes","reexport","getStarExcludesBlock","size","getImportBindingsBlock","importBindings","getExportsBlock","getHoistedExportsBlock","hoisted","uninitialized","getMissingExportsBlock","system","usesTopLevelAwait","dependencyIds","setters","setter","createdSetter","registeredName","wrapperParams","wrapperEnd","globalProp","globalVar","safeAccess","umd","factoryVar","amdDeps","cjsDeps","trimmedImports","globalDeps","factoryArgs","noConflict","amdParams","cjsExport","iifeExport","noConflictExportsVar","factory","iifeNeedsGlobal","globalParam","globalArg","iifeStart","iifeEnd","cjsIntro","finalisers","es","extractors","ArrayPattern","element","elements","AssignmentPattern","left","MemberExpression","ObjectPattern","extractAssignedNames","ExportAllDeclaration","ArrayExpression","BlockScope","isHoisted","ExpressionStatement$1","directive","BlockStatement$1","directlyIncluded","lastStatement","deoptimizeBody","firstBodyStatement","ArrowFunctionExpression","getSystemExportStatement","AssignmentExpression","deoptimized","applyDeoptimizations","right","operatorPos","operator","operation","systemPatternExports","AwaitExpression","checkTopLevelAwait","binaryOperators","BinaryExpression","leftValue","rightValue","operatorFn","BreakStatement","label","getResolvablePropertyKey","memberExpression","getResolvableComputedPropertyKey","propertyKey","getPathIfNotComputed","nextPathKey","parentPath","getStringFromPath","pathString","replacement","wasPathDeoptimizedWhileOptimized","baseVariable","resolvedVariable","resolveNamespaceVariables","getPropertyKey","disallowNamespaceReassignment","propertyReadSideEffects","isCalleeOfDifferentParent","exporter","missing","CallExpression$1","wasPathDeoptmizedWhileOptimized","callee","annotatedPure","lastIncludedIndex","CatchScope","CatchClause","ClassBody","classConstructor","method","ClassExpression","MultiExpression","expressions","ConditionalExpression","isBranchResolutionAnalysed","usedBranch","getUsedBranch","unusedBranch","consequent","alternate","preventASI","colonPos","inclusionStart","testValue","ContinueStatement","DoWhileStatement","EmptyStatement","ExportNamedDeclaration","ForInStatement","ForOfStatement","ForStatement","FunctionExpression$1","unset","IfStatement","getTestValue","consequentBrokenFlow","includeRecursively","includeUnknownTest","includeKnownTest","singleRetainedBranch","ImportDeclaration","addImport","Import","exportMode","includeDynamicImport","addDynamicImport","importMechanism","getDynamicImportMechanism","renderFinalResolution","resolution","setResolution","resolveNamespace","dynamicImportFunction","LabeledStatement","LogicalExpression","fulfil","err","contents","mkdirpath","dir","err2","dest","data","getRollupDefaultPlugin","preserveSymlinks","resolveId","createResolveId","load","resolveFileUrl","relativeUrlMechanisms","resolveImportMeta","chunkId","importMetaMechanisms","findFile","stats","isSymbolicLink","isFile","files","addJsExtensionIfNecessary","found","getResolveUrl","getUrlFromDocument","getGenericImportMetaMechanism","getUrl","urlMechanism","getRelativeUrlFromDocument","accessedMetaUrlGlobals","accessedFileUrlGlobals","ASSET_PREFIX","CHUNK_PREFIX","FILE_PREFIX","MetaProperty","metaProperty","meta","addImportMeta","renderFinalMechanism","outputPluginDriver","referenceId","chunkReferenceId","getFileName","warnDeprecation","hookFirstSync","assetFileName","relativeAssetPath","MethodDefinition","NewExpression","SpreadElement","ObjectExpression","deoptimizedPaths","hasUnknownDeoptimizedProperty","propertyMap","unmatchablePropertiesRead","unmatchablePropertiesWrite","getPropertyMap","deoptimizeAllProperties","propertiesRead","exactMatchRead","propertiesWrite","isWrite","isRead","keyValue","propertyMapProperty","exactMatchWrite","Program$1","Property$1","accessorCallOptions","shorthand","ReturnStatement$1","SequenceExpression","includedNodes","SwitchCase","testEnd","consequentStart","SwitchStatement","discriminant","minBrokenFlow","switchCase","cases","defaultCase","isCaseIncluded","caseIndex","hasEffectsContext","TaggedTemplateExpression","tag","TemplateElement","TemplateLiteral","quasis","cooked","ModuleScope","traceVariable","ThisExpression","alias","moduleContext","ThrowStatement","TryStatement","tryCatchDeoptimization","block","finalizer","handler","unaryOperators","UnaryExpression","argumentValue","UpdateExpression","prefix","op","isReassignedExportsMember","areAllDeclarationsIncludedAndNotExported","VariableDeclaration","declareDeclarator","renderReplacedDeclarations","renderDeclarationEnd","separatorString","lastSeparatorPos","actualContentEnd","renderedContentEnd","addSemicolon","separatedNodes","isInDeclaration","hasRenderedContent","leadingString","nextSeparatorString","VariableDeclarator","WhileStatement","YieldExpression","ImportExpression","SyntheticNamedExportVariableVariable","defaultVariable","getOriginalLocation","sourcemapChain","filteredSourcemapChain","sourcemap","locationFound","skipThrough","st","_node","_st","_c","base$1","list","stmt","Statement","ParenthesizedExpression","WithStatement","i$1","list$1","cs","cons","ForInit","DebuggerStatement","decl","Pattern","VariablePattern","MemberPattern","elt","Expression","Super","expr","quasi","specifiers","spec","ImportSpecifier","Class","handlePureAnnotationsOfNode","state","commentNode","commentNodes","commentIndex","markPureNode","comment","pureCommentRegex","isPureComment","text","markPureCallExpressions","comments","esTreeAst","SOURCEMAPPING_URL","SOURCEMAPPING_URL_RE","NOOP","getStartTime","getElapsedTime","getMemory","normalizeHrTime","time","setTimeHelpers","hrtime","memoryUsage","heapUsed","getPersistedLabel","level","timeStartImpl","memory","startMemory","startTime","totalMemory","currentMemory","timeEndImpl","getTimings","newTimings","timeStart","timeEnd","TIMED_PLUGIN_HOOKS","ongenerate","onwrite","resolveDynamicImport","transform","transformBundle","getPluginWithTimers","plugin","timedPlugin","hook","timerLabel","initialiseTimers","inputOptions","perf","plugins","defaultAcornOptions","ecmaVersion","preserveParens","sourceType","tryParse","acornOptions","onComment","parserError","handleMissingExport","importingModule","importedModule","importerStart","MISSING_EXPORT_SHIM_DESCRIPTION","localName","getVariableForExportNameRecursive","target","isExportAllSearch","searchedNamesAndModules","searchedModules","Module","isEntry","chunkFileNames","chunkName","dynamicallyImportedBy","dynamicDependencies","dynamicImports","entryPointsHash","exportAllModules","exportAllSources","exportShimVariable","facadeChunk","importDescriptions","importMetas","isUserDefinedEntryPoint","manualChunkAlias","reexportDescriptions","userChunkNames","allExportNames","defaultExport","namespaceVariable","syntheticExports","transformDependencies","transitiveReexports","excludeFromSourcemap","getModuleContext","isEntryPoint","ext","bindReferences","ast","originalCode","getAllExportNames","SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT","getDynamicImportExpressions","importArgument","getExportNamesByVariable","exportNamesByVariable","tracedVariable","existingExportNames","getOrCreateNamespace","astContext","getRenderedExports","renderedExports","removedExports","getTransitiveDependencies","moduleById","reexportDeclaration","syntheticExport","shimMissingExports","shimMissingExport","includeAllExports","needsTreeshakingPass","includeAllInBundle","isIncluded","linkDependencies","resolvedIds","addModulesToImportDescriptions","externalExportAllModules","setSource","customTransformCache","originalSourcemap","transformFiles","acornParser","removeExistingSourceMap","treeshakingOptions","isCrossChunkImport","importDescription","treeshake","toJSON","localVariable","importDeclaration","otherModule","warning","exportedName","isDefault","dynamicImport","variableModule","Source","isOriginal","traceSegment","Link","traceMappings","tracedLine","traced","tracedSegment","segments","getLinkMap","linkMap","getCollapsedSourcemap","directory","sourceRoot","baseSources","collapseSourcemaps","bundleSourcemapChain","excludeContent","moduleSources","collapseSourcemap","DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT","deconflictImportsOther","deconflictImportsEsm","deconflictChunk","deconflictTopLevelVariables","_dependencies","proposedName","chunkOrExternalModule","getVariableExportName","namespace","compareExecIndex","unitA","unitB","sortByExecutionOrder","units","analyseModuleExecution","entryModules","nextExecIndex","cyclePaths","analysedModules","orderedModules","parents","analyseModule","getCyclePath","curEntry","parentId","curId","guessIndentString","decodedSourcemap","renderChunk","renderChunkReducer","inTransformBundle","inRenderChunk","hookReduceArg0","renderNamePattern","patternName","replacements","_match","makeUnique","existingNames","existingNamesLowercase","uniqueName","uniqueIndex","NON_ASSET_EXTENSIONS","getGlobalName","guess","isChunkRendered","Chunk$1","facadeModule","usedModules","exportNames","needsExportsShim","renderedDeclarations","renderedHash","renderedModuleSources","renderedSource","renderedSourceLength","sortedExportNames","moduleForNaming","generateFacade","facadedModule","facadeName","assignFacadeName","canModuleBeFacade","moduleExportNamesByVariable","exposedVariable","generateFacades","facades","requiredFacades","generateId","addons","includeHash","entryFileNames","hash","computeContentHashWithDependencies","getChunkName","generateIdPreserveModules","preserveModulesRelativeDir","sanitizedId","extension","generateInternalExports","mangle","suggestedName","getFallbackChunkName","getDynamicImportIds","getExportNames","getImportIds","getRenderedHash","hashAugmentation","calculateHashAugmentation","getRenderedSourceLength","link","addDependenciesToChunk","setUpChunkImportsAndExportsForModule","merge","chunkList","thisOldExportNames","updateRenderedDeclaration","oldExportNames","impt","mergeRenderedDeclaration","into","includedDeclaration","duplicateDeclaration","preRender","renderOptions","preferConst","chunkOrExternal","hoistTransitiveImports","inlineChunkDependencies","prepareDynamicImports","setIdentifierRenderResolutions","hoistedSource","renderedModules","renderedLength","rendered","originalLength","setExternalRenderPaths","getChunkDependencyDeclarations","getChunkExportDeclarations","outputChunk","finalise","renderedDependency","depId","finaliseDynamicImports","finaliseImportMetas","banner","footer","prevCode","chunkSourcemapChain","sourcemapFile","decodedMap","sourcemapExcludeSources","sourcePath","sourcemapPathTransform","visitDependencies","handleDependency","toBeVisited","visited","visitStaticDependenciesUntilCondition","isConditionSatisfied","seen","visitDep","subDep","moduleDependencies","chunkDependencies","depModule","preRenderedChunk","isDynamicEntry","hookReduceValueSync","pluginHash","addon","resolutionChunk","importMeta","reexportDeclarations","exportChunk","renderedImports","renderedVariable","targetPath","deep","exportVariable","exportedVariable","exportingModule","reexportName","optimizeChunks","chunks","CHUNK_GROUPING_SIZE","chunkIndex","mainChunk","execGroup","execGroupIndex","seekingFirstMergeCandidate","nextChunk","isMergeCandidate","remainingSize","ignoreSizeChunks","optimizedChunkIndex","skipWhiteSpace","tt","tokTypes","acornExportNsFrom","parseExport","lastIndex","skip","input","startNode","expect","star","eatContextual","parseIdent","checkExport","lastTokStart","finishNode","expectContextual","unexpected","parseExprAtom","semicolon","tt$1","skipWhiteSpace$1","nextTokenIsDot","parser","acornImportMeta","refDestructuringErrors","_import","allowImportExportEverywhere","inModule","raise","dot","raiseRecoverable","containsEsc","parseStatement","topLevel","parseExpression","parseExpressionStatement","UndefinedVariable","GlobalScope","ANONYMOUS_PLUGIN_PREFIX","ANONYMOUS_OUTPUT_PLUGIN_PREFIX","throwPluginError","PLUGIN_ERROR","pluginCode","deprecatedHooks","active","deprecated","warnDeprecatedHooks","createPluginCache","cache","item","getTrackedPluginCache","pluginCache","trackedCache","NO_CACHE","uncacheablePluginError","getCacheForUncacheablePlugin","emittedFiles","trackedPluginCache","curPlugin","curSource","transformReducer","watchFiles","warnedTransformDependencies","setAssetSourceErr","pluginDriver","pluginContext","cacheKey","emitAsset","emittedFile","emitFile","emitChunk","addWatchFile","setAssetSource","getCombinedSourcemap","combinedMap","normalizeRelativeExternalId","getIdMatcher","ids","getHasModuleSideEffects","moduleSideEffectsOption","pureExternalModules","_id","isPureExternalModule","ModuleLoader","modulesById","getManualChunk","indexedEntryModules","latestLoadModulesPromise","manualChunkModules","nextEntryModuleIndex","loadEntryModule","hookFirst","resolveIdResult","fetchModule","isExternal","hasModuleSideEffects","addEntryModules","unresolvedEntryModules","isUserDefined","firstEntryModuleIndex","loadNewEntryModulesPromise","moduleIndex","existingIndexModule","indexedModule","indexA","indexB","awaitLoadModulesPromise","newEntryModules","manualChunkModulesByAlias","addManualChunks","manualChunks","unresolvedManualChunks","manualChunkIds","loadNewManualChunkModulesPromise","addModuleToManualChunk","normalizeResolveIdResult","loadNewModulesPromise","getCombinedPromise","startingPromise","fetchAllDependencies","fetchResolvedDependency","handleResolveId","resolvedId","existingModule","sourceDescription","cachedModule","cachedModules","exportAllModule","externalModule","BuildPhase","CHAR_CODE_A","CHAR_CODE_0","intToHex","Uint8ArrayToHexString","randomUint8Array","Uint8ArrayXor","assignChunkColouringHashes","dependentEntryPointsByModule","dynamicImportersByModule","analyzeModuleGraph","dynamicDependentEntryPointsByDynamicEntry","getDynamicDependentEntryPoints","staticEntries","addColourToModuleDependencies","entry","colour","dynamicDependentEntryPoints","modulesToHandle","areEntryPointsContainedOrDynamicallyDependent","entryPoints","superSet","entriesToCheck","dependentEntry","entryHash","entriesToHandle","currentEntry","getDependentModules","moduleMap","dependentModules","dynamicEntry","importers","entries","entryPoint","createHash$1","generateAssetFileName","emittedName","assetFileNames","reserveFileNameInBundle","FILE_PLACEHOLDER","hasValidType","hasValidName","validatedName","getValidSource","fileReferenceId","isBuffer","getAssetFileName","getChunkFileName","FileEmitter","baseFileEmitter","assertAssetsFinalized","filesByReferenceId","requestedSource","consumedFile","finalizeAsset","setOutputBundle","outputBundle","assignReferenceId","idBase","emittedAsset","consumedAsset","emittedChunk","phase","LOAD_AND_PARSE","consumedChunk","moduleLoader","findExistingAssetFileNameWithSource","assetWithFileName","isAsset","outputFile","equals","getDeprecatedContextHandler","handlerName","newHandlerName","activeDeprecation","deprecationWarningShown","getPluginContexts","fileEmitter","watcher","existingPluginNames","pidx","cacheable","cacheInstance","GENERATE","getModuleInfo","foundModule","importedIds","isResolved","rollupVersion","moduleIds","contextParse","skipSelf","deprecatedWatchListener","event","on","addListener","PluginDriver","userPlugins","basePluginDriver","previousHooks","finaliseAssets","pluginContexts","createOutputPluginDriver","replaceContext","promise","runHook","runHookSync","hookParallel","promises","hookPromise","arg0","hookReduceArg0Sync","hookReduceValue","initialValue","hookSeq","hookSeqSync","pluginIndex","permitValues","hookContext","makeOnwarn","normalizeEntryModules","Graph","externalModules","onwarn","strictDeprecations","cacheExpiry","experimentalCacheExpiry","handleChange","once","removeListener","optionsModuleContext","acorn","acornPluginsToInject","allowAwaitOutsideFunction","acornInjectPlugins","build","inlineDynamicImports","ANALYSE","includeMarked","chunkModules","entryPointsHashStr","curChunk","entryHashSum","chunkModulesOrdered","getCache","allDeleted","treeshakingPass","cyclePath","cycle","warnForMissingExports","evalIfFn","strOrFn","concatSep","out","concatDblSep","createAddons","assignChunkIds","outputOptions","entryChunks","otherChunks","chunksForNaming","commondir","commonSegments","pathSegements","getExportMode","exportKeys","createGetOption","config","command","defaultValue","normalizeObjectOptionValue","getObjectOption","commandOption","configOption","ensureArray","items","defaultOnWarn","getOnWarn","defaultOnWarnHandler","getExternal","configExternal","rest","commandAliases","o","v","mergeOptions","rawCommandOptions","getCommandOptions","getInputOptions","normalizedOutputOptions","singleOutputOptions","getOutputOptions","unknownOptionErrors","validInputOptions","addUnknownOptionErrors","validOutputOptions","allKeys","validCliOutputOptions","optionError","errors","validOptions","optionType","ignoredKeys","validOptionSet","unknownOptions","globalDefinition","getOption","chunkGroupingSize","experimentalOptimizeChunks","checkOutputOptions","getAbsoluteEntryModulePaths","absoluteEntryModulePaths","throwAsyncGenerateError","applyOptionHook","normalizePlugins","rawPlugins","anonymousPrefix","getInputOptions$1","rawInputOptions","curWatcher","setWatcher","assignChunksToBundle","rollup","useCache","optimized","getOutputOptionsAndPluginDriver","rawOutputOptions","normalizeOutputOptions","generate","outputBundleWithPlaceholders","createOutput","defineProperty","write","chunkCount","writeOutputFile","SortingFileType","getSortingFileType","ASSET","ENTRY_CHUNK","SECONDARY_CHUNK","outputFileA","outputFileB","fileTypeA","fileTypeB","writeSourceMapPromise","hasMultipleChunks","mergedOptions","mergedOutputOptions","outputOptionsReducer","emitError","utils$1","exceedsLimit","limit","escapeNode","escaped","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","flatten","flat","arr","ele","invalidBlock","escapeInvalid","invalidNode","isNumber","toRegexRange","opts","relaxZeros","strictZeros","relax","capture","wrap","isPadded","hasPadding","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","countNines","stops","countZeros","compare","rangeToPattern","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","toQuantifier","padZeros","comparison","intersection","diff","clearCache","toRegexRange_1","isObject$1","transform$1","toNumber","isValidValue","isNumber$1","stringify$1","maxLength","dash","toMaxLen","negative","toSequence","toRange","isNumbers","toRegex","rangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","fillLetters","fillRange","compile","walk","isOpen","isClose","compile_1","queue","stash","enclose","expand","rangeLimit","q","expand_1","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","stack","brackets","depth","keepEscaping","keepQuotes","brace","siblings","before","parse_1","braces","nodupes","noempty","braces_1","WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","PLUS_LITERAL","QMARK_LITERAL","SLASH_LITERAL","ONE_CHAR","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","POSIX_CHARS","WINDOWS_CHARS","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","lower","punct","space","upper","xdigit","constants$1","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHAR","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_BACKWARD_SLASH","CHAR_GRAVE_ACCENT","SEP","extglobChars","globChars","win32","utils$2","platform","hasRegexChars","isRegexChar","escapeRegex","toPosixSlashes","removeBackslashes","supportsLookbehinds","segs","isWindows","windows","escapeLast","lastIdx","idx","CHAR_COMMA$1","CHAR_DOT$1","CHAR_LEFT_CURLY_BRACE$1","CHAR_LEFT_PARENTHESES$1","CHAR_LEFT_SQUARE_BRACKET$1","CHAR_RIGHT_CURLY_BRACE$1","CHAR_RIGHT_PARENTHESES$1","CHAR_RIGHT_SQUARE_BRACKET$1","isPathSeparator","scan","isGlob","backslashes","negated","braceEscaped","eos","isExtglobChar","orig","glob","MAX_LENGTH$1","POSIX_REGEX_SOURCE$1","expandRange","negate","peek","syntaxError","parse$1","bos","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","nodot","bash","qmarkNoDot","noext","noextglob","consumed","backtrack","parens","quotes","extglobs","token","increment","decrement","isBrace","isExtglob","inner","extglobOpen","conditions","extglob","extglobClose","extglobStar","negatedExtglob","fastpaths","esc","slashes","posix","pre","strictBrackets","nobracket","prevValue","literalBrackets","nobrace","dots","nonegate","regex","noglobstar","prior","isStart","afterStar","after","strictSlashes","suffix","slashDot","parse_1$1","picomatch","returnState","fns","isMatch","makeRe","isIgnored","ignoreOpts","onMatch","onResult","matcher","returnObject","onIgnore","matchBase","patterns","returnOutput","flags","nocase","debug","picomatch_1","picomatch$1","isEmptyString","micromatch","omit","keep","matched","matches","failglob","nonull","nullglob","any","not","matchKeys","braceExpand","micromatch_1","ensureArray$1","getMatcherString","resolutionBase","createFilter","getMatcher","includeMatchers","excludeMatchers","getModule","rootPath","rootName","_nodeModulePaths","requireRelative","requested","relativeTo","require","_resolveFilename","requireRelative_1","chokidar","chokidar$1","encoding","persistent","watchers","addTask","task","chokidarOptions","chokidarOptionsHash","isTransformDependency","group","FileWatcher","fsWatcher","deleteTask","tasks","transformDependencyTasks","modifiedTime","mtime","handleWatchEvent","trigger","deleted","invalidate","DELAY","Watcher","configs","buildTimeout","invalidatedIds","rerun","emitter","setMaxListeners","Task","running","nextTick","run","removeAllListeners","emit","clear","taskPromise","invalidated","watched","outputs","outputFiles","watchOptions","useChokidar","disableGlobbing","ignoreInitial","updateWatchedFiles","duration","watchFile","previouslyWatched","VERSION"],"mappings":"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","sourcesContent":["/*\n  @license\n\tRollup.js v1.32.1\n\tFri, 06 Mar 2020 09:32:39 GMT - commit f458cbf6cb8cfcc1678593d8dc595e4b8757eb6d\n\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport util from 'util';\nimport path, { relative as relative$1, extname, basename, dirname, resolve, sep } from 'path';\nimport { readFile as readFile$1, writeFile as writeFile$1, readdirSync, mkdirSync, lstatSync, realpathSync, statSync, watch as watch$1 } from 'fs';\nimport * as acorn__default from 'acorn';\nimport { Parser } from 'acorn';\nimport { createHash as createHash$2 } from 'crypto';\nimport { EventEmitter } from 'events';\nimport module from 'module';\n\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n\nvar version = \"1.32.1\";\n\nvar charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nvar BitSet = function BitSet(arg) {\n    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\nBitSet.prototype.add = function add(n) {\n    this.bits[n >> 5] |= 1 << (n & 31);\n};\nBitSet.prototype.has = function has(n) {\n    return !!(this.bits[n >> 5] & (1 << (n & 31)));\n};\nvar Chunk = function Chunk(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = '';\n    this.outro = '';\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    // we make these non-enumerable, for sanity while debugging\n    Object.defineProperties(this, {\n        previous: { writable: true, value: null },\n        next: { writable: true, value: null }\n    });\n};\nChunk.prototype.appendLeft = function appendLeft(content) {\n    this.outro += content;\n};\nChunk.prototype.appendRight = function appendRight(content) {\n    this.intro = this.intro + content;\n};\nChunk.prototype.clone = function clone() {\n    var chunk = new Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n};\nChunk.prototype.contains = function contains(index) {\n    return this.start < index && index < this.end;\n};\nChunk.prototype.eachNext = function eachNext(fn) {\n    var chunk = this;\n    while (chunk) {\n        fn(chunk);\n        chunk = chunk.next;\n    }\n};\nChunk.prototype.eachPrevious = function eachPrevious(fn) {\n    var chunk = this;\n    while (chunk) {\n        fn(chunk);\n        chunk = chunk.previous;\n    }\n};\nChunk.prototype.edit = function edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n        this.intro = '';\n        this.outro = '';\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n};\nChunk.prototype.prependLeft = function prependLeft(content) {\n    this.outro = content + this.outro;\n};\nChunk.prototype.prependRight = function prependRight(content) {\n    this.intro = content + this.intro;\n};\nChunk.prototype.split = function split(index) {\n    var sliceIndex = index - this.start;\n    var originalBefore = this.original.slice(0, sliceIndex);\n    var originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    var newChunk = new Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = '';\n    this.end = index;\n    if (this.edited) {\n        // TODO is this block necessary?...\n        newChunk.edit('', false);\n        this.content = '';\n    }\n    else {\n        this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) {\n        newChunk.next.previous = newChunk;\n    }\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n};\nChunk.prototype.toString = function toString() {\n    return this.intro + this.content + this.outro;\n};\nChunk.prototype.trimEnd = function trimEnd(rx) {\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) {\n        return true;\n    }\n    var trimmed = this.content.replace(rx, '');\n    if (trimmed.length) {\n        if (trimmed !== this.content) {\n            this.split(this.start + trimmed.length).edit('', undefined, true);\n        }\n        return true;\n    }\n    else {\n        this.edit('', undefined, true);\n        this.intro = this.intro.replace(rx, '');\n        if (this.intro.length) {\n            return true;\n        }\n    }\n};\nChunk.prototype.trimStart = function trimStart(rx) {\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) {\n        return true;\n    }\n    var trimmed = this.content.replace(rx, '');\n    if (trimmed.length) {\n        if (trimmed !== this.content) {\n            this.split(this.end - trimmed.length);\n            this.edit('', undefined, true);\n        }\n        return true;\n    }\n    else {\n        this.edit('', undefined, true);\n        this.outro = this.outro.replace(rx, '');\n        if (this.outro.length) {\n            return true;\n        }\n    }\n};\nvar btoa = function () {\n    throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n    btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };\n}\nelse if (typeof Buffer === 'function') {\n    btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };\n}\nvar SourceMap = function SourceMap(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = encode(properties.mappings);\n};\nSourceMap.prototype.toString = function toString() {\n    return JSON.stringify(this);\n};\nSourceMap.prototype.toUrl = function toUrl() {\n    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\nfunction guessIndent(code) {\n    var lines = code.split('\\n');\n    var tabbed = lines.filter(function (line) { return /^\\t+/.test(line); });\n    var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });\n    if (tabbed.length === 0 && spaced.length === 0) {\n        return null;\n    }\n    // More lines tabbed than spaced? Assume tabs, and\n    // default to tabs in the case of a tie (or nothing\n    // to go on)\n    if (tabbed.length >= spaced.length) {\n        return '\\t';\n    }\n    // Otherwise, we need to guess the multiple\n    var min = spaced.reduce(function (previous, current) {\n        var numSpaces = /^ +/.exec(current)[0].length;\n        return Math.min(numSpaces, previous);\n    }, Infinity);\n    return new Array(min + 1).join(' ');\n}\nfunction getRelativePath(from, to) {\n    var fromParts = from.split(/[/\\\\]/);\n    var toParts = to.split(/[/\\\\]/);\n    fromParts.pop(); // get dirname\n    while (fromParts[0] === toParts[0]) {\n        fromParts.shift();\n        toParts.shift();\n    }\n    if (fromParts.length) {\n        var i = fromParts.length;\n        while (i--) {\n            fromParts[i] = '..';\n        }\n    }\n    return fromParts.concat(toParts).join('/');\n}\nvar toString = Object.prototype.toString;\nfunction isObject(thing) {\n    return toString.call(thing) === '[object Object]';\n}\nfunction getLocator(source) {\n    var originalLines = source.split('\\n');\n    var lineOffsets = [];\n    for (var i = 0, pos = 0; i < originalLines.length; i++) {\n        lineOffsets.push(pos);\n        pos += originalLines[i].length + 1;\n    }\n    return function locate(index) {\n        var i = 0;\n        var j = lineOffsets.length;\n        while (i < j) {\n            var m = (i + j) >> 1;\n            if (index < lineOffsets[m]) {\n                j = m;\n            }\n            else {\n                i = m + 1;\n            }\n        }\n        var line = i - 1;\n        var column = index - lineOffsets[line];\n        return { line: line, column: column };\n    };\n}\nvar Mappings = function Mappings(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n};\nMappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n        if (nameIndex >= 0) {\n            segment.push(nameIndex);\n        }\n        this.rawSegments.push(segment);\n    }\n    else if (this.pending) {\n        this.rawSegments.push(this.pending);\n    }\n    this.advance(content);\n    this.pending = null;\n};\nMappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    var originalCharIndex = chunk.start;\n    var first = true;\n    while (originalCharIndex < chunk.end) {\n        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n            this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n        }\n        if (original[originalCharIndex] === '\\n') {\n            loc.line += 1;\n            loc.column = 0;\n            this.generatedCodeLine += 1;\n            this.raw[this.generatedCodeLine] = this.rawSegments = [];\n            this.generatedCodeColumn = 0;\n            first = true;\n        }\n        else {\n            loc.column += 1;\n            this.generatedCodeColumn += 1;\n            first = false;\n        }\n        originalCharIndex += 1;\n    }\n    this.pending = sourceIndex > 0\n        ? [this.generatedCodeColumn, sourceIndex, loc.line, loc.column]\n        : null;\n};\nMappings.prototype.advance = function advance(str) {\n    if (!str) {\n        return;\n    }\n    var lines = str.split('\\n');\n    if (lines.length > 1) {\n        for (var i = 0; i < lines.length - 1; i++) {\n            this.generatedCodeLine++;\n            this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        }\n        this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n};\nvar n = '\\n';\nvar warned = {\n    insertLeft: false,\n    insertRight: false,\n    storeName: false\n};\nvar MagicString = function MagicString(string, options) {\n    if (options === void 0)\n        options = {};\n    var chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n        original: { writable: true, value: string },\n        outro: { writable: true, value: '' },\n        intro: { writable: true, value: '' },\n        firstChunk: { writable: true, value: chunk },\n        lastChunk: { writable: true, value: chunk },\n        lastSearchedChunk: { writable: true, value: chunk },\n        byStart: { writable: true, value: {} },\n        byEnd: { writable: true, value: {} },\n        filename: { writable: true, value: options.filename },\n        indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n        sourcemapLocations: { writable: true, value: new BitSet() },\n        storedNames: { writable: true, value: {} },\n        indentStr: { writable: true, value: guessIndent(string) }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n};\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n};\nMagicString.prototype.append = function append(content) {\n    if (typeof content !== 'string') {\n        throw new TypeError('outro content must be a string');\n    }\n    this.outro += content;\n    return this;\n};\nMagicString.prototype.appendLeft = function appendLeft(index, content) {\n    if (typeof content !== 'string') {\n        throw new TypeError('inserted content must be a string');\n    }\n    this._split(index);\n    var chunk = this.byEnd[index];\n    if (chunk) {\n        chunk.appendLeft(content);\n    }\n    else {\n        this.intro += content;\n    }\n    return this;\n};\nMagicString.prototype.appendRight = function appendRight(index, content) {\n    if (typeof content !== 'string') {\n        throw new TypeError('inserted content must be a string');\n    }\n    this._split(index);\n    var chunk = this.byStart[index];\n    if (chunk) {\n        chunk.appendRight(content);\n    }\n    else {\n        this.outro += content;\n    }\n    return this;\n};\nMagicString.prototype.clone = function clone() {\n    var cloned = new MagicString(this.original, { filename: this.filename });\n    var originalChunk = this.firstChunk;\n    var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n    while (originalChunk) {\n        cloned.byStart[clonedChunk.start] = clonedChunk;\n        cloned.byEnd[clonedChunk.end] = clonedChunk;\n        var nextOriginalChunk = originalChunk.next;\n        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n        if (nextClonedChunk) {\n            clonedChunk.next = nextClonedChunk;\n            nextClonedChunk.previous = clonedChunk;\n            clonedChunk = nextClonedChunk;\n        }\n        originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n};\nMagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n    var this$1 = this;\n    options = options || {};\n    var sourceIndex = 0;\n    var names = Object.keys(this.storedNames);\n    var mappings = new Mappings(options.hires);\n    var locate = getLocator(this.original);\n    if (this.intro) {\n        mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext(function (chunk) {\n        var loc = locate(chunk.start);\n        if (chunk.intro.length) {\n            mappings.advance(chunk.intro);\n        }\n        if (chunk.edited) {\n            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n        }\n        else {\n            mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);\n        }\n        if (chunk.outro.length) {\n            mappings.advance(chunk.outro);\n        }\n    });\n    return {\n        file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n        sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n        sourcesContent: options.includeContent ? [this.original] : [null],\n        names: names,\n        mappings: mappings.raw\n    };\n};\nMagicString.prototype.generateMap = function generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n};\nMagicString.prototype.getIndentString = function getIndentString() {\n    return this.indentStr === null ? '\\t' : this.indentStr;\n};\nMagicString.prototype.indent = function indent(indentStr, options) {\n    var pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n        options = indentStr;\n        indentStr = undefined;\n    }\n    indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n    if (indentStr === '') {\n        return this;\n    } // noop\n    options = options || {};\n    // Process exclusion ranges\n    var isExcluded = {};\n    if (options.exclude) {\n        var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n        exclusions.forEach(function (exclusion) {\n            for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n                isExcluded[i] = true;\n            }\n        });\n    }\n    var shouldIndentNextCharacter = options.indentStart !== false;\n    var replacer = function (match) {\n        if (shouldIndentNextCharacter) {\n            return (\"\" + indentStr + match);\n        }\n        shouldIndentNextCharacter = true;\n        return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    var charIndex = 0;\n    var chunk = this.firstChunk;\n    while (chunk) {\n        var end = chunk.end;\n        if (chunk.edited) {\n            if (!isExcluded[charIndex]) {\n                chunk.content = chunk.content.replace(pattern, replacer);\n                if (chunk.content.length) {\n                    shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n                }\n            }\n        }\n        else {\n            charIndex = chunk.start;\n            while (charIndex < end) {\n                if (!isExcluded[charIndex]) {\n                    var char = this.original[charIndex];\n                    if (char === '\\n') {\n                        shouldIndentNextCharacter = true;\n                    }\n                    else if (char !== '\\r' && shouldIndentNextCharacter) {\n                        shouldIndentNextCharacter = false;\n                        if (charIndex === chunk.start) {\n                            chunk.prependRight(indentStr);\n                        }\n                        else {\n                            this._splitChunk(chunk, charIndex);\n                            chunk = chunk.next;\n                            chunk.prependRight(indentStr);\n                        }\n                    }\n                }\n                charIndex += 1;\n            }\n        }\n        charIndex = chunk.end;\n        chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n};\nMagicString.prototype.insert = function insert() {\n    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\nMagicString.prototype.insertLeft = function insertLeft(index, content) {\n    if (!warned.insertLeft) {\n        console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n        warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n};\nMagicString.prototype.insertRight = function insertRight(index, content) {\n    if (!warned.insertRight) {\n        console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n        warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n};\nMagicString.prototype.move = function move(start, end, index) {\n    if (index >= start && index <= end) {\n        throw new Error('Cannot move a selection inside itself');\n    }\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    var first = this.byStart[start];\n    var last = this.byEnd[end];\n    var oldLeft = first.previous;\n    var oldRight = last.next;\n    var newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) {\n        return this;\n    }\n    var newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) {\n        oldLeft.next = oldRight;\n    }\n    if (oldRight) {\n        oldRight.previous = oldLeft;\n    }\n    if (newLeft) {\n        newLeft.next = first;\n    }\n    if (newRight) {\n        newRight.previous = last;\n    }\n    if (!first.previous) {\n        this.firstChunk = last.next;\n    }\n    if (!last.next) {\n        this.lastChunk = first.previous;\n        this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) {\n        this.firstChunk = first;\n    }\n    if (!newRight) {\n        this.lastChunk = last;\n    }\n    return this;\n};\nMagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n    if (typeof content !== 'string') {\n        throw new TypeError('replacement content must be a string');\n    }\n    while (start < 0) {\n        start += this.original.length;\n    }\n    while (end < 0) {\n        end += this.original.length;\n    }\n    if (end > this.original.length) {\n        throw new Error('end is out of bounds');\n    }\n    if (start === end) {\n        throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n    }\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n        if (!warned.storeName) {\n            console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n            warned.storeName = true;\n        }\n        options = { storeName: true };\n    }\n    var storeName = options !== undefined ? options.storeName : false;\n    var contentOnly = options !== undefined ? options.contentOnly : false;\n    if (storeName) {\n        var original = this.original.slice(start, end);\n        this.storedNames[original] = true;\n    }\n    var first = this.byStart[start];\n    var last = this.byEnd[end];\n    if (first) {\n        if (end > first.end && first.next !== this.byStart[first.end]) {\n            throw new Error('Cannot overwrite across a split point');\n        }\n        first.edit(content, storeName, contentOnly);\n        if (first !== last) {\n            var chunk = first.next;\n            while (chunk !== last) {\n                chunk.edit('', false);\n                chunk = chunk.next;\n            }\n            chunk.edit('', false);\n        }\n    }\n    else {\n        // must be inserting at the end\n        var newChunk = new Chunk(start, end, '').edit(content, storeName);\n        // TODO last chunk in the array may not be the last chunk, if it's moved...\n        last.next = newChunk;\n        newChunk.previous = last;\n    }\n    return this;\n};\nMagicString.prototype.prepend = function prepend(content) {\n    if (typeof content !== 'string') {\n        throw new TypeError('outro content must be a string');\n    }\n    this.intro = content + this.intro;\n    return this;\n};\nMagicString.prototype.prependLeft = function prependLeft(index, content) {\n    if (typeof content !== 'string') {\n        throw new TypeError('inserted content must be a string');\n    }\n    this._split(index);\n    var chunk = this.byEnd[index];\n    if (chunk) {\n        chunk.prependLeft(content);\n    }\n    else {\n        this.intro = content + this.intro;\n    }\n    return this;\n};\nMagicString.prototype.prependRight = function prependRight(index, content) {\n    if (typeof content !== 'string') {\n        throw new TypeError('inserted content must be a string');\n    }\n    this._split(index);\n    var chunk = this.byStart[index];\n    if (chunk) {\n        chunk.prependRight(content);\n    }\n    else {\n        this.outro = content + this.outro;\n    }\n    return this;\n};\nMagicString.prototype.remove = function remove(start, end) {\n    while (start < 0) {\n        start += this.original.length;\n    }\n    while (end < 0) {\n        end += this.original.length;\n    }\n    if (start === end) {\n        return this;\n    }\n    if (start < 0 || end > this.original.length) {\n        throw new Error('Character is out of bounds');\n    }\n    if (start > end) {\n        throw new Error('end must be greater than start');\n    }\n    this._split(start);\n    this._split(end);\n    var chunk = this.byStart[start];\n    while (chunk) {\n        chunk.intro = '';\n        chunk.outro = '';\n        chunk.edit('');\n        chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n};\nMagicString.prototype.lastChar = function lastChar() {\n    if (this.outro.length) {\n        return this.outro[this.outro.length - 1];\n    }\n    var chunk = this.lastChunk;\n    do {\n        if (chunk.outro.length) {\n            return chunk.outro[chunk.outro.length - 1];\n        }\n        if (chunk.content.length) {\n            return chunk.content[chunk.content.length - 1];\n        }\n        if (chunk.intro.length) {\n            return chunk.intro[chunk.intro.length - 1];\n        }\n    } while (chunk = chunk.previous);\n    if (this.intro.length) {\n        return this.intro[this.intro.length - 1];\n    }\n    return '';\n};\nMagicString.prototype.lastLine = function lastLine() {\n    var lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) {\n        return this.outro.substr(lineIndex + 1);\n    }\n    var lineStr = this.outro;\n    var chunk = this.lastChunk;\n    do {\n        if (chunk.outro.length > 0) {\n            lineIndex = chunk.outro.lastIndexOf(n);\n            if (lineIndex !== -1) {\n                return chunk.outro.substr(lineIndex + 1) + lineStr;\n            }\n            lineStr = chunk.outro + lineStr;\n        }\n        if (chunk.content.length > 0) {\n            lineIndex = chunk.content.lastIndexOf(n);\n            if (lineIndex !== -1) {\n                return chunk.content.substr(lineIndex + 1) + lineStr;\n            }\n            lineStr = chunk.content + lineStr;\n        }\n        if (chunk.intro.length > 0) {\n            lineIndex = chunk.intro.lastIndexOf(n);\n            if (lineIndex !== -1) {\n                return chunk.intro.substr(lineIndex + 1) + lineStr;\n            }\n            lineStr = chunk.intro + lineStr;\n        }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) {\n        return this.intro.substr(lineIndex + 1) + lineStr;\n    }\n    return this.intro + lineStr;\n};\nMagicString.prototype.slice = function slice(start, end) {\n    if (start === void 0)\n        start = 0;\n    if (end === void 0)\n        end = this.original.length;\n    while (start < 0) {\n        start += this.original.length;\n    }\n    while (end < 0) {\n        end += this.original.length;\n    }\n    var result = '';\n    // find start chunk\n    var chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n        // found end chunk before start\n        if (chunk.start < end && chunk.end >= end) {\n            return result;\n        }\n        chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start) {\n        throw new Error((\"Cannot use replaced character \" + start + \" as slice start anchor.\"));\n    }\n    var startChunk = chunk;\n    while (chunk) {\n        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n            result += chunk.intro;\n        }\n        var containsEnd = chunk.start < end && chunk.end >= end;\n        if (containsEnd && chunk.edited && chunk.end !== end) {\n            throw new Error((\"Cannot use replaced character \" + end + \" as slice end anchor.\"));\n        }\n        var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n        result += chunk.content.slice(sliceStart, sliceEnd);\n        if (chunk.outro && (!containsEnd || chunk.end === end)) {\n            result += chunk.outro;\n        }\n        if (containsEnd) {\n            break;\n        }\n        chunk = chunk.next;\n    }\n    return result;\n};\n// TODO deprecate this? not really very useful\nMagicString.prototype.snip = function snip(start, end) {\n    var clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n};\nMagicString.prototype._split = function _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) {\n        return;\n    }\n    var chunk = this.lastSearchedChunk;\n    var searchForward = index > chunk.end;\n    while (chunk) {\n        if (chunk.contains(index)) {\n            return this._splitChunk(chunk, index);\n        }\n        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n};\nMagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n        // zero-length edited chunks are a special case (overlapping replacements)\n        var loc = getLocator(this.original)(index);\n        throw new Error((\"Cannot split a chunk that has already been edited (\" + (loc.line) + \":\" + (loc.column) + \" – \\\"\" + (chunk.original) + \"\\\")\"));\n    }\n    var newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) {\n        this.lastChunk = newChunk;\n    }\n    this.lastSearchedChunk = chunk;\n    return true;\n};\nMagicString.prototype.toString = function toString() {\n    var str = this.intro;\n    var chunk = this.firstChunk;\n    while (chunk) {\n        str += chunk.toString();\n        chunk = chunk.next;\n    }\n    return str + this.outro;\n};\nMagicString.prototype.isEmpty = function isEmpty() {\n    var chunk = this.firstChunk;\n    do {\n        if (chunk.intro.length && chunk.intro.trim() ||\n            chunk.content.length && chunk.content.trim() ||\n            chunk.outro.length && chunk.outro.trim()) {\n            return false;\n        }\n    } while (chunk = chunk.next);\n    return true;\n};\nMagicString.prototype.length = function length() {\n    var chunk = this.firstChunk;\n    var length = 0;\n    do {\n        length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n};\nMagicString.prototype.trimLines = function trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n};\nMagicString.prototype.trim = function trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n};\nMagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n    var rx = new RegExp((charType || '\\\\s') + '+$');\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) {\n        return true;\n    }\n    var chunk = this.lastChunk;\n    do {\n        var end = chunk.end;\n        var aborted = chunk.trimEnd(rx);\n        // if chunk was trimmed, we have a new lastChunk\n        if (chunk.end !== end) {\n            if (this.lastChunk === chunk) {\n                this.lastChunk = chunk.next;\n            }\n            this.byEnd[chunk.end] = chunk;\n            this.byStart[chunk.next.start] = chunk.next;\n            this.byEnd[chunk.next.end] = chunk.next;\n        }\n        if (aborted) {\n            return true;\n        }\n        chunk = chunk.previous;\n    } while (chunk);\n    return false;\n};\nMagicString.prototype.trimEnd = function trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n};\nMagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n    var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) {\n        return true;\n    }\n    var chunk = this.firstChunk;\n    do {\n        var end = chunk.end;\n        var aborted = chunk.trimStart(rx);\n        if (chunk.end !== end) {\n            // special case...\n            if (chunk === this.lastChunk) {\n                this.lastChunk = chunk.next;\n            }\n            this.byEnd[chunk.end] = chunk;\n            this.byStart[chunk.next.start] = chunk.next;\n            this.byEnd[chunk.next.end] = chunk.next;\n        }\n        if (aborted) {\n            return true;\n        }\n        chunk = chunk.next;\n    } while (chunk);\n    return false;\n};\nMagicString.prototype.trimStart = function trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n};\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar Bundle = function Bundle(options) {\n    if (options === void 0)\n        options = {};\n    this.intro = options.intro || '';\n    this.separator = options.separator !== undefined ? options.separator : '\\n';\n    this.sources = [];\n    this.uniqueSources = [];\n    this.uniqueSourceIndexByFilename = {};\n};\nBundle.prototype.addSource = function addSource(source) {\n    if (source instanceof MagicString) {\n        return this.addSource({\n            content: source,\n            filename: source.filename,\n            separator: this.separator\n        });\n    }\n    if (!isObject(source) || !source.content) {\n        throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n    }\n    ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n        if (!hasOwnProp.call(source, option)) {\n            source[option] = source.content[option];\n        }\n    });\n    if (source.separator === undefined) {\n        // TODO there's a bunch of this sort of thing, needs cleaning up\n        source.separator = this.separator;\n    }\n    if (source.filename) {\n        if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n            this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n            this.uniqueSources.push({ filename: source.filename, content: source.content.original });\n        }\n        else {\n            var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n            if (source.content.original !== uniqueSource.content) {\n                throw new Error((\"Illegal source: same filename (\" + (source.filename) + \"), different contents\"));\n            }\n        }\n    }\n    this.sources.push(source);\n    return this;\n};\nBundle.prototype.append = function append(str, options) {\n    this.addSource({\n        content: new MagicString(str),\n        separator: (options && options.separator) || ''\n    });\n    return this;\n};\nBundle.prototype.clone = function clone() {\n    var bundle = new Bundle({\n        intro: this.intro,\n        separator: this.separator\n    });\n    this.sources.forEach(function (source) {\n        bundle.addSource({\n            filename: source.filename,\n            content: source.content.clone(),\n            separator: source.separator\n        });\n    });\n    return bundle;\n};\nBundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n    var this$1 = this;\n    if (options === void 0)\n        options = {};\n    var names = [];\n    this.sources.forEach(function (source) {\n        Object.keys(source.content.storedNames).forEach(function (name) {\n            if (!~names.indexOf(name)) {\n                names.push(name);\n            }\n        });\n    });\n    var mappings = new Mappings(options.hires);\n    if (this.intro) {\n        mappings.advance(this.intro);\n    }\n    this.sources.forEach(function (source, i) {\n        if (i > 0) {\n            mappings.advance(this$1.separator);\n        }\n        var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;\n        var magicString = source.content;\n        var locate = getLocator(magicString.original);\n        if (magicString.intro) {\n            mappings.advance(magicString.intro);\n        }\n        magicString.firstChunk.eachNext(function (chunk) {\n            var loc = locate(chunk.start);\n            if (chunk.intro.length) {\n                mappings.advance(chunk.intro);\n            }\n            if (source.filename) {\n                if (chunk.edited) {\n                    mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n                }\n                else {\n                    mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n                }\n            }\n            else {\n                mappings.advance(chunk.content);\n            }\n            if (chunk.outro.length) {\n                mappings.advance(chunk.outro);\n            }\n        });\n        if (magicString.outro) {\n            mappings.advance(magicString.outro);\n        }\n    });\n    return {\n        file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n        sources: this.uniqueSources.map(function (source) {\n            return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n        }),\n        sourcesContent: this.uniqueSources.map(function (source) {\n            return options.includeContent ? source.content : null;\n        }),\n        names: names,\n        mappings: mappings.raw\n    };\n};\nBundle.prototype.generateMap = function generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n};\nBundle.prototype.getIndentString = function getIndentString() {\n    var indentStringCounts = {};\n    this.sources.forEach(function (source) {\n        var indentStr = source.content.indentStr;\n        if (indentStr === null) {\n            return;\n        }\n        if (!indentStringCounts[indentStr]) {\n            indentStringCounts[indentStr] = 0;\n        }\n        indentStringCounts[indentStr] += 1;\n    });\n    return (Object.keys(indentStringCounts).sort(function (a, b) {\n        return indentStringCounts[a] - indentStringCounts[b];\n    })[0] || '\\t');\n};\nBundle.prototype.indent = function indent(indentStr) {\n    var this$1 = this;\n    if (!arguments.length) {\n        indentStr = this.getIndentString();\n    }\n    if (indentStr === '') {\n        return this;\n    } // noop\n    var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n    this.sources.forEach(function (source, i) {\n        var separator = source.separator !== undefined ? source.separator : this$1.separator;\n        var indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n        source.content.indent(indentStr, {\n            exclude: source.indentExclusionRanges,\n            indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n        });\n        trailingNewline = source.content.lastChar() === '\\n';\n    });\n    if (this.intro) {\n        this.intro =\n            indentStr +\n                this.intro.replace(/^[^\\n]/gm, function (match, index) {\n                    return index > 0 ? indentStr + match : match;\n                });\n    }\n    return this;\n};\nBundle.prototype.prepend = function prepend(str) {\n    this.intro = str + this.intro;\n    return this;\n};\nBundle.prototype.toString = function toString() {\n    var this$1 = this;\n    var body = this.sources\n        .map(function (source, i) {\n        var separator = source.separator !== undefined ? source.separator : this$1.separator;\n        var str = (i > 0 ? separator : '') + source.content.toString();\n        return str;\n    })\n        .join('');\n    return this.intro + body;\n};\nBundle.prototype.isEmpty = function isEmpty() {\n    if (this.intro.length && this.intro.trim()) {\n        return false;\n    }\n    if (this.sources.some(function (source) { return !source.content.isEmpty(); })) {\n        return false;\n    }\n    return true;\n};\nBundle.prototype.length = function length() {\n    return this.sources.reduce(function (length, source) { return length + source.content.length(); }, this.intro.length);\n};\nBundle.prototype.trimLines = function trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n};\nBundle.prototype.trim = function trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n};\nBundle.prototype.trimStart = function trimStart(charType) {\n    var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (!this.intro) {\n        var source;\n        var i = 0;\n        do {\n            source = this.sources[i++];\n            if (!source) {\n                break;\n            }\n        } while (!source.content.trimStartAborted(charType));\n    }\n    return this;\n};\nBundle.prototype.trimEnd = function trimEnd(charType) {\n    var rx = new RegExp((charType || '\\\\s') + '+$');\n    var source;\n    var i = this.sources.length - 1;\n    do {\n        source = this.sources[i--];\n        if (!source) {\n            this.intro = this.intro.replace(rx, '');\n            break;\n        }\n    } while (!source.content.trimEndAborted(charType));\n    return this;\n};\n\nvar minimalisticAssert = assert;\nfunction assert(val, msg) {\n    if (!val)\n        throw new Error(msg || 'Assertion failed');\n}\nassert.equal = function assertEqual(l, r, msg) {\n    if (l != r)\n        throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar inherits_browser = createCommonjsModule(function (module) {\n    if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n            ctor.super_ = superCtor;\n            ctor.prototype = Object.create(superCtor.prototype, {\n                constructor: {\n                    value: ctor,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true\n                }\n            });\n        };\n    }\n    else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n            ctor.super_ = superCtor;\n            var TempCtor = function () { };\n            TempCtor.prototype = superCtor.prototype;\n            ctor.prototype = new TempCtor();\n            ctor.prototype.constructor = ctor;\n        };\n    }\n});\n\nvar inherits = createCommonjsModule(function (module) {\n    try {\n        var util$1 = util;\n        if (typeof util$1.inherits !== 'function')\n            throw '';\n        module.exports = util$1.inherits;\n    }\n    catch (e) {\n        module.exports = inherits_browser;\n    }\n});\n\nvar inherits_1 = inherits;\nfunction isSurrogatePair(msg, i) {\n    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n        return false;\n    }\n    if (i < 0 || i + 1 >= msg.length) {\n        return false;\n    }\n    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n}\nfunction toArray(msg, enc) {\n    if (Array.isArray(msg))\n        return msg.slice();\n    if (!msg)\n        return [];\n    var res = [];\n    if (typeof msg === 'string') {\n        if (!enc) {\n            // Inspired by stringToUtf8ByteArray() in closure-library by Google\n            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n            // Apache License 2.0\n            // https://github.com/google/closure-library/blob/master/LICENSE\n            var p = 0;\n            for (var i = 0; i < msg.length; i++) {\n                var c = msg.charCodeAt(i);\n                if (c < 128) {\n                    res[p++] = c;\n                }\n                else if (c < 2048) {\n                    res[p++] = (c >> 6) | 192;\n                    res[p++] = (c & 63) | 128;\n                }\n                else if (isSurrogatePair(msg, i)) {\n                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n                    res[p++] = (c >> 18) | 240;\n                    res[p++] = ((c >> 12) & 63) | 128;\n                    res[p++] = ((c >> 6) & 63) | 128;\n                    res[p++] = (c & 63) | 128;\n                }\n                else {\n                    res[p++] = (c >> 12) | 224;\n                    res[p++] = ((c >> 6) & 63) | 128;\n                    res[p++] = (c & 63) | 128;\n                }\n            }\n        }\n        else if (enc === 'hex') {\n            msg = msg.replace(/[^a-z0-9]+/ig, '');\n            if (msg.length % 2 !== 0)\n                msg = '0' + msg;\n            for (i = 0; i < msg.length; i += 2)\n                res.push(parseInt(msg[i] + msg[i + 1], 16));\n        }\n    }\n    else {\n        for (i = 0; i < msg.length; i++)\n            res[i] = msg[i] | 0;\n    }\n    return res;\n}\nvar toArray_1 = toArray;\nfunction toHex(msg) {\n    var res = '';\n    for (var i = 0; i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n    return res;\n}\nvar toHex_1 = toHex;\nfunction htonl(w) {\n    var res = (w >>> 24) |\n        ((w >>> 8) & 0xff00) |\n        ((w << 8) & 0xff0000) |\n        ((w & 0xff) << 24);\n    return res >>> 0;\n}\nvar htonl_1 = htonl;\nfunction toHex32(msg, endian) {\n    var res = '';\n    for (var i = 0; i < msg.length; i++) {\n        var w = msg[i];\n        if (endian === 'little')\n            w = htonl(w);\n        res += zero8(w.toString(16));\n    }\n    return res;\n}\nvar toHex32_1 = toHex32;\nfunction zero2(word) {\n    if (word.length === 1)\n        return '0' + word;\n    else\n        return word;\n}\nvar zero2_1 = zero2;\nfunction zero8(word) {\n    if (word.length === 7)\n        return '0' + word;\n    else if (word.length === 6)\n        return '00' + word;\n    else if (word.length === 5)\n        return '000' + word;\n    else if (word.length === 4)\n        return '0000' + word;\n    else if (word.length === 3)\n        return '00000' + word;\n    else if (word.length === 2)\n        return '000000' + word;\n    else if (word.length === 1)\n        return '0000000' + word;\n    else\n        return word;\n}\nvar zero8_1 = zero8;\nfunction join32(msg, start, end, endian) {\n    var len = end - start;\n    minimalisticAssert(len % 4 === 0);\n    var res = new Array(len / 4);\n    for (var i = 0, k = start; i < res.length; i++, k += 4) {\n        var w;\n        if (endian === 'big')\n            w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n        else\n            w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n        res[i] = w >>> 0;\n    }\n    return res;\n}\nvar join32_1 = join32;\nfunction split32(msg, endian) {\n    var res = new Array(msg.length * 4);\n    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n        var m = msg[i];\n        if (endian === 'big') {\n            res[k] = m >>> 24;\n            res[k + 1] = (m >>> 16) & 0xff;\n            res[k + 2] = (m >>> 8) & 0xff;\n            res[k + 3] = m & 0xff;\n        }\n        else {\n            res[k + 3] = m >>> 24;\n            res[k + 2] = (m >>> 16) & 0xff;\n            res[k + 1] = (m >>> 8) & 0xff;\n            res[k] = m & 0xff;\n        }\n    }\n    return res;\n}\nvar split32_1 = split32;\nfunction rotr32(w, b) {\n    return (w >>> b) | (w << (32 - b));\n}\nvar rotr32_1 = rotr32;\nfunction rotl32(w, b) {\n    return (w << b) | (w >>> (32 - b));\n}\nvar rotl32_1 = rotl32;\nfunction sum32(a, b) {\n    return (a + b) >>> 0;\n}\nvar sum32_1 = sum32;\nfunction sum32_3(a, b, c) {\n    return (a + b + c) >>> 0;\n}\nvar sum32_3_1 = sum32_3;\nfunction sum32_4(a, b, c, d) {\n    return (a + b + c + d) >>> 0;\n}\nvar sum32_4_1 = sum32_4;\nfunction sum32_5(a, b, c, d, e) {\n    return (a + b + c + d + e) >>> 0;\n}\nvar sum32_5_1 = sum32_5;\nfunction sum64(buf, pos, ah, al) {\n    var bh = buf[pos];\n    var bl = buf[pos + 1];\n    var lo = (al + bl) >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    buf[pos] = hi >>> 0;\n    buf[pos + 1] = lo;\n}\nvar sum64_1 = sum64;\nfunction sum64_hi(ah, al, bh, bl) {\n    var lo = (al + bl) >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    return hi >>> 0;\n}\nvar sum64_hi_1 = sum64_hi;\nfunction sum64_lo(ah, al, bh, bl) {\n    var lo = al + bl;\n    return lo >>> 0;\n}\nvar sum64_lo_1 = sum64_lo;\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n    var carry = 0;\n    var lo = al;\n    lo = (lo + bl) >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = (lo + cl) >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = (lo + dl) >>> 0;\n    carry += lo < dl ? 1 : 0;\n    var hi = ah + bh + ch + dh + carry;\n    return hi >>> 0;\n}\nvar sum64_4_hi_1 = sum64_4_hi;\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n    var lo = al + bl + cl + dl;\n    return lo >>> 0;\n}\nvar sum64_4_lo_1 = sum64_4_lo;\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var carry = 0;\n    var lo = al;\n    lo = (lo + bl) >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = (lo + cl) >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = (lo + dl) >>> 0;\n    carry += lo < dl ? 1 : 0;\n    lo = (lo + el) >>> 0;\n    carry += lo < el ? 1 : 0;\n    var hi = ah + bh + ch + dh + eh + carry;\n    return hi >>> 0;\n}\nvar sum64_5_hi_1 = sum64_5_hi;\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var lo = al + bl + cl + dl + el;\n    return lo >>> 0;\n}\nvar sum64_5_lo_1 = sum64_5_lo;\nfunction rotr64_hi(ah, al, num) {\n    var r = (al << (32 - num)) | (ah >>> num);\n    return r >>> 0;\n}\nvar rotr64_hi_1 = rotr64_hi;\nfunction rotr64_lo(ah, al, num) {\n    var r = (ah << (32 - num)) | (al >>> num);\n    return r >>> 0;\n}\nvar rotr64_lo_1 = rotr64_lo;\nfunction shr64_hi(ah, al, num) {\n    return ah >>> num;\n}\nvar shr64_hi_1 = shr64_hi;\nfunction shr64_lo(ah, al, num) {\n    var r = (ah << (32 - num)) | (al >>> num);\n    return r >>> 0;\n}\nvar shr64_lo_1 = shr64_lo;\nvar utils = {\n    inherits: inherits_1,\n    toArray: toArray_1,\n    toHex: toHex_1,\n    htonl: htonl_1,\n    toHex32: toHex32_1,\n    zero2: zero2_1,\n    zero8: zero8_1,\n    join32: join32_1,\n    split32: split32_1,\n    rotr32: rotr32_1,\n    rotl32: rotl32_1,\n    sum32: sum32_1,\n    sum32_3: sum32_3_1,\n    sum32_4: sum32_4_1,\n    sum32_5: sum32_5_1,\n    sum64: sum64_1,\n    sum64_hi: sum64_hi_1,\n    sum64_lo: sum64_lo_1,\n    sum64_4_hi: sum64_4_hi_1,\n    sum64_4_lo: sum64_4_lo_1,\n    sum64_5_hi: sum64_5_hi_1,\n    sum64_5_lo: sum64_5_lo_1,\n    rotr64_hi: rotr64_hi_1,\n    rotr64_lo: rotr64_lo_1,\n    shr64_hi: shr64_hi_1,\n    shr64_lo: shr64_lo_1\n};\n\nfunction BlockHash() {\n    this.pending = null;\n    this.pendingTotal = 0;\n    this.blockSize = this.constructor.blockSize;\n    this.outSize = this.constructor.outSize;\n    this.hmacStrength = this.constructor.hmacStrength;\n    this.padLength = this.constructor.padLength / 8;\n    this.endian = 'big';\n    this._delta8 = this.blockSize / 8;\n    this._delta32 = this.blockSize / 32;\n}\nvar BlockHash_1 = BlockHash;\nBlockHash.prototype.update = function update(msg, enc) {\n    // Convert message to array, pad it, and join into 32bit blocks\n    msg = utils.toArray(msg, enc);\n    if (!this.pending)\n        this.pending = msg;\n    else\n        this.pending = this.pending.concat(msg);\n    this.pendingTotal += msg.length;\n    // Enough data, try updating\n    if (this.pending.length >= this._delta8) {\n        msg = this.pending;\n        // Process pending data in blocks\n        var r = msg.length % this._delta8;\n        this.pending = msg.slice(msg.length - r, msg.length);\n        if (this.pending.length === 0)\n            this.pending = null;\n        msg = utils.join32(msg, 0, msg.length - r, this.endian);\n        for (var i = 0; i < msg.length; i += this._delta32)\n            this._update(msg, i, i + this._delta32);\n    }\n    return this;\n};\nBlockHash.prototype.digest = function digest(enc) {\n    this.update(this._pad());\n    minimalisticAssert(this.pending === null);\n    return this._digest(enc);\n};\nBlockHash.prototype._pad = function pad() {\n    var len = this.pendingTotal;\n    var bytes = this._delta8;\n    var k = bytes - ((len + this.padLength) % bytes);\n    var res = new Array(k + this.padLength);\n    res[0] = 0x80;\n    for (var i = 1; i < k; i++)\n        res[i] = 0;\n    // Append length\n    len <<= 3;\n    if (this.endian === 'big') {\n        for (var t = 8; t < this.padLength; t++)\n            res[i++] = 0;\n        res[i++] = 0;\n        res[i++] = 0;\n        res[i++] = 0;\n        res[i++] = 0;\n        res[i++] = (len >>> 24) & 0xff;\n        res[i++] = (len >>> 16) & 0xff;\n        res[i++] = (len >>> 8) & 0xff;\n        res[i++] = len & 0xff;\n    }\n    else {\n        res[i++] = len & 0xff;\n        res[i++] = (len >>> 8) & 0xff;\n        res[i++] = (len >>> 16) & 0xff;\n        res[i++] = (len >>> 24) & 0xff;\n        res[i++] = 0;\n        res[i++] = 0;\n        res[i++] = 0;\n        res[i++] = 0;\n        for (t = 8; t < this.padLength; t++)\n            res[i++] = 0;\n    }\n    return res;\n};\nvar common = {\n    BlockHash: BlockHash_1\n};\n\nvar rotr32$1 = utils.rotr32;\nfunction ft_1(s, x, y, z) {\n    if (s === 0)\n        return ch32(x, y, z);\n    if (s === 1 || s === 3)\n        return p32(x, y, z);\n    if (s === 2)\n        return maj32(x, y, z);\n}\nvar ft_1_1 = ft_1;\nfunction ch32(x, y, z) {\n    return (x & y) ^ ((~x) & z);\n}\nvar ch32_1 = ch32;\nfunction maj32(x, y, z) {\n    return (x & y) ^ (x & z) ^ (y & z);\n}\nvar maj32_1 = maj32;\nfunction p32(x, y, z) {\n    return x ^ y ^ z;\n}\nvar p32_1 = p32;\nfunction s0_256(x) {\n    return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n}\nvar s0_256_1 = s0_256;\nfunction s1_256(x) {\n    return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n}\nvar s1_256_1 = s1_256;\nfunction g0_256(x) {\n    return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);\n}\nvar g0_256_1 = g0_256;\nfunction g1_256(x) {\n    return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);\n}\nvar g1_256_1 = g1_256;\nvar common$1 = {\n    ft_1: ft_1_1,\n    ch32: ch32_1,\n    maj32: maj32_1,\n    p32: p32_1,\n    s0_256: s0_256_1,\n    s1_256: s1_256_1,\n    g0_256: g0_256_1,\n    g1_256: g1_256_1\n};\n\nvar sum32$1 = utils.sum32;\nvar sum32_4$1 = utils.sum32_4;\nvar sum32_5$1 = utils.sum32_5;\nvar ch32$1 = common$1.ch32;\nvar maj32$1 = common$1.maj32;\nvar s0_256$1 = common$1.s0_256;\nvar s1_256$1 = common$1.s1_256;\nvar g0_256$1 = common$1.g0_256;\nvar g1_256$1 = common$1.g1_256;\nvar BlockHash$1 = common.BlockHash;\nvar sha256_K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\nfunction SHA256() {\n    if (!(this instanceof SHA256))\n        return new SHA256();\n    BlockHash$1.call(this);\n    this.h = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    ];\n    this.k = sha256_K;\n    this.W = new Array(64);\n}\nutils.inherits(SHA256, BlockHash$1);\nvar _256 = SHA256;\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\nSHA256.prototype._update = function _update(msg, start) {\n    var W = this.W;\n    for (var i = 0; i < 16; i++)\n        W[i] = msg[start + i];\n    for (; i < W.length; i++)\n        W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n    var f = this.h[5];\n    var g = this.h[6];\n    var h = this.h[7];\n    minimalisticAssert(this.k.length === W.length);\n    for (i = 0; i < W.length; i++) {\n        var T1 = sum32_5$1(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n        var T2 = sum32$1(s0_256$1(a), maj32$1(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = sum32$1(d, T1);\n        d = c;\n        c = b;\n        b = a;\n        a = sum32$1(T1, T2);\n    }\n    this.h[0] = sum32$1(this.h[0], a);\n    this.h[1] = sum32$1(this.h[1], b);\n    this.h[2] = sum32$1(this.h[2], c);\n    this.h[3] = sum32$1(this.h[3], d);\n    this.h[4] = sum32$1(this.h[4], e);\n    this.h[5] = sum32$1(this.h[5], f);\n    this.h[6] = sum32$1(this.h[6], g);\n    this.h[7] = sum32$1(this.h[7], h);\n};\nSHA256.prototype._digest = function digest(enc) {\n    if (enc === 'hex')\n        return utils.toHex32(this.h, 'big');\n    else\n        return utils.split32(this.h, 'big');\n};\n\nconst createHash = () => _256();\n\nfunction relative(from, to) {\n    const fromParts = from.split(/[/\\\\]/).filter(Boolean);\n    const toParts = to.split(/[/\\\\]/).filter(Boolean);\n    if (fromParts[0] === '.')\n        fromParts.shift();\n    if (toParts[0] === '.')\n        toParts.shift();\n    while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n        fromParts.shift();\n        toParts.shift();\n    }\n    while (toParts[0] === '..' && fromParts.length > 0) {\n        toParts.shift();\n        fromParts.pop();\n    }\n    while (fromParts.pop()) {\n        toParts.unshift('..');\n    }\n    return toParts.join('/');\n}\n\nconst UnknownKey = Symbol('Unknown Key');\nconst EMPTY_PATH = [];\nconst UNKNOWN_PATH = [UnknownKey];\nconst EntitiesKey = Symbol('Entities');\nclass PathTracker {\n    constructor() {\n        this.entityPaths = Object.create(null, { [EntitiesKey]: { value: new Set() } });\n    }\n    getEntities(path) {\n        let currentPaths = this.entityPaths;\n        for (const pathSegment of path) {\n            currentPaths = currentPaths[pathSegment] =\n                currentPaths[pathSegment] ||\n                    Object.create(null, { [EntitiesKey]: { value: new Set() } });\n        }\n        return currentPaths[EntitiesKey];\n    }\n}\nconst SHARED_RECURSION_TRACKER = new PathTracker();\n\nconst BROKEN_FLOW_NONE = 0;\nconst BROKEN_FLOW_BREAK_CONTINUE = 1;\nconst BROKEN_FLOW_ERROR_RETURN_LABEL = 2;\nfunction createInclusionContext() {\n    return {\n        brokenFlow: BROKEN_FLOW_NONE,\n        includedLabels: new Set()\n    };\n}\nfunction createHasEffectsContext() {\n    return {\n        accessed: new PathTracker(),\n        assigned: new PathTracker(),\n        brokenFlow: BROKEN_FLOW_NONE,\n        called: new PathTracker(),\n        ignore: {\n            breaks: false,\n            continues: false,\n            labels: new Set(),\n            returnAwaitYield: false\n        },\n        includedLabels: new Set(),\n        instantiated: new PathTracker(),\n        replacedVariableInits: new Map()\n    };\n}\n\nconst BlockStatement = 'BlockStatement';\nconst CallExpression = 'CallExpression';\nconst ExportNamespaceSpecifier = 'ExportNamespaceSpecifier';\nconst ExpressionStatement = 'ExpressionStatement';\nconst FunctionExpression = 'FunctionExpression';\nconst Identifier = 'Identifier';\nconst ImportDefaultSpecifier = 'ImportDefaultSpecifier';\nconst ImportNamespaceSpecifier = 'ImportNamespaceSpecifier';\nconst Program = 'Program';\nconst Property = 'Property';\nconst ReturnStatement = 'ReturnStatement';\n\nfunction treeshakeNode(node, code, start, end) {\n    code.remove(start, end);\n    if (node.annotations) {\n        for (const annotation of node.annotations) {\n            if (annotation.start < start) {\n                code.remove(annotation.start, annotation.end);\n            }\n            else {\n                return;\n            }\n        }\n    }\n}\nfunction removeAnnotations(node, code) {\n    if (!node.annotations && node.parent.type === ExpressionStatement) {\n        node = node.parent;\n    }\n    if (node.annotations) {\n        for (const annotation of node.annotations) {\n            code.remove(annotation.start, annotation.end);\n        }\n    }\n}\n\nconst NO_SEMICOLON = { isNoStatement: true };\n// This assumes there are only white-space and comments between start and the string we are looking for\nfunction findFirstOccurrenceOutsideComment(code, searchString, start = 0) {\n    let searchPos, charCodeAfterSlash;\n    searchPos = code.indexOf(searchString, start);\n    while (true) {\n        start = code.indexOf('/', start);\n        if (start === -1 || start >= searchPos)\n            return searchPos;\n        charCodeAfterSlash = code.charCodeAt(++start);\n        ++start;\n        // With our assumption, '/' always starts a comment. Determine comment type:\n        start =\n            charCodeAfterSlash === 47 /*\"/\"*/\n                ? code.indexOf('\\n', start) + 1\n                : code.indexOf('*/', start) + 2;\n        if (start > searchPos) {\n            searchPos = code.indexOf(searchString, start);\n        }\n    }\n}\n// This assumes \"code\" only contains white-space and comments\nfunction findFirstLineBreakOutsideComment(code) {\n    let lineBreakPos, charCodeAfterSlash, start = 0;\n    lineBreakPos = code.indexOf('\\n', start);\n    while (true) {\n        start = code.indexOf('/', start);\n        if (start === -1 || start > lineBreakPos)\n            return lineBreakPos;\n        // With our assumption, '/' always starts a comment. Determine comment type:\n        charCodeAfterSlash = code.charCodeAt(++start);\n        if (charCodeAfterSlash === 47 /*\"/\"*/)\n            return lineBreakPos;\n        start = code.indexOf('*/', start + 2) + 2;\n        if (start > lineBreakPos) {\n            lineBreakPos = code.indexOf('\\n', start);\n        }\n    }\n}\nfunction renderStatementList(statements, code, start, end, options) {\n    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;\n    let nextNode = statements[0];\n    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;\n    if (nextNodeNeedsBoundaries) {\n        nextNodeStart =\n            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start)) + 1;\n    }\n    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {\n        currentNode = nextNode;\n        currentNodeStart = nextNodeStart;\n        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;\n        nextNode = statements[nextIndex];\n        nextNodeNeedsBoundaries =\n            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;\n        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {\n            nextNodeStart =\n                currentNode.end +\n                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start)) +\n                    1;\n            if (currentNode.included) {\n                currentNodeNeedsBoundaries\n                    ? currentNode.render(code, options, {\n                        end: nextNodeStart,\n                        start: currentNodeStart\n                    })\n                    : currentNode.render(code, options);\n            }\n            else {\n                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);\n            }\n        }\n        else {\n            currentNode.render(code, options);\n        }\n    }\n}\n// This assumes that the first character is not part of the first node\nfunction getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {\n    const splitUpNodes = [];\n    let node, nextNode, nextNodeStart, contentEnd, char;\n    let separator = start - 1;\n    for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {\n        nextNode = nodes[nextIndex];\n        if (node !== undefined) {\n            separator =\n                node.end +\n                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');\n        }\n        nextNodeStart = contentEnd =\n            separator +\n                2 +\n                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start));\n        while (((char = code.original.charCodeAt(nextNodeStart)),\n            char === 32 /*\" \"*/ || char === 9 /*\"\\t\"*/ || char === 10 /*\"\\n\"*/ || char === 13) /*\"\\r\"*/)\n            nextNodeStart++;\n        if (node !== undefined) {\n            splitUpNodes.push({\n                contentEnd,\n                end: nextNodeStart,\n                node,\n                separator,\n                start\n            });\n        }\n        node = nextNode;\n        start = nextNodeStart;\n    }\n    splitUpNodes.push({\n        contentEnd: end,\n        end,\n        node: node,\n        separator: null,\n        start\n    });\n    return splitUpNodes;\n}\n// This assumes there are only white-space and comments between start and end\nfunction removeLineBreaks(code, start, end) {\n    while (true) {\n        const lineBreakPos = findFirstLineBreakOutsideComment(code.original.slice(start, end));\n        if (lineBreakPos === -1) {\n            break;\n        }\n        start = start + lineBreakPos + 1;\n        code.remove(start - 1, start);\n    }\n}\n\nconst chars$1 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';\nconst base = 64;\nfunction toBase64(num) {\n    let outStr = '';\n    do {\n        const curDigit = num % base;\n        num = Math.floor(num / base);\n        outStr = chars$1[curDigit] + outStr;\n    } while (num !== 0);\n    return outStr;\n}\n\n// Verified on IE 6/7 that these keywords can't be used for object properties without escaping:\n//   break case catch class const continue debugger default delete do\n//   else enum export extends false finally for function if import\n//   in instanceof new null return super switch this throw true\n//   try typeof var void while with\nconst RESERVED_NAMES = Object.assign(Object.create(null), {\n    await: true,\n    break: true,\n    case: true,\n    catch: true,\n    class: true,\n    const: true,\n    continue: true,\n    debugger: true,\n    default: true,\n    delete: true,\n    do: true,\n    else: true,\n    enum: true,\n    eval: true,\n    export: true,\n    extends: true,\n    false: true,\n    finally: true,\n    for: true,\n    function: true,\n    if: true,\n    implements: true,\n    import: true,\n    in: true,\n    instanceof: true,\n    interface: true,\n    let: true,\n    new: true,\n    null: true,\n    package: true,\n    private: true,\n    protected: true,\n    public: true,\n    return: true,\n    static: true,\n    super: true,\n    switch: true,\n    this: true,\n    throw: true,\n    true: true,\n    try: true,\n    typeof: true,\n    undefined: true,\n    var: true,\n    void: true,\n    while: true,\n    with: true,\n    yield: true\n});\n\nfunction getSafeName(baseName, usedNames) {\n    let safeName = baseName;\n    let count = 1;\n    while (usedNames.has(safeName) || RESERVED_NAMES[safeName]) {\n        safeName = `${baseName}$${toBase64(count++)}`;\n    }\n    usedNames.add(safeName);\n    return safeName;\n}\n\nconst NO_ARGS = [];\n\nfunction assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {\n    return Object.create(inheritedDescriptions, memberDescriptions);\n}\nconst UnknownValue = Symbol('Unknown Value');\nconst UNKNOWN_EXPRESSION = {\n    deoptimizePath: () => { },\n    getLiteralValueAtPath: () => UnknownValue,\n    getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,\n    hasEffectsWhenAccessedAtPath: path => path.length > 0,\n    hasEffectsWhenAssignedAtPath: path => path.length > 0,\n    hasEffectsWhenCalledAtPath: () => true,\n    include: () => { },\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    },\n    included: true,\n    toString: () => '[[UNKNOWN]]'\n};\nconst UNDEFINED_EXPRESSION = {\n    deoptimizePath: () => { },\n    getLiteralValueAtPath: () => undefined,\n    getReturnExpressionWhenCalledAtPath: () => UNKNOWN_EXPRESSION,\n    hasEffectsWhenAccessedAtPath: path => path.length > 0,\n    hasEffectsWhenAssignedAtPath: path => path.length > 0,\n    hasEffectsWhenCalledAtPath: () => true,\n    include: () => { },\n    includeCallArguments() { },\n    included: true,\n    toString: () => 'undefined'\n};\nconst returnsUnknown = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_EXPRESSION\n    }\n};\nconst mutatesSelfReturnsUnknown = {\n    value: { returns: null, returnsPrimitive: UNKNOWN_EXPRESSION, callsArgs: null, mutatesSelf: true }\n};\nconst callsArgReturnsUnknown = {\n    value: { returns: null, returnsPrimitive: UNKNOWN_EXPRESSION, callsArgs: [0], mutatesSelf: false }\n};\nclass UnknownArrayExpression {\n    constructor() {\n        this.included = false;\n    }\n    deoptimizePath() { }\n    getLiteralValueAtPath() {\n        return UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);\n        }\n        return UNKNOWN_EXPRESSION;\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenAssignedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length === 1) {\n            return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, context);\n        }\n        return true;\n    }\n    include() {\n        this.included = true;\n    }\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    }\n    toString() {\n        return '[[UNKNOWN ARRAY]]';\n    }\n}\nconst returnsArray = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: false,\n        returns: UnknownArrayExpression,\n        returnsPrimitive: null\n    }\n};\nconst mutatesSelfReturnsArray = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: true,\n        returns: UnknownArrayExpression,\n        returnsPrimitive: null\n    }\n};\nconst callsArgReturnsArray = {\n    value: {\n        callsArgs: [0],\n        mutatesSelf: false,\n        returns: UnknownArrayExpression,\n        returnsPrimitive: null\n    }\n};\nconst callsArgMutatesSelfReturnsArray = {\n    value: {\n        callsArgs: [0],\n        mutatesSelf: true,\n        returns: UnknownArrayExpression,\n        returnsPrimitive: null\n    }\n};\nconst UNKNOWN_LITERAL_BOOLEAN = {\n    deoptimizePath: () => { },\n    getLiteralValueAtPath: () => UnknownValue,\n    getReturnExpressionWhenCalledAtPath: path => {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);\n        }\n        return UNKNOWN_EXPRESSION;\n    },\n    hasEffectsWhenAccessedAtPath: path => path.length > 1,\n    hasEffectsWhenAssignedAtPath: path => path.length > 0,\n    hasEffectsWhenCalledAtPath: path => {\n        if (path.length === 1) {\n            const subPath = path[0];\n            return typeof subPath !== 'string' || !literalBooleanMembers[subPath];\n        }\n        return true;\n    },\n    include: () => { },\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    },\n    included: true,\n    toString: () => '[[UNKNOWN BOOLEAN]]'\n};\nconst returnsBoolean = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN\n    }\n};\nconst callsArgReturnsBoolean = {\n    value: {\n        callsArgs: [0],\n        mutatesSelf: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN\n    }\n};\nconst UNKNOWN_LITERAL_NUMBER = {\n    deoptimizePath: () => { },\n    getLiteralValueAtPath: () => UnknownValue,\n    getReturnExpressionWhenCalledAtPath: path => {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);\n        }\n        return UNKNOWN_EXPRESSION;\n    },\n    hasEffectsWhenAccessedAtPath: path => path.length > 1,\n    hasEffectsWhenAssignedAtPath: path => path.length > 0,\n    hasEffectsWhenCalledAtPath: path => {\n        if (path.length === 1) {\n            const subPath = path[0];\n            return typeof subPath !== 'string' || !literalNumberMembers[subPath];\n        }\n        return true;\n    },\n    include: () => { },\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    },\n    included: true,\n    toString: () => '[[UNKNOWN NUMBER]]'\n};\nconst returnsNumber = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n    }\n};\nconst mutatesSelfReturnsNumber = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: true,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n    }\n};\nconst callsArgReturnsNumber = {\n    value: {\n        callsArgs: [0],\n        mutatesSelf: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n    }\n};\nconst UNKNOWN_LITERAL_STRING = {\n    deoptimizePath: () => { },\n    getLiteralValueAtPath: () => UnknownValue,\n    getReturnExpressionWhenCalledAtPath: path => {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);\n        }\n        return UNKNOWN_EXPRESSION;\n    },\n    hasEffectsWhenAccessedAtPath: path => path.length > 1,\n    hasEffectsWhenAssignedAtPath: path => path.length > 0,\n    hasEffectsWhenCalledAtPath: (path, callOptions, context) => {\n        if (path.length === 1) {\n            return hasMemberEffectWhenCalled(literalStringMembers, path[0], true, callOptions, context);\n        }\n        return true;\n    },\n    include: () => { },\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    },\n    included: true,\n    toString: () => '[[UNKNOWN STRING]]'\n};\nconst returnsString = {\n    value: {\n        callsArgs: null,\n        mutatesSelf: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_STRING\n    }\n};\nclass UnknownObjectExpression {\n    constructor() {\n        this.included = false;\n    }\n    deoptimizePath() { }\n    getLiteralValueAtPath() {\n        return UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(objectMembers, path[0]);\n        }\n        return UNKNOWN_EXPRESSION;\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenAssignedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length === 1) {\n            return hasMemberEffectWhenCalled(objectMembers, path[0], this.included, callOptions, context);\n        }\n        return true;\n    }\n    include() {\n        this.included = true;\n    }\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    }\n    toString() {\n        return '[[UNKNOWN OBJECT]]';\n    }\n}\nconst objectMembers = assembleMemberDescriptions({\n    hasOwnProperty: returnsBoolean,\n    isPrototypeOf: returnsBoolean,\n    propertyIsEnumerable: returnsBoolean,\n    toLocaleString: returnsString,\n    toString: returnsString,\n    valueOf: returnsUnknown\n});\nconst arrayMembers = assembleMemberDescriptions({\n    concat: returnsArray,\n    copyWithin: mutatesSelfReturnsArray,\n    every: callsArgReturnsBoolean,\n    fill: mutatesSelfReturnsArray,\n    filter: callsArgReturnsArray,\n    find: callsArgReturnsUnknown,\n    findIndex: callsArgReturnsNumber,\n    forEach: callsArgReturnsUnknown,\n    includes: returnsBoolean,\n    indexOf: returnsNumber,\n    join: returnsString,\n    lastIndexOf: returnsNumber,\n    map: callsArgReturnsArray,\n    pop: mutatesSelfReturnsUnknown,\n    push: mutatesSelfReturnsNumber,\n    reduce: callsArgReturnsUnknown,\n    reduceRight: callsArgReturnsUnknown,\n    reverse: mutatesSelfReturnsArray,\n    shift: mutatesSelfReturnsUnknown,\n    slice: returnsArray,\n    some: callsArgReturnsBoolean,\n    sort: callsArgMutatesSelfReturnsArray,\n    splice: mutatesSelfReturnsArray,\n    unshift: mutatesSelfReturnsNumber\n}, objectMembers);\nconst literalBooleanMembers = assembleMemberDescriptions({\n    valueOf: returnsBoolean\n}, objectMembers);\nconst literalNumberMembers = assembleMemberDescriptions({\n    toExponential: returnsString,\n    toFixed: returnsString,\n    toLocaleString: returnsString,\n    toPrecision: returnsString,\n    valueOf: returnsNumber\n}, objectMembers);\nconst literalStringMembers = assembleMemberDescriptions({\n    charAt: returnsString,\n    charCodeAt: returnsNumber,\n    codePointAt: returnsNumber,\n    concat: returnsString,\n    endsWith: returnsBoolean,\n    includes: returnsBoolean,\n    indexOf: returnsNumber,\n    lastIndexOf: returnsNumber,\n    localeCompare: returnsNumber,\n    match: returnsBoolean,\n    normalize: returnsString,\n    padEnd: returnsString,\n    padStart: returnsString,\n    repeat: returnsString,\n    replace: {\n        value: {\n            callsArgs: [1],\n            mutatesSelf: false,\n            returns: null,\n            returnsPrimitive: UNKNOWN_LITERAL_STRING\n        }\n    },\n    search: returnsNumber,\n    slice: returnsString,\n    split: returnsArray,\n    startsWith: returnsBoolean,\n    substr: returnsString,\n    substring: returnsString,\n    toLocaleLowerCase: returnsString,\n    toLocaleUpperCase: returnsString,\n    toLowerCase: returnsString,\n    toUpperCase: returnsString,\n    trim: returnsString,\n    valueOf: returnsString\n}, objectMembers);\nfunction getLiteralMembersForValue(value) {\n    switch (typeof value) {\n        case 'boolean':\n            return literalBooleanMembers;\n        case 'number':\n            return literalNumberMembers;\n        case 'string':\n            return literalStringMembers;\n        default:\n            return Object.create(null);\n    }\n}\nfunction hasMemberEffectWhenCalled(members, memberName, parentIncluded, callOptions, context) {\n    if (typeof memberName !== 'string' ||\n        !members[memberName] ||\n        (members[memberName].mutatesSelf && parentIncluded))\n        return true;\n    if (!members[memberName].callsArgs)\n        return false;\n    for (const argIndex of members[memberName].callsArgs) {\n        if (callOptions.args[argIndex] &&\n            callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, {\n                args: NO_ARGS,\n                withNew: false\n            }, context))\n            return true;\n    }\n    return false;\n}\nfunction getMemberReturnExpressionWhenCalled(members, memberName) {\n    if (typeof memberName !== 'string' || !members[memberName])\n        return UNKNOWN_EXPRESSION;\n    return members[memberName].returnsPrimitive !== null\n        ? members[memberName].returnsPrimitive\n        : new members[memberName].returns();\n}\n\nclass Variable {\n    constructor(name) {\n        this.alwaysRendered = false;\n        this.exportName = null;\n        this.included = false;\n        this.isId = false;\n        this.isReassigned = false;\n        this.renderBaseName = null;\n        this.renderName = null;\n        this.safeExportName = null;\n        this.name = name;\n    }\n    /**\n     * Binds identifiers that reference this variable to this variable.\n     * Necessary to be able to change variable names.\n     */\n    addReference(_identifier) { }\n    deoptimizePath(_path) { }\n    getBaseVariableName() {\n        return this.renderBaseName || this.renderName || this.name;\n    }\n    getLiteralValueAtPath(_path, _recursionTracker, _origin) {\n        return UnknownValue;\n    }\n    getName() {\n        const name = this.renderName || this.name;\n        return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;\n    }\n    getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {\n        return UNKNOWN_EXPRESSION;\n    }\n    hasEffectsWhenAccessedAtPath(path, _context) {\n        return path.length > 0;\n    }\n    hasEffectsWhenAssignedAtPath(_path, _context) {\n        return true;\n    }\n    hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {\n        return true;\n    }\n    /**\n     * Marks this variable as being part of the bundle, which is usually the case when one of\n     * its identifiers becomes part of the bundle. Returns true if it has not been included\n     * previously.\n     * Once a variable is included, it should take care all its declarations are included.\n     */\n    include(_context) {\n        this.included = true;\n    }\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    }\n    markCalledFromTryStatement() { }\n    setRenderNames(baseName, name) {\n        this.renderBaseName = baseName;\n        this.renderName = name;\n    }\n    setSafeName(name) {\n        this.renderName = name;\n    }\n    toString() {\n        return this.name;\n    }\n}\nconst getPropertyAccess = (name) => {\n    return /^(?!\\d)[\\w$]+$/.test(name) ? `.${name}` : `[${JSON.stringify(name)}]`;\n};\n\nclass ExternalVariable extends Variable {\n    constructor(module, name) {\n        super(name);\n        this.module = module;\n        this.isNamespace = name === '*';\n        this.referenced = false;\n    }\n    addReference(identifier) {\n        this.referenced = true;\n        if (this.name === 'default' || this.name === '*') {\n            this.module.suggestName(identifier.name);\n        }\n    }\n    include() {\n        if (!this.included) {\n            this.included = true;\n            this.module.used = true;\n        }\n    }\n}\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');\nconst builtins = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');\nconst blacklisted = new Set(reservedWords.concat(builtins));\nconst illegalCharacters = /[^$_a-zA-Z0-9]/g;\nconst startsWithDigit = (str) => /\\d/.test(str[0]);\nfunction isLegal(str) {\n    if (startsWithDigit(str) || blacklisted.has(str)) {\n        return false;\n    }\n    return !illegalCharacters.test(str);\n}\nfunction makeLegal(str) {\n    str = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, '_');\n    if (startsWithDigit(str) || blacklisted.has(str))\n        str = `_${str}`;\n    return str || '_';\n}\n\nconst absolutePath = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst relativePath = /^\\.?\\.\\//;\nfunction isAbsolute(path) {\n    return absolutePath.test(path);\n}\nfunction isRelative(path) {\n    return relativePath.test(path);\n}\nfunction normalize(path) {\n    if (path.indexOf('\\\\') == -1)\n        return path;\n    return path.replace(/\\\\/g, '/');\n}\n\nclass ExternalModule {\n    constructor(graph, id, moduleSideEffects) {\n        this.exportsNames = false;\n        this.exportsNamespace = false;\n        this.mostCommonSuggestion = 0;\n        this.reexported = false;\n        this.renderPath = undefined;\n        this.renormalizeRenderPath = false;\n        this.used = false;\n        this.graph = graph;\n        this.id = id;\n        this.execIndex = Infinity;\n        this.moduleSideEffects = moduleSideEffects;\n        const parts = id.split(/[\\\\/]/);\n        this.variableName = makeLegal(parts.pop());\n        this.nameSuggestions = Object.create(null);\n        this.declarations = Object.create(null);\n        this.exportedVariables = new Map();\n    }\n    getVariableForExportName(name) {\n        if (name === '*') {\n            this.exportsNamespace = true;\n        }\n        else if (name !== 'default') {\n            this.exportsNames = true;\n        }\n        let declaration = this.declarations[name];\n        if (declaration)\n            return declaration;\n        this.declarations[name] = declaration = new ExternalVariable(this, name);\n        this.exportedVariables.set(declaration, name);\n        return declaration;\n    }\n    setRenderPath(options, inputBase) {\n        this.renderPath = '';\n        if (options.paths) {\n            this.renderPath =\n                typeof options.paths === 'function' ? options.paths(this.id) : options.paths[this.id];\n        }\n        if (!this.renderPath) {\n            if (!isAbsolute(this.id)) {\n                this.renderPath = this.id;\n            }\n            else {\n                this.renderPath = normalize(relative$1(inputBase, this.id));\n                this.renormalizeRenderPath = true;\n            }\n        }\n        return this.renderPath;\n    }\n    suggestName(name) {\n        if (!this.nameSuggestions[name])\n            this.nameSuggestions[name] = 0;\n        this.nameSuggestions[name] += 1;\n        if (this.nameSuggestions[name] > this.mostCommonSuggestion) {\n            this.mostCommonSuggestion = this.nameSuggestions[name];\n            this.variableName = name;\n        }\n    }\n    warnUnusedImports() {\n        const unused = Object.keys(this.declarations).filter(name => {\n            if (name === '*')\n                return false;\n            const declaration = this.declarations[name];\n            return !declaration.included && !this.reexported && !declaration.referenced;\n        });\n        if (unused.length === 0)\n            return;\n        const names = unused.length === 1\n            ? `'${unused[0]}' is`\n            : `${unused\n                .slice(0, -1)\n                .map(name => `'${name}'`)\n                .join(', ')} and '${unused.slice(-1)}' are`;\n        this.graph.warn({\n            code: 'UNUSED_EXTERNAL_IMPORT',\n            message: `${names} imported from external module '${this.id}' but never used`,\n            names: unused,\n            source: this.id\n        });\n    }\n}\n\nfunction markModuleAndImpureDependenciesAsExecuted(baseModule) {\n    baseModule.isExecuted = true;\n    const modules = [baseModule];\n    const visitedModules = new Set();\n    for (const module of modules) {\n        for (const dependency of module.dependencies) {\n            if (!(dependency instanceof ExternalModule) &&\n                !dependency.isExecuted &&\n                dependency.moduleSideEffects &&\n                !visitedModules.has(dependency.id)) {\n                dependency.isExecuted = true;\n                visitedModules.add(dependency.id);\n                modules.push(dependency);\n            }\n        }\n    }\n}\n\n// To avoid infinite recursions\nconst MAX_PATH_DEPTH = 7;\nclass LocalVariable extends Variable {\n    constructor(name, declarator, init, context) {\n        super(name);\n        this.additionalInitializers = null;\n        this.calledFromTryStatement = false;\n        this.expressionsToBeDeoptimized = [];\n        this.declarations = declarator ? [declarator] : [];\n        this.init = init;\n        this.deoptimizationTracker = context.deoptimizationTracker;\n        this.module = context.module;\n    }\n    addDeclaration(identifier, init) {\n        this.declarations.push(identifier);\n        if (this.additionalInitializers === null) {\n            this.additionalInitializers = this.init === null ? [] : [this.init];\n            this.init = UNKNOWN_EXPRESSION;\n            this.isReassigned = true;\n        }\n        if (init !== null) {\n            this.additionalInitializers.push(init);\n        }\n    }\n    consolidateInitializers() {\n        if (this.additionalInitializers !== null) {\n            for (const initializer of this.additionalInitializers) {\n                initializer.deoptimizePath(UNKNOWN_PATH);\n            }\n            this.additionalInitializers = null;\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length > MAX_PATH_DEPTH || this.isReassigned)\n            return;\n        const trackedEntities = this.deoptimizationTracker.getEntities(path);\n        if (trackedEntities.has(this))\n            return;\n        trackedEntities.add(this);\n        if (path.length === 0) {\n            if (!this.isReassigned) {\n                this.isReassigned = true;\n                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n                this.expressionsToBeDeoptimized = [];\n                for (const expression of expressionsToBeDeoptimized) {\n                    expression.deoptimizeCache();\n                }\n                if (this.init) {\n                    this.init.deoptimizePath(UNKNOWN_PATH);\n                }\n            }\n        }\n        else if (this.init) {\n            this.init.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (this.isReassigned || !this.init || path.length > MAX_PATH_DEPTH) {\n            return UnknownValue;\n        }\n        const trackedEntities = recursionTracker.getEntities(path);\n        if (trackedEntities.has(this.init)) {\n            return UnknownValue;\n        }\n        this.expressionsToBeDeoptimized.push(origin);\n        trackedEntities.add(this.init);\n        const value = this.init.getLiteralValueAtPath(path, recursionTracker, origin);\n        trackedEntities.delete(this.init);\n        return value;\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        if (this.isReassigned || !this.init || path.length > MAX_PATH_DEPTH) {\n            return UNKNOWN_EXPRESSION;\n        }\n        const trackedEntities = recursionTracker.getEntities(path);\n        if (trackedEntities.has(this.init)) {\n            return UNKNOWN_EXPRESSION;\n        }\n        this.expressionsToBeDeoptimized.push(origin);\n        trackedEntities.add(this.init);\n        const value = this.init.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n        trackedEntities.delete(this.init);\n        return value;\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (path.length === 0)\n            return false;\n        if (this.isReassigned || path.length > MAX_PATH_DEPTH)\n            return true;\n        const trackedExpressions = context.accessed.getEntities(path);\n        if (trackedExpressions.has(this))\n            return false;\n        trackedExpressions.add(this);\n        return (this.init && this.init.hasEffectsWhenAccessedAtPath(path, context));\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (this.included || path.length > MAX_PATH_DEPTH)\n            return true;\n        if (path.length === 0)\n            return false;\n        if (this.isReassigned)\n            return true;\n        const trackedExpressions = context.assigned.getEntities(path);\n        if (trackedExpressions.has(this))\n            return false;\n        trackedExpressions.add(this);\n        return (this.init && this.init.hasEffectsWhenAssignedAtPath(path, context));\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length > MAX_PATH_DEPTH || this.isReassigned)\n            return true;\n        const trackedExpressions = (callOptions.withNew\n            ? context.instantiated\n            : context.called).getEntities(path);\n        if (trackedExpressions.has(this))\n            return false;\n        trackedExpressions.add(this);\n        return (this.init && this.init.hasEffectsWhenCalledAtPath(path, callOptions, context));\n    }\n    include(context) {\n        if (!this.included) {\n            this.included = true;\n            if (!this.module.isExecuted) {\n                markModuleAndImpureDependenciesAsExecuted(this.module);\n            }\n            for (const declaration of this.declarations) {\n                // If node is a default export, it can save a tree-shaking run to include the full declaration now\n                if (!declaration.included)\n                    declaration.include(context, false);\n                let node = declaration.parent;\n                while (!node.included) {\n                    // We do not want to properly include parents in case they are part of a dead branch\n                    // in which case .include() might pull in more dead code\n                    node.included = true;\n                    if (node.type === Program)\n                        break;\n                    node = node.parent;\n                }\n            }\n        }\n    }\n    includeCallArguments(context, args) {\n        if (this.isReassigned) {\n            for (const arg of args) {\n                arg.include(context, false);\n            }\n        }\n        else if (this.init) {\n            this.init.includeCallArguments(context, args);\n        }\n    }\n    markCalledFromTryStatement() {\n        this.calledFromTryStatement = true;\n    }\n}\n\nclass Scope {\n    constructor() {\n        this.children = [];\n        this.variables = new Map();\n    }\n    addDeclaration(identifier, context, init = null, _isHoisted) {\n        const name = identifier.name;\n        let variable = this.variables.get(name);\n        if (variable) {\n            variable.addDeclaration(identifier, init);\n        }\n        else {\n            variable = new LocalVariable(identifier.name, identifier, init || UNDEFINED_EXPRESSION, context);\n            this.variables.set(name, variable);\n        }\n        return variable;\n    }\n    contains(name) {\n        return this.variables.has(name);\n    }\n    findVariable(_name) {\n        throw new Error('Internal Error: findVariable needs to be implemented by a subclass');\n    }\n}\n\nclass ChildScope extends Scope {\n    constructor(parent) {\n        super();\n        this.accessedOutsideVariables = new Map();\n        this.parent = parent;\n        parent.children.push(this);\n    }\n    addAccessedDynamicImport(importExpression) {\n        (this.accessedDynamicImports || (this.accessedDynamicImports = new Set())).add(importExpression);\n        if (this.parent instanceof ChildScope) {\n            this.parent.addAccessedDynamicImport(importExpression);\n        }\n    }\n    addAccessedGlobalsByFormat(globalsByFormat) {\n        const accessedGlobalVariablesByFormat = this.accessedGlobalVariablesByFormat || (this.accessedGlobalVariablesByFormat = new Map());\n        for (const format of Object.keys(globalsByFormat)) {\n            let accessedGlobalVariables = accessedGlobalVariablesByFormat.get(format);\n            if (!accessedGlobalVariables) {\n                accessedGlobalVariables = new Set();\n                accessedGlobalVariablesByFormat.set(format, accessedGlobalVariables);\n            }\n            for (const name of globalsByFormat[format]) {\n                accessedGlobalVariables.add(name);\n            }\n        }\n        if (this.parent instanceof ChildScope) {\n            this.parent.addAccessedGlobalsByFormat(globalsByFormat);\n        }\n    }\n    addNamespaceMemberAccess(name, variable) {\n        this.accessedOutsideVariables.set(name, variable);\n        this.parent.addNamespaceMemberAccess(name, variable);\n    }\n    addReturnExpression(expression) {\n        this.parent instanceof ChildScope && this.parent.addReturnExpression(expression);\n    }\n    addUsedOutsideNames(usedNames, format) {\n        for (const variable of this.accessedOutsideVariables.values()) {\n            if (variable.included) {\n                usedNames.add(variable.getBaseVariableName());\n                if (variable.exportName && format === 'system') {\n                    usedNames.add('exports');\n                }\n            }\n        }\n        const accessedGlobalVariables = this.accessedGlobalVariablesByFormat && this.accessedGlobalVariablesByFormat.get(format);\n        if (accessedGlobalVariables) {\n            for (const name of accessedGlobalVariables) {\n                usedNames.add(name);\n            }\n        }\n    }\n    contains(name) {\n        return this.variables.has(name) || this.parent.contains(name);\n    }\n    deconflict(format) {\n        const usedNames = new Set();\n        this.addUsedOutsideNames(usedNames, format);\n        if (this.accessedDynamicImports) {\n            for (const importExpression of this.accessedDynamicImports) {\n                if (importExpression.inlineNamespace) {\n                    usedNames.add(importExpression.inlineNamespace.getBaseVariableName());\n                }\n            }\n        }\n        for (const [name, variable] of this.variables) {\n            if (variable.included || variable.alwaysRendered) {\n                variable.setSafeName(getSafeName(name, usedNames));\n            }\n        }\n        for (const scope of this.children) {\n            scope.deconflict(format);\n        }\n    }\n    findLexicalBoundary() {\n        return this.parent.findLexicalBoundary();\n    }\n    findVariable(name) {\n        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);\n        if (knownVariable) {\n            return knownVariable;\n        }\n        const variable = this.parent.findVariable(name);\n        this.accessedOutsideVariables.set(name, variable);\n        return variable;\n    }\n}\n\nfunction getLocator$1(source, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator$1(source, options)(search, options && options.startIndex);\n}\n\nconst keys = {\n    Literal: [],\n    Program: ['body']\n};\nfunction getAndCreateKeys(esTreeNode) {\n    keys[esTreeNode.type] = Object.keys(esTreeNode).filter(key => typeof esTreeNode[key] === 'object');\n    return keys[esTreeNode.type];\n}\n\nconst INCLUDE_PARAMETERS = 'variables';\nclass NodeBase {\n    constructor(esTreeNode, parent, parentScope) {\n        this.included = false;\n        this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);\n        this.parent = parent;\n        this.context = parent.context;\n        this.createScope(parentScope);\n        this.parseNode(esTreeNode);\n        this.initialise();\n        this.context.magicString.addSourcemapLocation(this.start);\n        this.context.magicString.addSourcemapLocation(this.end);\n    }\n    /**\n     * Override this to bind assignments to variables and do any initialisations that\n     * require the scopes to be populated with variables.\n     */\n    bind() {\n        for (const key of this.keys) {\n            const value = this[key];\n            if (value === null || key === 'annotations')\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    if (child !== null)\n                        child.bind();\n                }\n            }\n            else {\n                value.bind();\n            }\n        }\n    }\n    /**\n     * Override if this node should receive a different scope than the parent scope.\n     */\n    createScope(parentScope) {\n        this.scope = parentScope;\n    }\n    declare(_kind, _init) {\n        return [];\n    }\n    deoptimizePath(_path) { }\n    getLiteralValueAtPath(_path, _recursionTracker, _origin) {\n        return UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(_path, _recursionTracker, _origin) {\n        return UNKNOWN_EXPRESSION;\n    }\n    hasEffects(context) {\n        for (const key of this.keys) {\n            const value = this[key];\n            if (value === null || key === 'annotations')\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    if (child !== null && child.hasEffects(context))\n                        return true;\n                }\n            }\n            else if (value.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsWhenAccessedAtPath(path, _context) {\n        return path.length > 0;\n    }\n    hasEffectsWhenAssignedAtPath(_path, _context) {\n        return true;\n    }\n    hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (const key of this.keys) {\n            const value = this[key];\n            if (value === null || key === 'annotations')\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    if (child !== null)\n                        child.include(context, includeChildrenRecursively);\n                }\n            }\n            else {\n                value.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    includeCallArguments(context, args) {\n        for (const arg of args) {\n            arg.include(context, false);\n        }\n    }\n    includeWithAllDeclaredVariables(includeChildrenRecursively, context) {\n        this.include(context, includeChildrenRecursively);\n    }\n    /**\n     * Override to perform special initialisation steps after the scope is initialised\n     */\n    initialise() { }\n    insertSemicolon(code) {\n        if (code.original[this.end - 1] !== ';') {\n            code.appendLeft(this.end, ';');\n        }\n    }\n    locate() {\n        // useful for debugging\n        const location = locate(this.context.code, this.start, { offsetLine: 1 });\n        location.file = this.context.fileName;\n        location.toString = () => JSON.stringify(location);\n        return location;\n    }\n    parseNode(esTreeNode) {\n        for (const key of Object.keys(esTreeNode)) {\n            // That way, we can override this function to add custom initialisation and then call super.parseNode\n            if (this.hasOwnProperty(key))\n                continue;\n            const value = esTreeNode[key];\n            if (typeof value !== 'object' || value === null || key === 'annotations') {\n                this[key] = value;\n            }\n            else if (Array.isArray(value)) {\n                this[key] = [];\n                for (const child of value) {\n                    this[key].push(child === null\n                        ? null\n                        : new (this.context.nodeConstructors[child.type] ||\n                            this.context.nodeConstructors.UnknownNode)(child, this, this.scope));\n                }\n            }\n            else {\n                this[key] = new (this.context.nodeConstructors[value.type] ||\n                    this.context.nodeConstructors.UnknownNode)(value, this, this.scope);\n            }\n        }\n    }\n    render(code, options) {\n        for (const key of this.keys) {\n            const value = this[key];\n            if (value === null || key === 'annotations')\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    if (child !== null)\n                        child.render(code, options);\n                }\n            }\n            else {\n                value.render(code, options);\n            }\n        }\n    }\n    shouldBeIncluded(context) {\n        return this.included || (!context.brokenFlow && this.hasEffects(createHasEffectsContext()));\n    }\n    toString() {\n        return this.context.code.slice(this.start, this.end);\n    }\n}\n\nclass ClassNode extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new ChildScope(parentScope);\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenAssignedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (!callOptions.withNew)\n            return true;\n        return (this.body.hasEffectsWhenCalledAtPath(path, callOptions, context) ||\n            (this.superClass !== null &&\n                this.superClass.hasEffectsWhenCalledAtPath(path, callOptions, context)));\n    }\n    initialise() {\n        if (this.id !== null) {\n            this.id.declare('class', this);\n        }\n    }\n}\n\nclass ClassDeclaration extends ClassNode {\n    initialise() {\n        super.initialise();\n        if (this.id !== null) {\n            this.id.variable.isId = true;\n        }\n    }\n    parseNode(esTreeNode) {\n        if (esTreeNode.id !== null) {\n            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope\n                .parent);\n        }\n        super.parseNode(esTreeNode);\n    }\n    render(code, options) {\n        if (options.format === 'system' && this.id && this.id.variable.exportName) {\n            code.appendLeft(this.end, ` exports('${this.id.variable.exportName}', ${this.id.variable.getName()});`);\n        }\n        super.render(code, options);\n    }\n}\n\nclass ArgumentsVariable extends LocalVariable {\n    constructor(context) {\n        super('arguments', null, UNKNOWN_EXPRESSION, context);\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenAssignedAtPath() {\n        return true;\n    }\n    hasEffectsWhenCalledAtPath() {\n        return true;\n    }\n}\n\nclass ThisVariable extends LocalVariable {\n    constructor(context) {\n        super('this', null, null, context);\n    }\n    getLiteralValueAtPath() {\n        return UnknownValue;\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        return (this.getInit(context).hasEffectsWhenAccessedAtPath(path, context) ||\n            super.hasEffectsWhenAccessedAtPath(path, context));\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        return (this.getInit(context).hasEffectsWhenAssignedAtPath(path, context) ||\n            super.hasEffectsWhenAssignedAtPath(path, context));\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        return (this.getInit(context).hasEffectsWhenCalledAtPath(path, callOptions, context) ||\n            super.hasEffectsWhenCalledAtPath(path, callOptions, context));\n    }\n    getInit(context) {\n        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;\n    }\n}\n\nclass ParameterScope extends ChildScope {\n    constructor(parent, context) {\n        super(parent);\n        this.parameters = [];\n        this.hasRest = false;\n        this.context = context;\n        this.hoistedBodyVarScope = new ChildScope(this);\n    }\n    /**\n     * Adds a parameter to this scope. Parameters must be added in the correct\n     * order, e.g. from left to right.\n     */\n    addParameterDeclaration(identifier) {\n        const name = identifier.name;\n        let variable = this.hoistedBodyVarScope.variables.get(name);\n        if (variable) {\n            variable.addDeclaration(identifier, null);\n        }\n        else {\n            variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);\n        }\n        this.variables.set(name, variable);\n        return variable;\n    }\n    addParameterVariables(parameters, hasRest) {\n        this.parameters = parameters;\n        for (const parameterList of parameters) {\n            for (const parameter of parameterList) {\n                parameter.alwaysRendered = true;\n            }\n        }\n        this.hasRest = hasRest;\n    }\n    includeCallArguments(context, args) {\n        let calledFromTryStatement = false;\n        let argIncluded = false;\n        const restParam = this.hasRest && this.parameters[this.parameters.length - 1];\n        for (let index = args.length - 1; index >= 0; index--) {\n            const paramVars = this.parameters[index] || restParam;\n            const arg = args[index];\n            if (paramVars) {\n                calledFromTryStatement = false;\n                for (const variable of paramVars) {\n                    if (variable.included) {\n                        argIncluded = true;\n                    }\n                    if (variable.calledFromTryStatement) {\n                        calledFromTryStatement = true;\n                    }\n                }\n            }\n            if (!argIncluded && arg.shouldBeIncluded(context)) {\n                argIncluded = true;\n            }\n            if (argIncluded) {\n                arg.include(context, calledFromTryStatement);\n            }\n        }\n    }\n}\n\nclass ReturnValueScope extends ParameterScope {\n    constructor() {\n        super(...arguments);\n        this.returnExpression = null;\n        this.returnExpressions = [];\n    }\n    addReturnExpression(expression) {\n        this.returnExpressions.push(expression);\n    }\n    getReturnExpression() {\n        if (this.returnExpression === null)\n            this.updateReturnExpression();\n        return this.returnExpression;\n    }\n    updateReturnExpression() {\n        if (this.returnExpressions.length === 1) {\n            this.returnExpression = this.returnExpressions[0];\n        }\n        else {\n            this.returnExpression = UNKNOWN_EXPRESSION;\n            for (const expression of this.returnExpressions) {\n                expression.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n    }\n}\n\nclass FunctionScope extends ReturnValueScope {\n    constructor(parent, context) {\n        super(parent, context);\n        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));\n        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));\n    }\n    findLexicalBoundary() {\n        return this;\n    }\n    includeCallArguments(context, args) {\n        super.includeCallArguments(context, args);\n        if (this.argumentsVariable.included) {\n            for (const arg of args) {\n                if (!arg.included) {\n                    arg.include(context, false);\n                }\n            }\n        }\n    }\n}\n\nfunction isReference(node, parent) {\n    if (node.type === 'MemberExpression') {\n        return !node.computed && isReference(node.object, node);\n    }\n    if (node.type === 'Identifier') {\n        if (!parent)\n            return true;\n        switch (parent.type) {\n            // disregard `bar` in `foo.bar`\n            case 'MemberExpression': return parent.computed || node === parent.object;\n            // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`\n            case 'MethodDefinition': return parent.computed;\n            // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`\n            case 'Property': return parent.computed || node === parent.value;\n            // disregard the `bar` in `export { foo as bar }` or\n            // the foo in `import { foo as bar }`\n            case 'ExportSpecifier':\n            case 'ImportSpecifier': return node === parent.local;\n            // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`\n            case 'LabeledStatement':\n            case 'BreakStatement':\n            case 'ContinueStatement': return false;\n            default: return true;\n        }\n    }\n    return false;\n}\n\nconst BLANK = Object.create(null);\n\nconst ValueProperties = Symbol('Value Properties');\nconst PURE = { pure: true };\nconst IMPURE = { pure: false };\n// We use shortened variables to reduce file size here\n/* OBJECT */\nconst O = {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE\n};\n/* PURE FUNCTION */\nconst PF = {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE\n};\n/* CONSTRUCTOR */\nconst C = {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    prototype: O\n};\n/* PURE CONSTRUCTOR */\nconst PC = {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    prototype: O\n};\nconst ARRAY_TYPE = {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    from: PF,\n    of: PF,\n    prototype: O\n};\nconst INTL_MEMBER = {\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: PURE,\n    supportedLocalesOf: PC\n};\nconst knownGlobals = {\n    // Placeholders for global objects to avoid shape mutations\n    global: O,\n    globalThis: O,\n    self: O,\n    window: O,\n    // Common globals\n    // @ts-ignore\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    Array: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        from: PF,\n        isArray: PF,\n        of: PF,\n        prototype: O\n    },\n    ArrayBuffer: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: PURE,\n        isView: PF,\n        prototype: O\n    },\n    Atomics: O,\n    BigInt: C,\n    BigInt64Array: C,\n    BigUint64Array: C,\n    Boolean: PC,\n    // @ts-ignore\n    constructor: C,\n    DataView: PC,\n    Date: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: PURE,\n        now: PF,\n        parse: PF,\n        prototype: O,\n        UTC: PF\n    },\n    decodeURI: PF,\n    decodeURIComponent: PF,\n    encodeURI: PF,\n    encodeURIComponent: PF,\n    Error: PC,\n    escape: PF,\n    eval: O,\n    EvalError: PC,\n    Float32Array: ARRAY_TYPE,\n    Float64Array: ARRAY_TYPE,\n    Function: C,\n    // @ts-ignore\n    hasOwnProperty: O,\n    Infinity: O,\n    Int16Array: ARRAY_TYPE,\n    Int32Array: ARRAY_TYPE,\n    Int8Array: ARRAY_TYPE,\n    isFinite: PF,\n    isNaN: PF,\n    // @ts-ignore\n    isPrototypeOf: O,\n    JSON: O,\n    Map: PC,\n    Math: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        abs: PF,\n        acos: PF,\n        acosh: PF,\n        asin: PF,\n        asinh: PF,\n        atan: PF,\n        atan2: PF,\n        atanh: PF,\n        cbrt: PF,\n        ceil: PF,\n        clz32: PF,\n        cos: PF,\n        cosh: PF,\n        exp: PF,\n        expm1: PF,\n        floor: PF,\n        fround: PF,\n        hypot: PF,\n        imul: PF,\n        log: PF,\n        log10: PF,\n        log1p: PF,\n        log2: PF,\n        max: PF,\n        min: PF,\n        pow: PF,\n        random: PF,\n        round: PF,\n        sign: PF,\n        sin: PF,\n        sinh: PF,\n        sqrt: PF,\n        tan: PF,\n        tanh: PF,\n        trunc: PF\n    },\n    NaN: O,\n    Number: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: PURE,\n        isFinite: PF,\n        isInteger: PF,\n        isNaN: PF,\n        isSafeInteger: PF,\n        parseFloat: PF,\n        parseInt: PF,\n        prototype: O\n    },\n    Object: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: PURE,\n        create: PF,\n        getNotifier: PF,\n        getOwn: PF,\n        getOwnPropertyDescriptor: PF,\n        getOwnPropertyNames: PF,\n        getOwnPropertySymbols: PF,\n        getPrototypeOf: PF,\n        is: PF,\n        isExtensible: PF,\n        isFrozen: PF,\n        isSealed: PF,\n        keys: PF,\n        prototype: O\n    },\n    parseFloat: PF,\n    parseInt: PF,\n    Promise: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        all: PF,\n        prototype: O,\n        race: PF,\n        resolve: PF\n    },\n    // @ts-ignore\n    propertyIsEnumerable: O,\n    Proxy: O,\n    RangeError: PC,\n    ReferenceError: PC,\n    Reflect: O,\n    RegExp: PC,\n    Set: PC,\n    SharedArrayBuffer: C,\n    String: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: PURE,\n        fromCharCode: PF,\n        fromCodePoint: PF,\n        prototype: O,\n        raw: PF\n    },\n    Symbol: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: PURE,\n        for: PF,\n        keyFor: PF,\n        prototype: O\n    },\n    SyntaxError: PC,\n    // @ts-ignore\n    toLocaleString: O,\n    // @ts-ignore\n    toString: O,\n    TypeError: PC,\n    Uint16Array: ARRAY_TYPE,\n    Uint32Array: ARRAY_TYPE,\n    Uint8Array: ARRAY_TYPE,\n    Uint8ClampedArray: ARRAY_TYPE,\n    // Technically, this is a global, but it needs special handling\n    // undefined: ?,\n    unescape: PF,\n    URIError: PC,\n    // @ts-ignore\n    valueOf: O,\n    WeakMap: PC,\n    WeakSet: PC,\n    // Additional globals shared by Node and Browser that are not strictly part of the language\n    clearInterval: C,\n    clearTimeout: C,\n    console: O,\n    Intl: {\n        // @ts-ignore\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        Collator: INTL_MEMBER,\n        DateTimeFormat: INTL_MEMBER,\n        ListFormat: INTL_MEMBER,\n        NumberFormat: INTL_MEMBER,\n        PluralRules: INTL_MEMBER,\n        RelativeTimeFormat: INTL_MEMBER\n    },\n    setInterval: C,\n    setTimeout: C,\n    TextDecoder: C,\n    TextEncoder: C,\n    URL: C,\n    URLSearchParams: C,\n    // Browser specific globals\n    AbortController: C,\n    AbortSignal: C,\n    addEventListener: O,\n    alert: O,\n    AnalyserNode: C,\n    Animation: C,\n    AnimationEvent: C,\n    applicationCache: O,\n    ApplicationCache: C,\n    ApplicationCacheErrorEvent: C,\n    atob: O,\n    Attr: C,\n    Audio: C,\n    AudioBuffer: C,\n    AudioBufferSourceNode: C,\n    AudioContext: C,\n    AudioDestinationNode: C,\n    AudioListener: C,\n    AudioNode: C,\n    AudioParam: C,\n    AudioProcessingEvent: C,\n    AudioScheduledSourceNode: C,\n    AudioWorkletNode: C,\n    BarProp: C,\n    BaseAudioContext: C,\n    BatteryManager: C,\n    BeforeUnloadEvent: C,\n    BiquadFilterNode: C,\n    Blob: C,\n    BlobEvent: C,\n    blur: O,\n    BroadcastChannel: C,\n    btoa: O,\n    ByteLengthQueuingStrategy: C,\n    Cache: C,\n    caches: O,\n    CacheStorage: C,\n    cancelAnimationFrame: O,\n    cancelIdleCallback: O,\n    CanvasCaptureMediaStreamTrack: C,\n    CanvasGradient: C,\n    CanvasPattern: C,\n    CanvasRenderingContext2D: C,\n    ChannelMergerNode: C,\n    ChannelSplitterNode: C,\n    CharacterData: C,\n    clientInformation: O,\n    ClipboardEvent: C,\n    close: O,\n    closed: O,\n    CloseEvent: C,\n    Comment: C,\n    CompositionEvent: C,\n    confirm: O,\n    ConstantSourceNode: C,\n    ConvolverNode: C,\n    CountQueuingStrategy: C,\n    createImageBitmap: O,\n    Credential: C,\n    CredentialsContainer: C,\n    crypto: O,\n    Crypto: C,\n    CryptoKey: C,\n    CSS: C,\n    CSSConditionRule: C,\n    CSSFontFaceRule: C,\n    CSSGroupingRule: C,\n    CSSImportRule: C,\n    CSSKeyframeRule: C,\n    CSSKeyframesRule: C,\n    CSSMediaRule: C,\n    CSSNamespaceRule: C,\n    CSSPageRule: C,\n    CSSRule: C,\n    CSSRuleList: C,\n    CSSStyleDeclaration: C,\n    CSSStyleRule: C,\n    CSSStyleSheet: C,\n    CSSSupportsRule: C,\n    CustomElementRegistry: C,\n    customElements: O,\n    CustomEvent: C,\n    DataTransfer: C,\n    DataTransferItem: C,\n    DataTransferItemList: C,\n    defaultstatus: O,\n    defaultStatus: O,\n    DelayNode: C,\n    DeviceMotionEvent: C,\n    DeviceOrientationEvent: C,\n    devicePixelRatio: O,\n    dispatchEvent: O,\n    document: O,\n    Document: C,\n    DocumentFragment: C,\n    DocumentType: C,\n    DOMError: C,\n    DOMException: C,\n    DOMImplementation: C,\n    DOMMatrix: C,\n    DOMMatrixReadOnly: C,\n    DOMParser: C,\n    DOMPoint: C,\n    DOMPointReadOnly: C,\n    DOMQuad: C,\n    DOMRect: C,\n    DOMRectReadOnly: C,\n    DOMStringList: C,\n    DOMStringMap: C,\n    DOMTokenList: C,\n    DragEvent: C,\n    DynamicsCompressorNode: C,\n    Element: C,\n    ErrorEvent: C,\n    Event: C,\n    EventSource: C,\n    EventTarget: C,\n    external: O,\n    fetch: O,\n    File: C,\n    FileList: C,\n    FileReader: C,\n    find: O,\n    focus: O,\n    FocusEvent: C,\n    FontFace: C,\n    FontFaceSetLoadEvent: C,\n    FormData: C,\n    frames: O,\n    GainNode: C,\n    Gamepad: C,\n    GamepadButton: C,\n    GamepadEvent: C,\n    getComputedStyle: O,\n    getSelection: O,\n    HashChangeEvent: C,\n    Headers: C,\n    history: O,\n    History: C,\n    HTMLAllCollection: C,\n    HTMLAnchorElement: C,\n    HTMLAreaElement: C,\n    HTMLAudioElement: C,\n    HTMLBaseElement: C,\n    HTMLBodyElement: C,\n    HTMLBRElement: C,\n    HTMLButtonElement: C,\n    HTMLCanvasElement: C,\n    HTMLCollection: C,\n    HTMLContentElement: C,\n    HTMLDataElement: C,\n    HTMLDataListElement: C,\n    HTMLDetailsElement: C,\n    HTMLDialogElement: C,\n    HTMLDirectoryElement: C,\n    HTMLDivElement: C,\n    HTMLDListElement: C,\n    HTMLDocument: C,\n    HTMLElement: C,\n    HTMLEmbedElement: C,\n    HTMLFieldSetElement: C,\n    HTMLFontElement: C,\n    HTMLFormControlsCollection: C,\n    HTMLFormElement: C,\n    HTMLFrameElement: C,\n    HTMLFrameSetElement: C,\n    HTMLHeadElement: C,\n    HTMLHeadingElement: C,\n    HTMLHRElement: C,\n    HTMLHtmlElement: C,\n    HTMLIFrameElement: C,\n    HTMLImageElement: C,\n    HTMLInputElement: C,\n    HTMLLabelElement: C,\n    HTMLLegendElement: C,\n    HTMLLIElement: C,\n    HTMLLinkElement: C,\n    HTMLMapElement: C,\n    HTMLMarqueeElement: C,\n    HTMLMediaElement: C,\n    HTMLMenuElement: C,\n    HTMLMetaElement: C,\n    HTMLMeterElement: C,\n    HTMLModElement: C,\n    HTMLObjectElement: C,\n    HTMLOListElement: C,\n    HTMLOptGroupElement: C,\n    HTMLOptionElement: C,\n    HTMLOptionsCollection: C,\n    HTMLOutputElement: C,\n    HTMLParagraphElement: C,\n    HTMLParamElement: C,\n    HTMLPictureElement: C,\n    HTMLPreElement: C,\n    HTMLProgressElement: C,\n    HTMLQuoteElement: C,\n    HTMLScriptElement: C,\n    HTMLSelectElement: C,\n    HTMLShadowElement: C,\n    HTMLSlotElement: C,\n    HTMLSourceElement: C,\n    HTMLSpanElement: C,\n    HTMLStyleElement: C,\n    HTMLTableCaptionElement: C,\n    HTMLTableCellElement: C,\n    HTMLTableColElement: C,\n    HTMLTableElement: C,\n    HTMLTableRowElement: C,\n    HTMLTableSectionElement: C,\n    HTMLTemplateElement: C,\n    HTMLTextAreaElement: C,\n    HTMLTimeElement: C,\n    HTMLTitleElement: C,\n    HTMLTrackElement: C,\n    HTMLUListElement: C,\n    HTMLUnknownElement: C,\n    HTMLVideoElement: C,\n    IDBCursor: C,\n    IDBCursorWithValue: C,\n    IDBDatabase: C,\n    IDBFactory: C,\n    IDBIndex: C,\n    IDBKeyRange: C,\n    IDBObjectStore: C,\n    IDBOpenDBRequest: C,\n    IDBRequest: C,\n    IDBTransaction: C,\n    IDBVersionChangeEvent: C,\n    IdleDeadline: C,\n    IIRFilterNode: C,\n    Image: C,\n    ImageBitmap: C,\n    ImageBitmapRenderingContext: C,\n    ImageCapture: C,\n    ImageData: C,\n    indexedDB: O,\n    innerHeight: O,\n    innerWidth: O,\n    InputEvent: C,\n    IntersectionObserver: C,\n    IntersectionObserverEntry: C,\n    isSecureContext: O,\n    KeyboardEvent: C,\n    KeyframeEffect: C,\n    length: O,\n    localStorage: O,\n    location: O,\n    Location: C,\n    locationbar: O,\n    matchMedia: O,\n    MediaDeviceInfo: C,\n    MediaDevices: C,\n    MediaElementAudioSourceNode: C,\n    MediaEncryptedEvent: C,\n    MediaError: C,\n    MediaKeyMessageEvent: C,\n    MediaKeySession: C,\n    MediaKeyStatusMap: C,\n    MediaKeySystemAccess: C,\n    MediaList: C,\n    MediaQueryList: C,\n    MediaQueryListEvent: C,\n    MediaRecorder: C,\n    MediaSettingsRange: C,\n    MediaSource: C,\n    MediaStream: C,\n    MediaStreamAudioDestinationNode: C,\n    MediaStreamAudioSourceNode: C,\n    MediaStreamEvent: C,\n    MediaStreamTrack: C,\n    MediaStreamTrackEvent: C,\n    menubar: O,\n    MessageChannel: C,\n    MessageEvent: C,\n    MessagePort: C,\n    MIDIAccess: C,\n    MIDIConnectionEvent: C,\n    MIDIInput: C,\n    MIDIInputMap: C,\n    MIDIMessageEvent: C,\n    MIDIOutput: C,\n    MIDIOutputMap: C,\n    MIDIPort: C,\n    MimeType: C,\n    MimeTypeArray: C,\n    MouseEvent: C,\n    moveBy: O,\n    moveTo: O,\n    MutationEvent: C,\n    MutationObserver: C,\n    MutationRecord: C,\n    name: O,\n    NamedNodeMap: C,\n    NavigationPreloadManager: C,\n    navigator: O,\n    Navigator: C,\n    NetworkInformation: C,\n    Node: C,\n    NodeFilter: O,\n    NodeIterator: C,\n    NodeList: C,\n    Notification: C,\n    OfflineAudioCompletionEvent: C,\n    OfflineAudioContext: C,\n    offscreenBuffering: O,\n    OffscreenCanvas: C,\n    open: O,\n    openDatabase: O,\n    Option: C,\n    origin: O,\n    OscillatorNode: C,\n    outerHeight: O,\n    outerWidth: O,\n    PageTransitionEvent: C,\n    pageXOffset: O,\n    pageYOffset: O,\n    PannerNode: C,\n    parent: O,\n    Path2D: C,\n    PaymentAddress: C,\n    PaymentRequest: C,\n    PaymentRequestUpdateEvent: C,\n    PaymentResponse: C,\n    performance: O,\n    Performance: C,\n    PerformanceEntry: C,\n    PerformanceLongTaskTiming: C,\n    PerformanceMark: C,\n    PerformanceMeasure: C,\n    PerformanceNavigation: C,\n    PerformanceNavigationTiming: C,\n    PerformanceObserver: C,\n    PerformanceObserverEntryList: C,\n    PerformancePaintTiming: C,\n    PerformanceResourceTiming: C,\n    PerformanceTiming: C,\n    PeriodicWave: C,\n    Permissions: C,\n    PermissionStatus: C,\n    personalbar: O,\n    PhotoCapabilities: C,\n    Plugin: C,\n    PluginArray: C,\n    PointerEvent: C,\n    PopStateEvent: C,\n    postMessage: O,\n    Presentation: C,\n    PresentationAvailability: C,\n    PresentationConnection: C,\n    PresentationConnectionAvailableEvent: C,\n    PresentationConnectionCloseEvent: C,\n    PresentationConnectionList: C,\n    PresentationReceiver: C,\n    PresentationRequest: C,\n    print: O,\n    ProcessingInstruction: C,\n    ProgressEvent: C,\n    PromiseRejectionEvent: C,\n    prompt: O,\n    PushManager: C,\n    PushSubscription: C,\n    PushSubscriptionOptions: C,\n    queueMicrotask: O,\n    RadioNodeList: C,\n    Range: C,\n    ReadableStream: C,\n    RemotePlayback: C,\n    removeEventListener: O,\n    Request: C,\n    requestAnimationFrame: O,\n    requestIdleCallback: O,\n    resizeBy: O,\n    ResizeObserver: C,\n    ResizeObserverEntry: C,\n    resizeTo: O,\n    Response: C,\n    RTCCertificate: C,\n    RTCDataChannel: C,\n    RTCDataChannelEvent: C,\n    RTCDtlsTransport: C,\n    RTCIceCandidate: C,\n    RTCIceTransport: C,\n    RTCPeerConnection: C,\n    RTCPeerConnectionIceEvent: C,\n    RTCRtpReceiver: C,\n    RTCRtpSender: C,\n    RTCSctpTransport: C,\n    RTCSessionDescription: C,\n    RTCStatsReport: C,\n    RTCTrackEvent: C,\n    screen: O,\n    Screen: C,\n    screenLeft: O,\n    ScreenOrientation: C,\n    screenTop: O,\n    screenX: O,\n    screenY: O,\n    ScriptProcessorNode: C,\n    scroll: O,\n    scrollbars: O,\n    scrollBy: O,\n    scrollTo: O,\n    scrollX: O,\n    scrollY: O,\n    SecurityPolicyViolationEvent: C,\n    Selection: C,\n    ServiceWorker: C,\n    ServiceWorkerContainer: C,\n    ServiceWorkerRegistration: C,\n    sessionStorage: O,\n    ShadowRoot: C,\n    SharedWorker: C,\n    SourceBuffer: C,\n    SourceBufferList: C,\n    speechSynthesis: O,\n    SpeechSynthesisEvent: C,\n    SpeechSynthesisUtterance: C,\n    StaticRange: C,\n    status: O,\n    statusbar: O,\n    StereoPannerNode: C,\n    stop: O,\n    Storage: C,\n    StorageEvent: C,\n    StorageManager: C,\n    styleMedia: O,\n    StyleSheet: C,\n    StyleSheetList: C,\n    SubtleCrypto: C,\n    SVGAElement: C,\n    SVGAngle: C,\n    SVGAnimatedAngle: C,\n    SVGAnimatedBoolean: C,\n    SVGAnimatedEnumeration: C,\n    SVGAnimatedInteger: C,\n    SVGAnimatedLength: C,\n    SVGAnimatedLengthList: C,\n    SVGAnimatedNumber: C,\n    SVGAnimatedNumberList: C,\n    SVGAnimatedPreserveAspectRatio: C,\n    SVGAnimatedRect: C,\n    SVGAnimatedString: C,\n    SVGAnimatedTransformList: C,\n    SVGAnimateElement: C,\n    SVGAnimateMotionElement: C,\n    SVGAnimateTransformElement: C,\n    SVGAnimationElement: C,\n    SVGCircleElement: C,\n    SVGClipPathElement: C,\n    SVGComponentTransferFunctionElement: C,\n    SVGDefsElement: C,\n    SVGDescElement: C,\n    SVGDiscardElement: C,\n    SVGElement: C,\n    SVGEllipseElement: C,\n    SVGFEBlendElement: C,\n    SVGFEColorMatrixElement: C,\n    SVGFEComponentTransferElement: C,\n    SVGFECompositeElement: C,\n    SVGFEConvolveMatrixElement: C,\n    SVGFEDiffuseLightingElement: C,\n    SVGFEDisplacementMapElement: C,\n    SVGFEDistantLightElement: C,\n    SVGFEDropShadowElement: C,\n    SVGFEFloodElement: C,\n    SVGFEFuncAElement: C,\n    SVGFEFuncBElement: C,\n    SVGFEFuncGElement: C,\n    SVGFEFuncRElement: C,\n    SVGFEGaussianBlurElement: C,\n    SVGFEImageElement: C,\n    SVGFEMergeElement: C,\n    SVGFEMergeNodeElement: C,\n    SVGFEMorphologyElement: C,\n    SVGFEOffsetElement: C,\n    SVGFEPointLightElement: C,\n    SVGFESpecularLightingElement: C,\n    SVGFESpotLightElement: C,\n    SVGFETileElement: C,\n    SVGFETurbulenceElement: C,\n    SVGFilterElement: C,\n    SVGForeignObjectElement: C,\n    SVGGElement: C,\n    SVGGeometryElement: C,\n    SVGGradientElement: C,\n    SVGGraphicsElement: C,\n    SVGImageElement: C,\n    SVGLength: C,\n    SVGLengthList: C,\n    SVGLinearGradientElement: C,\n    SVGLineElement: C,\n    SVGMarkerElement: C,\n    SVGMaskElement: C,\n    SVGMatrix: C,\n    SVGMetadataElement: C,\n    SVGMPathElement: C,\n    SVGNumber: C,\n    SVGNumberList: C,\n    SVGPathElement: C,\n    SVGPatternElement: C,\n    SVGPoint: C,\n    SVGPointList: C,\n    SVGPolygonElement: C,\n    SVGPolylineElement: C,\n    SVGPreserveAspectRatio: C,\n    SVGRadialGradientElement: C,\n    SVGRect: C,\n    SVGRectElement: C,\n    SVGScriptElement: C,\n    SVGSetElement: C,\n    SVGStopElement: C,\n    SVGStringList: C,\n    SVGStyleElement: C,\n    SVGSVGElement: C,\n    SVGSwitchElement: C,\n    SVGSymbolElement: C,\n    SVGTextContentElement: C,\n    SVGTextElement: C,\n    SVGTextPathElement: C,\n    SVGTextPositioningElement: C,\n    SVGTitleElement: C,\n    SVGTransform: C,\n    SVGTransformList: C,\n    SVGTSpanElement: C,\n    SVGUnitTypes: C,\n    SVGUseElement: C,\n    SVGViewElement: C,\n    TaskAttributionTiming: C,\n    Text: C,\n    TextEvent: C,\n    TextMetrics: C,\n    TextTrack: C,\n    TextTrackCue: C,\n    TextTrackCueList: C,\n    TextTrackList: C,\n    TimeRanges: C,\n    toolbar: O,\n    top: O,\n    Touch: C,\n    TouchEvent: C,\n    TouchList: C,\n    TrackEvent: C,\n    TransitionEvent: C,\n    TreeWalker: C,\n    UIEvent: C,\n    ValidityState: C,\n    visualViewport: O,\n    VisualViewport: C,\n    VTTCue: C,\n    WaveShaperNode: C,\n    WebAssembly: O,\n    WebGL2RenderingContext: C,\n    WebGLActiveInfo: C,\n    WebGLBuffer: C,\n    WebGLContextEvent: C,\n    WebGLFramebuffer: C,\n    WebGLProgram: C,\n    WebGLQuery: C,\n    WebGLRenderbuffer: C,\n    WebGLRenderingContext: C,\n    WebGLSampler: C,\n    WebGLShader: C,\n    WebGLShaderPrecisionFormat: C,\n    WebGLSync: C,\n    WebGLTexture: C,\n    WebGLTransformFeedback: C,\n    WebGLUniformLocation: C,\n    WebGLVertexArrayObject: C,\n    WebSocket: C,\n    WheelEvent: C,\n    Window: C,\n    Worker: C,\n    WritableStream: C,\n    XMLDocument: C,\n    XMLHttpRequest: C,\n    XMLHttpRequestEventTarget: C,\n    XMLHttpRequestUpload: C,\n    XMLSerializer: C,\n    XPathEvaluator: C,\n    XPathExpression: C,\n    XPathResult: C,\n    XSLTProcessor: C\n};\nfor (const global of ['window', 'global', 'self', 'globalThis']) {\n    knownGlobals[global] = knownGlobals;\n}\nfunction getGlobalAtPath(path) {\n    let currentGlobal = knownGlobals;\n    for (const pathSegment of path) {\n        if (typeof pathSegment !== 'string') {\n            return null;\n        }\n        currentGlobal = currentGlobal[pathSegment];\n        if (!currentGlobal) {\n            return null;\n        }\n    }\n    return currentGlobal[ValueProperties];\n}\nfunction isPureGlobal(path) {\n    const globalAtPath = getGlobalAtPath(path);\n    return globalAtPath !== null && globalAtPath.pure;\n}\nfunction isGlobalMember(path) {\n    if (path.length === 1) {\n        return path[0] === 'undefined' || getGlobalAtPath(path) !== null;\n    }\n    return getGlobalAtPath(path.slice(0, -1)) !== null;\n}\n\nclass GlobalVariable extends Variable {\n    hasEffectsWhenAccessedAtPath(path) {\n        return !isGlobalMember([this.name, ...path]);\n    }\n    hasEffectsWhenCalledAtPath(path) {\n        return !isPureGlobal([this.name, ...path]);\n    }\n}\n\nclass Identifier$1 extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.variable = null;\n        this.bound = false;\n    }\n    addExportedVariables(variables) {\n        if (this.variable !== null && this.variable.exportName) {\n            variables.push(this.variable);\n        }\n    }\n    bind() {\n        if (this.bound)\n            return;\n        this.bound = true;\n        if (this.variable === null && isReference(this, this.parent)) {\n            this.variable = this.scope.findVariable(this.name);\n            this.variable.addReference(this);\n        }\n        if (this.variable !== null &&\n            this.variable instanceof LocalVariable &&\n            this.variable.additionalInitializers !== null) {\n            this.variable.consolidateInitializers();\n        }\n    }\n    declare(kind, init) {\n        let variable;\n        switch (kind) {\n            case 'var':\n                variable = this.scope.addDeclaration(this, this.context, init, true);\n                break;\n            case 'function':\n                variable = this.scope.addDeclaration(this, this.context, init, 'function');\n                break;\n            case 'let':\n            case 'const':\n            case 'class':\n                variable = this.scope.addDeclaration(this, this.context, init, false);\n                break;\n            case 'parameter':\n                variable = this.scope.addParameterDeclaration(this);\n                break;\n            /* istanbul ignore next */\n            default:\n                /* istanbul ignore next */\n                throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);\n        }\n        return [(this.variable = variable)];\n    }\n    deoptimizePath(path) {\n        if (!this.bound)\n            this.bind();\n        if (path.length === 0 && !this.scope.contains(this.name)) {\n            this.disallowImportReassignment();\n        }\n        this.variable.deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (!this.bound)\n            this.bind();\n        return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        if (!this.bound)\n            this.bind();\n        return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    }\n    hasEffects() {\n        return (this.context.unknownGlobalSideEffects &&\n            this.variable instanceof GlobalVariable &&\n            this.variable.hasEffectsWhenAccessedAtPath(EMPTY_PATH));\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        return this.variable !== null && this.variable.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        return !this.variable || this.variable.hasEffectsWhenAssignedAtPath(path, context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        return !this.variable || this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n    include(context) {\n        if (!this.included) {\n            this.included = true;\n            if (this.variable !== null) {\n                this.context.includeVariable(context, this.variable);\n            }\n        }\n    }\n    includeCallArguments(context, args) {\n        this.variable.includeCallArguments(context, args);\n    }\n    render(code, _options, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {\n        if (this.variable) {\n            const name = this.variable.getName();\n            if (name !== this.name) {\n                code.overwrite(this.start, this.end, name, {\n                    contentOnly: true,\n                    storeName: true\n                });\n                if (isShorthandProperty) {\n                    code.prependRight(this.start, `${this.name}: `);\n                }\n            }\n            // In strict mode, any variable named \"eval\" must be the actual \"eval\" function\n            if (name === 'eval' &&\n                renderedParentType === CallExpression &&\n                isCalleeOfRenderedParent) {\n                code.appendRight(this.start, '0, ');\n            }\n        }\n    }\n    disallowImportReassignment() {\n        return this.context.error({\n            code: 'ILLEGAL_REASSIGNMENT',\n            message: `Illegal reassignment to import '${this.name}'`\n        }, this.start);\n    }\n}\n\nclass RestElement extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.declarationInit = null;\n    }\n    addExportedVariables(variables) {\n        this.argument.addExportedVariables(variables);\n    }\n    bind() {\n        super.bind();\n        if (this.declarationInit !== null) {\n            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);\n        }\n    }\n    declare(kind, init) {\n        this.declarationInit = init;\n        return this.argument.declare(kind, UNKNOWN_EXPRESSION);\n    }\n    deoptimizePath(path) {\n        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        return path.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n    }\n}\n\nclass FunctionNode extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.isPrototypeDeoptimized = false;\n    }\n    createScope(parentScope) {\n        this.scope = new FunctionScope(parentScope, this.context);\n    }\n    deoptimizePath(path) {\n        if (path.length === 1) {\n            if (path[0] === 'prototype') {\n                this.isPrototypeDeoptimized = true;\n            }\n            else if (path[0] === UnknownKey) {\n                this.isPrototypeDeoptimized = true;\n                // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track\n                // which means the return expression needs to be reassigned as well\n                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;\n    }\n    hasEffects() {\n        return this.id !== null && this.id.hasEffects();\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        if (path.length <= 1)\n            return false;\n        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;\n    }\n    hasEffectsWhenAssignedAtPath(path) {\n        if (path.length <= 1) {\n            return false;\n        }\n        return path.length > 2 || path[0] !== 'prototype' || this.isPrototypeDeoptimized;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length > 0)\n            return true;\n        for (const param of this.params) {\n            if (param.hasEffects(context))\n                return true;\n        }\n        const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);\n        context.replacedVariableInits.set(this.scope.thisVariable, callOptions.withNew ? new UnknownObjectExpression() : UNKNOWN_EXPRESSION);\n        const { brokenFlow, ignore } = context;\n        context.ignore = {\n            breaks: false,\n            continues: false,\n            labels: new Set(),\n            returnAwaitYield: true\n        };\n        if (this.body.hasEffects(context))\n            return true;\n        context.brokenFlow = brokenFlow;\n        if (thisInit) {\n            context.replacedVariableInits.set(this.scope.thisVariable, thisInit);\n        }\n        else {\n            context.replacedVariableInits.delete(this.scope.thisVariable);\n        }\n        context.ignore = ignore;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (this.id)\n            this.id.include(context);\n        const hasArguments = this.scope.argumentsVariable.included;\n        for (const param of this.params) {\n            if (!(param instanceof Identifier$1) || hasArguments) {\n                param.include(context, includeChildrenRecursively);\n            }\n        }\n        const { brokenFlow } = context;\n        context.brokenFlow = BROKEN_FLOW_NONE;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n    includeCallArguments(context, args) {\n        this.scope.includeCallArguments(context, args);\n    }\n    initialise() {\n        if (this.id !== null) {\n            this.id.declare('function', this);\n        }\n        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);\n        this.body.addImplicitReturnExpressionToScope();\n    }\n    parseNode(esTreeNode) {\n        this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);\n        super.parseNode(esTreeNode);\n    }\n}\nFunctionNode.prototype.preventChildBlockScope = true;\n\nclass FunctionDeclaration extends FunctionNode {\n    initialise() {\n        super.initialise();\n        if (this.id !== null) {\n            this.id.variable.isId = true;\n        }\n    }\n    parseNode(esTreeNode) {\n        if (esTreeNode.id !== null) {\n            this.id = new this.context.nodeConstructors.Identifier(esTreeNode.id, this, this.scope\n                .parent);\n        }\n        super.parseNode(esTreeNode);\n    }\n}\n\nconst WHITESPACE = /\\s/;\n// The header ends at the first non-white-space after \"default\"\nfunction getDeclarationStart(code, start = 0) {\n    start = findFirstOccurrenceOutsideComment(code, 'default', start) + 7;\n    while (WHITESPACE.test(code[start]))\n        start++;\n    return start;\n}\nfunction getIdInsertPosition(code, declarationKeyword, start = 0) {\n    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;\n    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, '{', declarationEnd));\n    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');\n    if (generatorStarPos === -1) {\n        return declarationEnd;\n    }\n    return declarationEnd + generatorStarPos + 1;\n}\nclass ExportDefaultDeclaration extends NodeBase {\n    include(context, includeChildrenRecursively) {\n        super.include(context, includeChildrenRecursively);\n        if (includeChildrenRecursively) {\n            this.context.includeVariable(context, this.variable);\n        }\n    }\n    initialise() {\n        const declaration = this.declaration;\n        this.declarationName =\n            (declaration.id && declaration.id.name) || this.declaration.name;\n        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);\n        this.context.addExport(this);\n    }\n    render(code, options, nodeRenderOptions) {\n        const { start, end } = nodeRenderOptions;\n        const declarationStart = getDeclarationStart(code.original, this.start);\n        if (this.declaration instanceof FunctionDeclaration) {\n            this.renderNamedDeclaration(code, declarationStart, 'function', this.declaration.id === null, options);\n        }\n        else if (this.declaration instanceof ClassDeclaration) {\n            this.renderNamedDeclaration(code, declarationStart, 'class', this.declaration.id === null, options);\n        }\n        else if (this.variable.getOriginalVariable() !== this.variable) {\n            // Remove altogether to prevent re-declaring the same variable\n            if (options.format === 'system' && this.variable.exportName) {\n                code.overwrite(start, end, `exports('${this.variable.exportName}', ${this.variable.getName()});`);\n            }\n            else {\n                treeshakeNode(this, code, start, end);\n            }\n            return;\n        }\n        else if (this.variable.included) {\n            this.renderVariableDeclaration(code, declarationStart, options);\n        }\n        else {\n            code.remove(this.start, declarationStart);\n            this.declaration.render(code, options, {\n                isCalleeOfRenderedParent: false,\n                renderedParentType: ExpressionStatement\n            });\n            if (code.original[this.end - 1] !== ';') {\n                code.appendLeft(this.end, ';');\n            }\n            return;\n        }\n        this.declaration.render(code, options);\n    }\n    renderNamedDeclaration(code, declarationStart, declarationKeyword, needsId, options) {\n        const name = this.variable.getName();\n        // Remove `export default`\n        code.remove(this.start, declarationStart);\n        if (needsId) {\n            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, declarationStart), ` ${name}`);\n        }\n        if (options.format === 'system' &&\n            this.declaration instanceof ClassDeclaration &&\n            this.variable.exportName) {\n            code.appendLeft(this.end, ` exports('${this.variable.exportName}', ${name});`);\n        }\n    }\n    renderVariableDeclaration(code, declarationStart, options) {\n        const systemBinding = options.format === 'system' && this.variable.exportName\n            ? `exports('${this.variable.exportName}', `\n            : '';\n        code.overwrite(this.start, declarationStart, `${options.varOrConst} ${this.variable.getName()} = ${systemBinding}`);\n        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*\";\"*/\n        if (systemBinding) {\n            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));\n        }\n        else if (!hasTrailingSemicolon) {\n            code.appendLeft(this.end, ';');\n        }\n    }\n}\nExportDefaultDeclaration.prototype.needsBoundaries = true;\n\nclass ExportDefaultVariable extends LocalVariable {\n    constructor(name, exportDefaultDeclaration, context) {\n        super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context);\n        this.hasId = false;\n        // Not initialised during construction\n        this.originalId = null;\n        this.originalVariable = null;\n        const declaration = exportDefaultDeclaration.declaration;\n        if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) &&\n            declaration.id) {\n            this.hasId = true;\n            this.originalId = declaration.id;\n        }\n        else if (declaration instanceof Identifier$1) {\n            this.originalId = declaration;\n        }\n    }\n    addReference(identifier) {\n        if (!this.hasId) {\n            this.name = identifier.name;\n        }\n    }\n    getAssignedVariableName() {\n        return (this.originalId && this.originalId.name) || null;\n    }\n    getBaseVariableName() {\n        const original = this.getOriginalVariable();\n        if (original === this) {\n            return super.getBaseVariableName();\n        }\n        else {\n            return original.getBaseVariableName();\n        }\n    }\n    getName() {\n        const original = this.getOriginalVariable();\n        if (original === this) {\n            return super.getName();\n        }\n        else {\n            return original.getName();\n        }\n    }\n    getOriginalVariable() {\n        if (this.originalVariable === null) {\n            if (!this.originalId || (!this.hasId && this.originalId.variable.isReassigned)) {\n                this.originalVariable = this;\n            }\n            else {\n                const assignedOriginal = this.originalId.variable;\n                this.originalVariable =\n                    assignedOriginal instanceof ExportDefaultVariable\n                        ? assignedOriginal.getOriginalVariable()\n                        : assignedOriginal;\n            }\n        }\n        return this.originalVariable;\n    }\n    setRenderNames(baseName, name) {\n        const original = this.getOriginalVariable();\n        if (original === this) {\n            super.setRenderNames(baseName, name);\n        }\n        else {\n            original.setRenderNames(baseName, name);\n        }\n    }\n    setSafeName(name) {\n        const original = this.getOriginalVariable();\n        if (original === this) {\n            super.setSafeName(name);\n        }\n        else {\n            original.setSafeName(name);\n        }\n    }\n}\n\nconst MISSING_EXPORT_SHIM_VARIABLE = '_missingExportShim';\nconst INTEROP_DEFAULT_VARIABLE = '_interopDefault';\nconst INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';\n\nclass ExportShimVariable extends Variable {\n    constructor(module) {\n        super(MISSING_EXPORT_SHIM_VARIABLE);\n        this.module = module;\n    }\n}\n\nclass NamespaceVariable extends Variable {\n    constructor(context, syntheticNamedExports) {\n        super(context.getModuleName());\n        this.memberVariables = Object.create(null);\n        this.containsExternalNamespace = false;\n        this.referencedEarly = false;\n        this.references = [];\n        this.context = context;\n        this.module = context.module;\n        this.syntheticNamedExports = syntheticNamedExports;\n    }\n    addReference(identifier) {\n        this.references.push(identifier);\n        this.name = identifier.name;\n    }\n    // This is only called if \"UNKNOWN_PATH\" is reassigned as in all other situations, either the\n    // build fails due to an illegal namespace reassignment or MemberExpression already forwards\n    // the reassignment to the right variable. This means we lost track of this variable and thus\n    // need to reassign all exports.\n    deoptimizePath() {\n        for (const key in this.memberVariables) {\n            this.memberVariables[key].deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    include(context) {\n        if (!this.included) {\n            if (this.containsExternalNamespace) {\n                return this.context.error({\n                    code: 'NAMESPACE_CANNOT_CONTAIN_EXTERNAL',\n                    id: this.module.id,\n                    message: `Cannot create an explicit namespace object for module \"${this.context.getModuleName()}\" because it contains a reexported external namespace`\n                });\n            }\n            this.included = true;\n            for (const identifier of this.references) {\n                if (identifier.context.getModuleExecIndex() <= this.context.getModuleExecIndex()) {\n                    this.referencedEarly = true;\n                    break;\n                }\n            }\n            if (this.context.preserveModules) {\n                for (const memberName of Object.keys(this.memberVariables))\n                    this.memberVariables[memberName].include(context);\n            }\n            else {\n                for (const memberName of Object.keys(this.memberVariables))\n                    this.context.includeVariable(context, this.memberVariables[memberName]);\n            }\n        }\n    }\n    initialise() {\n        for (const name of this.context.getExports().concat(this.context.getReexports())) {\n            if (name[0] === '*' && name.length > 1)\n                this.containsExternalNamespace = true;\n            this.memberVariables[name] = this.context.traceExport(name);\n        }\n    }\n    renderBlock(options) {\n        const _ = options.compact ? '' : ' ';\n        const n = options.compact ? '' : '\\n';\n        const t = options.indent;\n        const members = Object.keys(this.memberVariables).map(name => {\n            const original = this.memberVariables[name];\n            if (this.referencedEarly || original.isReassigned) {\n                return `${t}get ${name}${_}()${_}{${_}return ${original.getName()}${options.compact ? '' : ';'}${_}}`;\n            }\n            const safeName = RESERVED_NAMES[name] ? `'${name}'` : name;\n            return `${t}${safeName}: ${original.getName()}`;\n        });\n        members.unshift(`${t}__proto__:${_}null`);\n        if (options.namespaceToStringTag) {\n            members.unshift(`${t}[Symbol.toStringTag]:${_}'Module'`);\n        }\n        const name = this.getName();\n        let output = `{${n}${members.join(`,${n}`)}${n}}`;\n        if (this.syntheticNamedExports) {\n            output = `/*#__PURE__*/Object.assign(${output}, ${this.module.getDefaultExport().getName()})`;\n        }\n        if (options.freeze) {\n            output = `/*#__PURE__*/Object.freeze(${output})`;\n        }\n        output = `${options.varOrConst} ${name}${_}=${_}${output};`;\n        if (options.format === 'system' && this.exportName) {\n            output += `${n}exports('${this.exportName}',${_}${name});`;\n        }\n        return output;\n    }\n    renderFirst() {\n        return this.referencedEarly;\n    }\n}\nNamespaceVariable.prototype.isNamespace = true;\n\nconst esModuleExport = `Object.defineProperty(exports, '__esModule', { value: true });`;\nconst compactEsModuleExport = `Object.defineProperty(exports,'__esModule',{value:true});`;\n\nfunction getExportBlock(exports, dependencies, namedExportsMode, interop, compact, t, mechanism = 'return ') {\n    const _ = compact ? '' : ' ';\n    const n = compact ? '' : '\\n';\n    if (!namedExportsMode) {\n        let local;\n        if (exports.length > 0) {\n            local = exports[0].local;\n        }\n        else {\n            for (const dep of dependencies) {\n                if (dep.reexports) {\n                    const expt = dep.reexports[0];\n                    local =\n                        dep.namedExportsMode && expt.imported !== '*' && expt.imported !== 'default'\n                            ? `${dep.name}.${expt.imported}`\n                            : dep.name;\n                    break;\n                }\n            }\n        }\n        return `${mechanism}${local};`;\n    }\n    let exportBlock = '';\n    // star exports must always output first for precedence\n    for (const { name, reexports } of dependencies) {\n        if (reexports && namedExportsMode) {\n            for (const specifier of reexports) {\n                if (specifier.reexported === '*') {\n                    if (exportBlock)\n                        exportBlock += n;\n                    if (specifier.needsLiveBinding) {\n                        exportBlock +=\n                            `Object.keys(${name}).forEach(function${_}(k)${_}{${n}` +\n                                `${t}if${_}(k${_}!==${_}'default')${_}Object.defineProperty(exports,${_}k,${_}{${n}` +\n                                `${t}${t}enumerable:${_}true,${n}` +\n                                `${t}${t}get:${_}function${_}()${_}{${n}` +\n                                `${t}${t}${t}return ${name}[k];${n}` +\n                                `${t}${t}}${n}${t}});${n}});`;\n                    }\n                    else {\n                        exportBlock +=\n                            `Object.keys(${name}).forEach(function${_}(k)${_}{${n}` +\n                                `${t}if${_}(k${_}!==${_}'default')${_}exports[k]${_}=${_}${name}[k];${n}});`;\n                    }\n                }\n            }\n        }\n    }\n    for (const { name, imports, reexports, isChunk, namedExportsMode: depNamedExportsMode, exportsNames } of dependencies) {\n        if (reexports && namedExportsMode) {\n            for (const specifier of reexports) {\n                if (specifier.imported === 'default' && !isChunk) {\n                    if (exportBlock)\n                        exportBlock += n;\n                    if (exportsNames &&\n                        (reexports.some(specifier => specifier.imported === 'default'\n                            ? specifier.reexported === 'default'\n                            : specifier.imported !== '*') ||\n                            (imports && imports.some(specifier => specifier.imported !== 'default')))) {\n                        exportBlock += `exports.${specifier.reexported}${_}=${_}${name}${interop !== false ? '__default' : '.default'};`;\n                    }\n                    else {\n                        exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;\n                    }\n                }\n                else if (specifier.imported !== '*') {\n                    if (exportBlock)\n                        exportBlock += n;\n                    const importName = specifier.imported === 'default' && !depNamedExportsMode\n                        ? name\n                        : `${name}.${specifier.imported}`;\n                    exportBlock += specifier.needsLiveBinding\n                        ? `Object.defineProperty(exports,${_}'${specifier.reexported}',${_}{${n}` +\n                            `${t}enumerable:${_}true,${n}` +\n                            `${t}get:${_}function${_}()${_}{${n}` +\n                            `${t}${t}return ${importName};${n}${t}}${n}});`\n                        : `exports.${specifier.reexported}${_}=${_}${importName};`;\n                }\n                else if (specifier.reexported !== '*') {\n                    if (exportBlock)\n                        exportBlock += n;\n                    exportBlock += `exports.${specifier.reexported}${_}=${_}${name};`;\n                }\n            }\n        }\n    }\n    for (const expt of exports) {\n        const lhs = `exports.${expt.exported}`;\n        const rhs = expt.local;\n        if (lhs !== rhs) {\n            if (exportBlock)\n                exportBlock += n;\n            exportBlock += `${lhs}${_}=${_}${rhs};`;\n        }\n    }\n    return exportBlock;\n}\n\nfunction getInteropBlock(dependencies, options, varOrConst) {\n    const _ = options.compact ? '' : ' ';\n    return dependencies\n        .map(({ name, exportsNames, exportsDefault, namedExportsMode }) => {\n        if (!namedExportsMode || !exportsDefault || options.interop === false)\n            return null;\n        if (exportsNames) {\n            return (`${varOrConst} ${name}__default${_}=${_}'default'${_}in ${name}${_}?` +\n                `${_}${name}['default']${_}:${_}${name};`);\n        }\n        return (`${name}${_}=${_}${name}${_}&&${_}Object.prototype.hasOwnProperty.call(${name},${_}'default')${_}?` +\n            `${_}${name}['default']${_}:${_}${name};`);\n    })\n        .filter(Boolean)\n        .join(options.compact ? '' : '\\n');\n}\n\nfunction copyPropertyLiveBinding(_, n, t, i) {\n    return (`${i}var d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +\n        `${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +\n        `${i}${t}enumerable:${_}true,${n}` +\n        `${i}${t}get:${_}function${_}()${_}{${n}` +\n        `${i}${t}${t}return e[k];${n}` +\n        `${i}${t}}${n}` +\n        `${i}});${n}`);\n}\nfunction copyPropertyStatic(_, n, _t, i) {\n    return `${i}n[k]${_}=e${_}[k];${n}`;\n}\nfunction getInteropNamespace(_, n, t, liveBindings) {\n    return (`function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n}` +\n        `${t}if${_}(e${_}&&${_}e.__esModule)${_}{${_}return e;${_}}${_}else${_}{${n}` +\n        `${t}${t}var n${_}=${_}{};${n}` +\n        `${t}${t}if${_}(e)${_}{${n}` +\n        `${t}${t}${t}Object.keys(e).forEach(function${_}(k)${_}{${n}` +\n        (liveBindings ? copyPropertyLiveBinding : copyPropertyStatic)(_, n, t, t + t + t + t) +\n        `${t}${t}${t}});${n}` +\n        `${t}${t}}${n}` +\n        `${t}${t}n['default']${_}=${_}e;${n}` +\n        `${t}${t}return n;${n}` +\n        `${t}}${n}` +\n        `}${n}${n}`);\n}\n\nconst builtins$1 = {\n    assert: true,\n    buffer: true,\n    console: true,\n    constants: true,\n    domain: true,\n    events: true,\n    http: true,\n    https: true,\n    os: true,\n    path: true,\n    process: true,\n    punycode: true,\n    querystring: true,\n    stream: true,\n    string_decoder: true,\n    timers: true,\n    tty: true,\n    url: true,\n    util: true,\n    vm: true,\n    zlib: true\n};\n// Creating a browser chunk that depends on Node.js built-in modules ('util'). You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins\nfunction warnOnBuiltins(warn, dependencies) {\n    const externalBuiltins = dependencies.map(({ id }) => id).filter(id => id in builtins$1);\n    if (!externalBuiltins.length)\n        return;\n    const detail = externalBuiltins.length === 1\n        ? `module ('${externalBuiltins[0]}')`\n        : `modules (${externalBuiltins\n            .slice(0, -1)\n            .map(name => `'${name}'`)\n            .join(', ')} and '${externalBuiltins.slice(-1)}')`;\n    warn({\n        code: 'MISSING_NODE_BUILTINS',\n        message: `Creating a browser bundle that depends on Node.js built-in ${detail}. You might need to include https://www.npmjs.com/package/rollup-plugin-node-builtins`,\n        modules: externalBuiltins\n    });\n}\n\n// AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.\n// The assumption is that this makes sense for all relative ids:\n// https://requirejs.org/docs/api.html#jsfiles\nfunction removeExtensionFromRelativeAmdId(id) {\n    if (id[0] === '.' && id.endsWith('.js')) {\n        return id.slice(0, -3);\n    }\n    return id;\n}\nfunction amd(magicString, { accessedGlobals, dependencies, exports, hasExports, indentString: t, intro, isEntryModuleFacade, namedExportsMode, outro, varOrConst, warn }, options) {\n    warnOnBuiltins(warn, dependencies);\n    const deps = dependencies.map(m => `'${removeExtensionFromRelativeAmdId(m.id)}'`);\n    const args = dependencies.map(m => m.name);\n    const n = options.compact ? '' : '\\n';\n    const _ = options.compact ? '' : ' ';\n    if (namedExportsMode && hasExports) {\n        args.unshift(`exports`);\n        deps.unshift(`'exports'`);\n    }\n    if (accessedGlobals.has('require')) {\n        args.unshift('require');\n        deps.unshift(`'require'`);\n    }\n    if (accessedGlobals.has('module')) {\n        args.unshift('module');\n        deps.unshift(`'module'`);\n    }\n    const amdOptions = options.amd || {};\n    const params = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) +\n        (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);\n    const useStrict = options.strict !== false ? `${_}'use strict';` : ``;\n    const define = amdOptions.define || 'define';\n    const wrapperStart = `${define}(${params}function${_}(${args.join(`,${_}`)})${_}{${useStrict}${n}${n}`;\n    // var foo__default = 'default' in foo ? foo['default'] : foo;\n    const interopBlock = getInteropBlock(dependencies, options, varOrConst);\n    if (interopBlock) {\n        magicString.prepend(interopBlock + n + n);\n    }\n    if (accessedGlobals.has(INTEROP_NAMESPACE_VARIABLE)) {\n        magicString.prepend(getInteropNamespace(_, n, t, options.externalLiveBindings !== false));\n    }\n    if (intro)\n        magicString.prepend(intro);\n    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);\n    if (exportBlock)\n        magicString.append(n + n + exportBlock);\n    if (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule)\n        magicString.append(`${n}${n}${options.compact ? compactEsModuleExport : esModuleExport}`);\n    if (outro)\n        magicString.append(outro);\n    return magicString\n        .indent(t)\n        .append(n + n + '});')\n        .prepend(wrapperStart);\n}\n\nfunction cjs(magicString, { accessedGlobals, dependencies, exports, hasExports, indentString: t, intro, isEntryModuleFacade, namedExportsMode, outro, varOrConst }, options) {\n    const n = options.compact ? '' : '\\n';\n    const _ = options.compact ? '' : ' ';\n    intro =\n        (options.strict === false ? intro : `'use strict';${n}${n}${intro}`) +\n            (namedExportsMode && hasExports && isEntryModuleFacade && options.esModule\n                ? `${options.compact ? compactEsModuleExport : esModuleExport}${n}${n}`\n                : '');\n    let needsInterop = false;\n    const interop = options.interop !== false;\n    let importBlock;\n    let definingVariable = false;\n    importBlock = '';\n    for (const { id, namedExportsMode, isChunk, name, reexports, imports, exportsNames, exportsDefault } of dependencies) {\n        if (!reexports && !imports) {\n            if (importBlock) {\n                importBlock += !options.compact || definingVariable ? `;${n}` : ',';\n            }\n            definingVariable = false;\n            importBlock += `require('${id}')`;\n        }\n        else {\n            importBlock +=\n                options.compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${varOrConst} `;\n            definingVariable = true;\n            if (!interop || isChunk || !exportsDefault || !namedExportsMode) {\n                importBlock += `${name}${_}=${_}require('${id}')`;\n            }\n            else {\n                needsInterop = true;\n                if (exportsNames)\n                    importBlock += `${name}${_}=${_}require('${id}')${options.compact ? ',' : `;\\n${varOrConst} `}${name}__default${_}=${_}${INTEROP_DEFAULT_VARIABLE}(${name})`;\n                else\n                    importBlock += `${name}${_}=${_}${INTEROP_DEFAULT_VARIABLE}(require('${id}'))`;\n            }\n        }\n    }\n    if (importBlock)\n        importBlock += ';';\n    if (needsInterop) {\n        const ex = options.compact ? 'e' : 'ex';\n        intro +=\n            `function ${INTEROP_DEFAULT_VARIABLE}${_}(${ex})${_}{${_}return${_}` +\n                `(${ex}${_}&&${_}(typeof ${ex}${_}===${_}'object')${_}&&${_}'default'${_}in ${ex})${_}` +\n                `?${_}${ex}['default']${_}:${_}${ex}${options.compact ? '' : '; '}}${n}${n}`;\n    }\n    if (accessedGlobals.has(INTEROP_NAMESPACE_VARIABLE)) {\n        intro += getInteropNamespace(_, n, t, options.externalLiveBindings !== false);\n    }\n    if (importBlock)\n        intro += importBlock + n + n;\n    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t, `module.exports${_}=${_}`);\n    magicString.prepend(intro);\n    if (exportBlock)\n        magicString.append(n + n + exportBlock);\n    if (outro)\n        magicString.append(outro);\n    return magicString;\n}\n\nfunction esm(magicString, { intro, outro, dependencies, exports }, options) {\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const importBlock = getImportBlock(dependencies, _);\n    if (importBlock.length > 0)\n        intro += importBlock.join(n) + n + n;\n    if (intro)\n        magicString.prepend(intro);\n    const exportBlock = getExportBlock$1(exports, _);\n    if (exportBlock.length)\n        magicString.append(n + n + exportBlock.join(n).trim());\n    if (outro)\n        magicString.append(outro);\n    return magicString.trim();\n}\nfunction getImportBlock(dependencies, _) {\n    const importBlock = [];\n    for (const { id, reexports, imports, name } of dependencies) {\n        if (!reexports && !imports) {\n            importBlock.push(`import${_}'${id}';`);\n            continue;\n        }\n        if (imports) {\n            let defaultImport = null;\n            let starImport = null;\n            const importedNames = [];\n            for (const specifier of imports) {\n                if (specifier.imported === 'default') {\n                    defaultImport = specifier;\n                }\n                else if (specifier.imported === '*') {\n                    starImport = specifier;\n                }\n                else {\n                    importedNames.push(specifier);\n                }\n            }\n            if (starImport) {\n                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);\n            }\n            if (defaultImport && importedNames.length === 0) {\n                importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);\n            }\n            else if (importedNames.length > 0) {\n                importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames\n                    .map(specifier => {\n                    if (specifier.imported === specifier.local) {\n                        return specifier.imported;\n                    }\n                    else {\n                        return `${specifier.imported} as ${specifier.local}`;\n                    }\n                })\n                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);\n            }\n        }\n        if (reexports) {\n            let starExport = null;\n            const namespaceReexports = [];\n            const namedReexports = [];\n            for (const specifier of reexports) {\n                if (specifier.reexported === '*') {\n                    starExport = specifier;\n                }\n                else if (specifier.imported === '*') {\n                    namespaceReexports.push(specifier);\n                }\n                else {\n                    namedReexports.push(specifier);\n                }\n            }\n            if (starExport) {\n                importBlock.push(`export${_}*${_}from${_}'${id}';`);\n            }\n            if (namespaceReexports.length > 0) {\n                if (!imports ||\n                    !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {\n                    importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);\n                }\n                for (const specifier of namespaceReexports) {\n                    importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);\n                }\n            }\n            if (namedReexports.length > 0) {\n                importBlock.push(`export${_}{${_}${namedReexports\n                    .map(specifier => {\n                    if (specifier.imported === specifier.reexported) {\n                        return specifier.imported;\n                    }\n                    else {\n                        return `${specifier.imported} as ${specifier.reexported}`;\n                    }\n                })\n                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);\n            }\n        }\n    }\n    return importBlock;\n}\nfunction getExportBlock$1(exports, _) {\n    const exportBlock = [];\n    const exportDeclaration = [];\n    for (const specifier of exports) {\n        if (specifier.exported === 'default') {\n            exportBlock.push(`export default ${specifier.local};`);\n        }\n        else {\n            exportDeclaration.push(specifier.exported === specifier.local\n                ? specifier.local\n                : `${specifier.local} as ${specifier.exported}`);\n        }\n    }\n    if (exportDeclaration.length) {\n        exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);\n    }\n    return exportBlock;\n}\n\nfunction spaces(i) {\n    let result = '';\n    while (i--)\n        result += ' ';\n    return result;\n}\nfunction tabsToSpaces(str) {\n    return str.replace(/^\\t+/, match => match.split('\\t').join('  '));\n}\nfunction getCodeFrame(source, line, column) {\n    let lines = source.split('\\n');\n    const frameStart = Math.max(0, line - 3);\n    let frameEnd = Math.min(line + 2, lines.length);\n    lines = lines.slice(frameStart, frameEnd);\n    while (!/\\S/.test(lines[lines.length - 1])) {\n        lines.pop();\n        frameEnd -= 1;\n    }\n    const digits = String(frameEnd).length;\n    return lines\n        .map((str, i) => {\n        const isErrorLine = frameStart + i + 1 === line;\n        let lineNum = String(i + frameStart + 1);\n        while (lineNum.length < digits)\n            lineNum = ` ${lineNum}`;\n        if (isErrorLine) {\n            const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';\n            return `${lineNum}: ${tabsToSpaces(str)}\\n${indicator}`;\n        }\n        return `${lineNum}: ${tabsToSpaces(str)}`;\n    })\n        .join('\\n');\n}\n\nfunction sanitizeFileName(name) {\n    return name.replace(/[\\0?*]/g, '_');\n}\n\nfunction getAliasName(id) {\n    const base = basename(id);\n    return base.substr(0, base.length - extname(id).length);\n}\nfunction relativeId(id) {\n    if (typeof process === 'undefined' || !isAbsolute(id))\n        return id;\n    return relative$1(process.cwd(), id);\n}\nfunction isPlainPathFragment(name) {\n    // not starting with \"/\", \"./\", \"../\"\n    return (name[0] !== '/' &&\n        !(name[0] === '.' && (name[1] === '/' || name[1] === '.')) &&\n        sanitizeFileName(name) === name);\n}\n\nfunction error(base, props) {\n    if (!(base instanceof Error))\n        base = Object.assign(new Error(base.message), base);\n    if (props)\n        Object.assign(base, props);\n    throw base;\n}\nfunction augmentCodeLocation(object, pos, source, id) {\n    if (typeof pos === 'object') {\n        const { line, column } = pos;\n        object.loc = { file: id, line, column };\n    }\n    else {\n        object.pos = pos;\n        const { line, column } = locate(source, pos, { offsetLine: 1 });\n        object.loc = { file: id, line, column };\n    }\n    if (object.frame === undefined) {\n        const { line, column } = object.loc;\n        object.frame = getCodeFrame(source, line, column);\n    }\n}\nvar Errors;\n(function (Errors) {\n    Errors[\"ASSET_NOT_FINALISED\"] = \"ASSET_NOT_FINALISED\";\n    Errors[\"ASSET_NOT_FOUND\"] = \"ASSET_NOT_FOUND\";\n    Errors[\"ASSET_SOURCE_ALREADY_SET\"] = \"ASSET_SOURCE_ALREADY_SET\";\n    Errors[\"ASSET_SOURCE_MISSING\"] = \"ASSET_SOURCE_MISSING\";\n    Errors[\"BAD_LOADER\"] = \"BAD_LOADER\";\n    Errors[\"CANNOT_EMIT_FROM_OPTIONS_HOOK\"] = \"CANNOT_EMIT_FROM_OPTIONS_HOOK\";\n    Errors[\"CHUNK_NOT_GENERATED\"] = \"CHUNK_NOT_GENERATED\";\n    Errors[\"DEPRECATED_FEATURE\"] = \"DEPRECATED_FEATURE\";\n    Errors[\"FILE_NOT_FOUND\"] = \"FILE_NOT_FOUND\";\n    Errors[\"FILE_NAME_CONFLICT\"] = \"FILE_NAME_CONFLICT\";\n    Errors[\"INPUT_HOOK_IN_OUTPUT_PLUGIN\"] = \"INPUT_HOOK_IN_OUTPUT_PLUGIN\";\n    Errors[\"INVALID_CHUNK\"] = \"INVALID_CHUNK\";\n    Errors[\"INVALID_EXPORT_OPTION\"] = \"INVALID_EXPORT_OPTION\";\n    Errors[\"INVALID_EXTERNAL_ID\"] = \"INVALID_EXTERNAL_ID\";\n    Errors[\"INVALID_OPTION\"] = \"INVALID_OPTION\";\n    Errors[\"INVALID_PLUGIN_HOOK\"] = \"INVALID_PLUGIN_HOOK\";\n    Errors[\"INVALID_ROLLUP_PHASE\"] = \"INVALID_ROLLUP_PHASE\";\n    Errors[\"MIXED_EXPORTS\"] = \"MIXED_EXPORTS\";\n    Errors[\"NAMESPACE_CONFLICT\"] = \"NAMESPACE_CONFLICT\";\n    Errors[\"PLUGIN_ERROR\"] = \"PLUGIN_ERROR\";\n    Errors[\"UNRESOLVED_ENTRY\"] = \"UNRESOLVED_ENTRY\";\n    Errors[\"UNRESOLVED_IMPORT\"] = \"UNRESOLVED_IMPORT\";\n    Errors[\"VALIDATION_ERROR\"] = \"VALIDATION_ERROR\";\n    Errors[\"EXTERNAL_SYNTHETIC_EXPORTS\"] = \"EXTERNAL_SYNTHETIC_EXPORTS\";\n    Errors[\"SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT\"] = \"SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT\";\n})(Errors || (Errors = {}));\nfunction errAssetNotFinalisedForFileName(name) {\n    return {\n        code: Errors.ASSET_NOT_FINALISED,\n        message: `Plugin error - Unable to get file name for asset \"${name}\". Ensure that the source is set and that generate is called first.`\n    };\n}\nfunction errCannotEmitFromOptionsHook() {\n    return {\n        code: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,\n        message: `Cannot emit files or set asset sources in the \"outputOptions\" hook, use the \"renderStart\" hook instead.`\n    };\n}\nfunction errChunkNotGeneratedForFileName(name) {\n    return {\n        code: Errors.CHUNK_NOT_GENERATED,\n        message: `Plugin error - Unable to get file name for chunk \"${name}\". Ensure that generate is called first.`\n    };\n}\nfunction errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {\n    return {\n        code: Errors.ASSET_NOT_FOUND,\n        message: `Plugin error - Unable to set the source for unknown asset \"${assetReferenceId}\".`\n    };\n}\nfunction errAssetSourceAlreadySet(name) {\n    return {\n        code: Errors.ASSET_SOURCE_ALREADY_SET,\n        message: `Unable to set the source for asset \"${name}\", source already set.`\n    };\n}\nfunction errNoAssetSourceSet(assetName) {\n    return {\n        code: Errors.ASSET_SOURCE_MISSING,\n        message: `Plugin error creating asset \"${assetName}\" - no asset source set.`\n    };\n}\nfunction errBadLoader(id) {\n    return {\n        code: Errors.BAD_LOADER,\n        message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`\n    };\n}\nfunction errDeprecation(deprecation) {\n    return Object.assign({ code: Errors.DEPRECATED_FEATURE }, (typeof deprecation === 'string' ? { message: deprecation } : deprecation));\n}\nfunction errFileReferenceIdNotFoundForFilename(assetReferenceId) {\n    return {\n        code: Errors.FILE_NOT_FOUND,\n        message: `Plugin error - Unable to get file name for unknown file \"${assetReferenceId}\".`\n    };\n}\nfunction errFileNameConflict(fileName) {\n    return {\n        code: Errors.FILE_NAME_CONFLICT,\n        message: `The emitted file \"${fileName}\" overwrites a previously emitted file of the same name.`\n    };\n}\nfunction errInputHookInOutputPlugin(pluginName, hookName) {\n    return {\n        code: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,\n        message: `The \"${hookName}\" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`\n    };\n}\nfunction errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {\n    return {\n        code: Errors.INVALID_CHUNK,\n        message: `Cannot assign ${relativeId(moduleId)} to the \"${assignToAlias}\" chunk as it is already in the \"${currentAlias}\" chunk.`\n    };\n}\nfunction errInvalidExportOptionValue(optionValue) {\n    return {\n        code: Errors.INVALID_EXPORT_OPTION,\n        message: `\"output.exports\" must be \"default\", \"named\", \"none\", \"auto\", or left unspecified (defaults to \"auto\"), received \"${optionValue}\"`,\n        url: `https://rollupjs.org/guide/en/#output-exports`\n    };\n}\nfunction errIncompatibleExportOptionValue(optionValue, keys, entryModule) {\n    return {\n        code: 'INVALID_EXPORT_OPTION',\n        message: `\"${optionValue}\" was specified for \"output.exports\", but entry module \"${relativeId(entryModule)}\" has the following exports: ${keys.join(', ')}`\n    };\n}\nfunction errInternalIdCannotBeExternal(source, importer) {\n    return {\n        code: Errors.INVALID_EXTERNAL_ID,\n        message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`\n    };\n}\nfunction errInvalidOption(option, explanation) {\n    return {\n        code: Errors.INVALID_OPTION,\n        message: `Invalid value for option \"${option}\" - ${explanation}.`\n    };\n}\nfunction errInvalidRollupPhaseForAddWatchFile() {\n    return {\n        code: Errors.INVALID_ROLLUP_PHASE,\n        message: `Cannot call addWatchFile after the build has finished.`\n    };\n}\nfunction errInvalidRollupPhaseForChunkEmission() {\n    return {\n        code: Errors.INVALID_ROLLUP_PHASE,\n        message: `Cannot emit chunks after module loading has finished.`\n    };\n}\nfunction errMixedExport(facadeModuleId, name) {\n    return {\n        code: Errors.MIXED_EXPORTS,\n        id: facadeModuleId,\n        message: `Entry module \"${relativeId(facadeModuleId)}\" is using named and default exports together. Consumers of your bundle will have to use \\`${name ||\n            'chunk'}[\"default\"]\\` to access the default export, which may not be what you want. Use \\`output.exports: \"named\"\\` to disable this warning`,\n        url: `https://rollupjs.org/guide/en/#output-exports`\n    };\n}\nfunction errNamespaceConflict(name, reexportingModule, additionalExportAllModule) {\n    return {\n        code: Errors.NAMESPACE_CONFLICT,\n        message: `Conflicting namespaces: ${relativeId(reexportingModule.id)} re-exports '${name}' from both ${relativeId(reexportingModule.exportsAll[name])} and ${relativeId(additionalExportAllModule.exportsAll[name])} (will be ignored)`,\n        name,\n        reexporter: reexportingModule.id,\n        sources: [reexportingModule.exportsAll[name], additionalExportAllModule.exportsAll[name]]\n    };\n}\nfunction errEntryCannotBeExternal(unresolvedId) {\n    return {\n        code: Errors.UNRESOLVED_ENTRY,\n        message: `Entry module cannot be external (${relativeId(unresolvedId)}).`\n    };\n}\nfunction errUnresolvedEntry(unresolvedId) {\n    return {\n        code: Errors.UNRESOLVED_ENTRY,\n        message: `Could not resolve entry module (${relativeId(unresolvedId)}).`\n    };\n}\nfunction errUnresolvedImport(source, importer) {\n    return {\n        code: Errors.UNRESOLVED_IMPORT,\n        message: `Could not resolve '${source}' from ${relativeId(importer)}`\n    };\n}\nfunction errUnresolvedImportTreatedAsExternal(source, importer) {\n    return {\n        code: Errors.UNRESOLVED_IMPORT,\n        importer: relativeId(importer),\n        message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved – treating it as an external dependency`,\n        source,\n        url: 'https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency'\n    };\n}\nfunction errExternalSyntheticExports(source, importer) {\n    return {\n        code: Errors.EXTERNAL_SYNTHETIC_EXPORTS,\n        importer: relativeId(importer),\n        message: `External '${source}' can not have 'syntheticNamedExports' enabled.`,\n        source\n    };\n}\nfunction errFailedValidation(message) {\n    return {\n        code: Errors.VALIDATION_ERROR,\n        message\n    };\n}\n\n// Generate strings which dereference dotted properties, but use array notation `['prop-deref']`\n// if the property name isn't trivial\nconst shouldUseDot = /^[a-zA-Z$_][a-zA-Z0-9$_]*$/;\nfunction property(prop) {\n    return shouldUseDot.test(prop) ? `.${prop}` : `['${prop}']`;\n}\nfunction keypath(keypath) {\n    return keypath\n        .split('.')\n        .map(property)\n        .join('');\n}\n\nfunction setupNamespace(name, root, globals, compact) {\n    const parts = name.split('.');\n    if (globals) {\n        parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];\n    }\n    const _ = compact ? '' : ' ';\n    parts.pop();\n    let acc = root;\n    return (parts\n        .map(part => ((acc += property(part)), `${acc}${_}=${_}${acc}${_}||${_}{}${compact ? '' : ';'}`))\n        .join(compact ? ',' : '\\n') + (compact && parts.length ? ';' : '\\n'));\n}\nfunction assignToDeepVariable(deepName, root, globals, compact, assignment) {\n    const _ = compact ? '' : ' ';\n    const parts = deepName.split('.');\n    if (globals) {\n        parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];\n    }\n    const last = parts.pop();\n    let acc = root;\n    let deepAssignment = parts\n        .map(part => ((acc += property(part)), `${acc}${_}=${_}${acc}${_}||${_}{}`))\n        .concat(`${acc}${property(last)}`)\n        .join(`,${_}`)\n        .concat(`${_}=${_}${assignment}`);\n    if (parts.length > 0) {\n        deepAssignment = `(${deepAssignment})`;\n    }\n    return deepAssignment;\n}\n\nfunction trimEmptyImports(dependencies) {\n    let i = dependencies.length;\n    while (i--) {\n        const dependency = dependencies[i];\n        if (dependency.exportsDefault || dependency.exportsNames) {\n            return dependencies.slice(0, i + 1);\n        }\n    }\n    return [];\n}\n\nconst thisProp = (name) => `this${keypath(name)}`;\nfunction iife(magicString, { dependencies, exports, hasExports, indentString: t, intro, namedExportsMode, outro, varOrConst, warn }, options) {\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const { extend, name } = options;\n    const isNamespaced = name && name.indexOf('.') !== -1;\n    const useVariableAssignment = !extend && !isNamespaced;\n    if (name && useVariableAssignment && !isLegal(name)) {\n        return error({\n            code: 'ILLEGAL_IDENTIFIER_AS_NAME',\n            message: `Given name \"${name}\" is not a legal JS identifier. If you need this, you can try \"output.extend: true\".`\n        });\n    }\n    warnOnBuiltins(warn, dependencies);\n    const external = trimEmptyImports(dependencies);\n    const deps = external.map(dep => dep.globalName || 'null');\n    const args = external.map(m => m.name);\n    if (hasExports && !name) {\n        warn({\n            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',\n            message: `If you do not supply \"output.name\", you may not be able to access the exports of an IIFE bundle.`\n        });\n    }\n    if (namedExportsMode && hasExports) {\n        if (extend) {\n            deps.unshift(`${thisProp(name)}${_}=${_}${thisProp(name)}${_}||${_}{}`);\n            args.unshift('exports');\n        }\n        else {\n            deps.unshift('{}');\n            args.unshift('exports');\n        }\n    }\n    const useStrict = options.strict !== false ? `${t}'use strict';${n}${n}` : ``;\n    let wrapperIntro = `(function${_}(${args.join(`,${_}`)})${_}{${n}${useStrict}`;\n    if (hasExports && (!extend || !namedExportsMode) && name) {\n        wrapperIntro =\n            (useVariableAssignment ? `${varOrConst} ${name}` : thisProp(name)) +\n                `${_}=${_}${wrapperIntro}`;\n    }\n    if (isNamespaced && hasExports) {\n        wrapperIntro = setupNamespace(name, 'this', options.globals, options.compact) + wrapperIntro;\n    }\n    let wrapperOutro = `${n}${n}}(${deps.join(`,${_}`)}));`;\n    if (!extend && namedExportsMode && hasExports) {\n        wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;\n    }\n    // var foo__default = 'default' in foo ? foo['default'] : foo;\n    const interopBlock = getInteropBlock(dependencies, options, varOrConst);\n    if (interopBlock)\n        magicString.prepend(interopBlock + n + n);\n    if (intro)\n        magicString.prepend(intro);\n    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);\n    if (exportBlock)\n        magicString.append(n + n + exportBlock);\n    if (outro)\n        magicString.append(outro);\n    return magicString\n        .indent(t)\n        .prepend(wrapperIntro)\n        .append(wrapperOutro);\n}\n\nfunction getStarExcludes({ dependencies, exports }) {\n    const starExcludes = new Set(exports.map(expt => expt.exported));\n    if (!starExcludes.has('default'))\n        starExcludes.add('default');\n    // also include reexport names\n    for (const { reexports } of dependencies) {\n        if (reexports) {\n            for (const reexport of reexports) {\n                if (reexport.imported !== '*' && !starExcludes.has(reexport.reexported))\n                    starExcludes.add(reexport.reexported);\n            }\n        }\n    }\n    return starExcludes;\n}\nconst getStarExcludesBlock = (starExcludes, varOrConst, _, t, n) => starExcludes\n    ? `${n}${t}${varOrConst} _starExcludes${_}=${_}{${_}${Array.from(starExcludes).join(`:${_}1,${_}`)}${starExcludes.size ? `:${_}1` : ''}${_}};`\n    : '';\nconst getImportBindingsBlock = (importBindings, _, t, n) => (importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');\nfunction getExportsBlock(exports, _, t, n) {\n    if (exports.length === 0) {\n        return '';\n    }\n    if (exports.length === 1) {\n        return `${t}${t}${t}exports('${exports[0].name}',${_}${exports[0].value});${n}${n}`;\n    }\n    return (`${t}${t}${t}exports({${n}` +\n        exports.map(({ name, value }) => `${t}${t}${t}${t}${name}:${_}${value}`).join(`,${n}`) +\n        `${n}${t}${t}${t}});${n}${n}`);\n}\nconst getHoistedExportsBlock = (exports, _, t, n) => getExportsBlock(exports\n    .filter(expt => expt.hoisted || expt.uninitialized)\n    .map(expt => ({ name: expt.exported, value: expt.uninitialized ? 'void 0' : expt.local })), _, t, n);\nconst getMissingExportsBlock = (exports, _, t, n) => getExportsBlock(exports\n    .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)\n    .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), _, t, n);\nfunction system(magicString, { accessedGlobals, dependencies, exports, hasExports, indentString: t, intro, outro, usesTopLevelAwait, varOrConst }, options) {\n    const n = options.compact ? '' : '\\n';\n    const _ = options.compact ? '' : ' ';\n    const dependencyIds = dependencies.map(m => `'${m.id}'`);\n    const importBindings = [];\n    let starExcludes;\n    const setters = [];\n    for (const { imports, reexports } of dependencies) {\n        const setter = [];\n        if (imports) {\n            for (const specifier of imports) {\n                importBindings.push(specifier.local);\n                if (specifier.imported === '*') {\n                    setter.push(`${specifier.local}${_}=${_}module;`);\n                }\n                else {\n                    setter.push(`${specifier.local}${_}=${_}module.${specifier.imported};`);\n                }\n            }\n        }\n        if (reexports) {\n            let createdSetter = false;\n            // bulk-reexport form\n            if (reexports.length > 1 ||\n                (reexports.length === 1 &&\n                    (reexports[0].reexported === '*' || reexports[0].imported === '*'))) {\n                // star reexports\n                for (const specifier of reexports) {\n                    if (specifier.reexported !== '*')\n                        continue;\n                    // need own exports list for deduping in star export case\n                    if (!starExcludes) {\n                        starExcludes = getStarExcludes({ dependencies, exports });\n                    }\n                    if (!createdSetter) {\n                        setter.push(`${varOrConst} _setter${_}=${_}{};`);\n                        createdSetter = true;\n                    }\n                    setter.push(`for${_}(var _$p${_}in${_}module)${_}{`);\n                    setter.push(`${t}if${_}(!_starExcludes[_$p])${_}_setter[_$p]${_}=${_}module[_$p];`);\n                    setter.push('}');\n                }\n                // star import reexport\n                for (const specifier of reexports) {\n                    if (specifier.imported !== '*' || specifier.reexported === '*')\n                        continue;\n                    setter.push(`exports('${specifier.reexported}',${_}module);`);\n                }\n                // reexports\n                for (const specifier of reexports) {\n                    if (specifier.reexported === '*' || specifier.imported === '*')\n                        continue;\n                    if (!createdSetter) {\n                        setter.push(`${varOrConst} _setter${_}=${_}{};`);\n                        createdSetter = true;\n                    }\n                    setter.push(`_setter.${specifier.reexported}${_}=${_}module.${specifier.imported};`);\n                }\n                if (createdSetter) {\n                    setter.push('exports(_setter);');\n                }\n            }\n            else {\n                // single reexport\n                for (const specifier of reexports) {\n                    setter.push(`exports('${specifier.reexported}',${_}module.${specifier.imported});`);\n                }\n            }\n        }\n        setters.push(setter.join(`${n}${t}${t}${t}`));\n    }\n    const registeredName = options.name ? `'${options.name}',${_}` : '';\n    const wrapperParams = accessedGlobals.has('module')\n        ? `exports,${_}module`\n        : hasExports\n            ? 'exports'\n            : '';\n    let wrapperStart = `System.register(${registeredName}[` +\n        dependencyIds.join(`,${_}`) +\n        `],${_}function${_}(${wrapperParams})${_}{${n}${t}${options.strict ? \"'use strict';\" : ''}` +\n        getStarExcludesBlock(starExcludes, varOrConst, _, t, n) +\n        getImportBindingsBlock(importBindings, _, t, n) +\n        `${n}${t}return${_}{${setters.length\n            ? `${n}${t}${t}setters:${_}[${setters\n                .map(s => s\n                ? `function${_}(module)${_}{${n}${t}${t}${t}${s}${n}${t}${t}}`\n                : `function${_}()${_}{}`)\n                .join(`,${_}`)}],`\n            : ''}${n}`;\n    wrapperStart +=\n        `${t}${t}execute:${_}${usesTopLevelAwait ? `async${_}` : ''}function${_}()${_}{${n}${n}` +\n            getHoistedExportsBlock(exports, _, t, n);\n    const wrapperEnd = `${n}${n}` +\n        getMissingExportsBlock(exports, _, t, n) +\n        `${t}${t}}${n}${t}}${options.compact ? '' : ';'}${n}});`;\n    if (intro)\n        magicString.prepend(intro);\n    if (outro)\n        magicString.append(outro);\n    return magicString\n        .indent(`${t}${t}${t}`)\n        .append(wrapperEnd)\n        .prepend(wrapperStart);\n}\n\nfunction globalProp(name, globalVar) {\n    if (!name)\n        return 'null';\n    return `${globalVar}${keypath(name)}`;\n}\nfunction safeAccess(name, globalVar, _) {\n    const parts = name.split('.');\n    let acc = globalVar;\n    return parts.map(part => ((acc += property(part)), acc)).join(`${_}&&${_}`);\n}\nfunction umd(magicString, { dependencies, exports, hasExports, indentString: t, intro, namedExportsMode, outro, varOrConst, warn }, options) {\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const factoryVar = options.compact ? 'f' : 'factory';\n    const globalVar = options.compact ? 'g' : 'global';\n    if (hasExports && !options.name) {\n        return error({\n            code: 'INVALID_OPTION',\n            message: 'You must supply \"output.name\" for UMD bundles.'\n        });\n    }\n    warnOnBuiltins(warn, dependencies);\n    const amdDeps = dependencies.map(m => `'${m.id}'`);\n    const cjsDeps = dependencies.map(m => `require('${m.id}')`);\n    const trimmedImports = trimEmptyImports(dependencies);\n    const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar));\n    const factoryArgs = trimmedImports.map(m => m.name);\n    if (namedExportsMode && (hasExports || options.noConflict === true)) {\n        amdDeps.unshift(`'exports'`);\n        cjsDeps.unshift(`exports`);\n        globalDeps.unshift(assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${options.extend ? `${globalProp(options.name, globalVar)}${_}||${_}` : ''}{}`));\n        factoryArgs.unshift('exports');\n    }\n    const amdOptions = options.amd || {};\n    const amdParams = (amdOptions.id ? `'${amdOptions.id}',${_}` : ``) +\n        (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);\n    const define = amdOptions.define || 'define';\n    const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;\n    const useStrict = options.strict !== false ? `${_}'use strict';${n}` : ``;\n    let iifeExport;\n    if (options.noConflict === true) {\n        const noConflictExportsVar = options.compact ? 'e' : 'exports';\n        let factory;\n        if (!namedExportsMode && hasExports) {\n            factory = `var ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(options.name, globalVar, options.globals, options.compact, `${factoryVar}(${globalDeps.join(`,${_}`)})`)};`;\n        }\n        else if (namedExportsMode) {\n            const module = globalDeps.shift();\n            factory =\n                `var ${noConflictExportsVar}${_}=${_}${module};${n}` +\n                    `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;\n        }\n        iifeExport =\n            `(function${_}()${_}{${n}` +\n                `${t}${t}var current${_}=${_}${safeAccess(options.name, globalVar, _)};${n}` +\n                `${t}${t}${factory}${n}` +\n                `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}function${_}()${_}{${_}` +\n                `${globalProp(options.name, globalVar)}${_}=${_}current;${_}return ${noConflictExportsVar}${options.compact ? '' : '; '}};${n}` +\n                `${t}}())`;\n    }\n    else {\n        iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;\n        if (!namedExportsMode && hasExports) {\n            iifeExport = assignToDeepVariable(options.name, globalVar, options.globals, options.compact, iifeExport);\n        }\n    }\n    const iifeNeedsGlobal = hasExports || (options.noConflict === true && namedExportsMode) || globalDeps.length > 0;\n    const globalParam = iifeNeedsGlobal ? `${globalVar},${_}` : '';\n    const globalArg = iifeNeedsGlobal ? `this,${_}` : '';\n    const iifeStart = iifeNeedsGlobal ? `(${globalVar}${_}=${_}${globalVar}${_}||${_}self,${_}` : '';\n    const iifeEnd = iifeNeedsGlobal ? ')' : '';\n    const cjsIntro = iifeNeedsGlobal\n        ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +\n            `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}`\n        : '';\n    // factory function should be wrapped by parentheses to avoid lazy parsing\n    const wrapperIntro = `(function${_}(${globalParam}${factoryVar})${_}{${n}` +\n        cjsIntro +\n        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` +\n        `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +\n        `}(${globalArg}(function${_}(${factoryArgs.join(', ')})${_}{${useStrict}${n}`;\n    const wrapperOutro = n + n + '})));';\n    // var foo__default = 'default' in foo ? foo['default'] : foo;\n    const interopBlock = getInteropBlock(dependencies, options, varOrConst);\n    if (interopBlock)\n        magicString.prepend(interopBlock + n + n);\n    if (intro)\n        magicString.prepend(intro);\n    const exportBlock = getExportBlock(exports, dependencies, namedExportsMode, options.interop, options.compact, t);\n    if (exportBlock)\n        magicString.append(n + n + exportBlock);\n    if (namedExportsMode && hasExports && options.esModule)\n        magicString.append(n + n + (options.compact ? compactEsModuleExport : esModuleExport));\n    if (outro)\n        magicString.append(outro);\n    return magicString\n        .trim()\n        .indent(t)\n        .append(wrapperOutro)\n        .prepend(wrapperIntro);\n}\n\nvar finalisers = { system, amd, cjs, es: esm, iife, umd };\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\nclass ExportAllDeclaration extends NodeBase {\n    hasEffects() {\n        return false;\n    }\n    initialise() {\n        this.context.addExport(this);\n    }\n    render(code, _options, nodeRenderOptions) {\n        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);\n    }\n}\nExportAllDeclaration.prototype.needsBoundaries = true;\n\nclass ArrayExpression extends NodeBase {\n    bind() {\n        super.bind();\n        for (const element of this.elements) {\n            if (element !== null)\n                element.deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length !== 1)\n            return UNKNOWN_EXPRESSION;\n        return getMemberReturnExpressionWhenCalled(arrayMembers, path[0]);\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length === 1) {\n            return hasMemberEffectWhenCalled(arrayMembers, path[0], this.included, callOptions, context);\n        }\n        return true;\n    }\n}\n\nclass ArrayPattern extends NodeBase {\n    addExportedVariables(variables) {\n        for (const element of this.elements) {\n            if (element !== null) {\n                element.addExportedVariables(variables);\n            }\n        }\n    }\n    declare(kind) {\n        const variables = [];\n        for (const element of this.elements) {\n            if (element !== null) {\n                variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));\n            }\n        }\n        return variables;\n    }\n    deoptimizePath(path) {\n        if (path.length === 0) {\n            for (const element of this.elements) {\n                if (element !== null) {\n                    element.deoptimizePath(path);\n                }\n            }\n        }\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (path.length > 0)\n            return true;\n        for (const element of this.elements) {\n            if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))\n                return true;\n        }\n        return false;\n    }\n}\n\nclass BlockScope extends ChildScope {\n    addDeclaration(identifier, context, init = null, isHoisted) {\n        if (isHoisted) {\n            return this.parent.addDeclaration(identifier, context, isHoisted === 'function' ? init : UNKNOWN_EXPRESSION, isHoisted);\n        }\n        else {\n            return super.addDeclaration(identifier, context, init, false);\n        }\n    }\n}\n\nclass ExpressionStatement$1 extends NodeBase {\n    initialise() {\n        if (this.directive &&\n            this.directive !== 'use strict' &&\n            this.parent.type === Program) {\n            this.context.warn(\n            // This is necessary, because either way (deleting or not) can lead to errors.\n            {\n                code: 'MODULE_LEVEL_DIRECTIVE',\n                message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`\n            }, this.start);\n        }\n    }\n    render(code, options) {\n        super.render(code, options);\n        if (this.included)\n            this.insertSemicolon(code);\n    }\n    shouldBeIncluded(context) {\n        if (this.directive && this.directive !== 'use strict')\n            return this.parent.type !== Program;\n        return super.shouldBeIncluded(context);\n    }\n}\n\nclass BlockStatement$1 extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.directlyIncluded = false;\n    }\n    addImplicitReturnExpressionToScope() {\n        const lastStatement = this.body[this.body.length - 1];\n        if (!lastStatement || lastStatement.type !== ReturnStatement) {\n            this.scope.addReturnExpression(UNKNOWN_EXPRESSION);\n        }\n    }\n    createScope(parentScope) {\n        this.scope = this.parent.preventChildBlockScope\n            ? parentScope\n            : new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if (this.deoptimizeBody)\n            return true;\n        for (const node of this.body) {\n            if (node.hasEffects(context))\n                return true;\n            if (context.brokenFlow)\n                break;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimizeBody || !this.directlyIncluded) {\n            this.included = true;\n            this.directlyIncluded = true;\n            if (this.deoptimizeBody)\n                includeChildrenRecursively = true;\n            for (const node of this.body) {\n                if (includeChildrenRecursively || node.shouldBeIncluded(context))\n                    node.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    initialise() {\n        const firstBodyStatement = this.body[0];\n        this.deoptimizeBody =\n            firstBodyStatement instanceof ExpressionStatement$1 &&\n                firstBodyStatement.directive === 'use asm';\n    }\n    render(code, options) {\n        if (this.body.length) {\n            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\n\nclass ArrowFunctionExpression extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new ReturnValueScope(parentScope, this.context);\n    }\n    deoptimizePath(path) {\n        // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track\n        // which means the return expression needs to be reassigned\n        if (path.length === 1 && path[0] === UnknownKey) {\n            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        return path.length === 0 ? this.scope.getReturnExpression() : UNKNOWN_EXPRESSION;\n    }\n    hasEffects() {\n        return false;\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenAssignedAtPath(path) {\n        return path.length > 1;\n    }\n    hasEffectsWhenCalledAtPath(path, _callOptions, context) {\n        if (path.length > 0)\n            return true;\n        for (const param of this.params) {\n            if (param.hasEffects(context))\n                return true;\n        }\n        const { ignore, brokenFlow } = context;\n        context.ignore = {\n            breaks: false,\n            continues: false,\n            labels: new Set(),\n            returnAwaitYield: true\n        };\n        if (this.body.hasEffects(context))\n            return true;\n        context.ignore = ignore;\n        context.brokenFlow = brokenFlow;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (const param of this.params) {\n            if (!(param instanceof Identifier$1)) {\n                param.include(context, includeChildrenRecursively);\n            }\n        }\n        const { brokenFlow } = context;\n        context.brokenFlow = BROKEN_FLOW_NONE;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n    includeCallArguments(context, args) {\n        this.scope.includeCallArguments(context, args);\n    }\n    initialise() {\n        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);\n        if (this.body instanceof BlockStatement$1) {\n            this.body.addImplicitReturnExpressionToScope();\n        }\n        else {\n            this.scope.addReturnExpression(this.body);\n        }\n    }\n    parseNode(esTreeNode) {\n        if (esTreeNode.body.type === BlockStatement) {\n            this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);\n        }\n        super.parseNode(esTreeNode);\n    }\n}\nArrowFunctionExpression.prototype.preventChildBlockScope = true;\n\nfunction getSystemExportStatement(exportedVariables) {\n    if (exportedVariables.length === 1) {\n        return `exports('${exportedVariables[0].safeExportName ||\n            exportedVariables[0].exportName}', ${exportedVariables[0].getName()});`;\n    }\n    else {\n        return `exports({${exportedVariables\n            .map(variable => `${variable.safeExportName || variable.exportName}: ${variable.getName()}`)\n            .join(', ')}});`;\n    }\n}\n\nclass AssignmentExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.deoptimized = false;\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return (this.right.hasEffects(context) ||\n            this.left.hasEffects(context) ||\n            this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        return path.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        this.left.include(context, includeChildrenRecursively);\n        this.right.include(context, includeChildrenRecursively);\n    }\n    render(code, options) {\n        this.left.render(code, options);\n        this.right.render(code, options);\n        if (options.format === 'system') {\n            if (this.left.variable && this.left.variable.exportName) {\n                const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);\n                const operation = this.operator.length > 1\n                    ? ` ${this.left.variable.exportName} ${this.operator.slice(0, -1)}`\n                    : '';\n                code.overwrite(operatorPos, operatorPos + this.operator.length, `= exports('${this.left.variable.exportName}',${operation}`);\n                code.appendLeft(this.right.end, `)`);\n            }\n            else if ('addExportedVariables' in this.left) {\n                const systemPatternExports = [];\n                this.left.addExportedVariables(systemPatternExports);\n                if (systemPatternExports.length > 0) {\n                    code.prependRight(this.start, `function (v) {${getSystemExportStatement(systemPatternExports)} return v;} (`);\n                    code.appendLeft(this.end, ')');\n                }\n            }\n        }\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.deoptimizePath(UNKNOWN_PATH);\n    }\n}\n\nclass AssignmentPattern extends NodeBase {\n    addExportedVariables(variables) {\n        this.left.addExportedVariables(variables);\n    }\n    bind() {\n        super.bind();\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.deoptimizePath(UNKNOWN_PATH);\n    }\n    declare(kind, init) {\n        return this.left.declare(kind, init);\n    }\n    deoptimizePath(path) {\n        path.length === 0 && this.left.deoptimizePath(path);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        return path.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);\n    }\n    render(code, options, { isShorthandProperty } = BLANK) {\n        this.left.render(code, options, { isShorthandProperty });\n        this.right.render(code, options);\n    }\n}\n\nclass AwaitExpression extends NodeBase {\n    hasEffects(context) {\n        return !context.ignore.returnAwaitYield || this.argument.hasEffects(context);\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.included) {\n            this.included = true;\n            checkTopLevelAwait: if (!this.context.usesTopLevelAwait) {\n                let parent = this.parent;\n                do {\n                    if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)\n                        break checkTopLevelAwait;\n                } while ((parent = parent.parent));\n                this.context.usesTopLevelAwait = true;\n            }\n        }\n        this.argument.include(context, includeChildrenRecursively);\n    }\n}\n\nconst binaryOperators = {\n    '!=': (left, right) => left != right,\n    '!==': (left, right) => left !== right,\n    '%': (left, right) => left % right,\n    '&': (left, right) => left & right,\n    '*': (left, right) => left * right,\n    // At the moment, \"**\" will be transpiled to Math.pow\n    '**': (left, right) => Math.pow(left, right),\n    '+': (left, right) => left + right,\n    '-': (left, right) => left - right,\n    '/': (left, right) => left / right,\n    '<': (left, right) => left < right,\n    '<<': (left, right) => left << right,\n    '<=': (left, right) => left <= right,\n    '==': (left, right) => left == right,\n    '===': (left, right) => left === right,\n    '>': (left, right) => left > right,\n    '>=': (left, right) => left >= right,\n    '>>': (left, right) => left >> right,\n    '>>>': (left, right) => left >>> right,\n    '^': (left, right) => left ^ right,\n    in: () => UnknownValue,\n    instanceof: () => UnknownValue,\n    '|': (left, right) => left | right\n};\nclass BinaryExpression extends NodeBase {\n    deoptimizeCache() { }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (path.length > 0)\n            return UnknownValue;\n        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n        if (leftValue === UnknownValue)\n            return UnknownValue;\n        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n        if (rightValue === UnknownValue)\n            return UnknownValue;\n        const operatorFn = binaryOperators[this.operator];\n        if (!operatorFn)\n            return UnknownValue;\n        return operatorFn(leftValue, rightValue);\n    }\n    hasEffects(context) {\n        // support some implicit type coercion runtime errors\n        if (this.operator === '+' &&\n            this.parent instanceof ExpressionStatement$1 &&\n            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '')\n            return true;\n        return super.hasEffects(context);\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n}\n\nclass BreakStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.label) {\n            if (!context.ignore.labels.has(this.label.name))\n                return true;\n            context.includedLabels.add(this.label.name);\n            context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n        }\n        else {\n            if (!context.ignore.breaks)\n                return true;\n            context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;\n        }\n        return false;\n    }\n    include(context) {\n        this.included = true;\n        if (this.label) {\n            this.label.include(context);\n            context.includedLabels.add(this.label.name);\n        }\n        context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;\n    }\n}\n\nclass Literal extends NodeBase {\n    getLiteralValueAtPath(path) {\n        if (path.length > 0 ||\n            // unknown literals can also be null but do not start with an \"n\"\n            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||\n            typeof this.value === 'bigint' ||\n            // to support shims for regular expressions\n            this.context.code.charCodeAt(this.start) === 47) {\n            return UnknownValue;\n        }\n        return this.value;\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length !== 1)\n            return UNKNOWN_EXPRESSION;\n        return getMemberReturnExpressionWhenCalled(this.members, path[0]);\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        if (this.value === null) {\n            return path.length > 0;\n        }\n        return path.length > 1;\n    }\n    hasEffectsWhenAssignedAtPath(path) {\n        return path.length > 0;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length === 1) {\n            return hasMemberEffectWhenCalled(this.members, path[0], this.included, callOptions, context);\n        }\n        return true;\n    }\n    initialise() {\n        this.members = getLiteralMembersForValue(this.value);\n    }\n    render(code) {\n        if (typeof this.value === 'string') {\n            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);\n        }\n    }\n}\n\nfunction getResolvablePropertyKey(memberExpression) {\n    return memberExpression.computed\n        ? getResolvableComputedPropertyKey(memberExpression.property)\n        : memberExpression.property.name;\n}\nfunction getResolvableComputedPropertyKey(propertyKey) {\n    if (propertyKey instanceof Literal) {\n        return String(propertyKey.value);\n    }\n    return null;\n}\nfunction getPathIfNotComputed(memberExpression) {\n    const nextPathKey = memberExpression.propertyKey;\n    const object = memberExpression.object;\n    if (typeof nextPathKey === 'string') {\n        if (object instanceof Identifier$1) {\n            return [\n                { key: object.name, pos: object.start },\n                { key: nextPathKey, pos: memberExpression.property.start }\n            ];\n        }\n        if (object instanceof MemberExpression) {\n            const parentPath = getPathIfNotComputed(object);\n            return (parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression.property.start }]);\n        }\n    }\n    return null;\n}\nfunction getStringFromPath(path) {\n    let pathString = path[0].key;\n    for (let index = 1; index < path.length; index++) {\n        pathString += '.' + path[index].key;\n    }\n    return pathString;\n}\nclass MemberExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.variable = null;\n        this.bound = false;\n        this.expressionsToBeDeoptimized = [];\n        this.replacement = null;\n        this.wasPathDeoptimizedWhileOptimized = false;\n    }\n    addExportedVariables() { }\n    bind() {\n        if (this.bound)\n            return;\n        this.bound = true;\n        const path = getPathIfNotComputed(this);\n        const baseVariable = path && this.scope.findVariable(path[0].key);\n        if (baseVariable && baseVariable.isNamespace) {\n            const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path.slice(1));\n            if (!resolvedVariable) {\n                super.bind();\n            }\n            else if (typeof resolvedVariable === 'string') {\n                this.replacement = resolvedVariable;\n            }\n            else {\n                if (resolvedVariable instanceof ExternalVariable && resolvedVariable.module) {\n                    resolvedVariable.module.suggestName(path[0].key);\n                }\n                this.variable = resolvedVariable;\n                this.scope.addNamespaceMemberAccess(getStringFromPath(path), resolvedVariable);\n            }\n        }\n        else {\n            super.bind();\n            // ensure the propertyKey is set for the tree-shaking passes\n            this.getPropertyKey();\n        }\n    }\n    deoptimizeCache() {\n        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n        this.expressionsToBeDeoptimized = [];\n        this.propertyKey = UnknownKey;\n        if (this.wasPathDeoptimizedWhileOptimized) {\n            this.object.deoptimizePath(UNKNOWN_PATH);\n        }\n        for (const expression of expressionsToBeDeoptimized) {\n            expression.deoptimizeCache();\n        }\n    }\n    deoptimizePath(path) {\n        if (!this.bound)\n            this.bind();\n        if (path.length === 0)\n            this.disallowNamespaceReassignment();\n        if (this.variable) {\n            this.variable.deoptimizePath(path);\n        }\n        else {\n            const propertyKey = this.getPropertyKey();\n            if (propertyKey === UnknownKey) {\n                this.object.deoptimizePath(UNKNOWN_PATH);\n            }\n            else {\n                this.wasPathDeoptimizedWhileOptimized = true;\n                this.object.deoptimizePath([propertyKey, ...path]);\n            }\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (!this.bound)\n            this.bind();\n        if (this.variable !== null) {\n            return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);\n        }\n        this.expressionsToBeDeoptimized.push(origin);\n        return this.object.getLiteralValueAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        if (!this.bound)\n            this.bind();\n        if (this.variable !== null) {\n            return this.variable.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n        }\n        this.expressionsToBeDeoptimized.push(origin);\n        return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);\n    }\n    hasEffects(context) {\n        return (this.property.hasEffects(context) ||\n            this.object.hasEffects(context) ||\n            (this.context.propertyReadSideEffects &&\n                this.object.hasEffectsWhenAccessedAtPath([this.propertyKey], context)));\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (path.length === 0)\n            return false;\n        if (this.variable !== null) {\n            return this.variable.hasEffectsWhenAccessedAtPath(path, context);\n        }\n        return this.object.hasEffectsWhenAccessedAtPath([this.propertyKey, ...path], context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (this.variable !== null) {\n            return this.variable.hasEffectsWhenAssignedAtPath(path, context);\n        }\n        return this.object.hasEffectsWhenAssignedAtPath([this.propertyKey, ...path], context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (this.variable !== null) {\n            return this.variable.hasEffectsWhenCalledAtPath(path, callOptions, context);\n        }\n        return this.object.hasEffectsWhenCalledAtPath([this.propertyKey, ...path], callOptions, context);\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.included) {\n            this.included = true;\n            if (this.variable !== null) {\n                this.context.includeVariable(context, this.variable);\n            }\n        }\n        this.object.include(context, includeChildrenRecursively);\n        this.property.include(context, includeChildrenRecursively);\n    }\n    includeCallArguments(context, args) {\n        if (this.variable) {\n            this.variable.includeCallArguments(context, args);\n        }\n        else {\n            super.includeCallArguments(context, args);\n        }\n    }\n    initialise() {\n        this.propertyKey = getResolvablePropertyKey(this);\n    }\n    render(code, options, { renderedParentType, isCalleeOfRenderedParent } = BLANK) {\n        const isCalleeOfDifferentParent = renderedParentType === CallExpression && isCalleeOfRenderedParent;\n        if (this.variable || this.replacement) {\n            let replacement = this.variable ? this.variable.getName() : this.replacement;\n            if (isCalleeOfDifferentParent)\n                replacement = '0, ' + replacement;\n            code.overwrite(this.start, this.end, replacement, {\n                contentOnly: true,\n                storeName: true\n            });\n        }\n        else {\n            if (isCalleeOfDifferentParent) {\n                code.appendRight(this.start, '0, ');\n            }\n            super.render(code, options);\n        }\n    }\n    disallowNamespaceReassignment() {\n        if (this.object instanceof Identifier$1 &&\n            this.scope.findVariable(this.object.name).isNamespace) {\n            return this.context.error({\n                code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',\n                message: `Illegal reassignment to import '${this.object.name}'`\n            }, this.start);\n        }\n    }\n    getPropertyKey() {\n        if (this.propertyKey === null) {\n            this.propertyKey = UnknownKey;\n            const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n            return (this.propertyKey = value === UnknownValue ? UnknownKey : String(value));\n        }\n        return this.propertyKey;\n    }\n    resolveNamespaceVariables(baseVariable, path) {\n        if (path.length === 0)\n            return baseVariable;\n        if (!baseVariable.isNamespace)\n            return null;\n        const exportName = path[0].key;\n        const variable = baseVariable instanceof ExternalVariable\n            ? baseVariable.module.getVariableForExportName(exportName)\n            : baseVariable.context.traceExport(exportName);\n        if (!variable) {\n            const fileName = baseVariable instanceof ExternalVariable\n                ? baseVariable.module.id\n                : baseVariable.context.fileName;\n            this.context.warn({\n                code: 'MISSING_EXPORT',\n                exporter: relativeId(fileName),\n                importer: relativeId(this.context.fileName),\n                message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,\n                missing: exportName,\n                url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`\n            }, path[0].pos);\n            return 'undefined';\n        }\n        return this.resolveNamespaceVariables(variable, path.slice(1));\n    }\n}\n\nclass CallExpression$1 extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.expressionsToBeDeoptimized = [];\n        this.returnExpression = null;\n        this.wasPathDeoptmizedWhileOptimized = false;\n    }\n    bind() {\n        super.bind();\n        if (this.callee instanceof Identifier$1) {\n            const variable = this.scope.findVariable(this.callee.name);\n            if (variable.isNamespace) {\n                return this.context.error({\n                    code: 'CANNOT_CALL_NAMESPACE',\n                    message: `Cannot call a namespace ('${this.callee.name}')`\n                }, this.start);\n            }\n            if (this.callee.name === 'eval') {\n                this.context.warn({\n                    code: 'EVAL',\n                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,\n                    url: 'https://rollupjs.org/guide/en/#avoiding-eval'\n                }, this.start);\n            }\n        }\n        // ensure the returnExpression is set for the tree-shaking passes\n        this.getReturnExpression(SHARED_RECURSION_TRACKER);\n        // This deoptimizes \"this\" for non-namespace calls until we have a better solution\n        if (this.callee instanceof MemberExpression && !this.callee.variable) {\n            this.callee.object.deoptimizePath(UNKNOWN_PATH);\n        }\n        for (const argument of this.arguments) {\n            // This will make sure all properties of parameters behave as \"unknown\"\n            argument.deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    deoptimizeCache() {\n        if (this.returnExpression !== UNKNOWN_EXPRESSION) {\n            this.returnExpression = null;\n            const returnExpression = this.getReturnExpression(SHARED_RECURSION_TRACKER);\n            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n            if (returnExpression !== UNKNOWN_EXPRESSION) {\n                // We need to replace here because is possible new expressions are added\n                // while we are deoptimizing the old ones\n                this.expressionsToBeDeoptimized = [];\n                if (this.wasPathDeoptmizedWhileOptimized) {\n                    returnExpression.deoptimizePath(UNKNOWN_PATH);\n                    this.wasPathDeoptmizedWhileOptimized = false;\n                }\n            }\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length === 0)\n            return;\n        const trackedEntities = this.context.deoptimizationTracker.getEntities(path);\n        if (trackedEntities.has(this))\n            return;\n        trackedEntities.add(this);\n        const returnExpression = this.getReturnExpression(SHARED_RECURSION_TRACKER);\n        if (returnExpression !== UNKNOWN_EXPRESSION) {\n            this.wasPathDeoptmizedWhileOptimized = true;\n            returnExpression.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const returnExpression = this.getReturnExpression(recursionTracker);\n        if (returnExpression === UNKNOWN_EXPRESSION) {\n            return UnknownValue;\n        }\n        const trackedEntities = recursionTracker.getEntities(path);\n        if (trackedEntities.has(returnExpression)) {\n            return UnknownValue;\n        }\n        this.expressionsToBeDeoptimized.push(origin);\n        trackedEntities.add(returnExpression);\n        const value = returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);\n        trackedEntities.delete(returnExpression);\n        return value;\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        const returnExpression = this.getReturnExpression(recursionTracker);\n        if (this.returnExpression === UNKNOWN_EXPRESSION) {\n            return UNKNOWN_EXPRESSION;\n        }\n        const trackedEntities = recursionTracker.getEntities(path);\n        if (trackedEntities.has(returnExpression)) {\n            return UNKNOWN_EXPRESSION;\n        }\n        this.expressionsToBeDeoptimized.push(origin);\n        trackedEntities.add(returnExpression);\n        const value = returnExpression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n        trackedEntities.delete(returnExpression);\n        return value;\n    }\n    hasEffects(context) {\n        for (const argument of this.arguments) {\n            if (argument.hasEffects(context))\n                return true;\n        }\n        if (this.context.annotations && this.annotatedPure)\n            return false;\n        return (this.callee.hasEffects(context) ||\n            this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (path.length === 0)\n            return false;\n        const trackedExpressions = context.accessed.getEntities(path);\n        if (trackedExpressions.has(this))\n            return false;\n        trackedExpressions.add(this);\n        return this.returnExpression.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (path.length === 0)\n            return true;\n        const trackedExpressions = context.assigned.getEntities(path);\n        if (trackedExpressions.has(this))\n            return false;\n        trackedExpressions.add(this);\n        return this.returnExpression.hasEffectsWhenAssignedAtPath(path, context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        const trackedExpressions = (callOptions.withNew\n            ? context.instantiated\n            : context.called).getEntities(path);\n        if (trackedExpressions.has(this))\n            return false;\n        trackedExpressions.add(this);\n        return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n    include(context, includeChildrenRecursively) {\n        if (includeChildrenRecursively) {\n            super.include(context, includeChildrenRecursively);\n            if (includeChildrenRecursively === INCLUDE_PARAMETERS &&\n                this.callee instanceof Identifier$1 &&\n                this.callee.variable) {\n                this.callee.variable.markCalledFromTryStatement();\n            }\n        }\n        else {\n            this.included = true;\n            this.callee.include(context, false);\n        }\n        this.callee.includeCallArguments(context, this.arguments);\n        if (!this.returnExpression.included) {\n            this.returnExpression.include(context, false);\n        }\n    }\n    initialise() {\n        this.callOptions = {\n            args: this.arguments,\n            withNew: false\n        };\n    }\n    render(code, options, { renderedParentType } = BLANK) {\n        this.callee.render(code, options);\n        if (this.arguments.length > 0) {\n            if (this.arguments[this.arguments.length - 1].included) {\n                for (const arg of this.arguments) {\n                    arg.render(code, options);\n                }\n            }\n            else {\n                let lastIncludedIndex = this.arguments.length - 2;\n                while (lastIncludedIndex >= 0 && !this.arguments[lastIncludedIndex].included) {\n                    lastIncludedIndex--;\n                }\n                if (lastIncludedIndex >= 0) {\n                    for (let index = 0; index <= lastIncludedIndex; index++) {\n                        this.arguments[index].render(code, options);\n                    }\n                    code.remove(findFirstOccurrenceOutsideComment(code.original, ',', this.arguments[lastIncludedIndex].end), this.end - 1);\n                }\n                else {\n                    code.remove(findFirstOccurrenceOutsideComment(code.original, '(', this.callee.end) + 1, this.end - 1);\n                }\n            }\n        }\n        if (renderedParentType === ExpressionStatement &&\n            this.callee.type === FunctionExpression) {\n            code.appendRight(this.start, '(');\n            code.prependLeft(this.end, ')');\n        }\n    }\n    getReturnExpression(recursionTracker) {\n        if (this.returnExpression === null) {\n            this.returnExpression = UNKNOWN_EXPRESSION;\n            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, recursionTracker, this));\n        }\n        return this.returnExpression;\n    }\n}\n\nclass CatchScope extends ParameterScope {\n    addDeclaration(identifier, context, init, isHoisted) {\n        if (isHoisted) {\n            return this.parent.addDeclaration(identifier, context, init, isHoisted);\n        }\n        else {\n            return super.addDeclaration(identifier, context, init, false);\n        }\n    }\n}\n\nclass CatchClause extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new CatchScope(parentScope, this.context);\n    }\n    initialise() {\n        if (this.param) {\n            this.param.declare('parameter', UNKNOWN_EXPRESSION);\n        }\n    }\n    parseNode(esTreeNode) {\n        this.body = new this.context.nodeConstructors.BlockStatement(esTreeNode.body, this, this.scope);\n        super.parseNode(esTreeNode);\n    }\n}\nCatchClause.prototype.preventChildBlockScope = true;\n\nclass ClassBody extends NodeBase {\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (path.length > 0)\n            return true;\n        return (this.classConstructor !== null &&\n            this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context));\n    }\n    initialise() {\n        for (const method of this.body) {\n            if (method.kind === 'constructor') {\n                this.classConstructor = method;\n                return;\n            }\n        }\n        this.classConstructor = null;\n    }\n}\n\nclass ClassExpression extends ClassNode {\n}\n\nclass MultiExpression {\n    constructor(expressions) {\n        this.included = false;\n        this.expressions = expressions;\n    }\n    deoptimizePath(path) {\n        for (const expression of this.expressions) {\n            expression.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath() {\n        return UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)));\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        for (const expression of this.expressions) {\n            if (expression.hasEffectsWhenAccessedAtPath(path, context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        for (const expression of this.expressions) {\n            if (expression.hasEffectsWhenAssignedAtPath(path, context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        for (const expression of this.expressions) {\n            if (expression.hasEffectsWhenCalledAtPath(path, callOptions, context))\n                return true;\n        }\n        return false;\n    }\n    include() { }\n    includeCallArguments() { }\n}\n\nclass ConditionalExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.expressionsToBeDeoptimized = [];\n        this.isBranchResolutionAnalysed = false;\n        this.usedBranch = null;\n        this.wasPathDeoptimizedWhileOptimized = false;\n    }\n    bind() {\n        super.bind();\n        // ensure the usedBranch is set for the tree-shaking passes\n        this.getUsedBranch();\n    }\n    deoptimizeCache() {\n        if (this.usedBranch !== null) {\n            const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;\n            this.usedBranch = null;\n            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n            this.expressionsToBeDeoptimized = [];\n            if (this.wasPathDeoptimizedWhileOptimized) {\n                unusedBranch.deoptimizePath(UNKNOWN_PATH);\n            }\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length > 0) {\n            const usedBranch = this.getUsedBranch();\n            if (usedBranch === null) {\n                this.consequent.deoptimizePath(path);\n                this.alternate.deoptimizePath(path);\n            }\n            else {\n                this.wasPathDeoptimizedWhileOptimized = true;\n                usedBranch.deoptimizePath(path);\n            }\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch === null)\n            return UnknownValue;\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch === null)\n            return new MultiExpression([\n                this.consequent.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin),\n                this.alternate.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)\n            ]);\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        if (this.test.hasEffects(context))\n            return true;\n        if (this.usedBranch === null) {\n            return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);\n        }\n        return this.usedBranch.hasEffects(context);\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (path.length === 0)\n            return false;\n        if (this.usedBranch === null) {\n            return (this.consequent.hasEffectsWhenAccessedAtPath(path, context) ||\n                this.alternate.hasEffectsWhenAccessedAtPath(path, context));\n        }\n        return this.usedBranch.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (path.length === 0)\n            return true;\n        if (this.usedBranch === null) {\n            return (this.consequent.hasEffectsWhenAssignedAtPath(path, context) ||\n                this.alternate.hasEffectsWhenAssignedAtPath(path, context));\n        }\n        return this.usedBranch.hasEffectsWhenAssignedAtPath(path, context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (this.usedBranch === null) {\n            return (this.consequent.hasEffectsWhenCalledAtPath(path, callOptions, context) ||\n                this.alternate.hasEffectsWhenCalledAtPath(path, callOptions, context));\n        }\n        return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (includeChildrenRecursively ||\n            this.test.shouldBeIncluded(context) ||\n            this.usedBranch === null) {\n            this.test.include(context, includeChildrenRecursively);\n            this.consequent.include(context, includeChildrenRecursively);\n            this.alternate.include(context, includeChildrenRecursively);\n        }\n        else {\n            this.usedBranch.include(context, includeChildrenRecursively);\n        }\n    }\n    render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {\n        if (!this.test.included) {\n            const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);\n            const inclusionStart = (this.consequent.included\n                ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end)\n                : colonPos) + 1;\n            if (preventASI) {\n                removeLineBreaks(code, inclusionStart, this.usedBranch.start);\n            }\n            code.remove(this.start, inclusionStart);\n            if (this.consequent.included) {\n                code.remove(colonPos, this.end);\n            }\n            removeAnnotations(this, code);\n            this.usedBranch.render(code, options, {\n                isCalleeOfRenderedParent: renderedParentType\n                    ? isCalleeOfRenderedParent\n                    : this.parent.callee === this,\n                renderedParentType: renderedParentType || this.parent.type\n            });\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n    getUsedBranch() {\n        if (this.isBranchResolutionAnalysed) {\n            return this.usedBranch;\n        }\n        this.isBranchResolutionAnalysed = true;\n        const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n        return testValue === UnknownValue\n            ? null\n            : (this.usedBranch = testValue ? this.consequent : this.alternate);\n    }\n}\n\nclass ContinueStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.label) {\n            if (!context.ignore.labels.has(this.label.name))\n                return true;\n            context.includedLabels.add(this.label.name);\n            context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n        }\n        else {\n            if (!context.ignore.continues)\n                return true;\n            context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;\n        }\n        return false;\n    }\n    include(context) {\n        this.included = true;\n        if (this.label) {\n            this.label.include(context);\n            context.includedLabels.add(this.label.name);\n        }\n        context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;\n    }\n}\n\nclass DoWhileStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.test.hasEffects(context))\n            return true;\n        const { brokenFlow, ignore: { breaks, continues } } = context;\n        context.ignore.breaks = true;\n        context.ignore.continues = true;\n        if (this.body.hasEffects(context))\n            return true;\n        context.ignore.breaks = breaks;\n        context.ignore.continues = continues;\n        context.brokenFlow = brokenFlow;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.test.include(context, includeChildrenRecursively);\n        const { brokenFlow } = context;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n}\n\nclass EmptyStatement extends NodeBase {\n    hasEffects() {\n        return false;\n    }\n}\n\nclass ExportNamedDeclaration extends NodeBase {\n    bind() {\n        // Do not bind specifiers\n        if (this.declaration !== null)\n            this.declaration.bind();\n    }\n    hasEffects(context) {\n        return this.declaration !== null && this.declaration.hasEffects(context);\n    }\n    initialise() {\n        this.context.addExport(this);\n    }\n    render(code, options, nodeRenderOptions) {\n        const { start, end } = nodeRenderOptions;\n        if (this.declaration === null) {\n            code.remove(start, end);\n        }\n        else {\n            code.remove(this.start, this.declaration.start);\n            this.declaration.render(code, options, { start, end });\n        }\n    }\n}\nExportNamedDeclaration.prototype.needsBoundaries = true;\n\nclass ForInStatement extends NodeBase {\n    bind() {\n        this.left.bind();\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.bind();\n        this.body.bind();\n    }\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if ((this.left &&\n            (this.left.hasEffects(context) ||\n                this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))) ||\n            (this.right && this.right.hasEffects(context)))\n            return true;\n        const { brokenFlow, ignore: { breaks, continues } } = context;\n        context.ignore.breaks = true;\n        context.ignore.continues = true;\n        if (this.body.hasEffects(context))\n            return true;\n        context.ignore.breaks = breaks;\n        context.ignore.continues = continues;\n        context.brokenFlow = brokenFlow;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.left.includeWithAllDeclaredVariables(includeChildrenRecursively, context);\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.include(context, includeChildrenRecursively);\n        const { brokenFlow } = context;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n    render(code, options) {\n        this.left.render(code, options, NO_SEMICOLON);\n        this.right.render(code, options, NO_SEMICOLON);\n        // handle no space between \"in\" and the right side\n        if (code.original.charCodeAt(this.right.start - 1) === 110 /* n */) {\n            code.prependLeft(this.right.start, ' ');\n        }\n        this.body.render(code, options);\n    }\n}\n\nclass ForOfStatement extends NodeBase {\n    bind() {\n        this.left.bind();\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.bind();\n        this.body.bind();\n    }\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects() {\n        // Placeholder until proper Symbol.Iterator support\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.left.includeWithAllDeclaredVariables(includeChildrenRecursively, context);\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.include(context, includeChildrenRecursively);\n        const { brokenFlow } = context;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n    render(code, options) {\n        this.left.render(code, options, NO_SEMICOLON);\n        this.right.render(code, options, NO_SEMICOLON);\n        // handle no space between \"of\" and the right side\n        if (code.original.charCodeAt(this.right.start - 1) === 102 /* f */) {\n            code.prependLeft(this.right.start, ' ');\n        }\n        this.body.render(code, options);\n    }\n}\n\nclass ForStatement extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if ((this.init && this.init.hasEffects(context)) ||\n            (this.test && this.test.hasEffects(context)) ||\n            (this.update && this.update.hasEffects(context)))\n            return true;\n        const { brokenFlow, ignore: { breaks, continues } } = context;\n        context.ignore.breaks = true;\n        context.ignore.continues = true;\n        if (this.body.hasEffects(context))\n            return true;\n        context.ignore.breaks = breaks;\n        context.ignore.continues = continues;\n        context.brokenFlow = brokenFlow;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (this.init)\n            this.init.include(context, includeChildrenRecursively);\n        if (this.test)\n            this.test.include(context, includeChildrenRecursively);\n        const { brokenFlow } = context;\n        if (this.update)\n            this.update.include(context, includeChildrenRecursively);\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n    render(code, options) {\n        if (this.init)\n            this.init.render(code, options, NO_SEMICOLON);\n        if (this.test)\n            this.test.render(code, options, NO_SEMICOLON);\n        if (this.update)\n            this.update.render(code, options, NO_SEMICOLON);\n        this.body.render(code, options);\n    }\n}\n\nclass FunctionExpression$1 extends FunctionNode {\n}\n\nconst unset = Symbol('unset');\nclass IfStatement extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.testValue = unset;\n    }\n    deoptimizeCache() {\n        this.testValue = UnknownValue;\n    }\n    hasEffects(context) {\n        if (this.test.hasEffects(context)) {\n            return true;\n        }\n        const testValue = this.getTestValue();\n        if (testValue === UnknownValue) {\n            const { brokenFlow } = context;\n            if (this.consequent.hasEffects(context))\n                return true;\n            const consequentBrokenFlow = context.brokenFlow;\n            context.brokenFlow = brokenFlow;\n            if (this.alternate === null)\n                return false;\n            if (this.alternate.hasEffects(context))\n                return true;\n            context.brokenFlow =\n                context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;\n            return false;\n        }\n        return testValue\n            ? this.consequent.hasEffects(context)\n            : this.alternate !== null && this.alternate.hasEffects(context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (includeChildrenRecursively) {\n            this.includeRecursively(includeChildrenRecursively, context);\n        }\n        else {\n            const testValue = this.getTestValue();\n            if (testValue === UnknownValue) {\n                this.includeUnknownTest(context);\n            }\n            else {\n                this.includeKnownTest(context, testValue);\n            }\n        }\n    }\n    render(code, options) {\n        // Note that unknown test values are always included\n        const testValue = this.getTestValue();\n        if (!this.test.included &&\n            (testValue ? this.alternate === null || !this.alternate.included : !this.consequent.included)) {\n            const singleRetainedBranch = (testValue ? this.consequent : this.alternate);\n            code.remove(this.start, singleRetainedBranch.start);\n            code.remove(singleRetainedBranch.end, this.end);\n            removeAnnotations(this, code);\n            singleRetainedBranch.render(code, options);\n        }\n        else {\n            if (this.test.included) {\n                this.test.render(code, options);\n            }\n            else {\n                code.overwrite(this.test.start, this.test.end, testValue ? 'true' : 'false');\n            }\n            if (this.consequent.included) {\n                this.consequent.render(code, options);\n            }\n            else {\n                code.overwrite(this.consequent.start, this.consequent.end, ';');\n            }\n            if (this.alternate !== null) {\n                if (this.alternate.included) {\n                    if (code.original.charCodeAt(this.alternate.start - 1) === 101 /* e */) {\n                        code.prependLeft(this.alternate.start, ' ');\n                    }\n                    this.alternate.render(code, options);\n                }\n                else {\n                    code.remove(this.consequent.end, this.alternate.end);\n                }\n            }\n        }\n    }\n    getTestValue() {\n        if (this.testValue === unset) {\n            return (this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));\n        }\n        return this.testValue;\n    }\n    includeKnownTest(context, testValue) {\n        if (this.test.shouldBeIncluded(context)) {\n            this.test.include(context, false);\n        }\n        if (testValue && this.consequent.shouldBeIncluded(context)) {\n            this.consequent.include(context, false);\n        }\n        if (this.alternate !== null && !testValue && this.alternate.shouldBeIncluded(context)) {\n            this.alternate.include(context, false);\n        }\n    }\n    includeRecursively(includeChildrenRecursively, context) {\n        this.test.include(context, includeChildrenRecursively);\n        this.consequent.include(context, includeChildrenRecursively);\n        if (this.alternate !== null) {\n            this.alternate.include(context, includeChildrenRecursively);\n        }\n    }\n    includeUnknownTest(context) {\n        this.test.include(context, false);\n        const { brokenFlow } = context;\n        let consequentBrokenFlow = BROKEN_FLOW_NONE;\n        if (this.consequent.shouldBeIncluded(context)) {\n            this.consequent.include(context, false);\n            consequentBrokenFlow = context.brokenFlow;\n            context.brokenFlow = brokenFlow;\n        }\n        if (this.alternate !== null && this.alternate.shouldBeIncluded(context)) {\n            this.alternate.include(context, false);\n            context.brokenFlow =\n                context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;\n        }\n    }\n}\n\nclass ImportDeclaration extends NodeBase {\n    bind() { }\n    hasEffects() {\n        return false;\n    }\n    initialise() {\n        this.context.addImport(this);\n    }\n    render(code, _options, nodeRenderOptions) {\n        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);\n    }\n}\nImportDeclaration.prototype.needsBoundaries = true;\n\nclass Import extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.exportMode = 'auto';\n    }\n    hasEffects() {\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.included) {\n            this.included = true;\n            this.context.includeDynamicImport(this);\n            this.scope.addAccessedDynamicImport(this);\n        }\n        this.source.include(context, includeChildrenRecursively);\n    }\n    initialise() {\n        this.context.addDynamicImport(this);\n    }\n    render(code, options) {\n        if (this.inlineNamespace) {\n            const _ = options.compact ? '' : ' ';\n            const s = options.compact ? '' : ';';\n            code.overwrite(this.start, this.end, `Promise.resolve().then(function${_}()${_}{${_}return ${this.inlineNamespace.getName()}${s}${_}})`);\n            return;\n        }\n        const importMechanism = this.getDynamicImportMechanism(options);\n        if (importMechanism) {\n            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, importMechanism.left);\n            code.overwrite(this.end - 1, this.end, importMechanism.right);\n        }\n        this.source.render(code, options);\n    }\n    renderFinalResolution(code, resolution, format) {\n        if (this.included) {\n            if (format === 'amd' && resolution.startsWith(\"'.\") && resolution.endsWith(\".js'\")) {\n                resolution = resolution.slice(0, -4) + \"'\";\n            }\n            code.overwrite(this.source.start, this.source.end, resolution);\n        }\n    }\n    setResolution(exportMode, inlineNamespace) {\n        this.exportMode = exportMode;\n        if (inlineNamespace) {\n            this.inlineNamespace = inlineNamespace;\n        }\n        else {\n            this.scope.addAccessedGlobalsByFormat({\n                amd: ['require'],\n                cjs: ['require'],\n                system: ['module']\n            });\n            if (exportMode === 'auto') {\n                this.scope.addAccessedGlobalsByFormat({\n                    amd: [INTEROP_NAMESPACE_VARIABLE],\n                    cjs: [INTEROP_NAMESPACE_VARIABLE]\n                });\n            }\n        }\n    }\n    getDynamicImportMechanism(options) {\n        switch (options.format) {\n            case 'cjs': {\n                const _ = options.compact ? '' : ' ';\n                const resolve = options.compact ? 'c' : 'resolve';\n                switch (this.exportMode) {\n                    case 'default':\n                        return {\n                            left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}({${_}'default':${_}require(`,\n                            right: `)${_}});${_}})`\n                        };\n                    case 'auto':\n                        return {\n                            left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}(${INTEROP_NAMESPACE_VARIABLE}(require(`,\n                            right: `)));${_}})`\n                        };\n                    default:\n                        return {\n                            left: `new Promise(function${_}(${resolve})${_}{${_}${resolve}(require(`,\n                            right: `));${_}})`\n                        };\n                }\n            }\n            case 'amd': {\n                const _ = options.compact ? '' : ' ';\n                const resolve = options.compact ? 'c' : 'resolve';\n                const reject = options.compact ? 'e' : 'reject';\n                const resolveNamespace = this.exportMode === 'default'\n                    ? `function${_}(m)${_}{${_}${resolve}({${_}'default':${_}m${_}});${_}}`\n                    : this.exportMode === 'auto'\n                        ? `function${_}(m)${_}{${_}${resolve}(${INTEROP_NAMESPACE_VARIABLE}(m));${_}}`\n                        : resolve;\n                return {\n                    left: `new Promise(function${_}(${resolve},${_}${reject})${_}{${_}require([`,\n                    right: `],${_}${resolveNamespace},${_}${reject})${_}})`\n                };\n            }\n            case 'system':\n                return {\n                    left: 'module.import(',\n                    right: ')'\n                };\n            case 'es':\n                if (options.dynamicImportFunction) {\n                    return {\n                        left: `${options.dynamicImportFunction}(`,\n                        right: ')'\n                    };\n                }\n        }\n        return null;\n    }\n}\n\nclass LabeledStatement extends NodeBase {\n    hasEffects(context) {\n        const brokenFlow = context.brokenFlow;\n        context.ignore.labels.add(this.label.name);\n        if (this.body.hasEffects(context))\n            return true;\n        context.ignore.labels.delete(this.label.name);\n        if (context.includedLabels.has(this.label.name)) {\n            context.includedLabels.delete(this.label.name);\n            context.brokenFlow = brokenFlow;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        const brokenFlow = context.brokenFlow;\n        this.body.include(context, includeChildrenRecursively);\n        if (context.includedLabels.has(this.label.name)) {\n            this.label.include(context);\n            context.includedLabels.delete(this.label.name);\n            context.brokenFlow = brokenFlow;\n        }\n    }\n    render(code, options) {\n        if (this.label.included) {\n            this.label.render(code, options);\n        }\n        else {\n            code.remove(this.start, findFirstOccurrenceOutsideComment(code.original, ':', this.label.end) + 1);\n        }\n        this.body.render(code, options);\n    }\n}\n\nclass LogicalExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        // We collect deoptimization information if usedBranch !== null\n        this.expressionsToBeDeoptimized = [];\n        this.isBranchResolutionAnalysed = false;\n        this.unusedBranch = null;\n        this.usedBranch = null;\n        this.wasPathDeoptimizedWhileOptimized = false;\n    }\n    bind() {\n        super.bind();\n        // ensure the usedBranch is set for the tree-shaking passes\n        this.getUsedBranch();\n    }\n    deoptimizeCache() {\n        if (this.usedBranch !== null) {\n            this.usedBranch = null;\n            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n            this.expressionsToBeDeoptimized = [];\n            if (this.wasPathDeoptimizedWhileOptimized) {\n                this.unusedBranch.deoptimizePath(UNKNOWN_PATH);\n            }\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n        }\n    }\n    deoptimizePath(path) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch === null) {\n            this.left.deoptimizePath(path);\n            this.right.deoptimizePath(path);\n        }\n        else {\n            this.wasPathDeoptimizedWhileOptimized = true;\n            usedBranch.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch === null)\n            return UnknownValue;\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch === null)\n            return new MultiExpression([\n                this.left.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin),\n                this.right.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin)\n            ]);\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        if (this.usedBranch === null) {\n            return this.left.hasEffects(context) || this.right.hasEffects(context);\n        }\n        return this.usedBranch.hasEffects(context);\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (path.length === 0)\n            return false;\n        if (this.usedBranch === null) {\n            return (this.left.hasEffectsWhenAccessedAtPath(path, context) ||\n                this.right.hasEffectsWhenAccessedAtPath(path, context));\n        }\n        return this.usedBranch.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (path.length === 0)\n            return true;\n        if (this.usedBranch === null) {\n            return (this.left.hasEffectsWhenAssignedAtPath(path, context) ||\n                this.right.hasEffectsWhenAssignedAtPath(path, context));\n        }\n        return this.usedBranch.hasEffectsWhenAssignedAtPath(path, context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (this.usedBranch === null) {\n            return (this.left.hasEffectsWhenCalledAtPath(path, callOptions, context) ||\n                this.right.hasEffectsWhenCalledAtPath(path, callOptions, context));\n        }\n        return this.usedBranch.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (includeChildrenRecursively ||\n            (this.usedBranch === this.right && this.left.shouldBeIncluded(context)) ||\n            this.usedBranch === null) {\n            this.left.include(context, includeChildrenRecursively);\n            this.right.include(context, includeChildrenRecursively);\n        }\n        else {\n            this.usedBranch.include(context, includeChildrenRecursively);\n        }\n    }\n    render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {\n        if (!this.left.included || !this.right.included) {\n            const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);\n            if (this.right.included) {\n                code.remove(this.start, operatorPos + 2);\n                if (preventASI) {\n                    removeLineBreaks(code, operatorPos + 2, this.right.start);\n                }\n            }\n            else {\n                code.remove(operatorPos, this.end);\n            }\n            removeAnnotations(this, code);\n            this.usedBranch.render(code, options, {\n                isCalleeOfRenderedParent: renderedParentType\n                    ? isCalleeOfRenderedParent\n                    : this.parent.callee === this,\n                renderedParentType: renderedParentType || this.parent.type\n            });\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n    getUsedBranch() {\n        if (!this.isBranchResolutionAnalysed) {\n            this.isBranchResolutionAnalysed = true;\n            const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n            if (leftValue === UnknownValue) {\n                return null;\n            }\n            else {\n                if (this.operator === '||' ? leftValue : !leftValue) {\n                    this.usedBranch = this.left;\n                    this.unusedBranch = this.right;\n                }\n                else {\n                    this.usedBranch = this.right;\n                    this.unusedBranch = this.left;\n                }\n            }\n        }\n        return this.usedBranch;\n    }\n}\n\nconst readFile = (file) => new Promise((fulfil, reject) => readFile$1(file, 'utf-8', (err, contents) => (err ? reject(err) : fulfil(contents))));\nfunction mkdirpath(path) {\n    const dir = dirname(path);\n    try {\n        readdirSync(dir);\n    }\n    catch (err) {\n        mkdirpath(dir);\n        try {\n            mkdirSync(dir);\n        }\n        catch (err2) {\n            if (err2.code !== 'EEXIST') {\n                throw err2;\n            }\n        }\n    }\n}\nfunction writeFile(dest, data) {\n    return new Promise((fulfil, reject) => {\n        mkdirpath(dest);\n        writeFile$1(dest, data, err => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                fulfil();\n            }\n        });\n    });\n}\n\nfunction getRollupDefaultPlugin(preserveSymlinks) {\n    return {\n        name: 'Rollup Core',\n        resolveId: createResolveId(preserveSymlinks),\n        load(id) {\n            return readFile(id);\n        },\n        resolveFileUrl({ relativePath, format }) {\n            return relativeUrlMechanisms[format](relativePath);\n        },\n        resolveImportMeta(prop, { chunkId, format }) {\n            const mechanism = importMetaMechanisms[format] && importMetaMechanisms[format](prop, chunkId);\n            if (mechanism) {\n                return mechanism;\n            }\n        }\n    };\n}\nfunction findFile(file, preserveSymlinks) {\n    try {\n        const stats = lstatSync(file);\n        if (!preserveSymlinks && stats.isSymbolicLink())\n            return findFile(realpathSync(file), preserveSymlinks);\n        if ((preserveSymlinks && stats.isSymbolicLink()) || stats.isFile()) {\n            // check case\n            const name = basename(file);\n            const files = readdirSync(dirname(file));\n            if (files.indexOf(name) !== -1)\n                return file;\n        }\n    }\n    catch (err) {\n        // suppress\n    }\n}\nfunction addJsExtensionIfNecessary(file, preserveSymlinks) {\n    let found = findFile(file, preserveSymlinks);\n    if (found)\n        return found;\n    found = findFile(file + '.mjs', preserveSymlinks);\n    if (found)\n        return found;\n    found = findFile(file + '.js', preserveSymlinks);\n    return found;\n}\nfunction createResolveId(preserveSymlinks) {\n    return function (source, importer) {\n        if (typeof process === 'undefined') {\n            return error({\n                code: 'MISSING_PROCESS',\n                message: `It looks like you're using Rollup in a non-Node.js environment. This means you must supply a plugin with custom resolveId and load functions`,\n                url: 'https://rollupjs.org/guide/en/#a-simple-example'\n            });\n        }\n        // external modules (non-entry modules that start with neither '.' or '/')\n        // are skipped at this stage.\n        if (importer !== undefined && !isAbsolute(source) && source[0] !== '.')\n            return null;\n        // `resolve` processes paths from right to left, prepending them until an\n        // absolute path is created. Absolute importees therefore shortcircuit the\n        // resolve call and require no special handing on our part.\n        // See https://nodejs.org/api/path.html#path_path_resolve_paths\n        return addJsExtensionIfNecessary(resolve(importer ? dirname(importer) : resolve(), source), preserveSymlinks);\n    };\n}\nconst getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;\nconst getUrlFromDocument = (chunkId) => `(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;\nconst getGenericImportMetaMechanism = (getUrl) => (prop, chunkId) => {\n    const urlMechanism = getUrl(chunkId);\n    return prop === null ? `({ url: ${urlMechanism} })` : prop === 'url' ? urlMechanism : 'undefined';\n};\nconst importMetaMechanisms = {\n    amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),\n    cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),\n    iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),\n    system: prop => (prop === null ? `module.meta` : `module.meta.${prop}`),\n    umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`)\n};\nconst getRelativeUrlFromDocument = (relativePath) => getResolveUrl(`'${relativePath}', document.currentScript && document.currentScript.src || document.baseURI`);\nconst relativeUrlMechanisms = {\n    amd: relativePath => {\n        if (relativePath[0] !== '.')\n            relativePath = './' + relativePath;\n        return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);\n    },\n    cjs: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,\n    es: relativePath => getResolveUrl(`'${relativePath}', import.meta.url`),\n    iife: relativePath => getRelativeUrlFromDocument(relativePath),\n    system: relativePath => getResolveUrl(`'${relativePath}', module.meta.url`),\n    umd: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`\n};\nconst accessedMetaUrlGlobals = {\n    amd: ['document', 'module', 'URL'],\n    cjs: ['document', 'require', 'URL'],\n    iife: ['document', 'URL'],\n    system: ['module'],\n    umd: ['document', 'require', 'URL']\n};\nconst accessedFileUrlGlobals = {\n    amd: ['document', 'require', 'URL'],\n    cjs: ['document', 'require', 'URL'],\n    iife: ['document', 'URL'],\n    system: ['module', 'URL'],\n    umd: ['document', 'require', 'URL']\n};\n\nconst ASSET_PREFIX = 'ROLLUP_ASSET_URL_';\nconst CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';\nconst FILE_PREFIX = 'ROLLUP_FILE_URL_';\nclass MetaProperty extends NodeBase {\n    hasEffects() {\n        return false;\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    include() {\n        if (!this.included) {\n            this.included = true;\n            const parent = this.parent;\n            const metaProperty = (this.metaProperty =\n                parent instanceof MemberExpression && typeof parent.propertyKey === 'string'\n                    ? parent.propertyKey\n                    : null);\n            if (metaProperty &&\n                (metaProperty.startsWith(FILE_PREFIX) ||\n                    metaProperty.startsWith(ASSET_PREFIX) ||\n                    metaProperty.startsWith(CHUNK_PREFIX))) {\n                this.scope.addAccessedGlobalsByFormat(accessedFileUrlGlobals);\n            }\n            else {\n                this.scope.addAccessedGlobalsByFormat(accessedMetaUrlGlobals);\n            }\n        }\n    }\n    initialise() {\n        if (this.meta.name === 'import') {\n            this.context.addImportMeta(this);\n        }\n    }\n    renderFinalMechanism(code, chunkId, format, outputPluginDriver) {\n        if (!this.included)\n            return;\n        const parent = this.parent;\n        const metaProperty = this.metaProperty;\n        if (metaProperty &&\n            (metaProperty.startsWith(FILE_PREFIX) ||\n                metaProperty.startsWith(ASSET_PREFIX) ||\n                metaProperty.startsWith(CHUNK_PREFIX))) {\n            let referenceId = null;\n            let assetReferenceId = null;\n            let chunkReferenceId = null;\n            let fileName;\n            if (metaProperty.startsWith(FILE_PREFIX)) {\n                referenceId = metaProperty.substr(FILE_PREFIX.length);\n                fileName = outputPluginDriver.getFileName(referenceId);\n            }\n            else if (metaProperty.startsWith(ASSET_PREFIX)) {\n                this.context.warnDeprecation(`Using the \"${ASSET_PREFIX}\" prefix to reference files is deprecated. Use the \"${FILE_PREFIX}\" prefix instead.`, false);\n                assetReferenceId = metaProperty.substr(ASSET_PREFIX.length);\n                fileName = outputPluginDriver.getFileName(assetReferenceId);\n            }\n            else {\n                this.context.warnDeprecation(`Using the \"${CHUNK_PREFIX}\" prefix to reference files is deprecated. Use the \"${FILE_PREFIX}\" prefix instead.`, false);\n                chunkReferenceId = metaProperty.substr(CHUNK_PREFIX.length);\n                fileName = outputPluginDriver.getFileName(chunkReferenceId);\n            }\n            const relativePath = normalize(relative$1(dirname(chunkId), fileName));\n            let replacement;\n            if (assetReferenceId !== null) {\n                replacement = outputPluginDriver.hookFirstSync('resolveAssetUrl', [\n                    {\n                        assetFileName: fileName,\n                        chunkId,\n                        format,\n                        moduleId: this.context.module.id,\n                        relativeAssetPath: relativePath\n                    }\n                ]);\n            }\n            if (!replacement) {\n                replacement = outputPluginDriver.hookFirstSync('resolveFileUrl', [\n                    {\n                        assetReferenceId,\n                        chunkId,\n                        chunkReferenceId,\n                        fileName,\n                        format,\n                        moduleId: this.context.module.id,\n                        referenceId: referenceId || assetReferenceId || chunkReferenceId,\n                        relativePath\n                    }\n                ]);\n            }\n            code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });\n            return;\n        }\n        const replacement = outputPluginDriver.hookFirstSync('resolveImportMeta', [\n            metaProperty,\n            {\n                chunkId,\n                format,\n                moduleId: this.context.module.id\n            }\n        ]);\n        if (typeof replacement === 'string') {\n            if (parent instanceof MemberExpression) {\n                code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });\n            }\n            else {\n                code.overwrite(this.start, this.end, replacement, { contentOnly: true });\n            }\n        }\n    }\n}\n\nclass MethodDefinition extends NodeBase {\n    hasEffects(context) {\n        return this.key.hasEffects(context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        return (path.length > 0 || this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context));\n    }\n}\n\nclass NewExpression extends NodeBase {\n    bind() {\n        super.bind();\n        for (const argument of this.arguments) {\n            // This will make sure all properties of parameters behave as \"unknown\"\n            argument.deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    hasEffects(context) {\n        for (const argument of this.arguments) {\n            if (argument.hasEffects(context))\n                return true;\n        }\n        if (this.context.annotations && this.annotatedPure)\n            return false;\n        return (this.callee.hasEffects(context) ||\n            this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    initialise() {\n        this.callOptions = {\n            args: this.arguments,\n            withNew: true\n        };\n    }\n}\n\nclass SpreadElement extends NodeBase {\n    bind() {\n        super.bind();\n        // Only properties of properties of the argument could become subject to reassignment\n        // This will also reassign the return values of iterators\n        this.argument.deoptimizePath([UnknownKey, UnknownKey]);\n    }\n}\n\nclass ObjectExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.deoptimizedPaths = new Set();\n        // We collect deoptimization information if we can resolve a computed property access\n        this.expressionsToBeDeoptimized = new Map();\n        this.hasUnknownDeoptimizedProperty = false;\n        this.propertyMap = null;\n        this.unmatchablePropertiesRead = [];\n        this.unmatchablePropertiesWrite = [];\n    }\n    bind() {\n        super.bind();\n        // ensure the propertyMap is set for the tree-shaking passes\n        this.getPropertyMap();\n    }\n    // We could also track this per-property but this would quickly become much more complex\n    deoptimizeCache() {\n        if (!this.hasUnknownDeoptimizedProperty)\n            this.deoptimizeAllProperties();\n    }\n    deoptimizePath(path) {\n        if (this.hasUnknownDeoptimizedProperty)\n            return;\n        const propertyMap = this.getPropertyMap();\n        const key = path[0];\n        if (path.length === 1) {\n            if (typeof key !== 'string') {\n                this.deoptimizeAllProperties();\n                return;\n            }\n            if (!this.deoptimizedPaths.has(key)) {\n                this.deoptimizedPaths.add(key);\n                // we only deoptimizeCache exact matches as in all other cases,\n                // we do not return a literal value or return expression\n                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n                if (expressionsToBeDeoptimized) {\n                    for (const expression of expressionsToBeDeoptimized) {\n                        expression.deoptimizeCache();\n                    }\n                }\n            }\n        }\n        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);\n        for (const property of typeof key === 'string'\n            ? propertyMap[key]\n                ? propertyMap[key].propertiesRead\n                : []\n            : this.properties) {\n            property.deoptimizePath(subPath);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const propertyMap = this.getPropertyMap();\n        const key = path[0];\n        if (path.length === 0 ||\n            this.hasUnknownDeoptimizedProperty ||\n            typeof key !== 'string' ||\n            this.deoptimizedPaths.has(key))\n            return UnknownValue;\n        if (path.length === 1 &&\n            !propertyMap[key] &&\n            !objectMembers[key] &&\n            this.unmatchablePropertiesRead.length === 0) {\n            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n            if (expressionsToBeDeoptimized) {\n                expressionsToBeDeoptimized.push(origin);\n            }\n            else {\n                this.expressionsToBeDeoptimized.set(key, [origin]);\n            }\n            return undefined;\n        }\n        if (!propertyMap[key] ||\n            propertyMap[key].exactMatchRead === null ||\n            propertyMap[key].propertiesRead.length > 1) {\n            return UnknownValue;\n        }\n        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n        if (expressionsToBeDeoptimized) {\n            expressionsToBeDeoptimized.push(origin);\n        }\n        else {\n            this.expressionsToBeDeoptimized.set(key, [origin]);\n        }\n        return propertyMap[key].exactMatchRead.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        const propertyMap = this.getPropertyMap();\n        const key = path[0];\n        if (path.length === 0 ||\n            this.hasUnknownDeoptimizedProperty ||\n            typeof key !== 'string' ||\n            this.deoptimizedPaths.has(key))\n            return UNKNOWN_EXPRESSION;\n        if (path.length === 1 &&\n            objectMembers[key] &&\n            this.unmatchablePropertiesRead.length === 0 &&\n            (!propertyMap[key] || propertyMap[key].exactMatchRead === null))\n            return getMemberReturnExpressionWhenCalled(objectMembers, key);\n        if (!propertyMap[key] ||\n            propertyMap[key].exactMatchRead === null ||\n            propertyMap[key].propertiesRead.length > 1)\n            return UNKNOWN_EXPRESSION;\n        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized.get(key);\n        if (expressionsToBeDeoptimized) {\n            expressionsToBeDeoptimized.push(origin);\n        }\n        else {\n            this.expressionsToBeDeoptimized.set(key, [origin]);\n        }\n        return propertyMap[key].exactMatchRead.getReturnExpressionWhenCalledAtPath(path.slice(1), recursionTracker, origin);\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (path.length === 0)\n            return false;\n        const key = path[0];\n        const propertyMap = this.propertyMap;\n        if (path.length > 1 &&\n            (this.hasUnknownDeoptimizedProperty ||\n                typeof key !== 'string' ||\n                this.deoptimizedPaths.has(key) ||\n                !propertyMap[key] ||\n                propertyMap[key].exactMatchRead === null))\n            return true;\n        const subPath = path.slice(1);\n        for (const property of typeof key !== 'string'\n            ? this.properties\n            : propertyMap[key]\n                ? propertyMap[key].propertiesRead\n                : []) {\n            if (property.hasEffectsWhenAccessedAtPath(subPath, context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        const key = path[0];\n        const propertyMap = this.propertyMap;\n        if (path.length > 1 &&\n            (this.hasUnknownDeoptimizedProperty ||\n                this.deoptimizedPaths.has(key) ||\n                !propertyMap[key] ||\n                propertyMap[key].exactMatchRead === null)) {\n            return true;\n        }\n        const subPath = path.slice(1);\n        for (const property of typeof key !== 'string'\n            ? this.properties\n            : path.length > 1\n                ? propertyMap[key].propertiesRead\n                : propertyMap[key]\n                    ? propertyMap[key].propertiesWrite\n                    : []) {\n            if (property.hasEffectsWhenAssignedAtPath(subPath, context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        const key = path[0];\n        if (typeof key !== 'string' ||\n            this.hasUnknownDeoptimizedProperty ||\n            this.deoptimizedPaths.has(key) ||\n            (this.propertyMap[key]\n                ? !this.propertyMap[key].exactMatchRead\n                : path.length > 1 || !objectMembers[key])) {\n            return true;\n        }\n        const subPath = path.slice(1);\n        if (this.propertyMap[key]) {\n            for (const property of this.propertyMap[key].propertiesRead) {\n                if (property.hasEffectsWhenCalledAtPath(subPath, callOptions, context))\n                    return true;\n            }\n        }\n        if (path.length === 1 && objectMembers[key])\n            return hasMemberEffectWhenCalled(objectMembers, key, this.included, callOptions, context);\n        return false;\n    }\n    render(code, options, { renderedParentType } = BLANK) {\n        super.render(code, options);\n        if (renderedParentType === ExpressionStatement) {\n            code.appendRight(this.start, '(');\n            code.prependLeft(this.end, ')');\n        }\n    }\n    deoptimizeAllProperties() {\n        this.hasUnknownDeoptimizedProperty = true;\n        for (const property of this.properties) {\n            property.deoptimizePath(UNKNOWN_PATH);\n        }\n        for (const expressionsToBeDeoptimized of this.expressionsToBeDeoptimized.values()) {\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n        }\n    }\n    getPropertyMap() {\n        if (this.propertyMap !== null) {\n            return this.propertyMap;\n        }\n        const propertyMap = (this.propertyMap = Object.create(null));\n        for (let index = this.properties.length - 1; index >= 0; index--) {\n            const property = this.properties[index];\n            if (property instanceof SpreadElement) {\n                this.unmatchablePropertiesRead.push(property);\n                continue;\n            }\n            const isWrite = property.kind !== 'get';\n            const isRead = property.kind !== 'set';\n            let key;\n            if (property.computed) {\n                const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n                if (keyValue === UnknownValue) {\n                    if (isRead) {\n                        this.unmatchablePropertiesRead.push(property);\n                    }\n                    else {\n                        this.unmatchablePropertiesWrite.push(property);\n                    }\n                    continue;\n                }\n                key = String(keyValue);\n            }\n            else if (property.key instanceof Identifier$1) {\n                key = property.key.name;\n            }\n            else {\n                key = String(property.key.value);\n            }\n            const propertyMapProperty = propertyMap[key];\n            if (!propertyMapProperty) {\n                propertyMap[key] = {\n                    exactMatchRead: isRead ? property : null,\n                    exactMatchWrite: isWrite ? property : null,\n                    propertiesRead: isRead ? [property, ...this.unmatchablePropertiesRead] : [],\n                    propertiesWrite: isWrite && !isRead ? [property, ...this.unmatchablePropertiesWrite] : []\n                };\n                continue;\n            }\n            if (isRead && propertyMapProperty.exactMatchRead === null) {\n                propertyMapProperty.exactMatchRead = property;\n                propertyMapProperty.propertiesRead.push(property, ...this.unmatchablePropertiesRead);\n            }\n            if (isWrite && !isRead && propertyMapProperty.exactMatchWrite === null) {\n                propertyMapProperty.exactMatchWrite = property;\n                propertyMapProperty.propertiesWrite.push(property, ...this.unmatchablePropertiesWrite);\n            }\n        }\n        return propertyMap;\n    }\n}\n\nclass ObjectPattern extends NodeBase {\n    addExportedVariables(variables) {\n        for (const property of this.properties) {\n            if (property.type === Property) {\n                property.value.addExportedVariables(variables);\n            }\n            else {\n                property.argument.addExportedVariables(variables);\n            }\n        }\n    }\n    declare(kind, init) {\n        const variables = [];\n        for (const property of this.properties) {\n            variables.push(...property.declare(kind, init));\n        }\n        return variables;\n    }\n    deoptimizePath(path) {\n        if (path.length === 0) {\n            for (const property of this.properties) {\n                property.deoptimizePath(path);\n            }\n        }\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (path.length > 0)\n            return true;\n        for (const property of this.properties) {\n            if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))\n                return true;\n        }\n        return false;\n    }\n}\n\nclass Program$1 extends NodeBase {\n    hasEffects(context) {\n        for (const node of this.body) {\n            if (node.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (const node of this.body) {\n            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {\n                node.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    render(code, options) {\n        if (this.body.length) {\n            renderStatementList(this.body, code, this.start, this.end, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\n\nclass Property$1 extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.declarationInit = null;\n        this.returnExpression = null;\n    }\n    bind() {\n        super.bind();\n        if (this.kind === 'get') {\n            // ensure the returnExpression is set for the tree-shaking passes\n            this.getReturnExpression();\n        }\n        if (this.declarationInit !== null) {\n            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);\n        }\n    }\n    declare(kind, init) {\n        this.declarationInit = init;\n        return this.value.declare(kind, UNKNOWN_EXPRESSION);\n    }\n    // As getter properties directly receive their values from function expressions that always\n    // have a fixed return value, there is no known situation where a getter is deoptimized.\n    deoptimizeCache() { }\n    deoptimizePath(path) {\n        if (this.kind === 'get') {\n            this.getReturnExpression().deoptimizePath(path);\n        }\n        else {\n            this.value.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (this.kind === 'get') {\n            return this.getReturnExpression().getLiteralValueAtPath(path, recursionTracker, origin);\n        }\n        return this.value.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin) {\n        if (this.kind === 'get') {\n            return this.getReturnExpression().getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n        }\n        return this.value.getReturnExpressionWhenCalledAtPath(path, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        return this.key.hasEffects(context) || this.value.hasEffects(context);\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        if (this.kind === 'get') {\n            const trackedExpressions = context.accessed.getEntities(path);\n            if (trackedExpressions.has(this))\n                return false;\n            trackedExpressions.add(this);\n            return (this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context) ||\n                (path.length > 0 && this.returnExpression.hasEffectsWhenAccessedAtPath(path, context)));\n        }\n        return this.value.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        if (this.kind === 'get') {\n            const trackedExpressions = context.assigned.getEntities(path);\n            if (trackedExpressions.has(this))\n                return false;\n            trackedExpressions.add(this);\n            return this.returnExpression.hasEffectsWhenAssignedAtPath(path, context);\n        }\n        if (this.kind === 'set') {\n            const trackedExpressions = context.assigned.getEntities(path);\n            if (trackedExpressions.has(this))\n                return false;\n            trackedExpressions.add(this);\n            return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);\n        }\n        return this.value.hasEffectsWhenAssignedAtPath(path, context);\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        if (this.kind === 'get') {\n            const trackedExpressions = (callOptions.withNew\n                ? context.instantiated\n                : context.called).getEntities(path);\n            if (trackedExpressions.has(this))\n                return false;\n            trackedExpressions.add(this);\n            return this.returnExpression.hasEffectsWhenCalledAtPath(path, callOptions, context);\n        }\n        return this.value.hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n    initialise() {\n        this.accessorCallOptions = {\n            args: NO_ARGS,\n            withNew: false\n        };\n    }\n    render(code, options) {\n        if (!this.shorthand) {\n            this.key.render(code, options);\n        }\n        this.value.render(code, options, { isShorthandProperty: this.shorthand });\n    }\n    getReturnExpression() {\n        if (this.returnExpression === null) {\n            this.returnExpression = UNKNOWN_EXPRESSION;\n            return (this.returnExpression = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));\n        }\n        return this.returnExpression;\n    }\n}\n\nclass ReturnStatement$1 extends NodeBase {\n    hasEffects(context) {\n        if (!context.ignore.returnAwaitYield ||\n            (this.argument !== null && this.argument.hasEffects(context)))\n            return true;\n        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (this.argument) {\n            this.argument.include(context, includeChildrenRecursively);\n        }\n        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n    }\n    initialise() {\n        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);\n    }\n    render(code, options) {\n        if (this.argument) {\n            this.argument.render(code, options, { preventASI: true });\n            if (this.argument.start === this.start + 6 /* 'return'.length */) {\n                code.prependLeft(this.start + 6, ' ');\n            }\n        }\n    }\n}\n\nclass SequenceExpression extends NodeBase {\n    deoptimizePath(path) {\n        if (path.length > 0)\n            this.expressions[this.expressions.length - 1].deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        for (const expression of this.expressions) {\n            if (expression.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        return (path.length > 0 &&\n            this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path, context));\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        return (path.length === 0 ||\n            this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path, context));\n    }\n    hasEffectsWhenCalledAtPath(path, callOptions, context) {\n        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path, callOptions, context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (let i = 0; i < this.expressions.length - 1; i++) {\n            const node = this.expressions[i];\n            if (includeChildrenRecursively || node.shouldBeIncluded(context))\n                node.include(context, includeChildrenRecursively);\n        }\n        this.expressions[this.expressions.length - 1].include(context, includeChildrenRecursively);\n    }\n    render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {\n        let includedNodes = 0;\n        for (const { node, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {\n            if (!node.included) {\n                treeshakeNode(node, code, start, end);\n                continue;\n            }\n            includedNodes++;\n            if (includedNodes === 1 && preventASI) {\n                removeLineBreaks(code, start, node.start);\n            }\n            if (node === this.expressions[this.expressions.length - 1] && includedNodes === 1) {\n                node.render(code, options, {\n                    isCalleeOfRenderedParent: renderedParentType\n                        ? isCalleeOfRenderedParent\n                        : this.parent.callee === this,\n                    renderedParentType: renderedParentType || this.parent.type\n                });\n            }\n            else {\n                node.render(code, options);\n            }\n        }\n    }\n}\n\nclass SwitchCase extends NodeBase {\n    hasEffects(context) {\n        if (this.test && this.test.hasEffects(context))\n            return true;\n        for (const node of this.consequent) {\n            if (context.brokenFlow)\n                break;\n            if (node.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (this.test)\n            this.test.include(context, includeChildrenRecursively);\n        for (const node of this.consequent) {\n            if (includeChildrenRecursively || node.shouldBeIncluded(context))\n                node.include(context, includeChildrenRecursively);\n        }\n    }\n    render(code, options, nodeRenderOptions) {\n        if (this.consequent.length) {\n            this.test && this.test.render(code, options);\n            const testEnd = this.test\n                ? this.test.end\n                : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;\n            const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;\n            renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\nSwitchCase.prototype.needsBoundaries = true;\n\nclass SwitchStatement extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if (this.discriminant.hasEffects(context))\n            return true;\n        const { brokenFlow, ignore: { breaks } } = context;\n        let minBrokenFlow = Infinity;\n        context.ignore.breaks = true;\n        for (const switchCase of this.cases) {\n            if (switchCase.hasEffects(context))\n                return true;\n            minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;\n            context.brokenFlow = brokenFlow;\n        }\n        if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {\n            context.brokenFlow = minBrokenFlow;\n        }\n        context.ignore.breaks = breaks;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.discriminant.include(context, includeChildrenRecursively);\n        const { brokenFlow } = context;\n        let minBrokenFlow = Infinity;\n        let isCaseIncluded = includeChildrenRecursively ||\n            (this.defaultCase !== null && this.defaultCase < this.cases.length - 1);\n        for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {\n            const switchCase = this.cases[caseIndex];\n            if (switchCase.included) {\n                isCaseIncluded = true;\n            }\n            if (!isCaseIncluded) {\n                const hasEffectsContext = createHasEffectsContext();\n                hasEffectsContext.ignore.breaks = true;\n                isCaseIncluded = switchCase.hasEffects(hasEffectsContext);\n            }\n            if (isCaseIncluded) {\n                switchCase.include(context, includeChildrenRecursively);\n                minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;\n                context.brokenFlow = brokenFlow;\n            }\n            else {\n                minBrokenFlow = brokenFlow;\n            }\n        }\n        if (isCaseIncluded &&\n            this.defaultCase !== null &&\n            !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {\n            context.brokenFlow = minBrokenFlow;\n        }\n    }\n    initialise() {\n        for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {\n            if (this.cases[caseIndex].test === null) {\n                this.defaultCase = caseIndex;\n                return;\n            }\n        }\n        this.defaultCase = null;\n    }\n    render(code, options) {\n        this.discriminant.render(code, options);\n        if (this.cases.length > 0) {\n            renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);\n        }\n    }\n}\n\nclass TaggedTemplateExpression extends NodeBase {\n    bind() {\n        super.bind();\n        if (this.tag.type === Identifier) {\n            const name = this.tag.name;\n            const variable = this.scope.findVariable(name);\n            if (variable.isNamespace) {\n                return this.context.error({\n                    code: 'CANNOT_CALL_NAMESPACE',\n                    message: `Cannot call a namespace ('${name}')`\n                }, this.start);\n            }\n            if (name === 'eval') {\n                this.context.warn({\n                    code: 'EVAL',\n                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,\n                    url: 'https://rollupjs.org/guide/en/#avoiding-eval'\n                }, this.start);\n            }\n        }\n    }\n    hasEffects(context) {\n        return (super.hasEffects(context) ||\n            this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context));\n    }\n    initialise() {\n        this.callOptions = {\n            args: NO_ARGS,\n            withNew: false\n        };\n    }\n}\n\nclass TemplateElement extends NodeBase {\n    hasEffects() {\n        return false;\n    }\n}\n\nclass TemplateLiteral extends NodeBase {\n    getLiteralValueAtPath(path) {\n        if (path.length > 0 || this.quasis.length !== 1) {\n            return UnknownValue;\n        }\n        return this.quasis[0].value.cooked;\n    }\n    render(code, options) {\n        code.indentExclusionRanges.push([this.start, this.end]);\n        super.render(code, options);\n    }\n}\n\nclass ModuleScope extends ChildScope {\n    constructor(parent, context) {\n        super(parent);\n        this.context = context;\n        this.variables.set('this', new LocalVariable('this', null, UNDEFINED_EXPRESSION, context));\n    }\n    addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {\n        const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);\n        this.variables.set('default', variable);\n        return variable;\n    }\n    addNamespaceMemberAccess(_name, variable) {\n        if (variable instanceof GlobalVariable) {\n            this.accessedOutsideVariables.set(variable.name, variable);\n        }\n    }\n    deconflict(format) {\n        // all module level variables are already deconflicted when deconflicting the chunk\n        for (const scope of this.children)\n            scope.deconflict(format);\n    }\n    findLexicalBoundary() {\n        return this;\n    }\n    findVariable(name) {\n        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);\n        if (knownVariable) {\n            return knownVariable;\n        }\n        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);\n        if (variable instanceof GlobalVariable) {\n            this.accessedOutsideVariables.set(name, variable);\n        }\n        return variable;\n    }\n}\n\nclass ThisExpression extends NodeBase {\n    bind() {\n        super.bind();\n        this.variable = this.scope.findVariable('this');\n    }\n    hasEffectsWhenAccessedAtPath(path, context) {\n        return path.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path, context);\n    }\n    hasEffectsWhenAssignedAtPath(path, context) {\n        return this.variable.hasEffectsWhenAssignedAtPath(path, context);\n    }\n    initialise() {\n        this.alias =\n            this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;\n        if (this.alias === 'undefined') {\n            this.context.warn({\n                code: 'THIS_IS_UNDEFINED',\n                message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,\n                url: `https://rollupjs.org/guide/en/#error-this-is-undefined`\n            }, this.start);\n        }\n    }\n    render(code) {\n        if (this.alias !== null) {\n            code.overwrite(this.start, this.end, this.alias, {\n                contentOnly: false,\n                storeName: true\n            });\n        }\n    }\n}\n\nclass ThrowStatement extends NodeBase {\n    hasEffects() {\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.argument.include(context, includeChildrenRecursively);\n        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;\n    }\n    render(code, options) {\n        this.argument.render(code, options, { preventASI: true });\n        if (this.argument.start === this.start + 5 /* 'throw'.length */) {\n            code.prependLeft(this.start + 5, ' ');\n        }\n    }\n}\n\nclass TryStatement extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.directlyIncluded = false;\n    }\n    hasEffects(context) {\n        return ((this.context.tryCatchDeoptimization\n            ? this.block.body.length > 0\n            : this.block.hasEffects(context)) ||\n            (this.finalizer !== null && this.finalizer.hasEffects(context)));\n    }\n    include(context, includeChildrenRecursively) {\n        const { brokenFlow } = context;\n        if (!this.directlyIncluded || !this.context.tryCatchDeoptimization) {\n            this.included = true;\n            this.directlyIncluded = true;\n            this.block.include(context, this.context.tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);\n            context.brokenFlow = brokenFlow;\n        }\n        if (this.handler !== null) {\n            this.handler.include(context, includeChildrenRecursively);\n            context.brokenFlow = brokenFlow;\n        }\n        if (this.finalizer !== null) {\n            this.finalizer.include(context, includeChildrenRecursively);\n        }\n    }\n}\n\nconst unaryOperators = {\n    '!': value => !value,\n    '+': value => +value,\n    '-': value => -value,\n    delete: () => UnknownValue,\n    typeof: value => typeof value,\n    void: () => undefined,\n    '~': value => ~value\n};\nclass UnaryExpression extends NodeBase {\n    bind() {\n        super.bind();\n        if (this.operator === 'delete') {\n            this.argument.deoptimizePath(EMPTY_PATH);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (path.length > 0)\n            return UnknownValue;\n        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n        if (argumentValue === UnknownValue)\n            return UnknownValue;\n        return unaryOperators[this.operator](argumentValue);\n    }\n    hasEffects(context) {\n        if (this.operator === 'typeof' && this.argument instanceof Identifier$1)\n            return false;\n        return (this.argument.hasEffects(context) ||\n            (this.operator === 'delete' &&\n                this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)));\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        if (this.operator === 'void') {\n            return path.length > 0;\n        }\n        return path.length > 1;\n    }\n}\n\nclass UnknownNode extends NodeBase {\n    hasEffects() {\n        return true;\n    }\n    include(context) {\n        super.include(context, true);\n    }\n}\n\nclass UpdateExpression extends NodeBase {\n    bind() {\n        super.bind();\n        this.argument.deoptimizePath(EMPTY_PATH);\n        if (this.argument instanceof Identifier$1) {\n            const variable = this.scope.findVariable(this.argument.name);\n            variable.isReassigned = true;\n        }\n    }\n    hasEffects(context) {\n        return (this.argument.hasEffects(context) ||\n            this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context));\n    }\n    hasEffectsWhenAccessedAtPath(path) {\n        return path.length > 1;\n    }\n    render(code, options) {\n        this.argument.render(code, options);\n        const variable = this.argument.variable;\n        if (options.format === 'system' && variable && variable.exportName) {\n            const name = variable.getName();\n            if (this.prefix) {\n                code.overwrite(this.start, this.end, `exports('${variable.exportName}', ${this.operator}${name})`);\n            }\n            else {\n                let op;\n                switch (this.operator) {\n                    case '++':\n                        op = `${name} + 1`;\n                        break;\n                    case '--':\n                        op = `${name} - 1`;\n                        break;\n                }\n                code.overwrite(this.start, this.end, `(exports('${variable.exportName}', ${op}), ${name}${this.operator})`);\n            }\n        }\n    }\n}\n\nfunction isReassignedExportsMember(variable) {\n    return variable.renderBaseName !== null && variable.exportName !== null && variable.isReassigned;\n}\nfunction areAllDeclarationsIncludedAndNotExported(declarations) {\n    for (const declarator of declarations) {\n        if (!declarator.included)\n            return false;\n        if (declarator.id.type === Identifier) {\n            if (declarator.id.variable.exportName)\n                return false;\n        }\n        else {\n            const exportedVariables = [];\n            declarator.id.addExportedVariables(exportedVariables);\n            if (exportedVariables.length > 0)\n                return false;\n        }\n    }\n    return true;\n}\nclass VariableDeclaration extends NodeBase {\n    deoptimizePath() {\n        for (const declarator of this.declarations) {\n            declarator.deoptimizePath(EMPTY_PATH);\n        }\n    }\n    hasEffectsWhenAssignedAtPath() {\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (const declarator of this.declarations) {\n            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))\n                declarator.include(context, includeChildrenRecursively);\n        }\n    }\n    includeWithAllDeclaredVariables(includeChildrenRecursively, context) {\n        this.included = true;\n        for (const declarator of this.declarations) {\n            declarator.include(context, includeChildrenRecursively);\n        }\n    }\n    initialise() {\n        for (const declarator of this.declarations) {\n            declarator.declareDeclarator(this.kind);\n        }\n    }\n    render(code, options, nodeRenderOptions = BLANK) {\n        if (areAllDeclarationsIncludedAndNotExported(this.declarations)) {\n            for (const declarator of this.declarations) {\n                declarator.render(code, options);\n            }\n            if (!nodeRenderOptions.isNoStatement &&\n                code.original.charCodeAt(this.end - 1) !== 59 /*\";\"*/) {\n                code.appendLeft(this.end, ';');\n            }\n        }\n        else {\n            this.renderReplacedDeclarations(code, options, nodeRenderOptions);\n        }\n    }\n    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, addSemicolon, systemPatternExports) {\n        if (code.original.charCodeAt(this.end - 1) === 59 /*\";\"*/) {\n            code.remove(this.end - 1, this.end);\n        }\n        if (addSemicolon) {\n            separatorString += ';';\n        }\n        if (lastSeparatorPos !== null) {\n            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*\"\\n\"*/ &&\n                (code.original.charCodeAt(this.end) === 10 /*\"\\n\"*/ ||\n                    code.original.charCodeAt(this.end) === 13) /*\"\\r\"*/) {\n                actualContentEnd--;\n                if (code.original.charCodeAt(actualContentEnd) === 13 /*\"\\r\"*/) {\n                    actualContentEnd--;\n                }\n            }\n            if (actualContentEnd === lastSeparatorPos + 1) {\n                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);\n            }\n            else {\n                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);\n                code.remove(actualContentEnd, renderedContentEnd);\n            }\n        }\n        else {\n            code.appendLeft(renderedContentEnd, separatorString);\n        }\n        if (systemPatternExports.length > 0) {\n            code.appendLeft(renderedContentEnd, ' ' + getSystemExportStatement(systemPatternExports));\n        }\n    }\n    renderReplacedDeclarations(code, options, { start = this.start, end = this.end, isNoStatement }) {\n        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*\";\"*/ ? 1 : 0));\n        let actualContentEnd, renderedContentEnd;\n        if (/\\n\\s*$/.test(code.slice(this.start, separatedNodes[0].start))) {\n            renderedContentEnd = this.start + this.kind.length;\n        }\n        else {\n            renderedContentEnd = separatedNodes[0].start;\n        }\n        let lastSeparatorPos = renderedContentEnd - 1;\n        code.remove(this.start, lastSeparatorPos);\n        let isInDeclaration = false;\n        let hasRenderedContent = false;\n        let separatorString = '', leadingString, nextSeparatorString;\n        const systemPatternExports = [];\n        for (const { node, start, separator, contentEnd, end } of separatedNodes) {\n            if (!node.included ||\n                (node.id instanceof Identifier$1 &&\n                    isReassignedExportsMember(node.id.variable) &&\n                    node.init === null)) {\n                code.remove(start, end);\n                continue;\n            }\n            leadingString = '';\n            nextSeparatorString = '';\n            if (node.id instanceof Identifier$1 &&\n                isReassignedExportsMember(node.id.variable)) {\n                if (hasRenderedContent) {\n                    separatorString += ';';\n                }\n                isInDeclaration = false;\n            }\n            else {\n                if (options.format === 'system' && node.init !== null) {\n                    if (node.id.type !== Identifier) {\n                        node.id.addExportedVariables(systemPatternExports);\n                    }\n                    else if (node.id.variable.exportName) {\n                        code.prependLeft(code.original.indexOf('=', node.id.end) + 1, ` exports('${node.id.variable.safeExportName || node.id.variable.exportName}',`);\n                        nextSeparatorString += ')';\n                    }\n                }\n                if (isInDeclaration) {\n                    separatorString += ',';\n                }\n                else {\n                    if (hasRenderedContent) {\n                        separatorString += ';';\n                    }\n                    leadingString += `${this.kind} `;\n                    isInDeclaration = true;\n                }\n            }\n            if (renderedContentEnd === lastSeparatorPos + 1) {\n                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);\n            }\n            else {\n                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);\n                code.appendLeft(renderedContentEnd, leadingString);\n            }\n            node.render(code, options);\n            actualContentEnd = contentEnd;\n            renderedContentEnd = end;\n            hasRenderedContent = true;\n            lastSeparatorPos = separator;\n            separatorString = nextSeparatorString;\n        }\n        if (hasRenderedContent) {\n            this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, !isNoStatement, systemPatternExports);\n        }\n        else {\n            code.remove(start, end);\n        }\n    }\n}\n\nclass VariableDeclarator extends NodeBase {\n    declareDeclarator(kind) {\n        this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);\n    }\n    deoptimizePath(path) {\n        this.id.deoptimizePath(path);\n    }\n    render(code, options) {\n        // This can happen for hoisted variables in dead branches\n        if (this.init !== null && !this.init.included) {\n            code.remove(this.id.end, this.end);\n            this.id.render(code, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\n\nclass WhileStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.test.hasEffects(context))\n            return true;\n        const { brokenFlow, ignore: { breaks, continues } } = context;\n        context.ignore.breaks = true;\n        context.ignore.continues = true;\n        if (this.body.hasEffects(context))\n            return true;\n        context.ignore.breaks = breaks;\n        context.ignore.continues = continues;\n        context.brokenFlow = brokenFlow;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.test.include(context, includeChildrenRecursively);\n        const { brokenFlow } = context;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n}\n\nclass YieldExpression extends NodeBase {\n    bind() {\n        super.bind();\n        if (this.argument !== null) {\n            this.argument.deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    hasEffects(context) {\n        return (!context.ignore.returnAwaitYield ||\n            (this.argument !== null && this.argument.hasEffects(context)));\n    }\n    render(code, options) {\n        if (this.argument) {\n            this.argument.render(code, options);\n            if (this.argument.start === this.start + 5 /* 'yield'.length */) {\n                code.prependLeft(this.start + 5, ' ');\n            }\n        }\n    }\n}\n\nconst nodeConstructors = {\n    ArrayExpression,\n    ArrayPattern,\n    ArrowFunctionExpression,\n    AssignmentExpression,\n    AssignmentPattern,\n    AwaitExpression,\n    BinaryExpression,\n    BlockStatement: BlockStatement$1,\n    BreakStatement,\n    CallExpression: CallExpression$1,\n    CatchClause,\n    ClassBody,\n    ClassDeclaration,\n    ClassExpression,\n    ConditionalExpression,\n    ContinueStatement,\n    DoWhileStatement,\n    EmptyStatement,\n    ExportAllDeclaration,\n    ExportDefaultDeclaration,\n    ExportNamedDeclaration,\n    ExpressionStatement: ExpressionStatement$1,\n    ForInStatement,\n    ForOfStatement,\n    ForStatement,\n    FunctionDeclaration,\n    FunctionExpression: FunctionExpression$1,\n    Identifier: Identifier$1,\n    IfStatement,\n    ImportDeclaration,\n    ImportExpression: Import,\n    LabeledStatement,\n    Literal,\n    LogicalExpression,\n    MemberExpression,\n    MetaProperty,\n    MethodDefinition,\n    NewExpression,\n    ObjectExpression,\n    ObjectPattern,\n    Program: Program$1,\n    Property: Property$1,\n    RestElement,\n    ReturnStatement: ReturnStatement$1,\n    SequenceExpression,\n    SpreadElement,\n    SwitchCase,\n    SwitchStatement,\n    TaggedTemplateExpression,\n    TemplateElement,\n    TemplateLiteral,\n    ThisExpression,\n    ThrowStatement,\n    TryStatement,\n    UnaryExpression,\n    UnknownNode,\n    UpdateExpression,\n    VariableDeclaration,\n    VariableDeclarator,\n    WhileStatement,\n    YieldExpression\n};\n\nclass SyntheticNamedExportVariableVariable extends Variable {\n    constructor(context, name, defaultVariable) {\n        super(name);\n        this.context = context;\n        this.module = context.module;\n        this.defaultVariable = defaultVariable;\n        this.setRenderNames(defaultVariable.getName(), name);\n    }\n    include(context) {\n        if (!this.included) {\n            this.included = true;\n            this.context.includeVariable(context, this.defaultVariable);\n        }\n    }\n}\n\nfunction getOriginalLocation(sourcemapChain, location) {\n    // This cast is guaranteed. If it were a missing Map, it wouldn't have a mappings.\n    const filteredSourcemapChain = sourcemapChain.filter(sourcemap => sourcemap.mappings);\n    while (filteredSourcemapChain.length > 0) {\n        const sourcemap = filteredSourcemapChain.pop();\n        const line = sourcemap.mappings[location.line - 1];\n        let locationFound = false;\n        if (line !== undefined) {\n            for (const segment of line) {\n                if (segment[0] >= location.column) {\n                    if (segment.length === 1)\n                        break;\n                    location = {\n                        column: segment[3],\n                        line: segment[2] + 1,\n                        name: segment.length === 5 ? sourcemap.names[segment[4]] : undefined,\n                        source: sourcemap.sources[segment[1]]\n                    };\n                    locationFound = true;\n                    break;\n                }\n            }\n        }\n        if (!locationFound) {\n            throw new Error(\"Can't resolve original location of error.\");\n        }\n    }\n    return location;\n}\n\n// AST walker module for Mozilla Parser API compatible trees\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base$1 = {};\n\nbase$1.Program = base$1.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase$1.Statement = skipThrough;\nbase$1.EmptyStatement = ignore;\nbase$1.ExpressionStatement = base$1.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase$1.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase$1.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase$1.BreakStatement = base$1.ContinueStatement = ignore;\nbase$1.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase$1.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase$1.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase$1.ThrowStatement = base$1.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase$1.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase$1.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"Statement\");\n};\nbase$1.WhileStatement = base$1.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase$1.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase$1.ForInStatement = base$1.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase$1.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase$1.DebuggerStatement = ignore;\n\nbase$1.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase$1.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase$1.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase$1.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase$1.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase$1.VariablePattern = ignore;\nbase$1.MemberPattern = skipThrough;\nbase$1.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase$1.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase$1.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase$1.Expression = skipThrough;\nbase$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;\nbase$1.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase$1.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;\nbase$1.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase$1.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n    {\n    var quasi = list[i];\n\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n    {\n    var expr = list$1[i$1];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase$1.TemplateElement = ignore;\nbase$1.UnaryExpression = base$1.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase$1.BinaryExpression = base$1.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase$1.AssignmentExpression = base$1.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase$1.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase$1.NewExpression = base$1.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase$1.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase$1.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase$1.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase$1.ImportExpression = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.Literal = ignore;\n\nbase$1.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase$1.ClassDeclaration = base$1.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase$1.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase$1.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase$1.MethodDefinition = base$1.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\n// @ts-ignore\nfunction handlePureAnnotationsOfNode(node, state, type = node.type) {\n    let commentNode = state.commentNodes[state.commentIndex];\n    while (commentNode && node.start >= commentNode.end) {\n        markPureNode(node, commentNode);\n        commentNode = state.commentNodes[++state.commentIndex];\n    }\n    if (commentNode && commentNode.end <= node.end) {\n        base$1[type](node, state, handlePureAnnotationsOfNode);\n    }\n}\nfunction markPureNode(node, comment) {\n    if (node.annotations) {\n        node.annotations.push(comment);\n    }\n    else {\n        node.annotations = [comment];\n    }\n    if (node.type === 'ExpressionStatement') {\n        node = node.expression;\n    }\n    if (node.type === 'CallExpression' || node.type === 'NewExpression') {\n        node.annotatedPure = true;\n    }\n}\nconst pureCommentRegex = /[@#]__PURE__/;\nconst isPureComment = (comment) => pureCommentRegex.test(comment.text);\nfunction markPureCallExpressions(comments, esTreeAst) {\n    handlePureAnnotationsOfNode(esTreeAst, {\n        commentIndex: 0,\n        commentNodes: comments.filter(isPureComment)\n    });\n}\n\n// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nlet SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\nconst SOURCEMAPPING_URL_RE = new RegExp(`^#\\\\s+${SOURCEMAPPING_URL}=.+\\\\n?`);\n\nconst NOOP = () => { };\nlet getStartTime = () => [0, 0];\nlet getElapsedTime = () => 0;\nlet getMemory = () => 0;\nlet timers = {};\nconst normalizeHrTime = (time) => time[0] * 1e3 + time[1] / 1e6;\nfunction setTimeHelpers() {\n    if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n        getStartTime = process.hrtime.bind(process);\n        getElapsedTime = previous => normalizeHrTime(process.hrtime(previous));\n    }\n    else if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        getStartTime = () => [performance.now(), 0];\n        getElapsedTime = previous => performance.now() - previous[0];\n    }\n    if (typeof process !== 'undefined' && typeof process.memoryUsage === 'function') {\n        getMemory = () => process.memoryUsage().heapUsed;\n    }\n}\nfunction getPersistedLabel(label, level) {\n    switch (level) {\n        case 1:\n            return `# ${label}`;\n        case 2:\n            return `## ${label}`;\n        case 3:\n            return label;\n        default:\n            return `${'  '.repeat(level - 4)}- ${label}`;\n    }\n}\nfunction timeStartImpl(label, level = 3) {\n    label = getPersistedLabel(label, level);\n    if (!timers.hasOwnProperty(label)) {\n        timers[label] = {\n            memory: 0,\n            startMemory: undefined,\n            startTime: undefined,\n            time: 0,\n            totalMemory: 0\n        };\n    }\n    const currentMemory = getMemory();\n    timers[label].startTime = getStartTime();\n    timers[label].startMemory = currentMemory;\n}\nfunction timeEndImpl(label, level = 3) {\n    label = getPersistedLabel(label, level);\n    if (timers.hasOwnProperty(label)) {\n        const currentMemory = getMemory();\n        timers[label].time += getElapsedTime(timers[label].startTime);\n        timers[label].totalMemory = Math.max(timers[label].totalMemory, currentMemory);\n        timers[label].memory += currentMemory - timers[label].startMemory;\n    }\n}\nfunction getTimings() {\n    const newTimings = {};\n    for (const label of Object.keys(timers)) {\n        newTimings[label] = [timers[label].time, timers[label].memory, timers[label].totalMemory];\n    }\n    return newTimings;\n}\nlet timeStart = NOOP, timeEnd = NOOP;\nconst TIMED_PLUGIN_HOOKS = {\n    load: true,\n    ongenerate: true,\n    onwrite: true,\n    resolveDynamicImport: true,\n    resolveId: true,\n    transform: true,\n    transformBundle: true\n};\nfunction getPluginWithTimers(plugin, index) {\n    const timedPlugin = {};\n    for (const hook of Object.keys(plugin)) {\n        if (TIMED_PLUGIN_HOOKS[hook] === true) {\n            let timerLabel = `plugin ${index}`;\n            if (plugin.name) {\n                timerLabel += ` (${plugin.name})`;\n            }\n            timerLabel += ` - ${hook}`;\n            timedPlugin[hook] = function () {\n                timeStart(timerLabel, 4);\n                const result = plugin[hook].apply(this === timedPlugin ? plugin : this, arguments);\n                timeEnd(timerLabel, 4);\n                if (result && typeof result.then === 'function') {\n                    timeStart(`${timerLabel} (async)`, 4);\n                    result.then(() => timeEnd(`${timerLabel} (async)`, 4));\n                }\n                return result;\n            };\n        }\n        else {\n            timedPlugin[hook] = plugin[hook];\n        }\n    }\n    return timedPlugin;\n}\nfunction initialiseTimers(inputOptions) {\n    if (inputOptions.perf) {\n        timers = {};\n        setTimeHelpers();\n        timeStart = timeStartImpl;\n        timeEnd = timeEndImpl;\n        inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);\n    }\n    else {\n        timeStart = NOOP;\n        timeEnd = NOOP;\n    }\n}\n\nconst defaultAcornOptions = {\n    ecmaVersion: 2020,\n    preserveParens: false,\n    sourceType: 'module'\n};\nfunction tryParse(module, Parser, acornOptions) {\n    try {\n        return Parser.parse(module.code, Object.assign(Object.assign(Object.assign({}, defaultAcornOptions), acornOptions), { onComment: (block, text, start, end) => module.comments.push({ block, text, start, end }) }));\n    }\n    catch (err) {\n        let message = err.message.replace(/ \\(\\d+:\\d+\\)$/, '');\n        if (module.id.endsWith('.json')) {\n            message += ' (Note that you need @rollup/plugin-json to import JSON files)';\n        }\n        else if (!module.id.endsWith('.js')) {\n            message += ' (Note that you need plugins to import files that are not JavaScript)';\n        }\n        return module.error({\n            code: 'PARSE_ERROR',\n            message,\n            parserError: err\n        }, err.pos);\n    }\n}\nfunction handleMissingExport(exportName, importingModule, importedModule, importerStart) {\n    return importingModule.error({\n        code: 'MISSING_EXPORT',\n        message: `'${exportName}' is not exported by ${relativeId(importedModule)}, imported by ${relativeId(importingModule.id)}`,\n        url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`\n    }, importerStart);\n}\nconst MISSING_EXPORT_SHIM_DESCRIPTION = {\n    identifier: null,\n    localName: MISSING_EXPORT_SHIM_VARIABLE\n};\nfunction getVariableForExportNameRecursive(target, name, isExportAllSearch, searchedNamesAndModules = new Map()) {\n    const searchedModules = searchedNamesAndModules.get(name);\n    if (searchedModules) {\n        if (searchedModules.has(target)) {\n            return null;\n        }\n        searchedModules.add(target);\n    }\n    else {\n        searchedNamesAndModules.set(name, new Set([target]));\n    }\n    return target.getVariableForExportName(name, isExportAllSearch, searchedNamesAndModules);\n}\nclass Module {\n    constructor(graph, id, moduleSideEffects, syntheticNamedExports, isEntry) {\n        this.chunk = null;\n        this.chunkFileNames = new Set();\n        this.chunkName = null;\n        this.comments = [];\n        this.dependencies = [];\n        this.dynamicallyImportedBy = [];\n        this.dynamicDependencies = [];\n        this.dynamicImports = [];\n        this.entryPointsHash = new Uint8Array(10);\n        this.execIndex = Infinity;\n        this.exportAllModules = [];\n        this.exportAllSources = new Set();\n        this.exports = Object.create(null);\n        this.exportsAll = Object.create(null);\n        this.exportShimVariable = new ExportShimVariable(this);\n        this.facadeChunk = null;\n        this.importDescriptions = Object.create(null);\n        this.importMetas = [];\n        this.imports = new Set();\n        this.isExecuted = false;\n        this.isUserDefinedEntryPoint = false;\n        this.manualChunkAlias = null;\n        this.reexportDescriptions = Object.create(null);\n        this.sources = new Set();\n        this.userChunkNames = new Set();\n        this.usesTopLevelAwait = false;\n        this.allExportNames = null;\n        this.defaultExport = null;\n        this.namespaceVariable = null;\n        this.syntheticExports = new Map();\n        this.transformDependencies = [];\n        this.transitiveReexports = null;\n        this.id = id;\n        this.graph = graph;\n        this.excludeFromSourcemap = /\\0/.test(id);\n        this.context = graph.getModuleContext(id);\n        this.moduleSideEffects = moduleSideEffects;\n        this.syntheticNamedExports = syntheticNamedExports;\n        this.isEntryPoint = isEntry;\n    }\n    basename() {\n        const base = basename(this.id);\n        const ext = extname(this.id);\n        return makeLegal(ext ? base.slice(0, -ext.length) : base);\n    }\n    bindReferences() {\n        this.ast.bind();\n    }\n    error(props, pos) {\n        if (typeof pos === 'number') {\n            props.pos = pos;\n            let location = locate(this.code, pos, { offsetLine: 1 });\n            try {\n                location = getOriginalLocation(this.sourcemapChain, location);\n            }\n            catch (e) {\n                this.warn({\n                    code: 'SOURCEMAP_ERROR',\n                    loc: {\n                        column: location.column,\n                        file: this.id,\n                        line: location.line\n                    },\n                    message: `Error when using sourcemap for reporting an error: ${e.message}`,\n                    pos\n                });\n            }\n            props.loc = {\n                column: location.column,\n                file: this.id,\n                line: location.line\n            };\n            props.frame = getCodeFrame(this.originalCode, location.line, location.column);\n        }\n        return error(props);\n    }\n    getAllExportNames() {\n        if (this.allExportNames) {\n            return this.allExportNames;\n        }\n        const allExportNames = (this.allExportNames = new Set());\n        for (const name of Object.keys(this.exports)) {\n            allExportNames.add(name);\n        }\n        for (const name of Object.keys(this.reexportDescriptions)) {\n            allExportNames.add(name);\n        }\n        for (const module of this.exportAllModules) {\n            if (module instanceof ExternalModule) {\n                allExportNames.add(`*${module.id}`);\n                continue;\n            }\n            for (const name of module.getAllExportNames()) {\n                if (name !== 'default')\n                    allExportNames.add(name);\n            }\n        }\n        return allExportNames;\n    }\n    getDefaultExport() {\n        if (this.defaultExport === null) {\n            this.defaultExport = undefined;\n            this.defaultExport = this.getVariableForExportName('default');\n        }\n        if (!this.defaultExport) {\n            return error({\n                code: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_DEFAULT,\n                id: this.id,\n                message: `Modules with 'syntheticNamedExports' need a default export.`\n            });\n        }\n        return this.defaultExport;\n    }\n    getDynamicImportExpressions() {\n        return this.dynamicImports.map(({ node }) => {\n            const importArgument = node.source;\n            if (importArgument instanceof TemplateLiteral &&\n                importArgument.quasis.length === 1 &&\n                importArgument.quasis[0].value.cooked) {\n                return importArgument.quasis[0].value.cooked;\n            }\n            if (importArgument instanceof Literal && typeof importArgument.value === 'string') {\n                return importArgument.value;\n            }\n            return importArgument;\n        });\n    }\n    getExportNamesByVariable() {\n        const exportNamesByVariable = new Map();\n        for (const exportName of this.getAllExportNames()) {\n            const tracedVariable = this.getVariableForExportName(exportName);\n            if (!tracedVariable ||\n                !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {\n                continue;\n            }\n            const existingExportNames = exportNamesByVariable.get(tracedVariable);\n            if (existingExportNames) {\n                existingExportNames.push(exportName);\n            }\n            else {\n                exportNamesByVariable.set(tracedVariable, [exportName]);\n            }\n        }\n        return exportNamesByVariable;\n    }\n    getExports() {\n        return Object.keys(this.exports);\n    }\n    getOrCreateNamespace() {\n        if (!this.namespaceVariable) {\n            this.namespaceVariable = new NamespaceVariable(this.astContext, this.syntheticNamedExports);\n            this.namespaceVariable.initialise();\n        }\n        return this.namespaceVariable;\n    }\n    getReexports() {\n        if (this.transitiveReexports) {\n            return this.transitiveReexports;\n        }\n        // to avoid infinite recursion when using circular `export * from X`\n        this.transitiveReexports = [];\n        const reexports = new Set();\n        for (const name in this.reexportDescriptions) {\n            reexports.add(name);\n        }\n        for (const module of this.exportAllModules) {\n            if (module instanceof ExternalModule) {\n                reexports.add(`*${module.id}`);\n            }\n            else {\n                for (const name of module.getExports().concat(module.getReexports())) {\n                    if (name !== 'default')\n                        reexports.add(name);\n                }\n            }\n        }\n        return (this.transitiveReexports = Array.from(reexports));\n    }\n    getRenderedExports() {\n        // only direct exports are counted here, not reexports at all\n        const renderedExports = [];\n        const removedExports = [];\n        for (const exportName in this.exports) {\n            const variable = this.getVariableForExportName(exportName);\n            (variable && variable.included ? renderedExports : removedExports).push(exportName);\n        }\n        return { renderedExports, removedExports };\n    }\n    getTransitiveDependencies() {\n        return this.dependencies.concat(this.getReexports()\n            .concat(this.getExports())\n            .map((exportName) => this.getVariableForExportName(exportName).module));\n    }\n    getVariableForExportName(name, isExportAllSearch, searchedNamesAndModules) {\n        if (name[0] === '*') {\n            if (name.length === 1) {\n                return this.getOrCreateNamespace();\n            }\n            else {\n                // export * from 'external'\n                const module = this.graph.moduleById.get(name.slice(1));\n                return module.getVariableForExportName('*');\n            }\n        }\n        // export { foo } from './other'\n        const reexportDeclaration = this.reexportDescriptions[name];\n        if (reexportDeclaration) {\n            const declaration = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, false, searchedNamesAndModules);\n            if (!declaration) {\n                return handleMissingExport(reexportDeclaration.localName, this, reexportDeclaration.module.id, reexportDeclaration.start);\n            }\n            return declaration;\n        }\n        const exportDeclaration = this.exports[name];\n        if (exportDeclaration) {\n            if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {\n                return this.exportShimVariable;\n            }\n            const name = exportDeclaration.localName;\n            return this.traceVariable(name) || this.graph.scope.findVariable(name);\n        }\n        if (name !== 'default') {\n            for (const module of this.exportAllModules) {\n                const declaration = getVariableForExportNameRecursive(module, name, true, searchedNamesAndModules);\n                if (declaration)\n                    return declaration;\n            }\n        }\n        // we don't want to create shims when we are just\n        // probing export * modules for exports\n        if (!isExportAllSearch) {\n            if (this.syntheticNamedExports) {\n                let syntheticExport = this.syntheticExports.get(name);\n                if (!syntheticExport) {\n                    const defaultExport = this.getDefaultExport();\n                    syntheticExport = new SyntheticNamedExportVariableVariable(this.astContext, name, defaultExport);\n                    this.syntheticExports.set(name, syntheticExport);\n                    return syntheticExport;\n                }\n                return syntheticExport;\n            }\n            if (this.graph.shimMissingExports) {\n                this.shimMissingExport(name);\n                return this.exportShimVariable;\n            }\n        }\n        return null;\n    }\n    include() {\n        const context = createInclusionContext();\n        if (this.ast.shouldBeIncluded(context))\n            this.ast.include(context, false);\n    }\n    includeAllExports() {\n        if (!this.isExecuted) {\n            this.graph.needsTreeshakingPass = true;\n            markModuleAndImpureDependenciesAsExecuted(this);\n        }\n        const context = createInclusionContext();\n        for (const exportName of this.getExports()) {\n            const variable = this.getVariableForExportName(exportName);\n            variable.deoptimizePath(UNKNOWN_PATH);\n            if (!variable.included) {\n                variable.include(context);\n                this.graph.needsTreeshakingPass = true;\n            }\n        }\n        for (const name of this.getReexports()) {\n            const variable = this.getVariableForExportName(name);\n            variable.deoptimizePath(UNKNOWN_PATH);\n            if (!variable.included) {\n                variable.include(context);\n                this.graph.needsTreeshakingPass = true;\n            }\n            if (variable instanceof ExternalVariable) {\n                variable.module.reexported = true;\n            }\n        }\n    }\n    includeAllInBundle() {\n        this.ast.include(createInclusionContext(), true);\n    }\n    isIncluded() {\n        return this.ast.included || (this.namespaceVariable && this.namespaceVariable.included);\n    }\n    linkDependencies() {\n        for (const source of this.sources) {\n            const id = this.resolvedIds[source].id;\n            if (id) {\n                const module = this.graph.moduleById.get(id);\n                this.dependencies.push(module);\n            }\n        }\n        for (const { resolution } of this.dynamicImports) {\n            if (resolution instanceof Module || resolution instanceof ExternalModule) {\n                this.dynamicDependencies.push(resolution);\n            }\n        }\n        this.addModulesToImportDescriptions(this.importDescriptions);\n        this.addModulesToImportDescriptions(this.reexportDescriptions);\n        const externalExportAllModules = [];\n        for (const source of this.exportAllSources) {\n            const module = this.graph.moduleById.get(this.resolvedIds[source].id);\n            (module instanceof ExternalModule ? externalExportAllModules : this.exportAllModules).push(module);\n        }\n        this.exportAllModules = this.exportAllModules.concat(externalExportAllModules);\n    }\n    render(options) {\n        const magicString = this.magicString.clone();\n        this.ast.render(magicString, options);\n        this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;\n        return magicString;\n    }\n    setSource({ ast, code, customTransformCache, moduleSideEffects, originalCode, originalSourcemap, resolvedIds, sourcemapChain, syntheticNamedExports, transformDependencies, transformFiles }) {\n        this.code = code;\n        this.originalCode = originalCode;\n        this.originalSourcemap = originalSourcemap;\n        this.sourcemapChain = sourcemapChain;\n        if (transformFiles) {\n            this.transformFiles = transformFiles;\n        }\n        this.transformDependencies = transformDependencies;\n        this.customTransformCache = customTransformCache;\n        if (typeof moduleSideEffects === 'boolean') {\n            this.moduleSideEffects = moduleSideEffects;\n        }\n        if (typeof syntheticNamedExports === 'boolean') {\n            this.syntheticNamedExports = syntheticNamedExports;\n        }\n        timeStart('generate ast', 3);\n        this.esTreeAst = ast || tryParse(this, this.graph.acornParser, this.graph.acornOptions);\n        markPureCallExpressions(this.comments, this.esTreeAst);\n        timeEnd('generate ast', 3);\n        this.resolvedIds = resolvedIds || Object.create(null);\n        // By default, `id` is the file name. Custom resolvers and loaders\n        // can change that, but it makes sense to use it for the source file name\n        const fileName = this.id;\n        this.magicString = new MagicString(code, {\n            filename: (this.excludeFromSourcemap ? null : fileName),\n            indentExclusionRanges: []\n        });\n        this.removeExistingSourceMap();\n        timeStart('analyse ast', 3);\n        this.astContext = {\n            addDynamicImport: this.addDynamicImport.bind(this),\n            addExport: this.addExport.bind(this),\n            addImport: this.addImport.bind(this),\n            addImportMeta: this.addImportMeta.bind(this),\n            annotations: (this.graph.treeshakingOptions && this.graph.treeshakingOptions.annotations),\n            code,\n            deoptimizationTracker: this.graph.deoptimizationTracker,\n            error: this.error.bind(this),\n            fileName,\n            getExports: this.getExports.bind(this),\n            getModuleExecIndex: () => this.execIndex,\n            getModuleName: this.basename.bind(this),\n            getReexports: this.getReexports.bind(this),\n            importDescriptions: this.importDescriptions,\n            includeDynamicImport: this.includeDynamicImport.bind(this),\n            includeVariable: this.includeVariable.bind(this),\n            isCrossChunkImport: importDescription => importDescription.module.chunk !== this.chunk,\n            magicString: this.magicString,\n            module: this,\n            moduleContext: this.context,\n            nodeConstructors,\n            preserveModules: this.graph.preserveModules,\n            propertyReadSideEffects: (!this.graph.treeshakingOptions ||\n                this.graph.treeshakingOptions.propertyReadSideEffects),\n            traceExport: this.getVariableForExportName.bind(this),\n            traceVariable: this.traceVariable.bind(this),\n            treeshake: !!this.graph.treeshakingOptions,\n            tryCatchDeoptimization: (!this.graph.treeshakingOptions ||\n                this.graph.treeshakingOptions.tryCatchDeoptimization),\n            unknownGlobalSideEffects: (!this.graph.treeshakingOptions ||\n                this.graph.treeshakingOptions.unknownGlobalSideEffects),\n            usesTopLevelAwait: false,\n            warn: this.warn.bind(this),\n            warnDeprecation: this.graph.warnDeprecation.bind(this.graph)\n        };\n        this.scope = new ModuleScope(this.graph.scope, this.astContext);\n        this.ast = new Program$1(this.esTreeAst, { type: 'Module', context: this.astContext }, this.scope);\n        timeEnd('analyse ast', 3);\n    }\n    toJSON() {\n        return {\n            ast: this.esTreeAst,\n            code: this.code,\n            customTransformCache: this.customTransformCache,\n            dependencies: this.dependencies.map(module => module.id),\n            id: this.id,\n            moduleSideEffects: this.moduleSideEffects,\n            originalCode: this.originalCode,\n            originalSourcemap: this.originalSourcemap,\n            resolvedIds: this.resolvedIds,\n            sourcemapChain: this.sourcemapChain,\n            syntheticNamedExports: this.syntheticNamedExports,\n            transformDependencies: this.transformDependencies,\n            transformFiles: this.transformFiles\n        };\n    }\n    traceVariable(name) {\n        const localVariable = this.scope.variables.get(name);\n        if (localVariable) {\n            return localVariable;\n        }\n        if (name in this.importDescriptions) {\n            const importDeclaration = this.importDescriptions[name];\n            const otherModule = importDeclaration.module;\n            if (otherModule instanceof Module && importDeclaration.name === '*') {\n                return otherModule.getOrCreateNamespace();\n            }\n            const declaration = otherModule.getVariableForExportName(importDeclaration.name);\n            if (!declaration) {\n                return handleMissingExport(importDeclaration.name, this, otherModule.id, importDeclaration.start);\n            }\n            return declaration;\n        }\n        return null;\n    }\n    warn(warning, pos) {\n        if (typeof pos === 'number') {\n            warning.pos = pos;\n            const { line, column } = locate(this.code, pos, { offsetLine: 1 }); // TODO trace sourcemaps, cf. error()\n            warning.loc = { file: this.id, line, column };\n            warning.frame = getCodeFrame(this.code, line, column);\n        }\n        warning.id = this.id;\n        this.graph.warn(warning);\n    }\n    addDynamicImport(node) {\n        this.dynamicImports.push({ node, resolution: null });\n    }\n    addExport(node) {\n        if (node instanceof ExportDefaultDeclaration) {\n            // export default foo;\n            this.exports.default = {\n                identifier: node.variable.getAssignedVariableName(),\n                localName: 'default'\n            };\n        }\n        else if (node instanceof ExportAllDeclaration) {\n            // export * from './other'\n            const source = node.source.value;\n            this.sources.add(source);\n            this.exportAllSources.add(source);\n        }\n        else if (node.source instanceof Literal) {\n            // export { name } from './other'\n            const source = node.source.value;\n            this.sources.add(source);\n            for (const specifier of node.specifiers) {\n                const name = specifier.exported.name;\n                this.reexportDescriptions[name] = {\n                    localName: specifier.type === ExportNamespaceSpecifier ? '*' : specifier.local.name,\n                    module: null,\n                    source,\n                    start: specifier.start\n                };\n            }\n        }\n        else if (node.declaration) {\n            const declaration = node.declaration;\n            if (declaration instanceof VariableDeclaration) {\n                // export var { foo, bar } = ...\n                // export var foo = 1, bar = 2;\n                for (const declarator of declaration.declarations) {\n                    for (const localName of extractAssignedNames(declarator.id)) {\n                        this.exports[localName] = { identifier: null, localName };\n                    }\n                }\n            }\n            else {\n                // export function foo () {}\n                const localName = declaration.id.name;\n                this.exports[localName] = { identifier: null, localName };\n            }\n        }\n        else {\n            // export { foo, bar, baz }\n            for (const specifier of node.specifiers) {\n                const localName = specifier.local.name;\n                const exportedName = specifier.exported.name;\n                this.exports[exportedName] = { identifier: null, localName };\n            }\n        }\n    }\n    addImport(node) {\n        const source = node.source.value;\n        this.sources.add(source);\n        for (const specifier of node.specifiers) {\n            const localName = specifier.local.name;\n            if (this.importDescriptions[localName]) {\n                return this.error({\n                    code: 'DUPLICATE_IMPORT',\n                    message: `Duplicated import '${localName}'`\n                }, specifier.start);\n            }\n            const isDefault = specifier.type === ImportDefaultSpecifier;\n            const isNamespace = specifier.type === ImportNamespaceSpecifier;\n            const name = isDefault\n                ? 'default'\n                : isNamespace\n                    ? '*'\n                    : specifier.imported.name;\n            this.importDescriptions[localName] = {\n                module: null,\n                name,\n                source,\n                start: specifier.start\n            };\n        }\n    }\n    addImportMeta(node) {\n        this.importMetas.push(node);\n    }\n    addModulesToImportDescriptions(importDescription) {\n        for (const name of Object.keys(importDescription)) {\n            const specifier = importDescription[name];\n            const id = this.resolvedIds[specifier.source].id;\n            specifier.module = this.graph.moduleById.get(id);\n        }\n    }\n    includeDynamicImport(node) {\n        const resolution = this.dynamicImports.find(dynamicImport => dynamicImport.node === node).resolution;\n        if (resolution instanceof Module) {\n            resolution.dynamicallyImportedBy.push(this);\n            resolution.includeAllExports();\n        }\n    }\n    includeVariable(context, variable) {\n        const variableModule = variable.module;\n        if (!variable.included) {\n            variable.include(context);\n            this.graph.needsTreeshakingPass = true;\n        }\n        if (variableModule && variableModule !== this) {\n            this.imports.add(variable);\n        }\n    }\n    removeExistingSourceMap() {\n        for (const comment of this.comments) {\n            if (!comment.block && SOURCEMAPPING_URL_RE.test(comment.text)) {\n                this.magicString.remove(comment.start, comment.end);\n            }\n        }\n    }\n    shimMissingExport(name) {\n        if (!this.exports[name]) {\n            this.graph.warn({\n                code: 'SHIMMED_EXPORT',\n                exporter: relativeId(this.id),\n                exportName: name,\n                message: `Missing export \"${name}\" has been shimmed in module ${relativeId(this.id)}.`\n            });\n            this.exports[name] = MISSING_EXPORT_SHIM_DESCRIPTION;\n        }\n    }\n}\n\nclass Source {\n    constructor(filename, content) {\n        this.isOriginal = true;\n        this.filename = filename;\n        this.content = content;\n    }\n    traceSegment(line, column, name) {\n        return { line, column, name, source: this };\n    }\n}\nclass Link {\n    constructor(map, sources) {\n        this.sources = sources;\n        this.names = map.names;\n        this.mappings = map.mappings;\n    }\n    traceMappings() {\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        const mappings = [];\n        for (const line of this.mappings) {\n            const tracedLine = [];\n            for (const segment of line) {\n                if (segment.length == 1)\n                    continue;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    continue;\n                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');\n                if (traced) {\n                    // newer sources are more likely to be used, so search backwards.\n                    let sourceIndex = sources.lastIndexOf(traced.source.filename);\n                    if (sourceIndex === -1) {\n                        sourceIndex = sources.length;\n                        sources.push(traced.source.filename);\n                        sourcesContent[sourceIndex] = traced.source.content;\n                    }\n                    else if (sourcesContent[sourceIndex] == null) {\n                        sourcesContent[sourceIndex] = traced.source.content;\n                    }\n                    else if (traced.source.content != null &&\n                        sourcesContent[sourceIndex] !== traced.source.content) {\n                        return error({\n                            message: `Multiple conflicting contents for sourcemap source ${traced.source.filename}`\n                        });\n                    }\n                    const tracedSegment = [\n                        segment[0],\n                        sourceIndex,\n                        traced.line,\n                        traced.column\n                    ];\n                    if (traced.name) {\n                        let nameIndex = names.indexOf(traced.name);\n                        if (nameIndex === -1) {\n                            nameIndex = names.length;\n                            names.push(traced.name);\n                        }\n                        tracedSegment[4] = nameIndex;\n                    }\n                    tracedLine.push(tracedSegment);\n                }\n            }\n            mappings.push(tracedLine);\n        }\n        return { sources, sourcesContent, names, mappings };\n    }\n    traceSegment(line, column, name) {\n        const segments = this.mappings[line];\n        if (!segments)\n            return null;\n        // binary search through segments for the given column\n        let i = 0;\n        let j = segments.length - 1;\n        while (i <= j) {\n            const m = (i + j) >> 1;\n            const segment = segments[m];\n            if (segment[0] === column) {\n                if (segment.length == 1)\n                    return null;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    return null;\n                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);\n            }\n            if (segment[0] > column) {\n                j = m - 1;\n            }\n            else {\n                i = m + 1;\n            }\n        }\n        return null;\n    }\n}\nfunction getLinkMap(graph) {\n    return function linkMap(source, map) {\n        if (map.mappings) {\n            return new Link(map, [source]);\n        }\n        graph.warn({\n            code: 'SOURCEMAP_BROKEN',\n            message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform ` +\n                \"files, but didn't generate a sourcemap for the transformation. Consult the plugin \" +\n                'documentation for help',\n            plugin: map.plugin,\n            url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`\n        });\n        return new Link({\n            mappings: [],\n            names: []\n        }, [source]);\n    };\n}\nfunction getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {\n    let source;\n    if (!originalSourcemap) {\n        source = new Source(id, originalCode);\n    }\n    else {\n        const sources = originalSourcemap.sources;\n        const sourcesContent = originalSourcemap.sourcesContent || [];\n        // TODO indiscriminately treating IDs and sources as normal paths is probably bad.\n        const directory = dirname(id) || '.';\n        const sourceRoot = originalSourcemap.sourceRoot || '.';\n        const baseSources = sources.map((source, i) => new Source(resolve(directory, sourceRoot, source), sourcesContent[i]));\n        source = new Link(originalSourcemap, baseSources);\n    }\n    return sourcemapChain.reduce(linkMap, source);\n}\nfunction collapseSourcemaps(bundle, file, map, modules, bundleSourcemapChain, excludeContent) {\n    const linkMap = getLinkMap(bundle.graph);\n    const moduleSources = modules\n        .filter(module => !module.excludeFromSourcemap)\n        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));\n    // DecodedSourceMap (from magic-string) uses a number[] instead of the more\n    // correct SourceMapSegment tuples. Cast it here to gain type safety.\n    let source = new Link(map, moduleSources);\n    source = bundleSourcemapChain.reduce(linkMap, source);\n    let { sources, sourcesContent, names, mappings } = source.traceMappings();\n    if (file) {\n        const directory = dirname(file);\n        sources = sources.map((source) => relative$1(directory, source));\n        file = basename(file);\n    }\n    sourcesContent = (excludeContent ? null : sourcesContent);\n    return new SourceMap({ file, sources, sourcesContent, names, mappings });\n}\nfunction collapseSourcemap(graph, id, originalCode, originalSourcemap, sourcemapChain) {\n    if (!sourcemapChain.length) {\n        return originalSourcemap;\n    }\n    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(graph));\n    const map = source.traceMappings();\n    return Object.assign({ version: 3 }, map);\n}\n\nconst DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {\n    amd: deconflictImportsOther,\n    cjs: deconflictImportsOther,\n    es: deconflictImportsEsm,\n    iife: deconflictImportsOther,\n    system: deconflictImportsEsm,\n    umd: deconflictImportsOther\n};\nfunction deconflictChunk(modules, dependencies, imports, usedNames, format, interop, preserveModules) {\n    for (const module of modules) {\n        module.scope.addUsedOutsideNames(usedNames, format);\n    }\n    deconflictTopLevelVariables(usedNames, modules);\n    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependencies, interop, preserveModules);\n    for (const module of modules) {\n        module.scope.deconflict(format);\n    }\n}\nfunction deconflictImportsEsm(usedNames, imports, _dependencies, interop) {\n    for (const variable of imports) {\n        const module = variable.module;\n        const name = variable.name;\n        let proposedName;\n        if (module instanceof ExternalModule && (name === '*' || name === 'default')) {\n            if (name === 'default' && interop && module.exportsNamespace) {\n                proposedName = module.variableName + '__default';\n            }\n            else {\n                proposedName = module.variableName;\n            }\n        }\n        else {\n            proposedName = name;\n        }\n        variable.setRenderNames(null, getSafeName(proposedName, usedNames));\n    }\n}\nfunction deconflictImportsOther(usedNames, imports, dependencies, interop, preserveModules) {\n    for (const chunkOrExternalModule of dependencies) {\n        chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.variableName, usedNames);\n    }\n    for (const variable of imports) {\n        const module = variable.module;\n        if (module instanceof ExternalModule) {\n            const name = variable.name;\n            if (name === 'default' && interop && (module.exportsNamespace || module.exportsNames)) {\n                variable.setRenderNames(null, module.variableName + '__default');\n            }\n            else if (name === '*' || name === 'default') {\n                variable.setRenderNames(null, module.variableName);\n            }\n            else {\n                variable.setRenderNames(module.variableName, null);\n            }\n        }\n        else {\n            const chunk = module.chunk;\n            if (chunk.exportMode === 'default' || (preserveModules && variable.isNamespace)) {\n                variable.setRenderNames(null, chunk.variableName);\n            }\n            else {\n                variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));\n            }\n        }\n    }\n}\nfunction deconflictTopLevelVariables(usedNames, modules) {\n    for (const module of modules) {\n        for (const variable of module.scope.variables.values()) {\n            if (variable.included &&\n                // this will only happen for exports in some formats\n                !(variable.renderBaseName ||\n                    (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {\n                variable.setRenderNames(null, getSafeName(variable.name, usedNames));\n            }\n        }\n        const namespace = module.getOrCreateNamespace();\n        if (namespace.included) {\n            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));\n        }\n    }\n}\n\nconst compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;\nfunction sortByExecutionOrder(units) {\n    units.sort(compareExecIndex);\n}\nfunction analyseModuleExecution(entryModules) {\n    let nextExecIndex = 0;\n    const cyclePaths = [];\n    const analysedModules = {};\n    const orderedModules = [];\n    const dynamicImports = [];\n    const parents = {};\n    const analyseModule = (module) => {\n        if (analysedModules[module.id])\n            return;\n        if (module instanceof ExternalModule) {\n            module.execIndex = nextExecIndex++;\n            analysedModules[module.id] = true;\n            return;\n        }\n        for (const dependency of module.dependencies) {\n            if (dependency.id in parents) {\n                if (!analysedModules[dependency.id]) {\n                    cyclePaths.push(getCyclePath(dependency.id, module.id, parents));\n                }\n                continue;\n            }\n            parents[dependency.id] = module.id;\n            analyseModule(dependency);\n        }\n        for (const { resolution } of module.dynamicImports) {\n            if (resolution instanceof Module && dynamicImports.indexOf(resolution) === -1) {\n                dynamicImports.push(resolution);\n            }\n        }\n        module.execIndex = nextExecIndex++;\n        analysedModules[module.id] = true;\n        orderedModules.push(module);\n    };\n    for (const curEntry of entryModules) {\n        if (!parents[curEntry.id]) {\n            parents[curEntry.id] = null;\n            analyseModule(curEntry);\n        }\n    }\n    for (const curEntry of dynamicImports) {\n        if (!parents[curEntry.id]) {\n            parents[curEntry.id] = null;\n            analyseModule(curEntry);\n        }\n    }\n    return { orderedModules, cyclePaths };\n}\nfunction getCyclePath(id, parentId, parents) {\n    const path = [relativeId(id)];\n    let curId = parentId;\n    while (curId !== id) {\n        path.push(relativeId(curId));\n        curId = parents[curId];\n        if (!curId)\n            break;\n    }\n    path.push(path[0]);\n    path.reverse();\n    return path;\n}\n\nfunction guessIndentString(code) {\n    const lines = code.split('\\n');\n    const tabbed = lines.filter(line => /^\\t+/.test(line));\n    const spaced = lines.filter(line => /^ {2,}/.test(line));\n    if (tabbed.length === 0 && spaced.length === 0) {\n        return null;\n    }\n    // More lines tabbed than spaced? Assume tabs, and\n    // default to tabs in the case of a tie (or nothing\n    // to go on)\n    if (tabbed.length >= spaced.length) {\n        return '\\t';\n    }\n    // Otherwise, we need to guess the multiple\n    const min = spaced.reduce((previous, current) => {\n        const numSpaces = /^ +/.exec(current)[0].length;\n        return Math.min(numSpaces, previous);\n    }, Infinity);\n    return new Array(min + 1).join(' ');\n}\nfunction getIndentString(modules, options) {\n    if (options.indent !== true)\n        return options.indent || '';\n    for (let i = 0; i < modules.length; i++) {\n        const indent = guessIndentString(modules[i].originalCode);\n        if (indent !== null)\n            return indent;\n    }\n    return '\\t';\n}\n\nfunction decodedSourcemap(map) {\n    if (!map)\n        return null;\n    if (typeof map === 'string') {\n        map = JSON.parse(map);\n    }\n    if (map.mappings === '') {\n        return {\n            mappings: [],\n            names: [],\n            sources: [],\n            version: 3\n        };\n    }\n    let mappings;\n    if (typeof map.mappings === 'string') {\n        mappings = decode(map.mappings);\n    }\n    else {\n        mappings = map.mappings;\n    }\n    return Object.assign(Object.assign({}, map), { mappings });\n}\n\nfunction renderChunk({ chunk, code, options, outputPluginDriver, renderChunk, sourcemapChain }) {\n    const renderChunkReducer = (code, result, plugin) => {\n        if (result == null)\n            return code;\n        if (typeof result === 'string')\n            result = {\n                code: result,\n                map: undefined\n            };\n        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning\n        if (result.map !== null) {\n            const map = decodedSourcemap(result.map);\n            sourcemapChain.push(map || { missing: true, plugin: plugin.name });\n        }\n        return result.code;\n    };\n    let inTransformBundle = false;\n    let inRenderChunk = true;\n    return outputPluginDriver\n        .hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer)\n        .then(code => {\n        inRenderChunk = false;\n        return outputPluginDriver.hookReduceArg0('transformChunk', [code, options, chunk], renderChunkReducer);\n    })\n        .then(code => {\n        inTransformBundle = true;\n        return outputPluginDriver.hookReduceArg0('transformBundle', [code, options, chunk], renderChunkReducer);\n    })\n        .catch(err => {\n        if (inRenderChunk)\n            throw err;\n        return error(err, {\n            code: inTransformBundle ? 'BAD_BUNDLE_TRANSFORMER' : 'BAD_CHUNK_TRANSFORMER',\n            message: `Error transforming ${(inTransformBundle ? 'bundle' : 'chunk') +\n                (err.plugin ? ` with '${err.plugin}' plugin` : '')}: ${err.message}`,\n            plugin: err.plugin\n        });\n    });\n}\n\nfunction renderNamePattern(pattern, patternName, replacements) {\n    if (!isPlainPathFragment(pattern))\n        return error(errFailedValidation(`Invalid pattern \"${pattern}\" for \"${patternName}\", patterns can be neither absolute nor relative paths and must not contain invalid characters.`));\n    return pattern.replace(/\\[(\\w+)\\]/g, (_match, type) => {\n        if (!replacements.hasOwnProperty(type)) {\n            return error(errFailedValidation(`\"[${type}]\" is not a valid placeholder in \"${patternName}\" pattern.`));\n        }\n        const replacement = replacements[type]();\n        if (!isPlainPathFragment(replacement))\n            return error(errFailedValidation(`Invalid substitution \"${replacement}\" for placeholder \"[${type}]\" in \"${patternName}\" pattern, can be neither absolute nor relative path.`));\n        return replacement;\n    });\n}\nfunction makeUnique(name, existingNames) {\n    const existingNamesLowercase = new Set(Object.keys(existingNames).map(key => key.toLowerCase()));\n    if (!existingNamesLowercase.has(name.toLocaleLowerCase()))\n        return name;\n    const ext = extname(name);\n    name = name.substr(0, name.length - ext.length);\n    let uniqueName, uniqueIndex = 1;\n    while (existingNamesLowercase.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()))\n        ;\n    return uniqueName;\n}\n\nconst NON_ASSET_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];\nfunction getGlobalName(module, globals, graph, hasExports) {\n    let globalName;\n    if (typeof globals === 'function') {\n        globalName = globals(module.id);\n    }\n    else if (globals) {\n        globalName = globals[module.id];\n    }\n    if (globalName) {\n        return globalName;\n    }\n    if (hasExports) {\n        graph.warn({\n            code: 'MISSING_GLOBAL_NAME',\n            guess: module.variableName,\n            message: `No name was provided for external module '${module.id}' in output.globals – guessing '${module.variableName}'`,\n            source: module.id\n        });\n        return module.variableName;\n    }\n}\nfunction isChunkRendered(chunk) {\n    return !chunk.isEmpty || chunk.entryModules.length > 0 || chunk.manualChunkAlias !== null;\n}\nclass Chunk$1 {\n    constructor(graph, orderedModules) {\n        this.entryModules = [];\n        this.exportMode = 'named';\n        this.facadeModule = null;\n        this.id = null;\n        this.indentString = undefined;\n        this.manualChunkAlias = null;\n        this.usedModules = undefined;\n        this.variableName = 'chunk';\n        this.dependencies = undefined;\n        this.dynamicDependencies = undefined;\n        this.exportNames = Object.create(null);\n        this.exports = new Set();\n        this.fileName = null;\n        this.imports = new Set();\n        this.name = null;\n        this.needsExportsShim = false;\n        this.renderedDeclarations = undefined;\n        this.renderedHash = undefined;\n        this.renderedModuleSources = new Map();\n        this.renderedSource = null;\n        this.renderedSourceLength = undefined;\n        this.sortedExportNames = null;\n        this.graph = graph;\n        this.orderedModules = orderedModules;\n        this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;\n        this.isEmpty = true;\n        for (const module of orderedModules) {\n            if (this.isEmpty && module.isIncluded()) {\n                this.isEmpty = false;\n            }\n            if (module.manualChunkAlias) {\n                this.manualChunkAlias = module.manualChunkAlias;\n            }\n            module.chunk = this;\n            if (module.isEntryPoint ||\n                module.dynamicallyImportedBy.some(module => orderedModules.indexOf(module) === -1)) {\n                this.entryModules.push(module);\n            }\n        }\n        const moduleForNaming = this.entryModules[0] || this.orderedModules[this.orderedModules.length - 1];\n        if (moduleForNaming) {\n            this.variableName = makeLegal(basename(moduleForNaming.chunkName ||\n                moduleForNaming.manualChunkAlias ||\n                getAliasName(moduleForNaming.id)));\n        }\n    }\n    static generateFacade(graph, facadedModule, facadeName) {\n        const chunk = new Chunk$1(graph, []);\n        chunk.assignFacadeName(facadeName, facadedModule);\n        if (!facadedModule.facadeChunk) {\n            facadedModule.facadeChunk = chunk;\n        }\n        chunk.dependencies = [facadedModule.chunk];\n        chunk.dynamicDependencies = [];\n        chunk.facadeModule = facadedModule;\n        for (const exportName of facadedModule.getAllExportNames()) {\n            const tracedVariable = facadedModule.getVariableForExportName(exportName);\n            chunk.exports.add(tracedVariable);\n            chunk.exportNames[exportName] = tracedVariable;\n        }\n        return chunk;\n    }\n    canModuleBeFacade(moduleExportNamesByVariable) {\n        for (const exposedVariable of this.exports) {\n            if (!moduleExportNamesByVariable.has(exposedVariable)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    generateFacades() {\n        const facades = [];\n        for (const module of this.entryModules) {\n            const requiredFacades = Array.from(module.userChunkNames).map(name => ({\n                name\n            }));\n            if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {\n                requiredFacades.push({});\n            }\n            requiredFacades.push(...Array.from(module.chunkFileNames).map(fileName => ({ fileName })));\n            if (requiredFacades.length === 0) {\n                requiredFacades.push({});\n            }\n            if (!this.facadeModule) {\n                const exportNamesByVariable = module.getExportNamesByVariable();\n                if (this.graph.preserveModules || this.canModuleBeFacade(exportNamesByVariable)) {\n                    this.facadeModule = module;\n                    module.facadeChunk = this;\n                    for (const [variable, exportNames] of exportNamesByVariable) {\n                        for (const exportName of exportNames) {\n                            this.exportNames[exportName] = variable;\n                        }\n                    }\n                    this.assignFacadeName(requiredFacades.shift(), module);\n                }\n            }\n            for (const facadeName of requiredFacades) {\n                facades.push(Chunk$1.generateFacade(this.graph, module, facadeName));\n            }\n        }\n        return facades;\n    }\n    generateId(addons, options, existingNames, includeHash, outputPluginDriver) {\n        if (this.fileName !== null) {\n            return this.fileName;\n        }\n        const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint\n            ? [options.entryFileNames || '[name].js', 'output.entryFileNames']\n            : [options.chunkFileNames || '[name]-[hash].js', 'output.chunkFileNames'];\n        return makeUnique(renderNamePattern(pattern, patternName, {\n            format: () => (options.format === 'es' ? 'esm' : options.format),\n            hash: () => includeHash\n                ? this.computeContentHashWithDependencies(addons, options, existingNames, outputPluginDriver)\n                : '[hash]',\n            name: () => this.getChunkName()\n        }), existingNames);\n    }\n    generateIdPreserveModules(preserveModulesRelativeDir, options, existingNames) {\n        const id = this.orderedModules[0].id;\n        const sanitizedId = sanitizeFileName(id);\n        let path;\n        if (isAbsolute(id)) {\n            const extension = extname(id);\n            const name = renderNamePattern(options.entryFileNames ||\n                (NON_ASSET_EXTENSIONS.includes(extension) ? '[name].js' : '[name][extname].js'), 'output.entryFileNames', {\n                ext: () => extension.substr(1),\n                extname: () => extension,\n                format: () => (options.format === 'es' ? 'esm' : options.format),\n                name: () => this.getChunkName()\n            });\n            path = relative(preserveModulesRelativeDir, `${dirname(sanitizedId)}/${name}`);\n        }\n        else {\n            path = `_virtual/${basename(sanitizedId)}`;\n        }\n        return makeUnique(normalize(path), existingNames);\n    }\n    generateInternalExports(options) {\n        if (this.facadeModule !== null)\n            return;\n        const mangle = options.format === 'system' || options.format === 'es' || options.compact;\n        let i = 0, safeExportName;\n        this.exportNames = Object.create(null);\n        this.sortedExportNames = null;\n        if (mangle) {\n            for (const variable of this.exports) {\n                const suggestedName = variable.name[0];\n                if (!this.exportNames[suggestedName]) {\n                    this.exportNames[suggestedName] = variable;\n                }\n                else {\n                    do {\n                        safeExportName = toBase64(++i);\n                        // skip past leading number identifiers\n                        if (safeExportName.charCodeAt(0) === 49 /* '1' */) {\n                            i += 9 * Math.pow(64, (safeExportName.length - 1));\n                            safeExportName = toBase64(i);\n                        }\n                    } while (RESERVED_NAMES[safeExportName] || this.exportNames[safeExportName]);\n                    this.exportNames[safeExportName] = variable;\n                }\n            }\n        }\n        else {\n            for (const variable of this.exports) {\n                i = 0;\n                safeExportName = variable.name;\n                while (this.exportNames[safeExportName]) {\n                    safeExportName = variable.name + '$' + ++i;\n                }\n                this.exportNames[safeExportName] = variable;\n            }\n        }\n    }\n    getChunkName() {\n        return this.name || (this.name = sanitizeFileName(this.getFallbackChunkName()));\n    }\n    getDynamicImportIds() {\n        return this.dynamicDependencies.map(chunk => chunk.id).filter(Boolean);\n    }\n    getExportNames() {\n        return (this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportNames).sort()));\n    }\n    getImportIds() {\n        return this.dependencies.map(chunk => chunk.id).filter(Boolean);\n    }\n    getRenderedHash(outputPluginDriver) {\n        if (this.renderedHash)\n            return this.renderedHash;\n        if (!this.renderedSource)\n            return '';\n        const hash = createHash();\n        const hashAugmentation = this.calculateHashAugmentation(outputPluginDriver);\n        hash.update(hashAugmentation);\n        hash.update(this.renderedSource.toString());\n        hash.update(this.getExportNames()\n            .map(exportName => {\n            const variable = this.exportNames[exportName];\n            return `${relativeId(variable.module.id).replace(/\\\\/g, '/')}:${variable.name}:${exportName}`;\n        })\n            .join(','));\n        return (this.renderedHash = hash.digest('hex'));\n    }\n    getRenderedSourceLength() {\n        if (this.renderedSourceLength !== undefined)\n            return this.renderedSourceLength;\n        return (this.renderedSourceLength = this.renderedSource.length());\n    }\n    getVariableExportName(variable) {\n        if (this.graph.preserveModules && variable instanceof NamespaceVariable) {\n            return '*';\n        }\n        for (const exportName of Object.keys(this.exportNames)) {\n            if (this.exportNames[exportName] === variable)\n                return exportName;\n        }\n        throw new Error(`Internal Error: Could not find export name for variable ${variable.name}.`);\n    }\n    link() {\n        const dependencies = new Set();\n        const dynamicDependencies = new Set();\n        for (const module of this.orderedModules) {\n            this.addDependenciesToChunk(module.getTransitiveDependencies(), dependencies);\n            this.addDependenciesToChunk(module.dynamicDependencies, dynamicDependencies);\n            this.setUpChunkImportsAndExportsForModule(module);\n        }\n        this.dependencies = Array.from(dependencies);\n        this.dynamicDependencies = Array.from(dynamicDependencies);\n    }\n    /*\n     * Performs a full merge of another chunk into this chunk\n     * chunkList allows updating references in other chunks for the merged chunk to this chunk\n     * A new facade will be added to chunkList if tainting exports of either as an entry point\n     */\n    merge(chunk, chunkList, options, inputBase) {\n        if (this.facadeModule !== null || chunk.facadeModule !== null)\n            throw new Error('Internal error: Code splitting chunk merges not supported for facades');\n        for (const module of chunk.orderedModules) {\n            module.chunk = this;\n            this.orderedModules.push(module);\n        }\n        for (const variable of chunk.imports) {\n            if (!this.imports.has(variable) && variable.module.chunk !== this) {\n                this.imports.add(variable);\n            }\n        }\n        // NB detect when exported variables are orphaned by the merge itself\n        // (involves reverse tracing dependents)\n        for (const variable of chunk.exports) {\n            if (!this.exports.has(variable)) {\n                this.exports.add(variable);\n            }\n        }\n        const thisOldExportNames = this.exportNames;\n        // regenerate internal names\n        this.generateInternalExports(options);\n        const updateRenderedDeclaration = (dep, oldExportNames) => {\n            if (dep.imports) {\n                for (const impt of dep.imports) {\n                    impt.imported = this.getVariableExportName(oldExportNames[impt.imported]);\n                }\n            }\n            if (dep.reexports) {\n                for (const reexport of dep.reexports) {\n                    reexport.imported = this.getVariableExportName(oldExportNames[reexport.imported]);\n                }\n            }\n        };\n        const mergeRenderedDeclaration = (into, from) => {\n            if (from.imports) {\n                if (!into.imports) {\n                    into.imports = from.imports;\n                }\n                else {\n                    into.imports = into.imports.concat(from.imports);\n                }\n            }\n            if (from.reexports) {\n                if (!into.reexports) {\n                    into.reexports = from.reexports;\n                }\n                else {\n                    into.reexports = into.reexports.concat(from.reexports);\n                }\n            }\n            if (!into.exportsNames && from.exportsNames) {\n                into.exportsNames = true;\n            }\n            if (!into.exportsDefault && from.exportsDefault) {\n                into.exportsDefault = true;\n            }\n            into.name = this.variableName;\n        };\n        // go through the other chunks and update their dependencies\n        // also update their import and reexport names in the process\n        for (const c of chunkList) {\n            let includedDeclaration = undefined;\n            for (let i = 0; i < c.dependencies.length; i++) {\n                const dep = c.dependencies[i];\n                if ((dep === chunk || dep === this) && includedDeclaration) {\n                    const duplicateDeclaration = c.renderedDeclarations.dependencies[i];\n                    updateRenderedDeclaration(duplicateDeclaration, dep === chunk ? chunk.exportNames : thisOldExportNames);\n                    mergeRenderedDeclaration(includedDeclaration, duplicateDeclaration);\n                    c.renderedDeclarations.dependencies.splice(i, 1);\n                    c.dependencies.splice(i--, 1);\n                }\n                else if (dep === chunk) {\n                    c.dependencies[i] = this;\n                    includedDeclaration = c.renderedDeclarations.dependencies[i];\n                    updateRenderedDeclaration(includedDeclaration, chunk.exportNames);\n                }\n                else if (dep === this) {\n                    includedDeclaration = c.renderedDeclarations.dependencies[i];\n                    updateRenderedDeclaration(includedDeclaration, thisOldExportNames);\n                }\n            }\n        }\n        // re-render the merged chunk\n        this.preRender(options, inputBase);\n    }\n    // prerender allows chunk hashes and names to be generated before finalizing\n    preRender(options, inputBase) {\n        timeStart('render modules', 3);\n        const magicString = new Bundle({ separator: options.compact ? '' : '\\n\\n' });\n        this.usedModules = [];\n        this.indentString = options.compact ? '' : getIndentString(this.orderedModules, options);\n        const n = options.compact ? '' : '\\n';\n        const _ = options.compact ? '' : ' ';\n        const renderOptions = {\n            compact: options.compact,\n            dynamicImportFunction: options.dynamicImportFunction,\n            format: options.format,\n            freeze: options.freeze !== false,\n            indent: this.indentString,\n            namespaceToStringTag: options.namespaceToStringTag === true,\n            varOrConst: options.preferConst ? 'const' : 'var'\n        };\n        // Make sure the direct dependencies of a chunk are present to maintain execution order\n        for (const { module } of this.imports) {\n            const chunkOrExternal = (module instanceof Module ? module.chunk : module);\n            if (this.dependencies.indexOf(chunkOrExternal) === -1) {\n                this.dependencies.push(chunkOrExternal);\n            }\n        }\n        // for static and dynamic entry points, inline the execution list to avoid loading latency\n        if (options.hoistTransitiveImports !== false &&\n            !this.graph.preserveModules &&\n            this.facadeModule !== null) {\n            for (const dep of this.dependencies) {\n                if (dep instanceof Chunk$1)\n                    this.inlineChunkDependencies(dep, true);\n            }\n        }\n        // prune empty dependency chunks, inlining their side-effect dependencies\n        for (let i = 0; i < this.dependencies.length; i++) {\n            const dep = this.dependencies[i];\n            if (dep instanceof Chunk$1 && dep.isEmpty) {\n                this.dependencies.splice(i--, 1);\n                this.inlineChunkDependencies(dep, false);\n            }\n        }\n        sortByExecutionOrder(this.dependencies);\n        this.prepareDynamicImports();\n        this.setIdentifierRenderResolutions(options);\n        let hoistedSource = '';\n        const renderedModules = (this.renderedModules = Object.create(null));\n        for (const module of this.orderedModules) {\n            let renderedLength = 0;\n            if (module.isIncluded()) {\n                const source = module.render(renderOptions).trim();\n                if (options.compact && source.lastLine().indexOf('//') !== -1)\n                    source.append('\\n');\n                const namespace = module.getOrCreateNamespace();\n                if (namespace.included || source.length() > 0) {\n                    renderedLength = source.length();\n                    this.renderedModuleSources.set(module, source);\n                    magicString.addSource(source);\n                    this.usedModules.push(module);\n                    if (namespace.included && !this.graph.preserveModules) {\n                        const rendered = namespace.renderBlock(renderOptions);\n                        if (namespace.renderFirst())\n                            hoistedSource += n + rendered;\n                        else\n                            magicString.addSource(new MagicString(rendered));\n                    }\n                }\n            }\n            const { renderedExports, removedExports } = module.getRenderedExports();\n            renderedModules[module.id] = {\n                originalLength: module.originalCode.length,\n                removedExports,\n                renderedExports,\n                renderedLength\n            };\n        }\n        if (hoistedSource)\n            magicString.prepend(hoistedSource + n + n);\n        if (this.needsExportsShim) {\n            magicString.prepend(`${n}${renderOptions.varOrConst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);\n        }\n        if (options.compact) {\n            this.renderedSource = magicString;\n        }\n        else {\n            this.renderedSource = magicString.trim();\n        }\n        this.renderedSourceLength = undefined;\n        this.renderedHash = undefined;\n        if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.length === 0) {\n            const chunkName = this.getChunkName();\n            this.graph.warn({\n                chunkName,\n                code: 'EMPTY_BUNDLE',\n                message: `Generated an empty chunk: \"${chunkName}\"`\n            });\n        }\n        this.setExternalRenderPaths(options, inputBase);\n        this.renderedDeclarations = {\n            dependencies: this.getChunkDependencyDeclarations(options),\n            exports: this.exportMode === 'none' ? [] : this.getChunkExportDeclarations()\n        };\n        timeEnd('render modules', 3);\n    }\n    render(options, addons, outputChunk, outputPluginDriver) {\n        timeStart('render format', 3);\n        const format = options.format;\n        const finalise = finalisers[format];\n        if (options.dynamicImportFunction && format !== 'es') {\n            this.graph.warn({\n                code: 'INVALID_OPTION',\n                message: '\"output.dynamicImportFunction\" is ignored for formats other than \"esm\".'\n            });\n        }\n        // populate ids in the rendered declarations only here\n        // as chunk ids known only after prerender\n        for (let i = 0; i < this.dependencies.length; i++) {\n            const dep = this.dependencies[i];\n            if (dep instanceof ExternalModule && !dep.renormalizeRenderPath)\n                continue;\n            const renderedDependency = this.renderedDeclarations.dependencies[i];\n            const depId = dep instanceof ExternalModule ? renderedDependency.id : dep.id;\n            if (dep instanceof Chunk$1)\n                renderedDependency.namedExportsMode = dep.exportMode !== 'default';\n            renderedDependency.id = this.getRelativePath(depId);\n        }\n        this.finaliseDynamicImports(format);\n        this.finaliseImportMetas(format, outputPluginDriver);\n        const hasExports = this.renderedDeclarations.exports.length !== 0 ||\n            this.renderedDeclarations.dependencies.some(dep => (dep.reexports && dep.reexports.length !== 0));\n        let usesTopLevelAwait = false;\n        const accessedGlobals = new Set();\n        for (const module of this.orderedModules) {\n            if (module.usesTopLevelAwait) {\n                usesTopLevelAwait = true;\n            }\n            const accessedGlobalVariablesByFormat = module.scope.accessedGlobalVariablesByFormat;\n            const accessedGlobalVariables = accessedGlobalVariablesByFormat && accessedGlobalVariablesByFormat.get(format);\n            if (accessedGlobalVariables) {\n                for (const name of accessedGlobalVariables) {\n                    accessedGlobals.add(name);\n                }\n            }\n        }\n        if (usesTopLevelAwait && format !== 'es' && format !== 'system') {\n            return error({\n                code: 'INVALID_TLA_FORMAT',\n                message: `Module format ${format} does not support top-level await. Use the \"es\" or \"system\" output formats rather.`\n            });\n        }\n        const magicString = finalise(this.renderedSource, {\n            accessedGlobals,\n            dependencies: this.renderedDeclarations.dependencies,\n            exports: this.renderedDeclarations.exports,\n            hasExports,\n            indentString: this.indentString,\n            intro: addons.intro,\n            isEntryModuleFacade: this.graph.preserveModules ||\n                (this.facadeModule !== null && this.facadeModule.isEntryPoint),\n            namedExportsMode: this.exportMode !== 'default',\n            outro: addons.outro,\n            usesTopLevelAwait,\n            varOrConst: options.preferConst ? 'const' : 'var',\n            warn: this.graph.warn.bind(this.graph)\n        }, options);\n        if (addons.banner)\n            magicString.prepend(addons.banner);\n        if (addons.footer)\n            magicString.append(addons.footer);\n        const prevCode = magicString.toString();\n        timeEnd('render format', 3);\n        let map = null;\n        const chunkSourcemapChain = [];\n        return renderChunk({\n            chunk: this,\n            code: prevCode,\n            options,\n            outputPluginDriver,\n            renderChunk: outputChunk,\n            sourcemapChain: chunkSourcemapChain\n        }).then((code) => {\n            if (options.sourcemap) {\n                timeStart('sourcemap', 3);\n                let file;\n                if (options.file)\n                    file = resolve(options.sourcemapFile || options.file);\n                else if (options.dir)\n                    file = resolve(options.dir, this.id);\n                else\n                    file = resolve(this.id);\n                const decodedMap = magicString.generateDecodedMap({});\n                map = collapseSourcemaps(this, file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources);\n                map.sources = map.sources.map(sourcePath => normalize(options.sourcemapPathTransform ? options.sourcemapPathTransform(sourcePath) : sourcePath));\n                timeEnd('sourcemap', 3);\n            }\n            if (options.compact !== true && code[code.length - 1] !== '\\n')\n                code += '\\n';\n            return { code, map };\n        });\n    }\n    visitDependencies(handleDependency) {\n        const toBeVisited = [this];\n        const visited = new Set();\n        for (const current of toBeVisited) {\n            handleDependency(current);\n            if (current instanceof ExternalModule)\n                continue;\n            for (const dependency of current.dependencies.concat(current.dynamicDependencies)) {\n                if (!visited.has(dependency)) {\n                    visited.add(dependency);\n                    toBeVisited.push(dependency);\n                }\n            }\n        }\n    }\n    visitStaticDependenciesUntilCondition(isConditionSatisfied) {\n        const seen = new Set();\n        function visitDep(dep) {\n            if (seen.has(dep))\n                return undefined;\n            seen.add(dep);\n            if (dep instanceof Chunk$1) {\n                for (const subDep of dep.dependencies) {\n                    if (visitDep(subDep))\n                        return true;\n                }\n            }\n            return isConditionSatisfied(dep) === true;\n        }\n        return visitDep(this);\n    }\n    addDependenciesToChunk(moduleDependencies, chunkDependencies) {\n        for (const depModule of moduleDependencies) {\n            if (depModule.chunk === this) {\n                continue;\n            }\n            let dependency;\n            if (depModule instanceof Module) {\n                dependency = depModule.chunk;\n            }\n            else {\n                if (!(depModule.used || depModule.moduleSideEffects)) {\n                    continue;\n                }\n                dependency = depModule;\n            }\n            chunkDependencies.add(dependency);\n        }\n    }\n    assignFacadeName({ fileName, name }, facadedModule) {\n        if (fileName) {\n            this.fileName = fileName;\n        }\n        else {\n            this.name = sanitizeFileName(name || facadedModule.chunkName || getAliasName(facadedModule.id));\n        }\n    }\n    calculateHashAugmentation(outputPluginDriver) {\n        const facadeModule = this.facadeModule;\n        const getChunkName = this.getChunkName.bind(this);\n        const preRenderedChunk = {\n            dynamicImports: this.getDynamicImportIds(),\n            exports: this.getExportNames(),\n            facadeModuleId: facadeModule && facadeModule.id,\n            imports: this.getImportIds(),\n            isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,\n            isEntry: facadeModule !== null && facadeModule.isEntryPoint,\n            modules: this.renderedModules,\n            get name() {\n                return getChunkName();\n            }\n        };\n        return outputPluginDriver.hookReduceValueSync('augmentChunkHash', '', [preRenderedChunk], (hashAugmentation, pluginHash) => {\n            if (pluginHash) {\n                hashAugmentation += pluginHash;\n            }\n            return hashAugmentation;\n        });\n    }\n    computeContentHashWithDependencies(addons, options, existingNames, outputPluginDriver) {\n        const hash = createHash();\n        hash.update([addons.intro, addons.outro, addons.banner, addons.footer].map(addon => addon || '').join(':'));\n        hash.update(options.format);\n        this.visitDependencies(dep => {\n            if (dep instanceof ExternalModule) {\n                hash.update(':' + dep.renderPath);\n            }\n            else {\n                hash.update(dep.getRenderedHash(outputPluginDriver));\n                hash.update(dep.generateId(addons, options, existingNames, false, outputPluginDriver));\n            }\n        });\n        return hash.digest('hex').substr(0, 8);\n    }\n    finaliseDynamicImports(format) {\n        for (const [module, code] of this.renderedModuleSources) {\n            for (const { node, resolution } of module.dynamicImports) {\n                if (!resolution)\n                    continue;\n                if (resolution instanceof Module) {\n                    if (resolution.chunk !== this && isChunkRendered(resolution.chunk)) {\n                        const resolutionChunk = resolution.facadeChunk || resolution.chunk;\n                        node.renderFinalResolution(code, `'${this.getRelativePath(resolutionChunk.id)}'`, format);\n                    }\n                }\n                else {\n                    node.renderFinalResolution(code, resolution instanceof ExternalModule\n                        ? `'${resolution.renormalizeRenderPath\n                            ? this.getRelativePath(resolution.renderPath)\n                            : resolution.id}'`\n                        : resolution, format);\n                }\n            }\n        }\n    }\n    finaliseImportMetas(format, outputPluginDriver) {\n        for (const [module, code] of this.renderedModuleSources) {\n            for (const importMeta of module.importMetas) {\n                importMeta.renderFinalMechanism(code, this.id, format, outputPluginDriver);\n            }\n        }\n    }\n    getChunkDependencyDeclarations(options) {\n        const reexportDeclarations = new Map();\n        for (let exportName of this.getExportNames()) {\n            let exportChunk;\n            let importName;\n            let needsLiveBinding = false;\n            if (exportName[0] === '*') {\n                needsLiveBinding = options.externalLiveBindings !== false;\n                exportChunk = this.graph.moduleById.get(exportName.substr(1));\n                importName = exportName = '*';\n            }\n            else {\n                const variable = this.exportNames[exportName];\n                const module = variable.module;\n                // skip local exports\n                if (!module || module.chunk === this)\n                    continue;\n                if (module instanceof Module) {\n                    exportChunk = module.chunk;\n                    importName = exportChunk.getVariableExportName(variable);\n                    needsLiveBinding = variable.isReassigned;\n                }\n                else {\n                    exportChunk = module;\n                    importName = variable.name;\n                    needsLiveBinding = options.externalLiveBindings !== false;\n                }\n            }\n            let reexportDeclaration = reexportDeclarations.get(exportChunk);\n            if (!reexportDeclaration)\n                reexportDeclarations.set(exportChunk, (reexportDeclaration = []));\n            reexportDeclaration.push({ imported: importName, reexported: exportName, needsLiveBinding });\n        }\n        const renderedImports = new Set();\n        const dependencies = [];\n        for (const dep of this.dependencies) {\n            const imports = [];\n            for (const variable of this.imports) {\n                const renderedVariable = variable instanceof ExportDefaultVariable ? variable.getOriginalVariable() : variable;\n                if ((variable.module instanceof Module\n                    ? variable.module.chunk === dep\n                    : variable.module === dep) &&\n                    !renderedImports.has(renderedVariable)) {\n                    renderedImports.add(renderedVariable);\n                    imports.push({\n                        imported: variable.module instanceof ExternalModule\n                            ? variable.name\n                            : variable.module.chunk.getVariableExportName(variable),\n                        local: variable.getName()\n                    });\n                }\n            }\n            const reexports = reexportDeclarations.get(dep);\n            let exportsNames, exportsDefault;\n            let namedExportsMode = true;\n            if (dep instanceof ExternalModule) {\n                exportsNames = dep.exportsNames || dep.exportsNamespace;\n                exportsDefault = 'default' in dep.declarations;\n            }\n            else {\n                exportsNames = true;\n                // we don't want any interop patterns to trigger\n                exportsDefault = false;\n                namedExportsMode = dep.exportMode !== 'default';\n            }\n            let id = undefined;\n            let globalName = undefined;\n            if (dep instanceof ExternalModule) {\n                id = dep.renderPath;\n                if (options.format === 'umd' || options.format === 'iife') {\n                    globalName = getGlobalName(dep, options.globals, this.graph, exportsNames || exportsDefault);\n                }\n            }\n            dependencies.push({\n                exportsDefault,\n                exportsNames,\n                globalName,\n                id,\n                imports: imports.length > 0 ? imports : null,\n                isChunk: dep instanceof Chunk$1,\n                name: dep.variableName,\n                namedExportsMode,\n                reexports\n            });\n        }\n        return dependencies;\n    }\n    getChunkExportDeclarations() {\n        const exports = [];\n        for (const exportName of this.getExportNames()) {\n            if (exportName[0] === '*')\n                continue;\n            const variable = this.exportNames[exportName];\n            const module = variable.module;\n            if (module && module.chunk !== this)\n                continue;\n            let hoisted = false;\n            let uninitialized = false;\n            if (variable instanceof LocalVariable) {\n                if (variable.init === UNDEFINED_EXPRESSION) {\n                    uninitialized = true;\n                }\n                for (const declaration of variable.declarations) {\n                    if (declaration.parent instanceof FunctionDeclaration ||\n                        (declaration instanceof ExportDefaultDeclaration &&\n                            declaration.declaration instanceof FunctionDeclaration)) {\n                        hoisted = true;\n                        break;\n                    }\n                }\n            }\n            else if (variable instanceof GlobalVariable) {\n                hoisted = true;\n            }\n            const localName = variable.getName();\n            exports.push({\n                exported: exportName === '*' ? localName : exportName,\n                hoisted,\n                local: localName,\n                uninitialized\n            });\n        }\n        return exports;\n    }\n    getFallbackChunkName() {\n        if (this.manualChunkAlias) {\n            return this.manualChunkAlias;\n        }\n        if (this.fileName) {\n            return getAliasName(this.fileName);\n        }\n        return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);\n    }\n    getRelativePath(targetPath) {\n        const relativePath = normalize(relative(dirname(this.id), targetPath));\n        return relativePath.startsWith('../') ? relativePath : './' + relativePath;\n    }\n    inlineChunkDependencies(chunk, deep) {\n        for (const dep of chunk.dependencies) {\n            if (dep instanceof ExternalModule) {\n                if (this.dependencies.indexOf(dep) === -1)\n                    this.dependencies.push(dep);\n            }\n            else {\n                if (dep === this || this.dependencies.indexOf(dep) !== -1)\n                    continue;\n                if (!dep.isEmpty)\n                    this.dependencies.push(dep);\n                if (deep)\n                    this.inlineChunkDependencies(dep, true);\n            }\n        }\n    }\n    prepareDynamicImports() {\n        for (const module of this.orderedModules) {\n            for (const { node, resolution } of module.dynamicImports) {\n                if (!node.included)\n                    continue;\n                if (resolution instanceof Module) {\n                    if (resolution.chunk === this) {\n                        const namespace = resolution.getOrCreateNamespace();\n                        node.setResolution('named', namespace);\n                    }\n                    else {\n                        node.setResolution(resolution.chunk.exportMode);\n                    }\n                }\n                else {\n                    node.setResolution('auto');\n                }\n            }\n        }\n    }\n    setExternalRenderPaths(options, inputBase) {\n        for (const dependency of this.dependencies.concat(this.dynamicDependencies)) {\n            if (dependency instanceof ExternalModule) {\n                dependency.setRenderPath(options, inputBase);\n            }\n        }\n    }\n    setIdentifierRenderResolutions(options) {\n        for (const exportName of this.getExportNames()) {\n            const exportVariable = this.exportNames[exportName];\n            if (exportVariable) {\n                if (exportVariable instanceof ExportShimVariable) {\n                    this.needsExportsShim = true;\n                }\n                exportVariable.exportName = exportName;\n                if (options.format !== 'es' &&\n                    options.format !== 'system' &&\n                    exportVariable.isReassigned &&\n                    !exportVariable.isId &&\n                    !(exportVariable instanceof ExportDefaultVariable && exportVariable.hasId)) {\n                    exportVariable.setRenderNames('exports', exportName);\n                }\n                else {\n                    exportVariable.setRenderNames(null, null);\n                }\n            }\n        }\n        const usedNames = new Set();\n        if (this.needsExportsShim) {\n            usedNames.add(MISSING_EXPORT_SHIM_VARIABLE);\n        }\n        if (options.format !== 'es') {\n            usedNames.add('exports');\n            if (options.format === 'cjs') {\n                usedNames\n                    .add(INTEROP_DEFAULT_VARIABLE)\n                    .add('require')\n                    .add('module')\n                    .add('__filename')\n                    .add('__dirname');\n            }\n        }\n        deconflictChunk(this.orderedModules, this.dependencies, this.imports, usedNames, options.format, options.interop !== false, this.graph.preserveModules);\n    }\n    setUpChunkImportsAndExportsForModule(module) {\n        for (const variable of module.imports) {\n            if (variable.module.chunk !== this) {\n                this.imports.add(variable);\n                if (variable.module instanceof Module) {\n                    variable.module.chunk.exports.add(variable);\n                }\n            }\n        }\n        if (module.isEntryPoint ||\n            module.dynamicallyImportedBy.some(importer => importer.chunk !== this)) {\n            const map = module.getExportNamesByVariable();\n            for (const exportedVariable of map.keys()) {\n                this.exports.add(exportedVariable);\n                const exportingModule = exportedVariable.module;\n                if (exportingModule && exportingModule.chunk && exportingModule.chunk !== this) {\n                    exportingModule.chunk.exports.add(exportedVariable);\n                }\n            }\n        }\n        if (module.getOrCreateNamespace().included) {\n            for (const reexportName of Object.keys(module.reexportDescriptions)) {\n                const reexport = module.reexportDescriptions[reexportName];\n                const variable = reexport.module.getVariableForExportName(reexport.localName);\n                if (variable.module.chunk !== this) {\n                    this.imports.add(variable);\n                    if (variable.module instanceof Module) {\n                        variable.module.chunk.exports.add(variable);\n                    }\n                }\n            }\n        }\n        const context = createInclusionContext();\n        for (const { node, resolution } of module.dynamicImports) {\n            if (node.included && resolution instanceof Module && resolution.chunk === this)\n                resolution.getOrCreateNamespace().include(context);\n        }\n    }\n}\n\n/*\n * Given a chunk list, perform optimizations on that chunk list\n * to reduce the mumber of chunks. Mutates the chunks array.\n *\n * Manual chunks (with chunk.chunkAlias already set) are preserved\n * Entry points are carefully preserved as well\n *\n */\nfunction optimizeChunks(chunks, options, CHUNK_GROUPING_SIZE, inputBase) {\n    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n        const mainChunk = chunks[chunkIndex];\n        const execGroup = [];\n        mainChunk.visitStaticDependenciesUntilCondition(dep => {\n            if (dep instanceof Chunk$1) {\n                execGroup.push(dep);\n            }\n        });\n        if (execGroup.length < 2) {\n            continue;\n        }\n        let execGroupIndex = 1;\n        let seekingFirstMergeCandidate = true;\n        let lastChunk = undefined, chunk = execGroup[0], nextChunk = execGroup[1];\n        const isMergeCandidate = (chunk) => {\n            if (chunk.facadeModule !== null || chunk.manualChunkAlias !== null) {\n                return false;\n            }\n            if (!nextChunk || nextChunk.facadeModule !== null) {\n                return false;\n            }\n            if (chunk.getRenderedSourceLength() > CHUNK_GROUPING_SIZE) {\n                return false;\n            }\n            // if (!chunk.isPure()) continue;\n            return true;\n        };\n        do {\n            if (seekingFirstMergeCandidate) {\n                if (isMergeCandidate(chunk)) {\n                    seekingFirstMergeCandidate = false;\n                }\n                continue;\n            }\n            let remainingSize = CHUNK_GROUPING_SIZE - lastChunk.getRenderedSourceLength() - chunk.getRenderedSourceLength();\n            if (remainingSize <= 0) {\n                if (!isMergeCandidate(chunk)) {\n                    seekingFirstMergeCandidate = true;\n                }\n                continue;\n            }\n            // if (!chunk.isPure()) continue;\n            const chunkDependencies = new Set();\n            chunk.visitStaticDependenciesUntilCondition(dep => chunkDependencies.add(dep));\n            const ignoreSizeChunks = new Set([chunk, lastChunk]);\n            if (lastChunk.visitStaticDependenciesUntilCondition(dep => {\n                if (dep === chunk || dep === lastChunk) {\n                    return false;\n                }\n                if (chunkDependencies.has(dep)) {\n                    return false;\n                }\n                if (dep instanceof ExternalModule) {\n                    return true;\n                }\n                remainingSize -= dep.getRenderedSourceLength();\n                if (remainingSize <= 0) {\n                    return true;\n                }\n                ignoreSizeChunks.add(dep);\n            })) {\n                if (!isMergeCandidate(chunk)) {\n                    seekingFirstMergeCandidate = true;\n                }\n                continue;\n            }\n            if (chunk.visitStaticDependenciesUntilCondition(dep => {\n                if (ignoreSizeChunks.has(dep)) {\n                    return false;\n                }\n                if (dep instanceof ExternalModule) {\n                    return true;\n                }\n                remainingSize -= dep.getRenderedSourceLength();\n                if (remainingSize <= 0) {\n                    return true;\n                }\n            })) {\n                if (!isMergeCandidate(chunk)) {\n                    seekingFirstMergeCandidate = true;\n                }\n                continue;\n            }\n            // within the size limit -> merge!\n            const optimizedChunkIndex = chunks.indexOf(chunk);\n            if (optimizedChunkIndex <= chunkIndex)\n                chunkIndex--;\n            chunks.splice(optimizedChunkIndex, 1);\n            lastChunk.merge(chunk, chunks, options, inputBase);\n            execGroup.splice(--execGroupIndex, 1);\n            chunk = lastChunk;\n            // keep going to see if we can merge this with the next again\n            if (nextChunk && !isMergeCandidate(nextChunk)) {\n                seekingFirstMergeCandidate = true;\n            }\n        } while (((lastChunk = chunk), (chunk = nextChunk), (nextChunk = execGroup[++execGroupIndex]), chunk));\n    }\n    return chunks;\n}\n\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst tt = acorn__default.tokTypes;\nvar acornExportNsFrom = function (Parser) {\n    return class extends Parser {\n        parseExport(node, exports) {\n            skipWhiteSpace.lastIndex = this.pos;\n            const skip = skipWhiteSpace.exec(this.input);\n            const next = this.input.charAt(this.pos + skip[0].length);\n            if (next !== \"*\")\n                return super.parseExport(node, exports);\n            this.next();\n            const specifier = this.startNode();\n            this.expect(tt.star);\n            if (this.eatContextual(\"as\")) {\n                node.declaration = null;\n                specifier.exported = this.parseIdent(true);\n                this.checkExport(exports, specifier.exported.name, this.lastTokStart);\n                node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n            }\n            this.expectContextual(\"from\");\n            if (this.type !== tt.string)\n                this.unexpected();\n            node.source = this.parseExprAtom();\n            this.semicolon();\n            return this.finishNode(node, node.specifiers ? \"ExportNamedDeclaration\" : \"ExportAllDeclaration\");\n        }\n    };\n};\n\nconst tt$1 = acorn__default.tokTypes;\nconst skipWhiteSpace$1 = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst nextTokenIsDot = parser => {\n    skipWhiteSpace$1.lastIndex = parser.pos;\n    let skip = skipWhiteSpace$1.exec(parser.input);\n    let next = parser.pos + skip[0].length;\n    return parser.input.slice(next, next + 1) === \".\";\n};\nvar acornImportMeta = function (Parser) {\n    return class extends Parser {\n        parseExprAtom(refDestructuringErrors) {\n            if (this.type !== tt$1._import || !nextTokenIsDot(this))\n                return super.parseExprAtom(refDestructuringErrors);\n            if (!this.options.allowImportExportEverywhere && !this.inModule) {\n                this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n            }\n            let node = this.startNode();\n            node.meta = this.parseIdent(true);\n            this.expect(tt$1.dot);\n            node.property = this.parseIdent(true);\n            if (node.property.name !== \"meta\") {\n                this.raiseRecoverable(node.property.start, \"The only valid meta property for import is import.meta\");\n            }\n            if (this.containsEsc) {\n                this.raiseRecoverable(node.property.start, \"\\\"meta\\\" in import.meta must not contain escape sequences\");\n            }\n            return this.finishNode(node, \"MetaProperty\");\n        }\n        parseStatement(context, topLevel, exports) {\n            if (this.type !== tt$1._import || !nextTokenIsDot(this)) {\n                return super.parseStatement(context, topLevel, exports);\n            }\n            let node = this.startNode();\n            let expr = this.parseExpression();\n            return this.parseExpressionStatement(node, expr);\n        }\n    };\n};\n\nclass UndefinedVariable extends Variable {\n    constructor() {\n        super('undefined');\n    }\n    getLiteralValueAtPath() {\n        return undefined;\n    }\n}\n\nclass GlobalScope extends Scope {\n    constructor() {\n        super();\n        this.variables.set('undefined', new UndefinedVariable());\n    }\n    findVariable(name) {\n        let variable = this.variables.get(name);\n        if (!variable) {\n            variable = new GlobalVariable(name);\n            this.variables.set(name, variable);\n        }\n        return variable;\n    }\n}\n\nconst ANONYMOUS_PLUGIN_PREFIX = 'at position ';\nconst ANONYMOUS_OUTPUT_PLUGIN_PREFIX = 'at output position ';\nfunction throwPluginError(err, plugin, { hook, id } = {}) {\n    if (typeof err === 'string')\n        err = { message: err };\n    if (err.code && err.code !== Errors.PLUGIN_ERROR) {\n        err.pluginCode = err.code;\n    }\n    err.code = Errors.PLUGIN_ERROR;\n    err.plugin = plugin;\n    if (hook) {\n        err.hook = hook;\n    }\n    if (id) {\n        err.id = id;\n    }\n    return error(err);\n}\nconst deprecatedHooks = [\n    { active: true, deprecated: 'ongenerate', replacement: 'generateBundle' },\n    { active: true, deprecated: 'onwrite', replacement: 'generateBundle/writeBundle' },\n    { active: true, deprecated: 'transformBundle', replacement: 'renderChunk' },\n    { active: true, deprecated: 'transformChunk', replacement: 'renderChunk' },\n    { active: false, deprecated: 'resolveAssetUrl', replacement: 'resolveFileUrl' }\n];\nfunction warnDeprecatedHooks(plugins, graph) {\n    for (const { active, deprecated, replacement } of deprecatedHooks) {\n        for (const plugin of plugins) {\n            if (deprecated in plugin) {\n                graph.warnDeprecation({\n                    message: `The \"${deprecated}\" hook used by plugin ${plugin.name} is deprecated. The \"${replacement}\" hook should be used instead.`,\n                    plugin: plugin.name\n                }, active);\n            }\n        }\n    }\n}\n\nfunction createPluginCache(cache) {\n    return {\n        has(id) {\n            const item = cache[id];\n            if (!item)\n                return false;\n            item[0] = 0;\n            return true;\n        },\n        get(id) {\n            const item = cache[id];\n            if (!item)\n                return undefined;\n            item[0] = 0;\n            return item[1];\n        },\n        set(id, value) {\n            cache[id] = [0, value];\n        },\n        delete(id) {\n            return delete cache[id];\n        }\n    };\n}\nfunction getTrackedPluginCache(pluginCache) {\n    const trackedCache = {\n        cache: {\n            has(id) {\n                trackedCache.used = true;\n                return pluginCache.has(id);\n            },\n            get(id) {\n                trackedCache.used = true;\n                return pluginCache.get(id);\n            },\n            set(id, value) {\n                trackedCache.used = true;\n                return pluginCache.set(id, value);\n            },\n            delete(id) {\n                trackedCache.used = true;\n                return pluginCache.delete(id);\n            }\n        },\n        used: false\n    };\n    return trackedCache;\n}\nconst NO_CACHE = {\n    has() {\n        return false;\n    },\n    get() {\n        return undefined;\n    },\n    set() { },\n    delete() {\n        return false;\n    }\n};\nfunction uncacheablePluginError(pluginName) {\n    if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||\n        pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {\n        return error({\n            code: 'ANONYMOUS_PLUGIN_CACHE',\n            message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'\n        });\n    }\n    return error({\n        code: 'DUPLICATE_PLUGIN_NAME',\n        message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`\n    });\n}\nfunction getCacheForUncacheablePlugin(pluginName) {\n    return {\n        has() {\n            return uncacheablePluginError(pluginName);\n        },\n        get() {\n            return uncacheablePluginError(pluginName);\n        },\n        set() {\n            return uncacheablePluginError(pluginName);\n        },\n        delete() {\n            return uncacheablePluginError(pluginName);\n        }\n    };\n}\n\nfunction transform(graph, source, module) {\n    const id = module.id;\n    const sourcemapChain = [];\n    let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);\n    const originalCode = source.code;\n    let ast = source.ast;\n    const transformDependencies = [];\n    const emittedFiles = [];\n    let customTransformCache = false;\n    let moduleSideEffects = null;\n    let syntheticNamedExports = null;\n    let trackedPluginCache;\n    let curPlugin;\n    const curSource = source.code;\n    function transformReducer(code, result, plugin) {\n        // track which plugins use the custom this.cache to opt-out of transform caching\n        if (!customTransformCache && trackedPluginCache.used)\n            customTransformCache = true;\n        if (customTransformCache) {\n            if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {\n                for (const dep of result.dependencies) {\n                    graph.watchFiles[resolve(dirname(id), dep)] = true;\n                }\n            }\n        }\n        else {\n            // files emitted by a transform hook need to be emitted again if the hook is skipped\n            if (emittedFiles.length)\n                module.transformFiles = emittedFiles;\n            if (result && typeof result === 'object' && Array.isArray(result.dependencies)) {\n                // not great, but a useful way to track this without assuming WeakMap\n                if (!curPlugin.warnedTransformDependencies)\n                    graph.warnDeprecation(`Returning \"dependencies\" from the \"transform\" hook as done by plugin ${plugin.name} is deprecated. The \"this.addWatchFile\" plugin context function should be used instead.`, true);\n                curPlugin.warnedTransformDependencies = true;\n                for (const dep of result.dependencies)\n                    transformDependencies.push(resolve(dirname(id), dep));\n            }\n        }\n        if (typeof result === 'string') {\n            result = {\n                ast: undefined,\n                code: result,\n                map: undefined\n            };\n        }\n        else if (result && typeof result === 'object') {\n            if (typeof result.map === 'string') {\n                result.map = JSON.parse(result.map);\n            }\n            if (typeof result.moduleSideEffects === 'boolean') {\n                moduleSideEffects = result.moduleSideEffects;\n            }\n            if (typeof result.syntheticNamedExports === 'boolean') {\n                syntheticNamedExports = result.syntheticNamedExports;\n            }\n        }\n        else {\n            return code;\n        }\n        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning\n        if (result.map !== null) {\n            const map = decodedSourcemap(result.map);\n            sourcemapChain.push(map || { missing: true, plugin: plugin.name });\n        }\n        ast = result.ast;\n        return result.code;\n    }\n    let setAssetSourceErr;\n    return graph.pluginDriver\n        .hookReduceArg0('transform', [curSource, id], transformReducer, (pluginContext, plugin) => {\n        curPlugin = plugin;\n        if (curPlugin.cacheKey)\n            customTransformCache = true;\n        else\n            trackedPluginCache = getTrackedPluginCache(pluginContext.cache);\n        return Object.assign(Object.assign({}, pluginContext), { cache: trackedPluginCache ? trackedPluginCache.cache : pluginContext.cache, warn(warning, pos) {\n                if (typeof warning === 'string')\n                    warning = { message: warning };\n                if (pos)\n                    augmentCodeLocation(warning, pos, curSource, id);\n                warning.id = id;\n                warning.hook = 'transform';\n                pluginContext.warn(warning);\n            },\n            error(err, pos) {\n                if (typeof err === 'string')\n                    err = { message: err };\n                if (pos)\n                    augmentCodeLocation(err, pos, curSource, id);\n                err.id = id;\n                err.hook = 'transform';\n                return pluginContext.error(err);\n            },\n            emitAsset(name, source) {\n                const emittedFile = { type: 'asset', name, source };\n                emittedFiles.push(Object.assign({}, emittedFile));\n                return graph.pluginDriver.emitFile(emittedFile);\n            },\n            emitChunk(id, options) {\n                const emittedFile = { type: 'chunk', id, name: options && options.name };\n                emittedFiles.push(Object.assign({}, emittedFile));\n                return graph.pluginDriver.emitFile(emittedFile);\n            },\n            emitFile(emittedFile) {\n                emittedFiles.push(emittedFile);\n                return graph.pluginDriver.emitFile(emittedFile);\n            },\n            addWatchFile(id) {\n                transformDependencies.push(id);\n                pluginContext.addWatchFile(id);\n            },\n            setAssetSource(assetReferenceId, source) {\n                pluginContext.setAssetSource(assetReferenceId, source);\n                if (!customTransformCache && !setAssetSourceErr) {\n                    try {\n                        return this.error({\n                            code: 'INVALID_SETASSETSOURCE',\n                            message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`\n                        });\n                    }\n                    catch (err) {\n                        setAssetSourceErr = err;\n                    }\n                }\n            },\n            getCombinedSourcemap() {\n                const combinedMap = collapseSourcemap(graph, id, originalCode, originalSourcemap, sourcemapChain);\n                if (!combinedMap) {\n                    const magicString = new MagicString(originalCode);\n                    return magicString.generateMap({ includeContent: true, hires: true, source: id });\n                }\n                if (originalSourcemap !== combinedMap) {\n                    originalSourcemap = combinedMap;\n                    sourcemapChain.length = 0;\n                }\n                return new SourceMap(Object.assign(Object.assign({}, combinedMap), { file: null, sourcesContent: combinedMap.sourcesContent }));\n            } });\n    })\n        .catch(err => throwPluginError(err, curPlugin.name, { hook: 'transform', id }))\n        .then(code => {\n        if (!customTransformCache && setAssetSourceErr)\n            throw setAssetSourceErr;\n        return {\n            ast: ast,\n            code,\n            customTransformCache,\n            moduleSideEffects,\n            originalCode,\n            originalSourcemap,\n            sourcemapChain,\n            syntheticNamedExports,\n            transformDependencies\n        };\n    });\n}\n\nfunction normalizeRelativeExternalId(importer, source) {\n    return isRelative(source) ? resolve(importer, '..', source) : source;\n}\nfunction getIdMatcher(option) {\n    if (option === true) {\n        return () => true;\n    }\n    if (typeof option === 'function') {\n        return (id, ...args) => (!id.startsWith('\\0') && option(id, ...args)) || false;\n    }\n    if (option) {\n        const ids = new Set(Array.isArray(option) ? option : option ? [option] : []);\n        return (id => ids.has(id));\n    }\n    return () => false;\n}\nfunction getHasModuleSideEffects(moduleSideEffectsOption, pureExternalModules, graph) {\n    if (typeof moduleSideEffectsOption === 'boolean') {\n        return () => moduleSideEffectsOption;\n    }\n    if (moduleSideEffectsOption === 'no-external') {\n        return (_id, external) => !external;\n    }\n    if (typeof moduleSideEffectsOption === 'function') {\n        return (id, external) => !id.startsWith('\\0') ? moduleSideEffectsOption(id, external) !== false : true;\n    }\n    if (Array.isArray(moduleSideEffectsOption)) {\n        const ids = new Set(moduleSideEffectsOption);\n        return id => ids.has(id);\n    }\n    if (moduleSideEffectsOption) {\n        graph.warn(errInvalidOption('treeshake.moduleSideEffects', 'please use one of false, \"no-external\", a function or an array'));\n    }\n    const isPureExternalModule = getIdMatcher(pureExternalModules);\n    return (id, external) => !(external && isPureExternalModule(id));\n}\nclass ModuleLoader {\n    constructor(graph, modulesById, pluginDriver, external, getManualChunk, moduleSideEffects, pureExternalModules) {\n        this.indexedEntryModules = [];\n        this.latestLoadModulesPromise = Promise.resolve();\n        this.manualChunkModules = {};\n        this.nextEntryModuleIndex = 0;\n        this.loadEntryModule = (unresolvedId, isEntry) => this.pluginDriver.hookFirst('resolveId', [unresolvedId, undefined]).then(resolveIdResult => {\n            if (resolveIdResult === false ||\n                (resolveIdResult && typeof resolveIdResult === 'object' && resolveIdResult.external)) {\n                return error(errEntryCannotBeExternal(unresolvedId));\n            }\n            const id = resolveIdResult && typeof resolveIdResult === 'object'\n                ? resolveIdResult.id\n                : resolveIdResult;\n            if (typeof id === 'string') {\n                return this.fetchModule(id, undefined, true, false, isEntry);\n            }\n            return error(errUnresolvedEntry(unresolvedId));\n        });\n        this.graph = graph;\n        this.modulesById = modulesById;\n        this.pluginDriver = pluginDriver;\n        this.isExternal = getIdMatcher(external);\n        this.hasModuleSideEffects = getHasModuleSideEffects(moduleSideEffects, pureExternalModules, graph);\n        this.getManualChunk = typeof getManualChunk === 'function' ? getManualChunk : () => null;\n    }\n    addEntryModules(unresolvedEntryModules, isUserDefined) {\n        const firstEntryModuleIndex = this.nextEntryModuleIndex;\n        this.nextEntryModuleIndex += unresolvedEntryModules.length;\n        const loadNewEntryModulesPromise = Promise.all(unresolvedEntryModules.map(({ fileName, id, name }) => this.loadEntryModule(id, true).then(module => {\n            if (fileName !== null) {\n                module.chunkFileNames.add(fileName);\n            }\n            else if (name !== null) {\n                if (module.chunkName === null) {\n                    module.chunkName = name;\n                }\n                if (isUserDefined) {\n                    module.userChunkNames.add(name);\n                }\n            }\n            return module;\n        }))).then(entryModules => {\n            let moduleIndex = firstEntryModuleIndex;\n            for (const entryModule of entryModules) {\n                entryModule.isUserDefinedEntryPoint = entryModule.isUserDefinedEntryPoint || isUserDefined;\n                const existingIndexModule = this.indexedEntryModules.find(indexedModule => indexedModule.module.id === entryModule.id);\n                if (!existingIndexModule) {\n                    this.indexedEntryModules.push({ module: entryModule, index: moduleIndex });\n                }\n                else {\n                    existingIndexModule.index = Math.min(existingIndexModule.index, moduleIndex);\n                }\n                moduleIndex++;\n            }\n            this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);\n            return entryModules;\n        });\n        return this.awaitLoadModulesPromise(loadNewEntryModulesPromise).then(newEntryModules => ({\n            entryModules: this.indexedEntryModules.map(({ module }) => module),\n            manualChunkModulesByAlias: this.manualChunkModules,\n            newEntryModules\n        }));\n    }\n    addManualChunks(manualChunks) {\n        const unresolvedManualChunks = [];\n        for (const alias of Object.keys(manualChunks)) {\n            const manualChunkIds = manualChunks[alias];\n            for (const id of manualChunkIds) {\n                unresolvedManualChunks.push({ id, alias });\n            }\n        }\n        const loadNewManualChunkModulesPromise = Promise.all(unresolvedManualChunks.map(({ id }) => this.loadEntryModule(id, false))).then(manualChunkModules => {\n            for (let index = 0; index < manualChunkModules.length; index++) {\n                this.addModuleToManualChunk(unresolvedManualChunks[index].alias, manualChunkModules[index]);\n            }\n        });\n        return this.awaitLoadModulesPromise(loadNewManualChunkModulesPromise);\n    }\n    resolveId(source, importer, skip) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.normalizeResolveIdResult(this.isExternal(source, importer, false)\n                ? false\n                : yield this.pluginDriver.hookFirst('resolveId', [source, importer], null, skip), importer, source);\n        });\n    }\n    addModuleToManualChunk(alias, module) {\n        if (module.manualChunkAlias !== null && module.manualChunkAlias !== alias) {\n            return error(errCannotAssignModuleToChunk(module.id, alias, module.manualChunkAlias));\n        }\n        module.manualChunkAlias = alias;\n        if (!this.manualChunkModules[alias]) {\n            this.manualChunkModules[alias] = [];\n        }\n        this.manualChunkModules[alias].push(module);\n    }\n    awaitLoadModulesPromise(loadNewModulesPromise) {\n        this.latestLoadModulesPromise = Promise.all([\n            loadNewModulesPromise,\n            this.latestLoadModulesPromise\n        ]);\n        const getCombinedPromise = () => {\n            const startingPromise = this.latestLoadModulesPromise;\n            return startingPromise.then(() => {\n                if (this.latestLoadModulesPromise !== startingPromise) {\n                    return getCombinedPromise();\n                }\n            });\n        };\n        return getCombinedPromise().then(() => loadNewModulesPromise);\n    }\n    fetchAllDependencies(module) {\n        return Promise.all([\n            ...Array.from(module.sources).map((source) => __awaiter(this, void 0, void 0, function* () {\n                return this.fetchResolvedDependency(source, module.id, (module.resolvedIds[source] =\n                    module.resolvedIds[source] ||\n                        this.handleResolveId(yield this.resolveId(source, module.id), source, module.id)));\n            })),\n            ...module.getDynamicImportExpressions().map((specifier, index) => this.resolveDynamicImport(module, specifier, module.id).then(resolvedId => {\n                if (resolvedId === null)\n                    return;\n                const dynamicImport = module.dynamicImports[index];\n                if (typeof resolvedId === 'string') {\n                    dynamicImport.resolution = resolvedId;\n                    return;\n                }\n                return this.fetchResolvedDependency(relativeId(resolvedId.id), module.id, resolvedId).then(module => {\n                    dynamicImport.resolution = module;\n                });\n            }))\n        ]);\n    }\n    fetchModule(id, importer, moduleSideEffects, syntheticNamedExports, isEntry) {\n        const existingModule = this.modulesById.get(id);\n        if (existingModule instanceof Module) {\n            existingModule.isEntryPoint = existingModule.isEntryPoint || isEntry;\n            return Promise.resolve(existingModule);\n        }\n        const module = new Module(this.graph, id, moduleSideEffects, syntheticNamedExports, isEntry);\n        this.modulesById.set(id, module);\n        this.graph.watchFiles[id] = true;\n        const manualChunkAlias = this.getManualChunk(id);\n        if (typeof manualChunkAlias === 'string') {\n            this.addModuleToManualChunk(manualChunkAlias, module);\n        }\n        timeStart('load modules', 3);\n        return Promise.resolve(this.pluginDriver.hookFirst('load', [id]))\n            .catch((err) => {\n            timeEnd('load modules', 3);\n            let msg = `Could not load ${id}`;\n            if (importer)\n                msg += ` (imported by ${importer})`;\n            msg += `: ${err.message}`;\n            err.message = msg;\n            throw err;\n        })\n            .then(source => {\n            timeEnd('load modules', 3);\n            if (typeof source === 'string')\n                return { code: source };\n            if (source && typeof source === 'object' && typeof source.code === 'string')\n                return source;\n            return error(errBadLoader(id));\n        })\n            .then(sourceDescription => {\n            const cachedModule = this.graph.cachedModules.get(id);\n            if (cachedModule &&\n                !cachedModule.customTransformCache &&\n                cachedModule.originalCode === sourceDescription.code) {\n                if (cachedModule.transformFiles) {\n                    for (const emittedFile of cachedModule.transformFiles)\n                        this.pluginDriver.emitFile(emittedFile);\n                }\n                return cachedModule;\n            }\n            if (typeof sourceDescription.moduleSideEffects === 'boolean') {\n                module.moduleSideEffects = sourceDescription.moduleSideEffects;\n            }\n            if (typeof sourceDescription.syntheticNamedExports === 'boolean') {\n                module.syntheticNamedExports = sourceDescription.syntheticNamedExports;\n            }\n            return transform(this.graph, sourceDescription, module);\n        })\n            .then((source) => {\n            module.setSource(source);\n            this.modulesById.set(id, module);\n            return this.fetchAllDependencies(module).then(() => {\n                for (const name in module.exports) {\n                    if (name !== 'default') {\n                        module.exportsAll[name] = module.id;\n                    }\n                }\n                for (const source of module.exportAllSources) {\n                    const id = module.resolvedIds[source].id;\n                    const exportAllModule = this.modulesById.get(id);\n                    if (exportAllModule instanceof ExternalModule)\n                        continue;\n                    for (const name in exportAllModule.exportsAll) {\n                        if (name in module.exportsAll) {\n                            this.graph.warn(errNamespaceConflict(name, module, exportAllModule));\n                        }\n                        else {\n                            module.exportsAll[name] = exportAllModule.exportsAll[name];\n                        }\n                    }\n                }\n                return module;\n            });\n        });\n    }\n    fetchResolvedDependency(source, importer, resolvedId) {\n        if (resolvedId.external) {\n            if (!this.modulesById.has(resolvedId.id)) {\n                this.modulesById.set(resolvedId.id, new ExternalModule(this.graph, resolvedId.id, resolvedId.moduleSideEffects));\n            }\n            const externalModule = this.modulesById.get(resolvedId.id);\n            if (!(externalModule instanceof ExternalModule)) {\n                return error(errInternalIdCannotBeExternal(source, importer));\n            }\n            return Promise.resolve(externalModule);\n        }\n        else {\n            return this.fetchModule(resolvedId.id, importer, resolvedId.moduleSideEffects, resolvedId.syntheticNamedExports, false);\n        }\n    }\n    handleResolveId(resolvedId, source, importer) {\n        if (resolvedId === null) {\n            if (isRelative(source)) {\n                return error(errUnresolvedImport(source, importer));\n            }\n            this.graph.warn(errUnresolvedImportTreatedAsExternal(source, importer));\n            return {\n                external: true,\n                id: source,\n                moduleSideEffects: this.hasModuleSideEffects(source, true),\n                syntheticNamedExports: false\n            };\n        }\n        else {\n            if (resolvedId.external && resolvedId.syntheticNamedExports) {\n                this.graph.warn(errExternalSyntheticExports(source, importer));\n            }\n        }\n        return resolvedId;\n    }\n    normalizeResolveIdResult(resolveIdResult, importer, source) {\n        let id = '';\n        let external = false;\n        let moduleSideEffects = null;\n        let syntheticNamedExports = false;\n        if (resolveIdResult) {\n            if (typeof resolveIdResult === 'object') {\n                id = resolveIdResult.id;\n                if (resolveIdResult.external) {\n                    external = true;\n                }\n                if (typeof resolveIdResult.moduleSideEffects === 'boolean') {\n                    moduleSideEffects = resolveIdResult.moduleSideEffects;\n                }\n                if (typeof resolveIdResult.syntheticNamedExports === 'boolean') {\n                    syntheticNamedExports = resolveIdResult.syntheticNamedExports;\n                }\n            }\n            else {\n                if (this.isExternal(resolveIdResult, importer, true)) {\n                    external = true;\n                }\n                id = external ? normalizeRelativeExternalId(importer, resolveIdResult) : resolveIdResult;\n            }\n        }\n        else {\n            id = normalizeRelativeExternalId(importer, source);\n            if (resolveIdResult !== false && !this.isExternal(id, importer, true)) {\n                return null;\n            }\n            external = true;\n        }\n        return {\n            external,\n            id,\n            moduleSideEffects: typeof moduleSideEffects === 'boolean'\n                ? moduleSideEffects\n                : this.hasModuleSideEffects(id, external),\n            syntheticNamedExports\n        };\n    }\n    resolveDynamicImport(module, specifier, importer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO we only should expose the acorn AST here\n            const resolution = yield this.pluginDriver.hookFirst('resolveDynamicImport', [\n                specifier,\n                importer\n            ]);\n            if (typeof specifier !== 'string') {\n                if (typeof resolution === 'string') {\n                    return resolution;\n                }\n                if (!resolution) {\n                    return null;\n                }\n                return Object.assign({ external: false, moduleSideEffects: true }, resolution);\n            }\n            if (resolution == null) {\n                return (module.resolvedIds[specifier] =\n                    module.resolvedIds[specifier] ||\n                        this.handleResolveId(yield this.resolveId(specifier, module.id), specifier, module.id));\n            }\n            return this.handleResolveId(this.normalizeResolveIdResult(resolution, importer, specifier), specifier, importer);\n        });\n    }\n}\n\nvar BuildPhase;\n(function (BuildPhase) {\n    BuildPhase[BuildPhase[\"LOAD_AND_PARSE\"] = 0] = \"LOAD_AND_PARSE\";\n    BuildPhase[BuildPhase[\"ANALYSE\"] = 1] = \"ANALYSE\";\n    BuildPhase[BuildPhase[\"GENERATE\"] = 2] = \"GENERATE\";\n})(BuildPhase || (BuildPhase = {}));\n\nconst CHAR_CODE_A = 97;\nconst CHAR_CODE_0 = 48;\nfunction intToHex(num) {\n    if (num < 10)\n        return String.fromCharCode(CHAR_CODE_0 + num);\n    else\n        return String.fromCharCode(CHAR_CODE_A + (num - 10));\n}\nfunction Uint8ArrayToHexString(buffer) {\n    let str = '';\n    // hex conversion - 2 chars per 8 bit component\n    for (let i = 0; i < buffer.length; i++) {\n        const num = buffer[i];\n        // big endian conversion, but whatever\n        str += intToHex(num >> 4);\n        str += intToHex(num & 0xf);\n    }\n    return str;\n}\nfunction randomUint8Array(len) {\n    const buffer = new Uint8Array(len);\n    for (let i = 0; i < buffer.length; i++)\n        buffer[i] = Math.random() * (2 << 8);\n    return buffer;\n}\nfunction Uint8ArrayXor(to, from) {\n    for (let i = 0; i < to.length; i++)\n        to[i] = to[i] ^ from[i];\n    return to;\n}\n\nfunction assignChunkColouringHashes(entryModules, manualChunkModules) {\n    const { dependentEntryPointsByModule, dynamicImportersByModule } = analyzeModuleGraph(entryModules);\n    const dynamicDependentEntryPointsByDynamicEntry = getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicImportersByModule);\n    const staticEntries = new Set(entryModules);\n    function addColourToModuleDependencies(entry, colour, dynamicDependentEntryPoints) {\n        const manualChunkAlias = entry.manualChunkAlias;\n        const modulesToHandle = new Set([entry]);\n        for (const module of modulesToHandle) {\n            if (manualChunkAlias) {\n                module.manualChunkAlias = manualChunkAlias;\n                module.entryPointsHash = colour;\n            }\n            else if (dynamicDependentEntryPoints &&\n                areEntryPointsContainedOrDynamicallyDependent(dynamicDependentEntryPoints, dependentEntryPointsByModule.get(module))) {\n                continue;\n            }\n            else {\n                Uint8ArrayXor(module.entryPointsHash, colour);\n            }\n            for (const dependency of module.dependencies) {\n                if (!(dependency instanceof ExternalModule || dependency.manualChunkAlias)) {\n                    modulesToHandle.add(dependency);\n                }\n            }\n        }\n    }\n    function areEntryPointsContainedOrDynamicallyDependent(entryPoints, superSet) {\n        const entriesToCheck = new Set(entryPoints);\n        for (const entry of entriesToCheck) {\n            if (!superSet.has(entry)) {\n                if (staticEntries.has(entry))\n                    return false;\n                const dynamicDependentEntryPoints = dynamicDependentEntryPointsByDynamicEntry.get(entry);\n                for (const dependentEntry of dynamicDependentEntryPoints) {\n                    entriesToCheck.add(dependentEntry);\n                }\n            }\n        }\n        return true;\n    }\n    if (manualChunkModules) {\n        for (const chunkName of Object.keys(manualChunkModules)) {\n            const entryHash = randomUint8Array(10);\n            for (const entry of manualChunkModules[chunkName]) {\n                addColourToModuleDependencies(entry, entryHash, null);\n            }\n        }\n    }\n    for (const entry of entryModules) {\n        if (!entry.manualChunkAlias) {\n            const entryHash = randomUint8Array(10);\n            addColourToModuleDependencies(entry, entryHash, null);\n        }\n    }\n    for (const entry of dynamicImportersByModule.keys()) {\n        if (!entry.manualChunkAlias) {\n            const entryHash = randomUint8Array(10);\n            addColourToModuleDependencies(entry, entryHash, dynamicDependentEntryPointsByDynamicEntry.get(entry));\n        }\n    }\n}\nfunction analyzeModuleGraph(entryModules) {\n    const dynamicImportersByModule = new Map();\n    const dependentEntryPointsByModule = new Map();\n    const entriesToHandle = new Set(entryModules);\n    for (const currentEntry of entriesToHandle) {\n        const modulesToHandle = new Set([currentEntry]);\n        for (const module of modulesToHandle) {\n            getDependentModules(dependentEntryPointsByModule, module).add(currentEntry);\n            for (const dependency of module.dependencies) {\n                if (!(dependency instanceof ExternalModule)) {\n                    modulesToHandle.add(dependency);\n                }\n            }\n            for (const { resolution } of module.dynamicImports) {\n                if (resolution instanceof Module &&\n                    resolution.dynamicallyImportedBy.length > 0 &&\n                    !resolution.manualChunkAlias) {\n                    getDependentModules(dynamicImportersByModule, resolution).add(module);\n                    entriesToHandle.add(resolution);\n                }\n            }\n        }\n    }\n    return { dependentEntryPointsByModule, dynamicImportersByModule };\n}\nfunction getDependentModules(moduleMap, module) {\n    const dependentModules = moduleMap.get(module) || new Set();\n    moduleMap.set(module, dependentModules);\n    return dependentModules;\n}\nfunction getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicImportersByModule) {\n    const dynamicDependentEntryPointsByDynamicEntry = new Map();\n    for (const [dynamicEntry, importers] of dynamicImportersByModule.entries()) {\n        const dynamicDependentEntryPoints = getDependentModules(dynamicDependentEntryPointsByDynamicEntry, dynamicEntry);\n        for (const importer of importers) {\n            for (const entryPoint of dependentEntryPointsByModule.get(importer)) {\n                dynamicDependentEntryPoints.add(entryPoint);\n            }\n        }\n    }\n    return dynamicDependentEntryPointsByDynamicEntry;\n}\n\nconst createHash$1 = () => createHash$2('sha256');\n\nfunction generateAssetFileName(name, source, output) {\n    const emittedName = name || 'asset';\n    return makeUnique(renderNamePattern(output.assetFileNames, 'output.assetFileNames', {\n        hash() {\n            const hash = createHash$1();\n            hash.update(emittedName);\n            hash.update(':');\n            hash.update(source);\n            return hash.digest('hex').substr(0, 8);\n        },\n        ext: () => extname(emittedName).substr(1),\n        extname: () => extname(emittedName),\n        name: () => emittedName.substr(0, emittedName.length - extname(emittedName).length)\n    }), output.bundle);\n}\nfunction reserveFileNameInBundle(fileName, bundle, graph) {\n    if (fileName in bundle) {\n        graph.warn(errFileNameConflict(fileName));\n    }\n    bundle[fileName] = FILE_PLACEHOLDER;\n}\nconst FILE_PLACEHOLDER = {\n    type: 'placeholder'\n};\nfunction hasValidType(emittedFile) {\n    return (emittedFile &&\n        (emittedFile.type === 'asset' ||\n            emittedFile.type === 'chunk'));\n}\nfunction hasValidName(emittedFile) {\n    const validatedName = emittedFile.fileName || emittedFile.name;\n    return (!validatedName || (typeof validatedName === 'string' && isPlainPathFragment(validatedName)));\n}\nfunction getValidSource(source, emittedFile, fileReferenceId) {\n    if (typeof source !== 'string' && !Buffer.isBuffer(source)) {\n        const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;\n        return error(errFailedValidation(`Could not set source for ${typeof assetName === 'string' ? `asset \"${assetName}\"` : 'unnamed asset'}, asset source needs to be a string of Buffer.`));\n    }\n    return source;\n}\nfunction getAssetFileName(file, referenceId) {\n    if (typeof file.fileName !== 'string') {\n        return error(errAssetNotFinalisedForFileName(file.name || referenceId));\n    }\n    return file.fileName;\n}\nfunction getChunkFileName(file) {\n    const fileName = file.fileName || (file.module && file.module.facadeChunk.id);\n    if (!fileName)\n        return error(errChunkNotGeneratedForFileName(file.fileName || file.name));\n    return fileName;\n}\nclass FileEmitter {\n    constructor(graph, baseFileEmitter) {\n        this.output = null;\n        this.assertAssetsFinalized = () => {\n            for (const [referenceId, emittedFile] of this.filesByReferenceId.entries()) {\n                if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')\n                    return error(errNoAssetSourceSet(emittedFile.name || referenceId));\n            }\n        };\n        this.emitFile = (emittedFile) => {\n            if (!hasValidType(emittedFile)) {\n                return error(errFailedValidation(`Emitted files must be of type \"asset\" or \"chunk\", received \"${emittedFile &&\n                    emittedFile.type}\".`));\n            }\n            if (!hasValidName(emittedFile)) {\n                return error(errFailedValidation(`The \"fileName\" or \"name\" properties of emitted files must be strings that are neither absolute nor relative paths and do not contain invalid characters, received \"${emittedFile.fileName ||\n                    emittedFile.name}\".`));\n            }\n            if (emittedFile.type === 'chunk') {\n                return this.emitChunk(emittedFile);\n            }\n            else {\n                return this.emitAsset(emittedFile);\n            }\n        };\n        this.getFileName = (fileReferenceId) => {\n            const emittedFile = this.filesByReferenceId.get(fileReferenceId);\n            if (!emittedFile)\n                return error(errFileReferenceIdNotFoundForFilename(fileReferenceId));\n            if (emittedFile.type === 'chunk') {\n                return getChunkFileName(emittedFile);\n            }\n            else {\n                return getAssetFileName(emittedFile, fileReferenceId);\n            }\n        };\n        this.setAssetSource = (referenceId, requestedSource) => {\n            const consumedFile = this.filesByReferenceId.get(referenceId);\n            if (!consumedFile)\n                return error(errAssetReferenceIdNotFoundForSetSource(referenceId));\n            if (consumedFile.type !== 'asset') {\n                return error(errFailedValidation(`Asset sources can only be set for emitted assets but \"${referenceId}\" is an emitted chunk.`));\n            }\n            if (consumedFile.source !== undefined) {\n                return error(errAssetSourceAlreadySet(consumedFile.name || referenceId));\n            }\n            const source = getValidSource(requestedSource, consumedFile, referenceId);\n            if (this.output) {\n                this.finalizeAsset(consumedFile, source, referenceId, this.output);\n            }\n            else {\n                consumedFile.source = source;\n            }\n        };\n        this.setOutputBundle = (outputBundle, assetFileNames) => {\n            this.output = {\n                assetFileNames,\n                bundle: outputBundle\n            };\n            for (const emittedFile of this.filesByReferenceId.values()) {\n                if (emittedFile.fileName) {\n                    reserveFileNameInBundle(emittedFile.fileName, this.output.bundle, this.graph);\n                }\n            }\n            for (const [referenceId, consumedFile] of this.filesByReferenceId.entries()) {\n                if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {\n                    this.finalizeAsset(consumedFile, consumedFile.source, referenceId, this.output);\n                }\n            }\n        };\n        this.graph = graph;\n        this.filesByReferenceId = baseFileEmitter\n            ? new Map(baseFileEmitter.filesByReferenceId)\n            : new Map();\n    }\n    assignReferenceId(file, idBase) {\n        let referenceId;\n        do {\n            const hash = createHash$1();\n            if (referenceId) {\n                hash.update(referenceId);\n            }\n            else {\n                hash.update(idBase);\n            }\n            referenceId = hash.digest('hex').substr(0, 8);\n        } while (this.filesByReferenceId.has(referenceId));\n        this.filesByReferenceId.set(referenceId, file);\n        return referenceId;\n    }\n    emitAsset(emittedAsset) {\n        const source = typeof emittedAsset.source !== 'undefined'\n            ? getValidSource(emittedAsset.source, emittedAsset, null)\n            : undefined;\n        const consumedAsset = {\n            fileName: emittedAsset.fileName,\n            name: emittedAsset.name,\n            source,\n            type: 'asset'\n        };\n        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || emittedAsset.type);\n        if (this.output) {\n            if (emittedAsset.fileName) {\n                reserveFileNameInBundle(emittedAsset.fileName, this.output.bundle, this.graph);\n            }\n            if (source !== undefined) {\n                this.finalizeAsset(consumedAsset, source, referenceId, this.output);\n            }\n        }\n        return referenceId;\n    }\n    emitChunk(emittedChunk) {\n        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {\n            return error(errInvalidRollupPhaseForChunkEmission());\n        }\n        if (typeof emittedChunk.id !== 'string') {\n            return error(errFailedValidation(`Emitted chunks need to have a valid string id, received \"${emittedChunk.id}\"`));\n        }\n        const consumedChunk = {\n            fileName: emittedChunk.fileName,\n            module: null,\n            name: emittedChunk.name || emittedChunk.id,\n            type: 'chunk'\n        };\n        this.graph.moduleLoader\n            .addEntryModules([\n            {\n                fileName: emittedChunk.fileName || null,\n                id: emittedChunk.id,\n                name: emittedChunk.name || null\n            }\n        ], false)\n            .then(({ newEntryModules: [module] }) => {\n            consumedChunk.module = module;\n        })\n            .catch(() => {\n            // Avoid unhandled Promise rejection as the error will be thrown later\n            // once module loading has finished\n        });\n        return this.assignReferenceId(consumedChunk, emittedChunk.id);\n    }\n    finalizeAsset(consumedFile, source, referenceId, output) {\n        const fileName = consumedFile.fileName ||\n            this.findExistingAssetFileNameWithSource(output.bundle, source) ||\n            generateAssetFileName(consumedFile.name, source, output);\n        // We must not modify the original assets to avoid interaction between outputs\n        const assetWithFileName = Object.assign(Object.assign({}, consumedFile), { source, fileName });\n        this.filesByReferenceId.set(referenceId, assetWithFileName);\n        const graph = this.graph;\n        output.bundle[fileName] = {\n            fileName,\n            get isAsset() {\n                graph.warnDeprecation('Accessing \"isAsset\" on files in the bundle is deprecated, please use \"type === \\'asset\\'\" instead', false);\n                return true;\n            },\n            source,\n            type: 'asset'\n        };\n    }\n    findExistingAssetFileNameWithSource(bundle, source) {\n        for (const fileName of Object.keys(bundle)) {\n            const outputFile = bundle[fileName];\n            if (outputFile.type === 'asset' &&\n                (Buffer.isBuffer(source) && Buffer.isBuffer(outputFile.source)\n                    ? source.equals(outputFile.source)\n                    : source === outputFile.source))\n                return fileName;\n        }\n        return null;\n    }\n}\n\nfunction getDeprecatedContextHandler(handler, handlerName, newHandlerName, pluginName, activeDeprecation, graph) {\n    let deprecationWarningShown = false;\n    return ((...args) => {\n        if (!deprecationWarningShown) {\n            deprecationWarningShown = true;\n            graph.warnDeprecation({\n                message: `The \"this.${handlerName}\" plugin context function used by plugin ${pluginName} is deprecated. The \"this.${newHandlerName}\" plugin context function should be used instead.`,\n                plugin: pluginName\n            }, activeDeprecation);\n        }\n        return handler(...args);\n    });\n}\nfunction getPluginContexts(pluginCache, graph, fileEmitter, watcher) {\n    const existingPluginNames = new Set();\n    return (plugin, pidx) => {\n        let cacheable = true;\n        if (typeof plugin.cacheKey !== 'string') {\n            if (plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||\n                plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) ||\n                existingPluginNames.has(plugin.name)) {\n                cacheable = false;\n            }\n            else {\n                existingPluginNames.add(plugin.name);\n            }\n        }\n        let cacheInstance;\n        if (!pluginCache) {\n            cacheInstance = NO_CACHE;\n        }\n        else if (cacheable) {\n            const cacheKey = plugin.cacheKey || plugin.name;\n            cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = Object.create(null)));\n        }\n        else {\n            cacheInstance = getCacheForUncacheablePlugin(plugin.name);\n        }\n        const context = {\n            addWatchFile(id) {\n                if (graph.phase >= BuildPhase.GENERATE) {\n                    return this.error(errInvalidRollupPhaseForAddWatchFile());\n                }\n                graph.watchFiles[id] = true;\n            },\n            cache: cacheInstance,\n            emitAsset: getDeprecatedContextHandler((name, source) => fileEmitter.emitFile({ type: 'asset', name, source }), 'emitAsset', 'emitFile', plugin.name, false, graph),\n            emitChunk: getDeprecatedContextHandler((id, options) => fileEmitter.emitFile({ type: 'chunk', id, name: options && options.name }), 'emitChunk', 'emitFile', plugin.name, false, graph),\n            emitFile: fileEmitter.emitFile,\n            error(err) {\n                return throwPluginError(err, plugin.name);\n            },\n            getAssetFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getAssetFileName', 'getFileName', plugin.name, false, graph),\n            getChunkFileName: getDeprecatedContextHandler(fileEmitter.getFileName, 'getChunkFileName', 'getFileName', plugin.name, false, graph),\n            getFileName: fileEmitter.getFileName,\n            getModuleInfo(moduleId) {\n                const foundModule = graph.moduleById.get(moduleId);\n                if (foundModule == null) {\n                    throw new Error(`Unable to find module ${moduleId}`);\n                }\n                return {\n                    hasModuleSideEffects: foundModule.moduleSideEffects,\n                    id: foundModule.id,\n                    importedIds: foundModule instanceof ExternalModule\n                        ? []\n                        : Array.from(foundModule.sources).map(id => foundModule.resolvedIds[id].id),\n                    isEntry: foundModule instanceof Module && foundModule.isEntryPoint,\n                    isExternal: foundModule instanceof ExternalModule\n                };\n            },\n            isExternal: getDeprecatedContextHandler((id, parentId, isResolved = false) => graph.moduleLoader.isExternal(id, parentId, isResolved), 'isExternal', 'resolve', plugin.name, false, graph),\n            meta: {\n                rollupVersion: version\n            },\n            get moduleIds() {\n                return graph.moduleById.keys();\n            },\n            parse: graph.contextParse,\n            resolve(source, importer, options) {\n                return graph.moduleLoader.resolveId(source, importer, options && options.skipSelf ? pidx : null);\n            },\n            resolveId: getDeprecatedContextHandler((source, importer) => graph.moduleLoader\n                .resolveId(source, importer)\n                .then(resolveId => resolveId && resolveId.id), 'resolveId', 'resolve', plugin.name, false, graph),\n            setAssetSource: fileEmitter.setAssetSource,\n            warn(warning) {\n                if (typeof warning === 'string')\n                    warning = { message: warning };\n                if (warning.code)\n                    warning.pluginCode = warning.code;\n                warning.code = 'PLUGIN_WARNING';\n                warning.plugin = plugin.name;\n                graph.warn(warning);\n            },\n            watcher: watcher\n                ? (() => {\n                    let deprecationWarningShown = false;\n                    function deprecatedWatchListener(event, handler) {\n                        if (!deprecationWarningShown) {\n                            context.warn({\n                                code: 'PLUGIN_WATCHER_DEPRECATED',\n                                message: `this.watcher usage is deprecated in plugins. Use the watchChange plugin hook and this.addWatchFile() instead.`\n                            });\n                            deprecationWarningShown = true;\n                        }\n                        return watcher.on(event, handler);\n                    }\n                    return Object.assign(Object.assign({}, watcher), { addListener: deprecatedWatchListener, on: deprecatedWatchListener });\n                })()\n                : undefined\n        };\n        return context;\n    };\n}\n\nclass PluginDriver {\n    constructor(graph, userPlugins, pluginCache, preserveSymlinks, watcher, basePluginDriver) {\n        this.previousHooks = new Set(['options']);\n        warnDeprecatedHooks(userPlugins, graph);\n        this.graph = graph;\n        this.pluginCache = pluginCache;\n        this.preserveSymlinks = preserveSymlinks;\n        this.watcher = watcher;\n        this.fileEmitter = new FileEmitter(graph, basePluginDriver && basePluginDriver.fileEmitter);\n        this.emitFile = this.fileEmitter.emitFile;\n        this.getFileName = this.fileEmitter.getFileName;\n        this.finaliseAssets = this.fileEmitter.assertAssetsFinalized;\n        this.setOutputBundle = this.fileEmitter.setOutputBundle;\n        this.plugins = userPlugins.concat(basePluginDriver ? basePluginDriver.plugins : [getRollupDefaultPlugin(preserveSymlinks)]);\n        this.pluginContexts = this.plugins.map(getPluginContexts(pluginCache, graph, this.fileEmitter, watcher));\n        if (basePluginDriver) {\n            for (const plugin of userPlugins) {\n                for (const hook of basePluginDriver.previousHooks) {\n                    if (hook in plugin) {\n                        graph.warn(errInputHookInOutputPlugin(plugin.name, hook));\n                    }\n                }\n            }\n        }\n    }\n    createOutputPluginDriver(plugins) {\n        return new PluginDriver(this.graph, plugins, this.pluginCache, this.preserveSymlinks, this.watcher, this);\n    }\n    // chains, first non-null result stops and returns\n    hookFirst(hookName, args, replaceContext, skip) {\n        let promise = Promise.resolve();\n        for (let i = 0; i < this.plugins.length; i++) {\n            if (skip === i)\n                continue;\n            promise = promise.then((result) => {\n                if (result != null)\n                    return result;\n                return this.runHook(hookName, args, i, false, replaceContext);\n            });\n        }\n        return promise;\n    }\n    // chains synchronously, first non-null result stops and returns\n    hookFirstSync(hookName, args, replaceContext) {\n        for (let i = 0; i < this.plugins.length; i++) {\n            const result = this.runHookSync(hookName, args, i, replaceContext);\n            if (result != null)\n                return result;\n        }\n        return null;\n    }\n    // parallel, ignores returns\n    hookParallel(hookName, args, replaceContext) {\n        const promises = [];\n        for (let i = 0; i < this.plugins.length; i++) {\n            const hookPromise = this.runHook(hookName, args, i, false, replaceContext);\n            if (!hookPromise)\n                continue;\n            promises.push(hookPromise);\n        }\n        return Promise.all(promises).then(() => { });\n    }\n    // chains, reduces returns of type R, to type T, handling the reduced value as the first hook argument\n    hookReduceArg0(hookName, [arg0, ...args], reduce, replaceContext) {\n        let promise = Promise.resolve(arg0);\n        for (let i = 0; i < this.plugins.length; i++) {\n            promise = promise.then(arg0 => {\n                const hookPromise = this.runHook(hookName, [arg0, ...args], i, false, replaceContext);\n                if (!hookPromise)\n                    return arg0;\n                return hookPromise.then((result) => reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i]));\n            });\n        }\n        return promise;\n    }\n    // chains synchronously, reduces returns of type R, to type T, handling the reduced value as the first hook argument\n    hookReduceArg0Sync(hookName, [arg0, ...args], reduce, replaceContext) {\n        for (let i = 0; i < this.plugins.length; i++) {\n            const result = this.runHookSync(hookName, [arg0, ...args], i, replaceContext);\n            arg0 = reduce.call(this.pluginContexts[i], arg0, result, this.plugins[i]);\n        }\n        return arg0;\n    }\n    // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.\n    hookReduceValue(hookName, initialValue, args, reduce, replaceContext) {\n        let promise = Promise.resolve(initialValue);\n        for (let i = 0; i < this.plugins.length; i++) {\n            promise = promise.then(value => {\n                const hookPromise = this.runHook(hookName, args, i, true, replaceContext);\n                if (!hookPromise)\n                    return value;\n                return hookPromise.then((result) => reduce.call(this.pluginContexts[i], value, result, this.plugins[i]));\n            });\n        }\n        return promise;\n    }\n    // chains, reduces returns of type R, to type T, handling the reduced value separately. permits hooks as values.\n    hookReduceValueSync(hookName, initialValue, args, reduce, replaceContext) {\n        let acc = initialValue;\n        for (let i = 0; i < this.plugins.length; i++) {\n            const result = this.runHookSync(hookName, args, i, replaceContext);\n            acc = reduce.call(this.pluginContexts[i], acc, result, this.plugins[i]);\n        }\n        return acc;\n    }\n    // chains, ignores returns\n    hookSeq(hookName, args, replaceContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let promise = Promise.resolve();\n            for (let i = 0; i < this.plugins.length; i++)\n                promise = promise.then(() => this.runHook(hookName, args, i, false, replaceContext));\n            return promise;\n        });\n    }\n    // chains, ignores returns\n    hookSeqSync(hookName, args, replaceContext) {\n        for (let i = 0; i < this.plugins.length; i++)\n            this.runHookSync(hookName, args, i, replaceContext);\n    }\n    runHook(hookName, args, pluginIndex, permitValues, hookContext) {\n        this.previousHooks.add(hookName);\n        const plugin = this.plugins[pluginIndex];\n        const hook = plugin[hookName];\n        if (!hook)\n            return undefined;\n        let context = this.pluginContexts[pluginIndex];\n        if (hookContext) {\n            context = hookContext(context, plugin);\n        }\n        return Promise.resolve()\n            .then(() => {\n            // permit values allows values to be returned instead of a functional hook\n            if (typeof hook !== 'function') {\n                if (permitValues)\n                    return hook;\n                return error({\n                    code: 'INVALID_PLUGIN_HOOK',\n                    message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`\n                });\n            }\n            return hook.apply(context, args);\n        })\n            .catch(err => throwPluginError(err, plugin.name, { hook: hookName }));\n    }\n    runHookSync(hookName, args, pluginIndex, hookContext) {\n        this.previousHooks.add(hookName);\n        const plugin = this.plugins[pluginIndex];\n        let context = this.pluginContexts[pluginIndex];\n        const hook = plugin[hookName];\n        if (!hook)\n            return undefined;\n        if (hookContext) {\n            context = hookContext(context, plugin);\n        }\n        try {\n            // permit values allows values to be returned instead of a functional hook\n            if (typeof hook !== 'function') {\n                return error({\n                    code: 'INVALID_PLUGIN_HOOK',\n                    message: `Error running plugin hook ${hookName} for ${plugin.name}, expected a function hook.`\n                });\n            }\n            return hook.apply(context, args);\n        }\n        catch (err) {\n            return throwPluginError(err, plugin.name, { hook: hookName });\n        }\n    }\n}\n\nfunction makeOnwarn() {\n    const warned = Object.create(null);\n    return (warning) => {\n        const str = warning.toString();\n        if (str in warned)\n            return;\n        console.error(str);\n        warned[str] = true;\n    };\n}\nfunction normalizeEntryModules(entryModules) {\n    if (typeof entryModules === 'string') {\n        return [{ fileName: null, name: null, id: entryModules }];\n    }\n    if (Array.isArray(entryModules)) {\n        return entryModules.map(id => ({ fileName: null, name: null, id }));\n    }\n    return Object.keys(entryModules).map(name => ({\n        fileName: null,\n        id: entryModules[name],\n        name\n    }));\n}\nclass Graph {\n    constructor(options, watcher) {\n        this.moduleById = new Map();\n        this.needsTreeshakingPass = false;\n        this.phase = BuildPhase.LOAD_AND_PARSE;\n        this.watchFiles = Object.create(null);\n        this.externalModules = [];\n        this.modules = [];\n        this.onwarn = options.onwarn || makeOnwarn();\n        this.deoptimizationTracker = new PathTracker();\n        this.cachedModules = new Map();\n        if (options.cache) {\n            if (options.cache.modules)\n                for (const module of options.cache.modules)\n                    this.cachedModules.set(module.id, module);\n        }\n        if (options.cache !== false) {\n            this.pluginCache = (options.cache && options.cache.plugins) || Object.create(null);\n            // increment access counter\n            for (const name in this.pluginCache) {\n                const cache = this.pluginCache[name];\n                for (const key of Object.keys(cache))\n                    cache[key][0]++;\n            }\n        }\n        this.preserveModules = options.preserveModules;\n        this.strictDeprecations = options.strictDeprecations;\n        this.cacheExpiry = options.experimentalCacheExpiry;\n        if (options.treeshake !== false) {\n            this.treeshakingOptions =\n                options.treeshake && options.treeshake !== true\n                    ? {\n                        annotations: options.treeshake.annotations !== false,\n                        moduleSideEffects: options.treeshake.moduleSideEffects,\n                        propertyReadSideEffects: options.treeshake.propertyReadSideEffects !== false,\n                        pureExternalModules: options.treeshake.pureExternalModules,\n                        tryCatchDeoptimization: options.treeshake.tryCatchDeoptimization !== false,\n                        unknownGlobalSideEffects: options.treeshake.unknownGlobalSideEffects !== false\n                    }\n                    : {\n                        annotations: true,\n                        moduleSideEffects: true,\n                        propertyReadSideEffects: true,\n                        tryCatchDeoptimization: true,\n                        unknownGlobalSideEffects: true\n                    };\n            if (typeof this.treeshakingOptions.pureExternalModules !== 'undefined') {\n                this.warnDeprecation(`The \"treeshake.pureExternalModules\" option is deprecated. The \"treeshake.moduleSideEffects\" option should be used instead. \"treeshake.pureExternalModules: true\" is equivalent to \"treeshake.moduleSideEffects: 'no-external'\"`, false);\n            }\n        }\n        this.contextParse = (code, options = {}) => this.acornParser.parse(code, Object.assign(Object.assign(Object.assign({}, defaultAcornOptions), options), this.acornOptions));\n        this.pluginDriver = new PluginDriver(this, options.plugins, this.pluginCache, options.preserveSymlinks === true, watcher);\n        if (watcher) {\n            const handleChange = (id) => this.pluginDriver.hookSeqSync('watchChange', [id]);\n            watcher.on('change', handleChange);\n            watcher.once('restart', () => {\n                watcher.removeListener('change', handleChange);\n            });\n        }\n        this.shimMissingExports = options.shimMissingExports;\n        this.scope = new GlobalScope();\n        this.context = String(options.context);\n        const optionsModuleContext = options.moduleContext;\n        if (typeof optionsModuleContext === 'function') {\n            this.getModuleContext = id => optionsModuleContext(id) || this.context;\n        }\n        else if (typeof optionsModuleContext === 'object') {\n            const moduleContext = new Map();\n            for (const key in optionsModuleContext) {\n                moduleContext.set(resolve(key), optionsModuleContext[key]);\n            }\n            this.getModuleContext = id => moduleContext.get(id) || this.context;\n        }\n        else {\n            this.getModuleContext = () => this.context;\n        }\n        this.acornOptions = options.acorn ? Object.assign({}, options.acorn) : {};\n        const acornPluginsToInject = [];\n        acornPluginsToInject.push(acornImportMeta, acornExportNsFrom);\n        this.acornOptions.allowAwaitOutsideFunction = true;\n        const acornInjectPlugins = options.acornInjectPlugins;\n        acornPluginsToInject.push(...(Array.isArray(acornInjectPlugins)\n            ? acornInjectPlugins\n            : acornInjectPlugins\n                ? [acornInjectPlugins]\n                : []));\n        this.acornParser = Parser.extend(...acornPluginsToInject);\n        this.moduleLoader = new ModuleLoader(this, this.moduleById, this.pluginDriver, options.external, (typeof options.manualChunks === 'function' && options.manualChunks), (this.treeshakingOptions ? this.treeshakingOptions.moduleSideEffects : null), (this.treeshakingOptions ? this.treeshakingOptions.pureExternalModules : false));\n    }\n    build(entryModules, manualChunks, inlineDynamicImports) {\n        // Phase 1 – discovery. We load the entry module and find which\n        // modules it imports, and import those, until we have all\n        // of the entry module's dependencies\n        timeStart('parse modules', 2);\n        return Promise.all([\n            this.moduleLoader.addEntryModules(normalizeEntryModules(entryModules), true),\n            (manualChunks &&\n                typeof manualChunks === 'object' &&\n                this.moduleLoader.addManualChunks(manualChunks))\n        ]).then(([{ entryModules, manualChunkModulesByAlias }]) => {\n            if (entryModules.length === 0) {\n                throw new Error('You must supply options.input to rollup');\n            }\n            for (const module of this.moduleById.values()) {\n                if (module instanceof Module) {\n                    this.modules.push(module);\n                }\n                else {\n                    this.externalModules.push(module);\n                }\n            }\n            timeEnd('parse modules', 2);\n            this.phase = BuildPhase.ANALYSE;\n            // Phase 2 - linking. We populate the module dependency links and\n            // determine the topological execution order for the bundle\n            timeStart('analyse dependency graph', 2);\n            this.link(entryModules);\n            timeEnd('analyse dependency graph', 2);\n            // Phase 3 – marking. We include all statements that should be included\n            timeStart('mark included statements', 2);\n            if (inlineDynamicImports) {\n                if (entryModules.length > 1) {\n                    throw new Error('Internal Error: can only inline dynamic imports for single-file builds.');\n                }\n            }\n            for (const module of entryModules) {\n                module.includeAllExports();\n            }\n            this.includeMarked(this.modules);\n            // check for unused external imports\n            for (const externalModule of this.externalModules)\n                externalModule.warnUnusedImports();\n            timeEnd('mark included statements', 2);\n            // Phase 4 – we construct the chunks, working out the optimal chunking using\n            // entry point graph colouring, before generating the import and export facades\n            timeStart('generate chunks', 2);\n            if (!this.preserveModules && !inlineDynamicImports) {\n                assignChunkColouringHashes(entryModules, manualChunkModulesByAlias);\n            }\n            // TODO: there is one special edge case unhandled here and that is that any module\n            //       exposed as an unresolvable export * (to a graph external export *,\n            //       either as a namespace import reexported or top-level export *)\n            //       should be made to be its own entry point module before chunking\n            let chunks = [];\n            if (this.preserveModules) {\n                for (const module of this.modules) {\n                    const chunk = new Chunk$1(this, [module]);\n                    if (module.isEntryPoint || !chunk.isEmpty) {\n                        chunk.entryModules = [module];\n                    }\n                    chunks.push(chunk);\n                }\n            }\n            else {\n                const chunkModules = {};\n                for (const module of this.modules) {\n                    const entryPointsHashStr = Uint8ArrayToHexString(module.entryPointsHash);\n                    const curChunk = chunkModules[entryPointsHashStr];\n                    if (curChunk) {\n                        curChunk.push(module);\n                    }\n                    else {\n                        chunkModules[entryPointsHashStr] = [module];\n                    }\n                }\n                for (const entryHashSum in chunkModules) {\n                    const chunkModulesOrdered = chunkModules[entryHashSum];\n                    sortByExecutionOrder(chunkModulesOrdered);\n                    const chunk = new Chunk$1(this, chunkModulesOrdered);\n                    chunks.push(chunk);\n                }\n            }\n            for (const chunk of chunks) {\n                chunk.link();\n            }\n            chunks = chunks.filter(isChunkRendered);\n            const facades = [];\n            for (const chunk of chunks) {\n                facades.push(...chunk.generateFacades());\n            }\n            timeEnd('generate chunks', 2);\n            this.phase = BuildPhase.GENERATE;\n            return chunks.concat(facades);\n        });\n    }\n    getCache() {\n        // handle plugin cache eviction\n        for (const name in this.pluginCache) {\n            const cache = this.pluginCache[name];\n            let allDeleted = true;\n            for (const key of Object.keys(cache)) {\n                if (cache[key][0] >= this.cacheExpiry)\n                    delete cache[key];\n                else\n                    allDeleted = false;\n            }\n            if (allDeleted)\n                delete this.pluginCache[name];\n        }\n        return {\n            modules: this.modules.map(module => module.toJSON()),\n            plugins: this.pluginCache\n        };\n    }\n    includeMarked(modules) {\n        if (this.treeshakingOptions) {\n            let treeshakingPass = 1;\n            do {\n                timeStart(`treeshaking pass ${treeshakingPass}`, 3);\n                this.needsTreeshakingPass = false;\n                for (const module of modules) {\n                    if (module.isExecuted)\n                        module.include();\n                }\n                timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);\n            } while (this.needsTreeshakingPass);\n        }\n        else {\n            // Necessary to properly replace namespace imports\n            for (const module of modules)\n                module.includeAllInBundle();\n        }\n    }\n    warn(warning) {\n        warning.toString = () => {\n            let str = '';\n            if (warning.plugin)\n                str += `(${warning.plugin} plugin) `;\n            if (warning.loc)\n                str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;\n            str += warning.message;\n            return str;\n        };\n        this.onwarn(warning);\n    }\n    warnDeprecation(deprecation, activeDeprecation) {\n        if (activeDeprecation || this.strictDeprecations) {\n            const warning = errDeprecation(deprecation);\n            if (this.strictDeprecations) {\n                return error(warning);\n            }\n            this.warn(warning);\n        }\n    }\n    link(entryModules) {\n        for (const module of this.modules) {\n            module.linkDependencies();\n        }\n        const { orderedModules, cyclePaths } = analyseModuleExecution(entryModules);\n        for (const cyclePath of cyclePaths) {\n            this.warn({\n                code: 'CIRCULAR_DEPENDENCY',\n                cycle: cyclePath,\n                importer: cyclePath[0],\n                message: `Circular dependency: ${cyclePath.join(' -> ')}`\n            });\n        }\n        this.modules = orderedModules;\n        for (const module of this.modules) {\n            module.bindReferences();\n        }\n        this.warnForMissingExports();\n    }\n    warnForMissingExports() {\n        for (const module of this.modules) {\n            for (const importName of Object.keys(module.importDescriptions)) {\n                const importDescription = module.importDescriptions[importName];\n                if (importDescription.name !== '*' &&\n                    !importDescription.module.getVariableForExportName(importDescription.name)) {\n                    module.warn({\n                        code: 'NON_EXISTENT_EXPORT',\n                        message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,\n                        name: importDescription.name,\n                        source: importDescription.module.id\n                    }, importDescription.start);\n                }\n            }\n        }\n    }\n}\n\nfunction evalIfFn(strOrFn) {\n    switch (typeof strOrFn) {\n        case 'function':\n            return strOrFn();\n        case 'string':\n            return strOrFn;\n        default:\n            return '';\n    }\n}\nconst concatSep = (out, next) => (next ? `${out}\\n${next}` : out);\nconst concatDblSep = (out, next) => (next ? `${out}\\n\\n${next}` : out);\nfunction createAddons(options, outputPluginDriver) {\n    return Promise.all([\n        outputPluginDriver.hookReduceValue('banner', evalIfFn(options.banner), [], concatSep),\n        outputPluginDriver.hookReduceValue('footer', evalIfFn(options.footer), [], concatSep),\n        outputPluginDriver.hookReduceValue('intro', evalIfFn(options.intro), [], concatDblSep),\n        outputPluginDriver.hookReduceValue('outro', evalIfFn(options.outro), [], concatDblSep)\n    ])\n        .then(([banner, footer, intro, outro]) => {\n        if (intro)\n            intro += '\\n\\n';\n        if (outro)\n            outro = `\\n\\n${outro}`;\n        if (banner.length)\n            banner += '\\n';\n        if (footer.length)\n            footer = '\\n' + footer;\n        return { intro, outro, banner, footer };\n    })\n        .catch((err) => {\n        return error({\n            code: 'ADDON_ERROR',\n            message: `Could not retrieve ${err.hook}. Check configuration of plugin ${err.plugin}.\n\\tError Message: ${err.message}`\n        });\n    });\n}\n\nfunction assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons, bundle, outputPluginDriver) {\n    const entryChunks = [];\n    const otherChunks = [];\n    for (const chunk of chunks) {\n        (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint\n            ? entryChunks\n            : otherChunks).push(chunk);\n    }\n    // make sure entry chunk names take precedence with regard to deconflicting\n    const chunksForNaming = entryChunks.concat(otherChunks);\n    for (const chunk of chunksForNaming) {\n        if (outputOptions.file) {\n            chunk.id = basename(outputOptions.file);\n        }\n        else if (inputOptions.preserveModules) {\n            chunk.id = chunk.generateIdPreserveModules(inputBase, outputOptions, bundle);\n        }\n        else {\n            chunk.id = chunk.generateId(addons, outputOptions, bundle, true, outputPluginDriver);\n        }\n        bundle[chunk.id] = FILE_PLACEHOLDER;\n    }\n}\n\n// ported from https://github.com/substack/node-commondir\nfunction commondir(files) {\n    if (files.length === 0)\n        return '/';\n    if (files.length === 1)\n        return dirname(files[0]);\n    const commonSegments = files.slice(1).reduce((commonSegments, file) => {\n        const pathSegements = file.split(/\\/+|\\\\+/);\n        let i;\n        for (i = 0; commonSegments[i] === pathSegements[i] &&\n            i < Math.min(commonSegments.length, pathSegements.length); i++)\n            ;\n        return commonSegments.slice(0, i);\n    }, files[0].split(/\\/+|\\\\+/));\n    // Windows correctly handles paths with forward-slashes\n    return commonSegments.length > 1 ? commonSegments.join('/') : '/';\n}\n\nfunction getExportMode(chunk, { exports: exportMode, name, format }, facadeModuleId) {\n    const exportKeys = chunk.getExportNames();\n    if (exportMode === 'default') {\n        if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {\n            return error(errIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));\n        }\n    }\n    else if (exportMode === 'none' && exportKeys.length) {\n        return error(errIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));\n    }\n    if (!exportMode || exportMode === 'auto') {\n        if (exportKeys.length === 0) {\n            exportMode = 'none';\n        }\n        else if (exportKeys.length === 1 && exportKeys[0] === 'default') {\n            exportMode = 'default';\n        }\n        else {\n            if (format !== 'es' && exportKeys.indexOf('default') !== -1) {\n                chunk.graph.warn(errMixedExport(facadeModuleId, name));\n            }\n            exportMode = 'named';\n        }\n    }\n    return exportMode;\n}\n\nconst createGetOption = (config, command) => (name, defaultValue) => command[name] !== undefined\n    ? command[name]\n    : config[name] !== undefined\n        ? config[name]\n        : defaultValue;\nconst normalizeObjectOptionValue = (optionValue) => {\n    if (!optionValue) {\n        return optionValue;\n    }\n    if (typeof optionValue !== 'object') {\n        return {};\n    }\n    return optionValue;\n};\nconst getObjectOption = (config, command, name) => {\n    const commandOption = normalizeObjectOptionValue(command[name]);\n    const configOption = normalizeObjectOptionValue(config[name]);\n    if (commandOption !== undefined) {\n        return commandOption && configOption ? Object.assign(Object.assign({}, configOption), commandOption) : commandOption;\n    }\n    return configOption;\n};\nfunction ensureArray(items) {\n    if (Array.isArray(items)) {\n        return items.filter(Boolean);\n    }\n    if (items) {\n        return [items];\n    }\n    return [];\n}\nconst defaultOnWarn = warning => {\n    if (typeof warning === 'string') {\n        console.warn(warning);\n    }\n    else {\n        console.warn(warning.message);\n    }\n};\nconst getOnWarn = (config, defaultOnWarnHandler = defaultOnWarn) => config.onwarn\n    ? warning => config.onwarn(warning, defaultOnWarnHandler)\n    : defaultOnWarnHandler;\nconst getExternal = (config, command) => {\n    const configExternal = config.external;\n    return typeof configExternal === 'function'\n        ? (id, ...rest) => configExternal(id, ...rest) || command.external.indexOf(id) !== -1\n        : (typeof config.external === 'string'\n            ? [configExternal]\n            : Array.isArray(configExternal)\n                ? configExternal\n                : []).concat(command.external);\n};\nconst commandAliases = {\n    c: 'config',\n    d: 'dir',\n    e: 'external',\n    f: 'format',\n    g: 'globals',\n    h: 'help',\n    i: 'input',\n    m: 'sourcemap',\n    n: 'name',\n    o: 'file',\n    p: 'plugin',\n    v: 'version',\n    w: 'watch'\n};\nfunction mergeOptions({ config = {}, command: rawCommandOptions = {}, defaultOnWarnHandler }) {\n    const command = getCommandOptions(rawCommandOptions);\n    const inputOptions = getInputOptions(config, command, defaultOnWarnHandler);\n    if (command.output) {\n        Object.assign(command, command.output);\n    }\n    const output = config.output;\n    const normalizedOutputOptions = Array.isArray(output) ? output : output ? [output] : [];\n    if (normalizedOutputOptions.length === 0)\n        normalizedOutputOptions.push({});\n    const outputOptions = normalizedOutputOptions.map(singleOutputOptions => getOutputOptions(singleOutputOptions, command));\n    const unknownOptionErrors = [];\n    const validInputOptions = Object.keys(inputOptions);\n    addUnknownOptionErrors(unknownOptionErrors, Object.keys(config), validInputOptions, 'input option', /^output$/);\n    const validOutputOptions = Object.keys(outputOptions[0]);\n    addUnknownOptionErrors(unknownOptionErrors, outputOptions.reduce((allKeys, options) => allKeys.concat(Object.keys(options)), []), validOutputOptions, 'output option');\n    const validCliOutputOptions = validOutputOptions.filter(option => option !== 'sourcemapPathTransform');\n    addUnknownOptionErrors(unknownOptionErrors, Object.keys(command), validInputOptions.concat(validCliOutputOptions, Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'stdin'), 'CLI flag', /^_|output|(config.*)$/);\n    return {\n        inputOptions,\n        optionError: unknownOptionErrors.length > 0 ? unknownOptionErrors.join('\\n') : null,\n        outputOptions\n    };\n}\nfunction addUnknownOptionErrors(errors, options, validOptions, optionType, ignoredKeys = /$./) {\n    const validOptionSet = new Set(validOptions);\n    const unknownOptions = options.filter(key => !validOptionSet.has(key) && !ignoredKeys.test(key));\n    if (unknownOptions.length > 0)\n        errors.push(`Unknown ${optionType}: ${unknownOptions.join(', ')}. Allowed options: ${Array.from(validOptionSet)\n            .sort()\n            .join(', ')}`);\n}\nfunction getCommandOptions(rawCommandOptions) {\n    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'\n        ? rawCommandOptions.external.split(',')\n        : [];\n    return Object.assign(Object.assign({}, rawCommandOptions), { external, globals: typeof rawCommandOptions.globals === 'string'\n            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {\n                const [id, variableName] = globalDefinition.split(':');\n                globals[id] = variableName;\n                if (external.indexOf(id) === -1) {\n                    external.push(id);\n                }\n                return globals;\n            }, Object.create(null))\n            : undefined });\n}\nfunction getInputOptions(config, command = { external: [], globals: undefined }, defaultOnWarnHandler) {\n    const getOption = createGetOption(config, command);\n    const inputOptions = {\n        acorn: config.acorn,\n        acornInjectPlugins: config.acornInjectPlugins,\n        cache: getOption('cache'),\n        chunkGroupingSize: getOption('chunkGroupingSize', 5000),\n        context: getOption('context'),\n        experimentalCacheExpiry: getOption('experimentalCacheExpiry', 10),\n        experimentalOptimizeChunks: getOption('experimentalOptimizeChunks'),\n        external: getExternal(config, command),\n        inlineDynamicImports: getOption('inlineDynamicImports', false),\n        input: getOption('input', []),\n        manualChunks: getOption('manualChunks'),\n        moduleContext: config.moduleContext,\n        onwarn: getOnWarn(config, defaultOnWarnHandler),\n        perf: getOption('perf', false),\n        plugins: ensureArray(config.plugins),\n        preserveModules: getOption('preserveModules'),\n        preserveSymlinks: getOption('preserveSymlinks'),\n        shimMissingExports: getOption('shimMissingExports'),\n        strictDeprecations: getOption('strictDeprecations', false),\n        treeshake: getObjectOption(config, command, 'treeshake'),\n        watch: config.watch\n    };\n    // support rollup({ cache: prevBuildObject })\n    if (inputOptions.cache && inputOptions.cache.cache)\n        inputOptions.cache = inputOptions.cache.cache;\n    return inputOptions;\n}\nfunction getOutputOptions(config, command = {}) {\n    const getOption = createGetOption(config, command);\n    let format = getOption('format');\n    // Handle format aliases\n    switch (format) {\n        case undefined:\n        case 'esm':\n        case 'module':\n            format = 'es';\n            break;\n        case 'commonjs':\n            format = 'cjs';\n    }\n    return {\n        amd: Object.assign(Object.assign({}, config.amd), command.amd),\n        assetFileNames: getOption('assetFileNames'),\n        banner: getOption('banner'),\n        chunkFileNames: getOption('chunkFileNames'),\n        compact: getOption('compact', false),\n        dir: getOption('dir'),\n        dynamicImportFunction: getOption('dynamicImportFunction'),\n        entryFileNames: getOption('entryFileNames'),\n        esModule: getOption('esModule', true),\n        exports: getOption('exports'),\n        extend: getOption('extend'),\n        externalLiveBindings: getOption('externalLiveBindings', true),\n        file: getOption('file'),\n        footer: getOption('footer'),\n        format,\n        freeze: getOption('freeze', true),\n        globals: getOption('globals'),\n        hoistTransitiveImports: getOption('hoistTransitiveImports', true),\n        indent: getOption('indent', true),\n        interop: getOption('interop', true),\n        intro: getOption('intro'),\n        name: getOption('name'),\n        namespaceToStringTag: getOption('namespaceToStringTag', false),\n        noConflict: getOption('noConflict'),\n        outro: getOption('outro'),\n        paths: getOption('paths'),\n        plugins: ensureArray(config.plugins),\n        preferConst: getOption('preferConst'),\n        sourcemap: getOption('sourcemap'),\n        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),\n        sourcemapFile: getOption('sourcemapFile'),\n        sourcemapPathTransform: getOption('sourcemapPathTransform'),\n        strict: getOption('strict', true)\n    };\n}\n\nfunction checkOutputOptions(options) {\n    if (options.format === 'es6') {\n        return error(errDeprecation({\n            message: 'The \"es6\" output format is deprecated – use \"esm\" instead',\n            url: `https://rollupjs.org/guide/en/#output-format`\n        }));\n    }\n    if (['amd', 'cjs', 'system', 'es', 'iife', 'umd'].indexOf(options.format) < 0) {\n        return error({\n            message: `You must specify \"output.format\", which can be one of \"amd\", \"cjs\", \"system\", \"esm\", \"iife\" or \"umd\".`,\n            url: `https://rollupjs.org/guide/en/#output-format`\n        });\n    }\n    if (options.exports && !['default', 'named', 'none', 'auto'].includes(options.exports)) {\n        return error(errInvalidExportOptionValue(options.exports));\n    }\n}\nfunction getAbsoluteEntryModulePaths(chunks) {\n    const absoluteEntryModulePaths = [];\n    for (const chunk of chunks) {\n        for (const entryModule of chunk.entryModules) {\n            if (isAbsolute(entryModule.id)) {\n                absoluteEntryModulePaths.push(entryModule.id);\n            }\n        }\n    }\n    return absoluteEntryModulePaths;\n}\nconst throwAsyncGenerateError = {\n    get() {\n        throw new Error(`bundle.generate(...) now returns a Promise instead of a { code, map } object`);\n    }\n};\nfunction applyOptionHook(inputOptions, plugin) {\n    if (plugin.options)\n        return plugin.options.call({ meta: { rollupVersion: version } }, inputOptions) || inputOptions;\n    return inputOptions;\n}\nfunction normalizePlugins(rawPlugins, anonymousPrefix) {\n    const plugins = ensureArray(rawPlugins);\n    for (let pluginIndex = 0; pluginIndex < plugins.length; pluginIndex++) {\n        const plugin = plugins[pluginIndex];\n        if (!plugin.name) {\n            plugin.name = `${anonymousPrefix}${pluginIndex + 1}`;\n        }\n    }\n    return plugins;\n}\nfunction getInputOptions$1(rawInputOptions) {\n    if (!rawInputOptions) {\n        throw new Error('You must supply an options object to rollup');\n    }\n    let { inputOptions, optionError } = mergeOptions({\n        config: rawInputOptions\n    });\n    if (optionError)\n        inputOptions.onwarn({ message: optionError, code: 'UNKNOWN_OPTION' });\n    inputOptions = inputOptions.plugins.reduce(applyOptionHook, inputOptions);\n    inputOptions.plugins = normalizePlugins(inputOptions.plugins, ANONYMOUS_PLUGIN_PREFIX);\n    if (inputOptions.inlineDynamicImports) {\n        if (inputOptions.preserveModules)\n            return error({\n                code: 'INVALID_OPTION',\n                message: `\"preserveModules\" does not support the \"inlineDynamicImports\" option.`\n            });\n        if (inputOptions.manualChunks)\n            return error({\n                code: 'INVALID_OPTION',\n                message: '\"manualChunks\" option is not supported for \"inlineDynamicImports\".'\n            });\n        if (inputOptions.experimentalOptimizeChunks)\n            return error({\n                code: 'INVALID_OPTION',\n                message: '\"experimentalOptimizeChunks\" option is not supported for \"inlineDynamicImports\".'\n            });\n        if ((inputOptions.input instanceof Array && inputOptions.input.length > 1) ||\n            (typeof inputOptions.input === 'object' && Object.keys(inputOptions.input).length > 1))\n            return error({\n                code: 'INVALID_OPTION',\n                message: 'Multiple inputs are not supported for \"inlineDynamicImports\".'\n            });\n    }\n    else if (inputOptions.preserveModules) {\n        if (inputOptions.manualChunks)\n            return error({\n                code: 'INVALID_OPTION',\n                message: '\"preserveModules\" does not support the \"manualChunks\" option.'\n            });\n        if (inputOptions.experimentalOptimizeChunks)\n            return error({\n                code: 'INVALID_OPTION',\n                message: '\"preserveModules\" does not support the \"experimentalOptimizeChunks\" option.'\n            });\n    }\n    return inputOptions;\n}\nlet curWatcher;\nfunction setWatcher(watcher) {\n    curWatcher = watcher;\n}\nfunction assignChunksToBundle(chunks, outputBundle) {\n    for (let i = 0; i < chunks.length; i++) {\n        const chunk = chunks[i];\n        const facadeModule = chunk.facadeModule;\n        outputBundle[chunk.id] = {\n            code: undefined,\n            dynamicImports: chunk.getDynamicImportIds(),\n            exports: chunk.getExportNames(),\n            facadeModuleId: facadeModule && facadeModule.id,\n            fileName: chunk.id,\n            imports: chunk.getImportIds(),\n            isDynamicEntry: facadeModule !== null && facadeModule.dynamicallyImportedBy.length > 0,\n            isEntry: facadeModule !== null && facadeModule.isEntryPoint,\n            map: undefined,\n            modules: chunk.renderedModules,\n            get name() {\n                return chunk.getChunkName();\n            },\n            type: 'chunk'\n        };\n    }\n    return outputBundle;\n}\nfunction rollup(rawInputOptions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const inputOptions = getInputOptions$1(rawInputOptions);\n        initialiseTimers(inputOptions);\n        const graph = new Graph(inputOptions, curWatcher);\n        curWatcher = undefined;\n        // remove the cache option from the memory after graph creation (cache is not used anymore)\n        const useCache = rawInputOptions.cache !== false;\n        delete inputOptions.cache;\n        delete rawInputOptions.cache;\n        timeStart('BUILD', 1);\n        let chunks;\n        try {\n            yield graph.pluginDriver.hookParallel('buildStart', [inputOptions]);\n            chunks = yield graph.build(inputOptions.input, inputOptions.manualChunks, inputOptions.inlineDynamicImports);\n        }\n        catch (err) {\n            const watchFiles = Object.keys(graph.watchFiles);\n            if (watchFiles.length > 0) {\n                err.watchFiles = watchFiles;\n            }\n            yield graph.pluginDriver.hookParallel('buildEnd', [err]);\n            throw err;\n        }\n        yield graph.pluginDriver.hookParallel('buildEnd', []);\n        timeEnd('BUILD', 1);\n        // ensure we only do one optimization pass per build\n        let optimized = false;\n        function getOutputOptionsAndPluginDriver(rawOutputOptions) {\n            if (!rawOutputOptions) {\n                throw new Error('You must supply an options object');\n            }\n            const outputPluginDriver = graph.pluginDriver.createOutputPluginDriver(normalizePlugins(rawOutputOptions.plugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX));\n            return {\n                outputOptions: normalizeOutputOptions(inputOptions, rawOutputOptions, chunks.length > 1, outputPluginDriver),\n                outputPluginDriver\n            };\n        }\n        function generate(outputOptions, isWrite, outputPluginDriver) {\n            return __awaiter(this, void 0, void 0, function* () {\n                timeStart('GENERATE', 1);\n                const assetFileNames = outputOptions.assetFileNames || 'assets/[name]-[hash][extname]';\n                const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));\n                const outputBundleWithPlaceholders = Object.create(null);\n                outputPluginDriver.setOutputBundle(outputBundleWithPlaceholders, assetFileNames);\n                let outputBundle;\n                try {\n                    yield outputPluginDriver.hookParallel('renderStart', [outputOptions, inputOptions]);\n                    const addons = yield createAddons(outputOptions, outputPluginDriver);\n                    for (const chunk of chunks) {\n                        if (!inputOptions.preserveModules)\n                            chunk.generateInternalExports(outputOptions);\n                        if (inputOptions.preserveModules || (chunk.facadeModule && chunk.facadeModule.isEntryPoint))\n                            chunk.exportMode = getExportMode(chunk, outputOptions, chunk.facadeModule.id);\n                    }\n                    for (const chunk of chunks) {\n                        chunk.preRender(outputOptions, inputBase);\n                    }\n                    if (!optimized && inputOptions.experimentalOptimizeChunks) {\n                        optimizeChunks(chunks, outputOptions, inputOptions.chunkGroupingSize, inputBase);\n                        optimized = true;\n                    }\n                    assignChunkIds(chunks, inputOptions, outputOptions, inputBase, addons, outputBundleWithPlaceholders, outputPluginDriver);\n                    outputBundle = assignChunksToBundle(chunks, outputBundleWithPlaceholders);\n                    yield Promise.all(chunks.map(chunk => {\n                        const outputChunk = outputBundleWithPlaceholders[chunk.id];\n                        return chunk\n                            .render(outputOptions, addons, outputChunk, outputPluginDriver)\n                            .then(rendered => {\n                            outputChunk.code = rendered.code;\n                            outputChunk.map = rendered.map;\n                            return outputPluginDriver.hookParallel('ongenerate', [\n                                Object.assign({ bundle: outputChunk }, outputOptions),\n                                outputChunk\n                            ]);\n                        });\n                    }));\n                }\n                catch (error) {\n                    yield outputPluginDriver.hookParallel('renderError', [error]);\n                    throw error;\n                }\n                yield outputPluginDriver.hookSeq('generateBundle', [outputOptions, outputBundle, isWrite]);\n                for (const key of Object.keys(outputBundle)) {\n                    const file = outputBundle[key];\n                    if (!file.type) {\n                        graph.warnDeprecation('A plugin is directly adding properties to the bundle object in the \"generateBundle\" hook. This is deprecated and will be removed in a future Rollup version, please use \"this.emitFile\" instead.', false);\n                        file.type = 'asset';\n                    }\n                }\n                outputPluginDriver.finaliseAssets();\n                timeEnd('GENERATE', 1);\n                return outputBundle;\n            });\n        }\n        const cache = useCache ? graph.getCache() : undefined;\n        const result = {\n            cache: cache,\n            generate: ((rawOutputOptions) => {\n                const { outputOptions, outputPluginDriver } = getOutputOptionsAndPluginDriver(rawOutputOptions);\n                const promise = generate(outputOptions, false, outputPluginDriver).then(result => createOutput(result));\n                Object.defineProperty(promise, 'code', throwAsyncGenerateError);\n                Object.defineProperty(promise, 'map', throwAsyncGenerateError);\n                return promise;\n            }),\n            watchFiles: Object.keys(graph.watchFiles),\n            write: ((rawOutputOptions) => {\n                const { outputOptions, outputPluginDriver } = getOutputOptionsAndPluginDriver(rawOutputOptions);\n                if (!outputOptions.dir && !outputOptions.file) {\n                    return error({\n                        code: 'MISSING_OPTION',\n                        message: 'You must specify \"output.file\" or \"output.dir\" for the build.'\n                    });\n                }\n                return generate(outputOptions, true, outputPluginDriver).then((bundle) => __awaiter(this, void 0, void 0, function* () {\n                    let chunkCount = 0;\n                    for (const fileName of Object.keys(bundle)) {\n                        const file = bundle[fileName];\n                        if (file.type === 'asset')\n                            continue;\n                        chunkCount++;\n                        if (chunkCount > 1)\n                            break;\n                    }\n                    if (chunkCount > 1) {\n                        if (outputOptions.sourcemapFile)\n                            return error({\n                                code: 'INVALID_OPTION',\n                                message: '\"output.sourcemapFile\" is only supported for single-file builds.'\n                            });\n                        if (typeof outputOptions.file === 'string')\n                            return error({\n                                code: 'INVALID_OPTION',\n                                message: 'When building multiple chunks, the \"output.dir\" option must be used, not \"output.file\".' +\n                                    (typeof inputOptions.input !== 'string' ||\n                                        inputOptions.inlineDynamicImports === true\n                                        ? ''\n                                        : ' To inline dynamic imports, set the \"inlineDynamicImports\" option.')\n                            });\n                    }\n                    yield Promise.all(Object.keys(bundle).map(chunkId => writeOutputFile(result, bundle[chunkId], outputOptions, outputPluginDriver)));\n                    yield outputPluginDriver.hookParallel('writeBundle', [bundle]);\n                    return createOutput(bundle);\n                }));\n            })\n        };\n        if (inputOptions.perf === true)\n            result.getTimings = getTimings;\n        return result;\n    });\n}\nvar SortingFileType;\n(function (SortingFileType) {\n    SortingFileType[SortingFileType[\"ENTRY_CHUNK\"] = 0] = \"ENTRY_CHUNK\";\n    SortingFileType[SortingFileType[\"SECONDARY_CHUNK\"] = 1] = \"SECONDARY_CHUNK\";\n    SortingFileType[SortingFileType[\"ASSET\"] = 2] = \"ASSET\";\n})(SortingFileType || (SortingFileType = {}));\nfunction getSortingFileType(file) {\n    if (file.type === 'asset') {\n        return SortingFileType.ASSET;\n    }\n    if (file.isEntry) {\n        return SortingFileType.ENTRY_CHUNK;\n    }\n    return SortingFileType.SECONDARY_CHUNK;\n}\nfunction createOutput(outputBundle) {\n    return {\n        output: Object.keys(outputBundle)\n            .map(fileName => outputBundle[fileName])\n            .filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {\n            const fileTypeA = getSortingFileType(outputFileA);\n            const fileTypeB = getSortingFileType(outputFileB);\n            if (fileTypeA === fileTypeB)\n                return 0;\n            return fileTypeA < fileTypeB ? -1 : 1;\n        })\n    };\n}\nfunction writeOutputFile(build, outputFile, outputOptions, outputPluginDriver) {\n    const fileName = resolve(outputOptions.dir || dirname(outputOptions.file), outputFile.fileName);\n    let writeSourceMapPromise;\n    let source;\n    if (outputFile.type === 'asset') {\n        source = outputFile.source;\n    }\n    else {\n        source = outputFile.code;\n        if (outputOptions.sourcemap && outputFile.map) {\n            let url;\n            if (outputOptions.sourcemap === 'inline') {\n                url = outputFile.map.toUrl();\n            }\n            else {\n                url = `${basename(outputFile.fileName)}.map`;\n                writeSourceMapPromise = writeFile(`${fileName}.map`, outputFile.map.toString());\n            }\n            if (outputOptions.sourcemap !== 'hidden') {\n                source += `//# ${SOURCEMAPPING_URL}=${url}\\n`;\n            }\n        }\n    }\n    return writeFile(fileName, source)\n        .then(() => writeSourceMapPromise)\n        .then(() => outputFile.type === 'chunk' &&\n        outputPluginDriver.hookSeq('onwrite', [\n            Object.assign({ bundle: build }, outputOptions),\n            outputFile\n        ]))\n        .then(() => { });\n}\nfunction normalizeOutputOptions(inputOptions, rawOutputOptions, hasMultipleChunks, outputPluginDriver) {\n    const mergedOptions = mergeOptions({\n        config: {\n            output: Object.assign(Object.assign(Object.assign({}, rawOutputOptions), rawOutputOptions.output), inputOptions.output)\n        }\n    });\n    if (mergedOptions.optionError)\n        throw new Error(mergedOptions.optionError);\n    // now outputOptions is an array, but rollup.rollup API doesn't support arrays\n    const mergedOutputOptions = mergedOptions.outputOptions[0];\n    const outputOptionsReducer = (outputOptions, result) => result || outputOptions;\n    const outputOptions = outputPluginDriver.hookReduceArg0Sync('outputOptions', [mergedOutputOptions], outputOptionsReducer, pluginContext => {\n        const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());\n        return Object.assign(Object.assign({}, pluginContext), { emitFile: emitError, setAssetSource: emitError });\n    });\n    checkOutputOptions(outputOptions);\n    if (typeof outputOptions.file === 'string') {\n        if (typeof outputOptions.dir === 'string')\n            return error({\n                code: 'INVALID_OPTION',\n                message: 'You must set either \"output.file\" for a single-file build or \"output.dir\" when generating multiple chunks.'\n            });\n        if (inputOptions.preserveModules) {\n            return error({\n                code: 'INVALID_OPTION',\n                message: 'You must set \"output.dir\" instead of \"output.file\" when using the \"preserveModules\" option.'\n            });\n        }\n        if (typeof inputOptions.input === 'object' && !Array.isArray(inputOptions.input))\n            return error({\n                code: 'INVALID_OPTION',\n                message: 'You must set \"output.dir\" instead of \"output.file\" when providing named inputs.'\n            });\n    }\n    if (hasMultipleChunks) {\n        if (outputOptions.format === 'umd' || outputOptions.format === 'iife')\n            return error({\n                code: 'INVALID_OPTION',\n                message: 'UMD and IIFE output formats are not supported for code-splitting builds.'\n            });\n        if (typeof outputOptions.file === 'string')\n            return error({\n                code: 'INVALID_OPTION',\n                message: 'You must set \"output.dir\" instead of \"output.file\" when generating multiple chunks.'\n            });\n    }\n    return outputOptions;\n}\n\nvar utils$1 = createCommonjsModule(function (module, exports) {\n    exports.isInteger = num => {\n        if (typeof num === 'number') {\n            return Number.isInteger(num);\n        }\n        if (typeof num === 'string' && num.trim() !== '') {\n            return Number.isInteger(Number(num));\n        }\n        return false;\n    };\n    /**\n     * Find a node of the given type\n     */\n    exports.find = (node, type) => node.nodes.find(node => node.type === type);\n    /**\n     * Find a node of the given type\n     */\n    exports.exceedsLimit = (min, max, step = 1, limit) => {\n        if (limit === false)\n            return false;\n        if (!exports.isInteger(min) || !exports.isInteger(max))\n            return false;\n        return ((Number(max) - Number(min)) / Number(step)) >= limit;\n    };\n    /**\n     * Escape the given node with '\\\\' before node.value\n     */\n    exports.escapeNode = (block, n = 0, type) => {\n        let node = block.nodes[n];\n        if (!node)\n            return;\n        if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n            if (node.escaped !== true) {\n                node.value = '\\\\' + node.value;\n                node.escaped = true;\n            }\n        }\n    };\n    /**\n     * Returns true if the given brace node should be enclosed in literal braces\n     */\n    exports.encloseBrace = node => {\n        if (node.type !== 'brace')\n            return false;\n        if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n            node.invalid = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns true if a brace node is invalid.\n     */\n    exports.isInvalidBrace = block => {\n        if (block.type !== 'brace')\n            return false;\n        if (block.invalid === true || block.dollar)\n            return true;\n        if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n            block.invalid = true;\n            return true;\n        }\n        if (block.open !== true || block.close !== true) {\n            block.invalid = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns true if a node is an open or close node\n     */\n    exports.isOpenOrClose = node => {\n        if (node.type === 'open' || node.type === 'close') {\n            return true;\n        }\n        return node.open === true || node.close === true;\n    };\n    /**\n     * Reduce an array of text nodes.\n     */\n    exports.reduce = nodes => nodes.reduce((acc, node) => {\n        if (node.type === 'text')\n            acc.push(node.value);\n        if (node.type === 'range')\n            node.type = 'text';\n        return acc;\n    }, []);\n    /**\n     * Flatten an array\n     */\n    exports.flatten = (...args) => {\n        const result = [];\n        const flat = arr => {\n            for (let i = 0; i < arr.length; i++) {\n                let ele = arr[i];\n                Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n            }\n            return result;\n        };\n        flat(args);\n        return result;\n    };\n});\n\nvar stringify = (ast, options = {}) => {\n    let stringify = (node, parent = {}) => {\n        let invalidBlock = options.escapeInvalid && utils$1.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let output = '';\n        if (node.value) {\n            if ((invalidBlock || invalidNode) && utils$1.isOpenOrClose(node)) {\n                return '\\\\' + node.value;\n            }\n            return node.value;\n        }\n        if (node.value) {\n            return node.value;\n        }\n        if (node.nodes) {\n            for (let child of node.nodes) {\n                output += stringify(child);\n            }\n        }\n        return output;\n    };\n    return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nvar isNumber = function (num) {\n    if (typeof num === 'number') {\n        return num - num === 0;\n    }\n    if (typeof num === 'string' && num.trim() !== '') {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    }\n    return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n    if (isNumber(min) === false) {\n        throw new TypeError('toRegexRange: expected the first argument to be a number');\n    }\n    if (max === void 0 || min === max) {\n        return String(min);\n    }\n    if (isNumber(max) === false) {\n        throw new TypeError('toRegexRange: expected the second argument to be a number.');\n    }\n    let opts = Object.assign({ relaxZeros: true }, options);\n    if (typeof opts.strictZeros === 'boolean') {\n        opts.relaxZeros = opts.strictZeros === false;\n    }\n    let relax = String(opts.relaxZeros);\n    let shorthand = String(opts.shorthand);\n    let capture = String(opts.capture);\n    let wrap = String(opts.wrap);\n    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n        return toRegexRange.cache[cacheKey].result;\n    }\n    let a = Math.min(min, max);\n    let b = Math.max(min, max);\n    if (Math.abs(a - b) === 1) {\n        let result = min + '|' + max;\n        if (opts.capture) {\n            return `(${result})`;\n        }\n        if (opts.wrap === false) {\n            return result;\n        }\n        return `(?:${result})`;\n    }\n    let isPadded = hasPadding(min) || hasPadding(max);\n    let state = { min, max, a, b };\n    let positives = [];\n    let negatives = [];\n    if (isPadded) {\n        state.isPadded = isPadded;\n        state.maxLen = String(state.max).length;\n    }\n    if (a < 0) {\n        let newMin = b < 0 ? Math.abs(b) : 1;\n        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n        a = state.a = 0;\n    }\n    if (b >= 0) {\n        positives = splitToPatterns(a, b, state, opts);\n    }\n    state.negatives = negatives;\n    state.positives = positives;\n    state.result = collatePatterns(negatives, positives);\n    if (opts.capture === true) {\n        state.result = `(${state.result})`;\n    }\n    else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n        state.result = `(?:${state.result})`;\n    }\n    toRegexRange.cache[cacheKey] = state;\n    return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n    let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n    let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n    let intersected = filterPatterns(neg, pos, '-?', true) || [];\n    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n    return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n    let nines = 1;\n    let zeros = 1;\n    let stop = countNines(min, nines);\n    let stops = new Set([max]);\n    while (min <= stop && stop <= max) {\n        stops.add(stop);\n        nines += 1;\n        stop = countNines(min, nines);\n    }\n    stop = countZeros(max + 1, zeros) - 1;\n    while (min < stop && stop <= max) {\n        stops.add(stop);\n        zeros += 1;\n        stop = countZeros(max + 1, zeros) - 1;\n    }\n    stops = [...stops];\n    stops.sort(compare);\n    return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\nfunction rangeToPattern(start, stop, options) {\n    if (start === stop) {\n        return { pattern: start, count: [], digits: 0 };\n    }\n    let zipped = zip(start, stop);\n    let digits = zipped.length;\n    let pattern = '';\n    let count = 0;\n    for (let i = 0; i < digits; i++) {\n        let [startDigit, stopDigit] = zipped[i];\n        if (startDigit === stopDigit) {\n            pattern += startDigit;\n        }\n        else if (startDigit !== '0' || stopDigit !== '9') {\n            pattern += toCharacterClass(startDigit, stopDigit);\n        }\n        else {\n            count++;\n        }\n    }\n    if (count) {\n        pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n    }\n    return { pattern, count: [count], digits };\n}\nfunction splitToPatterns(min, max, tok, options) {\n    let ranges = splitToRanges(min, max);\n    let tokens = [];\n    let start = min;\n    let prev;\n    for (let i = 0; i < ranges.length; i++) {\n        let max = ranges[i];\n        let obj = rangeToPattern(String(start), String(max), options);\n        let zeros = '';\n        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n            if (prev.count.length > 1) {\n                prev.count.pop();\n            }\n            prev.count.push(obj.count[0]);\n            prev.string = prev.pattern + toQuantifier(prev.count);\n            start = max + 1;\n            continue;\n        }\n        if (tok.isPadded) {\n            zeros = padZeros(max, tok, options);\n        }\n        obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n        tokens.push(obj);\n        start = max + 1;\n        prev = obj;\n    }\n    return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n    let result = [];\n    for (let ele of arr) {\n        let { string } = ele;\n        // only push if _both_ are negative...\n        if (!intersection && !contains(comparison, 'string', string)) {\n            result.push(prefix + string);\n        }\n        // or _both_ are positive\n        if (intersection && contains(comparison, 'string', string)) {\n            result.push(prefix + string);\n        }\n    }\n    return result;\n}\n/**\n * Zip strings\n */\nfunction zip(a, b) {\n    let arr = [];\n    for (let i = 0; i < a.length; i++)\n        arr.push([a[i], b[i]]);\n    return arr;\n}\nfunction compare(a, b) {\n    return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n    return arr.some(ele => ele[key] === val);\n}\nfunction countNines(min, len) {\n    return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n    return integer - (integer % Math.pow(10, zeros));\n}\nfunction toQuantifier(digits) {\n    let [start = 0, stop = ''] = digits;\n    if (stop || start > 1) {\n        return `{${start + (stop ? ',' + stop : '')}}`;\n    }\n    return '';\n}\nfunction toCharacterClass(a, b, options) {\n    return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\nfunction hasPadding(str) {\n    return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n    if (!tok.isPadded) {\n        return value;\n    }\n    let diff = Math.abs(tok.maxLen - String(value).length);\n    let relax = options.relaxZeros !== false;\n    switch (diff) {\n        case 0:\n            return '';\n        case 1:\n            return relax ? '0?' : '0';\n        case 2:\n            return relax ? '0{0,2}' : '00';\n        default: {\n            return relax ? `0{0,${diff}}` : `0{${diff}}`;\n        }\n    }\n}\n/**\n * Cache\n */\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n/**\n * Expose `toRegexRange`\n */\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject$1 = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nconst transform$1 = toNumber => {\n    return value => toNumber === true ? Number(value) : String(value);\n};\nconst isValidValue = value => {\n    return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\nconst isNumber$1 = num => Number.isInteger(+num);\nconst zeros = input => {\n    let value = `${input}`;\n    let index = -1;\n    if (value[0] === '-')\n        value = value.slice(1);\n    if (value === '0')\n        return false;\n    while (value[++index] === '0')\n        ;\n    return index > 0;\n};\nconst stringify$1 = (start, end, options) => {\n    if (typeof start === 'string' || typeof end === 'string') {\n        return true;\n    }\n    return options.stringify === true;\n};\nconst pad = (input, maxLength, toNumber) => {\n    if (maxLength > 0) {\n        let dash = input[0] === '-' ? '-' : '';\n        if (dash)\n            input = input.slice(1);\n        input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n    }\n    if (toNumber === false) {\n        return String(input);\n    }\n    return input;\n};\nconst toMaxLen = (input, maxLength) => {\n    let negative = input[0] === '-' ? '-' : '';\n    if (negative) {\n        input = input.slice(1);\n        maxLength--;\n    }\n    while (input.length < maxLength)\n        input = '0' + input;\n    return negative ? ('-' + input) : input;\n};\nconst toSequence = (parts, options) => {\n    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    let prefix = options.capture ? '' : '?:';\n    let positives = '';\n    let negatives = '';\n    let result;\n    if (parts.positives.length) {\n        positives = parts.positives.join('|');\n    }\n    if (parts.negatives.length) {\n        negatives = `-(${prefix}${parts.negatives.join('|')})`;\n    }\n    if (positives && negatives) {\n        result = `${positives}|${negatives}`;\n    }\n    else {\n        result = positives || negatives;\n    }\n    if (options.wrap) {\n        return `(${prefix}${result})`;\n    }\n    return result;\n};\nconst toRange = (a, b, isNumbers, options) => {\n    if (isNumbers) {\n        return toRegexRange_1(a, b, Object.assign({ wrap: false }, options));\n    }\n    let start = String.fromCharCode(a);\n    if (a === b)\n        return start;\n    let stop = String.fromCharCode(b);\n    return `[${start}-${stop}]`;\n};\nconst toRegex = (start, end, options) => {\n    if (Array.isArray(start)) {\n        let wrap = options.wrap === true;\n        let prefix = options.capture ? '' : '?:';\n        return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n    }\n    return toRegexRange_1(start, end, options);\n};\nconst rangeError = (...args) => {\n    return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\nconst invalidRange = (start, end, options) => {\n    if (options.strictRanges === true)\n        throw rangeError([start, end]);\n    return [];\n};\nconst invalidStep = (step, options) => {\n    if (options.strictRanges === true) {\n        throw new TypeError(`Expected step \"${step}\" to be a number`);\n    }\n    return [];\n};\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n    let a = Number(start);\n    let b = Number(end);\n    if (!Number.isInteger(a) || !Number.isInteger(b)) {\n        if (options.strictRanges === true)\n            throw rangeError([start, end]);\n        return [];\n    }\n    // fix negative zero\n    if (a === 0)\n        a = 0;\n    if (b === 0)\n        b = 0;\n    let descending = a > b;\n    let startString = String(start);\n    let endString = String(end);\n    let stepString = String(step);\n    step = Math.max(Math.abs(step), 1);\n    let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n    let toNumber = padded === false && stringify$1(start, end, options) === false;\n    let format = options.transform || transform$1(toNumber);\n    if (options.toRegex && step === 1) {\n        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n    }\n    let parts = { negatives: [], positives: [] };\n    let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n        if (options.toRegex === true && step > 1) {\n            push(a);\n        }\n        else {\n            range.push(pad(format(a, index), maxLen, toNumber));\n        }\n        a = descending ? a - step : a + step;\n        index++;\n    }\n    if (options.toRegex === true) {\n        return step > 1\n            ? toSequence(parts, options)\n            : toRegex(range, null, Object.assign({ wrap: false }, options));\n    }\n    return range;\n};\nconst fillLetters = (start, end, step = 1, options = {}) => {\n    if ((!isNumber$1(start) && start.length > 1) || (!isNumber$1(end) && end.length > 1)) {\n        return invalidRange(start, end, options);\n    }\n    let format = options.transform || (val => String.fromCharCode(val));\n    let a = `${start}`.charCodeAt(0);\n    let b = `${end}`.charCodeAt(0);\n    let descending = a > b;\n    let min = Math.min(a, b);\n    let max = Math.max(a, b);\n    if (options.toRegex && step === 1) {\n        return toRange(min, max, false, options);\n    }\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n        range.push(format(a, index));\n        a = descending ? a - step : a + step;\n        index++;\n    }\n    if (options.toRegex === true) {\n        return toRegex(range, null, { wrap: false, options });\n    }\n    return range;\n};\nconst fill = (start, end, step, options = {}) => {\n    if (end == null && isValidValue(start)) {\n        return [start];\n    }\n    if (!isValidValue(start) || !isValidValue(end)) {\n        return invalidRange(start, end, options);\n    }\n    if (typeof step === 'function') {\n        return fill(start, end, 1, { transform: step });\n    }\n    if (isObject$1(step)) {\n        return fill(start, end, 0, step);\n    }\n    let opts = Object.assign({}, options);\n    if (opts.capture === true)\n        opts.wrap = true;\n    step = step || opts.step || 1;\n    if (!isNumber$1(step)) {\n        if (step != null && !isObject$1(step))\n            return invalidStep(step, opts);\n        return fill(start, end, 1, step);\n    }\n    if (isNumber$1(start) && isNumber$1(end)) {\n        return fillNumbers(start, end, step, opts);\n    }\n    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n    let walk = (node, parent = {}) => {\n        let invalidBlock = utils$1.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let invalid = invalidBlock === true || invalidNode === true;\n        let prefix = options.escapeInvalid === true ? '\\\\' : '';\n        let output = '';\n        if (node.isOpen === true) {\n            return prefix + node.value;\n        }\n        if (node.isClose === true) {\n            return prefix + node.value;\n        }\n        if (node.type === 'open') {\n            return invalid ? (prefix + node.value) : '(';\n        }\n        if (node.type === 'close') {\n            return invalid ? (prefix + node.value) : ')';\n        }\n        if (node.type === 'comma') {\n            return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n        }\n        if (node.value) {\n            return node.value;\n        }\n        if (node.nodes && node.ranges > 0) {\n            let args = utils$1.reduce(node.nodes);\n            let range = fillRange(...args, Object.assign(Object.assign({}, options), { wrap: false, toRegex: true }));\n            if (range.length !== 0) {\n                return args.length > 1 && range.length > 1 ? `(${range})` : range;\n            }\n        }\n        if (node.nodes) {\n            for (let child of node.nodes) {\n                output += walk(child, node);\n            }\n        }\n        return output;\n    };\n    return walk(ast);\n};\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n    let result = [];\n    queue = [].concat(queue);\n    stash = [].concat(stash);\n    if (!stash.length)\n        return queue;\n    if (!queue.length) {\n        return enclose ? utils$1.flatten(stash).map(ele => `{${ele}}`) : stash;\n    }\n    for (let item of queue) {\n        if (Array.isArray(item)) {\n            for (let value of item) {\n                result.push(append(value, stash, enclose));\n            }\n        }\n        else {\n            for (let ele of stash) {\n                if (enclose === true && typeof ele === 'string')\n                    ele = `{${ele}}`;\n                result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n            }\n        }\n    }\n    return utils$1.flatten(result);\n};\nconst expand = (ast, options = {}) => {\n    let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n    let walk = (node, parent = {}) => {\n        node.queue = [];\n        let p = parent;\n        let q = parent.queue;\n        while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n            p = p.parent;\n            q = p.queue;\n        }\n        if (node.invalid || node.dollar) {\n            q.push(append(q.pop(), stringify(node, options)));\n            return;\n        }\n        if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n            q.push(append(q.pop(), ['{}']));\n            return;\n        }\n        if (node.nodes && node.ranges > 0) {\n            let args = utils$1.reduce(node.nodes);\n            if (utils$1.exceedsLimit(...args, options.step, rangeLimit)) {\n                throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n            }\n            let range = fillRange(...args, options);\n            if (range.length === 0) {\n                range = stringify(node, options);\n            }\n            q.push(append(q.pop(), range));\n            node.nodes = [];\n            return;\n        }\n        let enclose = utils$1.encloseBrace(node);\n        let queue = node.queue;\n        let block = node;\n        while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n            block = block.parent;\n            queue = block.queue;\n        }\n        for (let i = 0; i < node.nodes.length; i++) {\n            let child = node.nodes[i];\n            if (child.type === 'comma' && node.type === 'brace') {\n                if (i === 1)\n                    queue.push('');\n                queue.push('');\n                continue;\n            }\n            if (child.type === 'close') {\n                q.push(append(q.pop(), queue, enclose));\n                continue;\n            }\n            if (child.value && child.type !== 'open') {\n                queue.push(append(queue.pop(), child.value));\n                continue;\n            }\n            if (child.nodes) {\n                walk(child, node);\n            }\n        }\n        return queue;\n    };\n    return utils$1.flatten(walk(ast));\n};\nvar expand_1 = expand;\n\nvar constants = {\n    MAX_LENGTH: 1024 * 64,\n    // Digits\n    CHAR_0: '0',\n    CHAR_9: '9',\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 'A',\n    CHAR_LOWERCASE_A: 'a',\n    CHAR_UPPERCASE_Z: 'Z',\n    CHAR_LOWERCASE_Z: 'z',\n    CHAR_LEFT_PARENTHESES: '(',\n    CHAR_RIGHT_PARENTHESES: ')',\n    CHAR_ASTERISK: '*',\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: '&',\n    CHAR_AT: '@',\n    CHAR_BACKSLASH: '\\\\',\n    CHAR_BACKTICK: '`',\n    CHAR_CARRIAGE_RETURN: '\\r',\n    CHAR_CIRCUMFLEX_ACCENT: '^',\n    CHAR_COLON: ':',\n    CHAR_COMMA: ',',\n    CHAR_DOLLAR: '$',\n    CHAR_DOT: '.',\n    CHAR_DOUBLE_QUOTE: '\"',\n    CHAR_EQUAL: '=',\n    CHAR_EXCLAMATION_MARK: '!',\n    CHAR_FORM_FEED: '\\f',\n    CHAR_FORWARD_SLASH: '/',\n    CHAR_HASH: '#',\n    CHAR_HYPHEN_MINUS: '-',\n    CHAR_LEFT_ANGLE_BRACKET: '<',\n    CHAR_LEFT_CURLY_BRACE: '{',\n    CHAR_LEFT_SQUARE_BRACKET: '[',\n    CHAR_LINE_FEED: '\\n',\n    CHAR_NO_BREAK_SPACE: '\\u00A0',\n    CHAR_PERCENT: '%',\n    CHAR_PLUS: '+',\n    CHAR_QUESTION_MARK: '?',\n    CHAR_RIGHT_ANGLE_BRACKET: '>',\n    CHAR_RIGHT_CURLY_BRACE: '}',\n    CHAR_RIGHT_SQUARE_BRACKET: ']',\n    CHAR_SEMICOLON: ';',\n    CHAR_SINGLE_QUOTE: '\\'',\n    CHAR_SPACE: ' ',\n    CHAR_TAB: '\\t',\n    CHAR_UNDERSCORE: '_',\n    CHAR_VERTICAL_LINE: '|',\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n/**\n * Constants\n */\nconst { MAX_LENGTH, CHAR_BACKSLASH, /* \\ */ CHAR_BACKTICK, /* ` */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_RIGHT_SQUARE_BRACKET, /* ] */ CHAR_DOUBLE_QUOTE, /* \" */ CHAR_SINGLE_QUOTE, /* ' */ CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = constants;\n/**\n * parse\n */\nconst parse = (input, options = {}) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    let opts = options || {};\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    if (input.length > max) {\n        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n    }\n    let ast = { type: 'root', input, nodes: [] };\n    let stack = [ast];\n    let block = ast;\n    let prev = ast;\n    let brackets = 0;\n    let length = input.length;\n    let index = 0;\n    let depth = 0;\n    let value;\n    /**\n     * Helpers\n     */\n    const advance = () => input[index++];\n    const push = node => {\n        if (node.type === 'text' && prev.type === 'dot') {\n            prev.type = 'text';\n        }\n        if (prev && prev.type === 'text' && node.type === 'text') {\n            prev.value += node.value;\n            return;\n        }\n        block.nodes.push(node);\n        node.parent = block;\n        node.prev = prev;\n        prev = node;\n        return node;\n    };\n    push({ type: 'bos' });\n    while (index < length) {\n        block = stack[stack.length - 1];\n        value = advance();\n        /**\n         * Invalid chars\n         */\n        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n            continue;\n        }\n        /**\n         * Escaped chars\n         */\n        if (value === CHAR_BACKSLASH) {\n            push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n            continue;\n        }\n        /**\n         * Right square bracket (literal): ']'\n         */\n        if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n            push({ type: 'text', value: '\\\\' + value });\n            continue;\n        }\n        /**\n         * Left square bracket: '['\n         */\n        if (value === CHAR_LEFT_SQUARE_BRACKET) {\n            brackets++;\n            let next;\n            while (index < length && (next = advance())) {\n                value += next;\n                if (next === CHAR_LEFT_SQUARE_BRACKET) {\n                    brackets++;\n                    continue;\n                }\n                if (next === CHAR_BACKSLASH) {\n                    value += advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n                    brackets--;\n                    if (brackets === 0) {\n                        break;\n                    }\n                }\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Parentheses\n         */\n        if (value === CHAR_LEFT_PARENTHESES) {\n            block = push({ type: 'paren', nodes: [] });\n            stack.push(block);\n            push({ type: 'text', value });\n            continue;\n        }\n        if (value === CHAR_RIGHT_PARENTHESES) {\n            if (block.type !== 'paren') {\n                push({ type: 'text', value });\n                continue;\n            }\n            block = stack.pop();\n            push({ type: 'text', value });\n            block = stack[stack.length - 1];\n            continue;\n        }\n        /**\n         * Quotes: '|\"|`\n         */\n        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n            let open = value;\n            let next;\n            if (options.keepQuotes !== true) {\n                value = '';\n            }\n            while (index < length && (next = advance())) {\n                if (next === CHAR_BACKSLASH) {\n                    value += next + advance();\n                    continue;\n                }\n                if (next === open) {\n                    if (options.keepQuotes === true)\n                        value += next;\n                    break;\n                }\n                value += next;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Left curly brace: '{'\n         */\n        if (value === CHAR_LEFT_CURLY_BRACE) {\n            depth++;\n            let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n            let brace = {\n                type: 'brace',\n                open: true,\n                close: false,\n                dollar,\n                depth,\n                commas: 0,\n                ranges: 0,\n                nodes: []\n            };\n            block = push(brace);\n            stack.push(block);\n            push({ type: 'open', value });\n            continue;\n        }\n        /**\n         * Right curly brace: '}'\n         */\n        if (value === CHAR_RIGHT_CURLY_BRACE) {\n            if (block.type !== 'brace') {\n                push({ type: 'text', value });\n                continue;\n            }\n            let type = 'close';\n            block = stack.pop();\n            block.close = true;\n            push({ type, value });\n            depth--;\n            block = stack[stack.length - 1];\n            continue;\n        }\n        /**\n         * Comma: ','\n         */\n        if (value === CHAR_COMMA && depth > 0) {\n            if (block.ranges > 0) {\n                block.ranges = 0;\n                let open = block.nodes.shift();\n                block.nodes = [open, { type: 'text', value: stringify(block) }];\n            }\n            push({ type: 'comma', value });\n            block.commas++;\n            continue;\n        }\n        /**\n         * Dot: '.'\n         */\n        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n            let siblings = block.nodes;\n            if (depth === 0 || siblings.length === 0) {\n                push({ type: 'text', value });\n                continue;\n            }\n            if (prev.type === 'dot') {\n                block.range = [];\n                prev.value += value;\n                prev.type = 'range';\n                if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n                    block.invalid = true;\n                    block.ranges = 0;\n                    prev.type = 'text';\n                    continue;\n                }\n                block.ranges++;\n                block.args = [];\n                continue;\n            }\n            if (prev.type === 'range') {\n                siblings.pop();\n                let before = siblings[siblings.length - 1];\n                before.value += prev.value + value;\n                prev = before;\n                block.ranges--;\n                continue;\n            }\n            push({ type: 'dot', value });\n            continue;\n        }\n        /**\n         * Text\n         */\n        push({ type: 'text', value });\n    }\n    // Mark imbalanced braces and brackets as invalid\n    do {\n        block = stack.pop();\n        if (block.type !== 'root') {\n            block.nodes.forEach(node => {\n                if (!node.nodes) {\n                    if (node.type === 'open')\n                        node.isOpen = true;\n                    if (node.type === 'close')\n                        node.isClose = true;\n                    if (!node.nodes)\n                        node.type = 'text';\n                    node.invalid = true;\n                }\n            });\n            // get the location of the block on parent.nodes (block's siblings)\n            let parent = stack[stack.length - 1];\n            let index = parent.nodes.indexOf(block);\n            // replace the (invalid) block with it's nodes\n            parent.nodes.splice(index, 1, ...block.nodes);\n        }\n    } while (stack.length > 0);\n    push({ type: 'eos' });\n    return ast;\n};\nvar parse_1 = parse;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\nconst braces = (input, options = {}) => {\n    let output = [];\n    if (Array.isArray(input)) {\n        for (let pattern of input) {\n            let result = braces.create(pattern, options);\n            if (Array.isArray(result)) {\n                output.push(...result);\n            }\n            else {\n                output.push(result);\n            }\n        }\n    }\n    else {\n        output = [].concat(braces.create(input, options));\n    }\n    if (options && options.expand === true && options.nodupes === true) {\n        output = [...new Set(output)];\n    }\n    return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\nbraces.parse = (input, options = {}) => parse_1(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.stringify = (input, options = {}) => {\n    if (typeof input === 'string') {\n        return stringify(braces.parse(input, options), options);\n    }\n    return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.compile = (input, options = {}) => {\n    if (typeof input === 'string') {\n        input = braces.parse(input, options);\n    }\n    return compile_1(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.expand = (input, options = {}) => {\n    if (typeof input === 'string') {\n        input = braces.parse(input, options);\n    }\n    let result = expand_1(input, options);\n    // filter out empty strings if specified\n    if (options.noempty === true) {\n        result = result.filter(Boolean);\n    }\n    // filter out duplicates if specified\n    if (options.nodupes === true) {\n        result = [...new Set(result)];\n    }\n    return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.create = (input, options = {}) => {\n    if (input === '' || input.length < 3) {\n        return [input];\n    }\n    return options.expand !== true\n        ? braces.compile(input, options)\n        : braces.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\nvar braces_1 = braces;\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    QMARK_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    QMARK,\n    END_ANCHOR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n};\n/**\n * Windows glob regex\n */\nconst WINDOWS_CHARS = Object.assign(Object.assign({}, POSIX_CHARS), { SLASH_LITERAL: `[${WIN_SLASH}]`, QMARK: WIN_NO_SLASH, STAR: `${WIN_NO_SLASH}*?`, DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`, NO_DOT: `(?!${DOT_LITERAL})`, NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`, NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, QMARK_NO_DOT: `[^.${WIN_SLASH}]`, START_ANCHOR: `(?:^|[${WIN_SLASH}])`, END_ANCHOR: `(?:[${WIN_SLASH}]|$)` });\n/**\n * POSIX Bracket Regex\n */\nconst POSIX_REGEX_SOURCE = {\n    alnum: 'a-zA-Z0-9',\n    alpha: 'a-zA-Z',\n    ascii: '\\\\x00-\\\\x7F',\n    blank: ' \\\\t',\n    cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n    digit: '0-9',\n    graph: '\\\\x21-\\\\x7E',\n    lower: 'a-z',\n    print: '\\\\x20-\\\\x7E ',\n    punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n    space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n    upper: 'A-Z',\n    word: 'A-Za-z0-9_',\n    xdigit: 'A-Fa-f0-9'\n};\nvar constants$1 = {\n    MAX_LENGTH: 1024 * 64,\n    POSIX_REGEX_SOURCE,\n    // regular expressions\n    REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n    REGEX_NON_SPECIAL_CHAR: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n    REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n    REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n    // Replace globs with equivalent patterns to reduce parsing time.\n    REPLACEMENTS: {\n        '***': '*',\n        '**/**': '**',\n        '**/**/**': '**'\n    },\n    // Digits\n    CHAR_0: 48,\n    CHAR_9: 57,\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 65,\n    CHAR_LOWERCASE_A: 97,\n    CHAR_UPPERCASE_Z: 90,\n    CHAR_LOWERCASE_Z: 122,\n    CHAR_LEFT_PARENTHESES: 40,\n    CHAR_RIGHT_PARENTHESES: 41,\n    CHAR_ASTERISK: 42,\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: 38,\n    CHAR_AT: 64,\n    CHAR_BACKWARD_SLASH: 92,\n    CHAR_CARRIAGE_RETURN: 13,\n    CHAR_CIRCUMFLEX_ACCENT: 94,\n    CHAR_COLON: 58,\n    CHAR_COMMA: 44,\n    CHAR_DOT: 46,\n    CHAR_DOUBLE_QUOTE: 34,\n    CHAR_EQUAL: 61,\n    CHAR_EXCLAMATION_MARK: 33,\n    CHAR_FORM_FEED: 12,\n    CHAR_FORWARD_SLASH: 47,\n    CHAR_GRAVE_ACCENT: 96,\n    CHAR_HASH: 35,\n    CHAR_HYPHEN_MINUS: 45,\n    CHAR_LEFT_ANGLE_BRACKET: 60,\n    CHAR_LEFT_CURLY_BRACE: 123,\n    CHAR_LEFT_SQUARE_BRACKET: 91,\n    CHAR_LINE_FEED: 10,\n    CHAR_NO_BREAK_SPACE: 160,\n    CHAR_PERCENT: 37,\n    CHAR_PLUS: 43,\n    CHAR_QUESTION_MARK: 63,\n    CHAR_RIGHT_ANGLE_BRACKET: 62,\n    CHAR_RIGHT_CURLY_BRACE: 125,\n    CHAR_RIGHT_SQUARE_BRACKET: 93,\n    CHAR_SEMICOLON: 59,\n    CHAR_SINGLE_QUOTE: 39,\n    CHAR_SPACE: 32,\n    CHAR_TAB: 9,\n    CHAR_UNDERSCORE: 95,\n    CHAR_VERTICAL_LINE: 124,\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n    SEP: path.sep,\n    /**\n     * Create EXTGLOB_CHARS\n     */\n    extglobChars(chars) {\n        return {\n            '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n            '?': { type: 'qmark', open: '(?:', close: ')?' },\n            '+': { type: 'plus', open: '(?:', close: ')+' },\n            '*': { type: 'star', open: '(?:', close: ')*' },\n            '@': { type: 'at', open: '(?:', close: ')' }\n        };\n    },\n    /**\n     * Create GLOB_CHARS\n     */\n    globChars(win32) {\n        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n    }\n};\n\nvar utils$2 = createCommonjsModule(function (module, exports) {\n    const win32 = process.platform === 'win32';\n    const { REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL, REGEX_REMOVE_BACKSLASH } = constants$1;\n    exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n    exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n    exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n    exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n    exports.toPosixSlashes = str => str.replace(/\\\\/g, '/');\n    exports.removeBackslashes = str => {\n        return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n            return match === '\\\\' ? '' : match;\n        });\n    };\n    exports.supportsLookbehinds = () => {\n        let segs = process.version.slice(1).split('.');\n        if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {\n            return true;\n        }\n        return false;\n    };\n    exports.isWindows = options => {\n        if (options && typeof options.windows === 'boolean') {\n            return options.windows;\n        }\n        return win32 === true || path.sep === '\\\\';\n    };\n    exports.escapeLast = (input, char, lastIdx) => {\n        let idx = input.lastIndexOf(char, lastIdx);\n        if (idx === -1)\n            return input;\n        if (input[idx - 1] === '\\\\')\n            return exports.escapeLast(input, char, idx - 1);\n        return input.slice(0, idx) + '\\\\' + input.slice(idx);\n    };\n});\n\nconst { CHAR_ASTERISK, /* * */ CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH, /* \\ */ CHAR_COMMA: CHAR_COMMA$1, /* , */ CHAR_DOT: CHAR_DOT$1, /* . */ CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1, /* { */ CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1, /* ( */ CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1, /* [ */ CHAR_PLUS, /* + */ CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1, /* } */ CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1, /* ) */ CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1 /* ] */ } = constants$1;\nconst isPathSeparator = code => {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\nvar scan = (input, options) => {\n    let opts = options || {};\n    let length = input.length - 1;\n    let index = -1;\n    let start = 0;\n    let lastIndex = 0;\n    let isGlob = false;\n    let backslashes = false;\n    let negated = false;\n    let braces = 0;\n    let prev;\n    let code;\n    let braceEscaped = false;\n    let eos = () => index >= length;\n    let advance = () => {\n        prev = code;\n        return input.charCodeAt(++index);\n    };\n    while (index < length) {\n        code = advance();\n        let next;\n        if (code === CHAR_BACKWARD_SLASH) {\n            backslashes = true;\n            next = advance();\n            if (next === CHAR_LEFT_CURLY_BRACE$1) {\n                braceEscaped = true;\n            }\n            continue;\n        }\n        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {\n            braces++;\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_LEFT_CURLY_BRACE$1) {\n                    braces++;\n                    continue;\n                }\n                if (!braceEscaped && next === CHAR_DOT$1 && (next = advance()) === CHAR_DOT$1) {\n                    isGlob = true;\n                    break;\n                }\n                if (!braceEscaped && next === CHAR_COMMA$1) {\n                    isGlob = true;\n                    break;\n                }\n                if (next === CHAR_RIGHT_CURLY_BRACE$1) {\n                    braces--;\n                    if (braces === 0) {\n                        braceEscaped = false;\n                        break;\n                    }\n                }\n            }\n        }\n        if (code === CHAR_FORWARD_SLASH) {\n            if (prev === CHAR_DOT$1 && index === (start + 1)) {\n                start += 2;\n                continue;\n            }\n            lastIndex = index + 1;\n            continue;\n        }\n        if (code === CHAR_ASTERISK) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_LEFT_SQUARE_BRACKET$1) {\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n                    isGlob = true;\n                    break;\n                }\n            }\n        }\n        let isExtglobChar = code === CHAR_PLUS\n            || code === CHAR_AT\n            || code === CHAR_EXCLAMATION_MARK;\n        if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES$1) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n            negated = true;\n            start++;\n            continue;\n        }\n        if (code === CHAR_LEFT_PARENTHESES$1) {\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_PARENTHESES$1) {\n                    isGlob = true;\n                    break;\n                }\n            }\n        }\n        if (isGlob) {\n            break;\n        }\n    }\n    let prefix = '';\n    let orig = input;\n    let base = input;\n    let glob = '';\n    if (start > 0) {\n        prefix = input.slice(0, start);\n        input = input.slice(start);\n        lastIndex -= start;\n    }\n    if (base && isGlob === true && lastIndex > 0) {\n        base = input.slice(0, lastIndex);\n        glob = input.slice(lastIndex);\n    }\n    else if (isGlob === true) {\n        base = '';\n        glob = input;\n    }\n    else {\n        base = input;\n    }\n    if (base && base !== '' && base !== '/' && base !== input) {\n        if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n            base = base.slice(0, -1);\n        }\n    }\n    if (opts.unescape === true) {\n        if (glob)\n            glob = utils$2.removeBackslashes(glob);\n        if (base && backslashes === true) {\n            base = utils$2.removeBackslashes(base);\n        }\n    }\n    return { prefix, input: orig, base, glob, negated, isGlob };\n};\n\n/**\n * Constants\n */\nconst { MAX_LENGTH: MAX_LENGTH$1, POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1, REGEX_NON_SPECIAL_CHAR, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants$1;\n/**\n * Helpers\n */\nconst expandRange = (args, options) => {\n    if (typeof options.expandRange === 'function') {\n        return options.expandRange(...args, options);\n    }\n    args.sort();\n    let value = `[${args.join('-')}]`;\n    return value;\n};\nconst negate = state => {\n    let count = 1;\n    while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {\n        state.advance();\n        state.start++;\n        count++;\n    }\n    if (count % 2 === 0) {\n        return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n};\n/**\n * Create the message for a syntax error\n */\nconst syntaxError = (type, char) => {\n    return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\nconst parse$1 = (input, options) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    input = REPLACEMENTS[input] || input;\n    let opts = Object.assign({}, options);\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    let bos = { type: 'bos', value: '', output: opts.prepend || '' };\n    let tokens = [bos];\n    let capture = opts.capture ? '' : '?:';\n    let win32 = utils$2.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const PLATFORM_CHARS = constants$1.globChars(win32);\n    const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);\n    const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;\n    const globstar = (opts) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    let nodot = opts.dot ? '' : NO_DOT;\n    let star = opts.bash === true ? globstar(opts) : STAR;\n    let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    // minimatch options support\n    if (typeof opts.noext === 'boolean') {\n        opts.noextglob = opts.noext;\n    }\n    let state = {\n        index: -1,\n        start: 0,\n        consumed: '',\n        output: '',\n        backtrack: false,\n        brackets: 0,\n        braces: 0,\n        parens: 0,\n        quotes: 0,\n        tokens\n    };\n    let extglobs = [];\n    let stack = [];\n    let prev = bos;\n    let value;\n    /**\n     * Tokenizing helpers\n     */\n    const eos = () => state.index === len - 1;\n    const peek = state.peek = (n = 1) => input[state.index + n];\n    const advance = state.advance = () => input[++state.index];\n    const append = token => {\n        state.output += token.output != null ? token.output : token.value;\n        state.consumed += token.value || '';\n    };\n    const increment = type => {\n        state[type]++;\n        stack.push(type);\n    };\n    const decrement = type => {\n        state[type]--;\n        stack.pop();\n    };\n    /**\n     * Push tokens onto the tokens array. This helper speeds up\n     * tokenizing by 1) helping us avoid backtracking as much as possible,\n     * and 2) helping us avoid creating extra tokens when consecutive\n     * characters are plain text. This improves performance and simplifies\n     * lookbehinds.\n     */\n    const push = tok => {\n        if (prev.type === 'globstar') {\n            let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n            let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n            if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n                state.output = state.output.slice(0, -prev.output.length);\n                prev.type = 'star';\n                prev.value = '*';\n                prev.output = star;\n                state.output += prev.output;\n            }\n        }\n        if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n            extglobs[extglobs.length - 1].inner += tok.value;\n        }\n        if (tok.value || tok.output)\n            append(tok);\n        if (prev && prev.type === 'text' && tok.type === 'text') {\n            prev.value += tok.value;\n            return;\n        }\n        tok.prev = prev;\n        tokens.push(tok);\n        prev = tok;\n    };\n    const extglobOpen = (type, value) => {\n        let token = Object.assign(Object.assign({}, EXTGLOB_CHARS[value]), { conditions: 1, inner: '' });\n        token.prev = prev;\n        token.parens = state.parens;\n        token.output = state.output;\n        let output = (opts.capture ? '(' : '') + token.open;\n        push({ type, value, output: state.output ? '' : ONE_CHAR });\n        push({ type: 'paren', extglob: true, value: advance(), output });\n        increment('parens');\n        extglobs.push(token);\n    };\n    const extglobClose = token => {\n        let output = token.close + (opts.capture ? ')' : '');\n        if (token.type === 'negate') {\n            let extglobStar = star;\n            if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n                extglobStar = globstar(opts);\n            }\n            if (extglobStar !== star || eos() || /^\\)+$/.test(input.slice(state.index + 1))) {\n                output = token.close = ')$))' + extglobStar;\n            }\n            if (token.prev.type === 'bos' && eos()) {\n                state.negatedExtglob = true;\n            }\n        }\n        push({ type: 'paren', extglob: true, value, output });\n        decrement('parens');\n    };\n    if (opts.fastpaths !== false && !/(^[*!]|[/{[()\\]}\"])/.test(input)) {\n        let backslashes = false;\n        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n            if (first === '\\\\') {\n                backslashes = true;\n                return m;\n            }\n            if (first === '?') {\n                if (esc) {\n                    return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n                }\n                if (index === 0) {\n                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n                }\n                return QMARK.repeat(chars.length);\n            }\n            if (first === '.') {\n                return DOT_LITERAL.repeat(chars.length);\n            }\n            if (first === '*') {\n                if (esc) {\n                    return esc + first + (rest ? star : '');\n                }\n                return star;\n            }\n            return esc ? m : '\\\\' + m;\n        });\n        if (backslashes === true) {\n            if (opts.unescape === true) {\n                output = output.replace(/\\\\/g, '');\n            }\n            else {\n                output = output.replace(/\\\\+/g, m => {\n                    return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n                });\n            }\n        }\n        state.output = output;\n        return state;\n    }\n    /**\n     * Tokenize input until we reach end-of-string\n     */\n    while (!eos()) {\n        value = advance();\n        if (value === '\\u0000') {\n            continue;\n        }\n        /**\n         * Escaped characters\n         */\n        if (value === '\\\\') {\n            let next = peek();\n            if (next === '/' && opts.bash !== true) {\n                continue;\n            }\n            if (next === '.' || next === ';') {\n                continue;\n            }\n            if (!next) {\n                value += '\\\\';\n                push({ type: 'text', value });\n                continue;\n            }\n            // collapse slashes to reduce potential for exploits\n            let match = /^\\\\+/.exec(input.slice(state.index + 1));\n            let slashes = 0;\n            if (match && match[0].length > 2) {\n                slashes = match[0].length;\n                state.index += slashes;\n                if (slashes % 2 !== 0) {\n                    value += '\\\\';\n                }\n            }\n            if (opts.unescape === true) {\n                value = advance() || '';\n            }\n            else {\n                value += advance() || '';\n            }\n            if (state.brackets === 0) {\n                push({ type: 'text', value });\n                continue;\n            }\n        }\n        /**\n         * If we're inside a regex character class, continue\n         * until we reach the closing bracket.\n         */\n        if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n            if (opts.posix !== false && value === ':') {\n                let inner = prev.value.slice(1);\n                if (inner.includes('[')) {\n                    prev.posix = true;\n                    if (inner.includes(':')) {\n                        let idx = prev.value.lastIndexOf('[');\n                        let pre = prev.value.slice(0, idx);\n                        let rest = prev.value.slice(idx + 2);\n                        let posix = POSIX_REGEX_SOURCE$1[rest];\n                        if (posix) {\n                            prev.value = pre + posix;\n                            state.backtrack = true;\n                            advance();\n                            if (!bos.output && tokens.indexOf(prev) === 1) {\n                                bos.output = ONE_CHAR;\n                            }\n                            continue;\n                        }\n                    }\n                }\n            }\n            if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n                value = '\\\\' + value;\n            }\n            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n                value = '\\\\' + value;\n            }\n            if (opts.posix === true && value === '!' && prev.value === '[') {\n                value = '^';\n            }\n            prev.value += value;\n            append({ value });\n            continue;\n        }\n        /**\n         * If we're inside a quoted string, continue\n         * until we reach the closing double quote.\n         */\n        if (state.quotes === 1 && value !== '\"') {\n            value = utils$2.escapeRegex(value);\n            prev.value += value;\n            append({ value });\n            continue;\n        }\n        /**\n         * Double quotes\n         */\n        if (value === '\"') {\n            state.quotes = state.quotes === 1 ? 0 : 1;\n            if (opts.keepQuotes === true) {\n                push({ type: 'text', value });\n            }\n            continue;\n        }\n        /**\n         * Parentheses\n         */\n        if (value === '(') {\n            push({ type: 'paren', value });\n            increment('parens');\n            continue;\n        }\n        if (value === ')') {\n            if (state.parens === 0 && opts.strictBrackets === true) {\n                throw new SyntaxError(syntaxError('opening', '('));\n            }\n            let extglob = extglobs[extglobs.length - 1];\n            if (extglob && state.parens === extglob.parens + 1) {\n                extglobClose(extglobs.pop());\n                continue;\n            }\n            push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n            decrement('parens');\n            continue;\n        }\n        /**\n         * Brackets\n         */\n        if (value === '[') {\n            if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {\n                if (opts.nobracket !== true && opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError('closing', ']'));\n                }\n                value = '\\\\' + value;\n            }\n            else {\n                increment('brackets');\n            }\n            push({ type: 'bracket', value });\n            continue;\n        }\n        if (value === ']') {\n            if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            if (state.brackets === 0) {\n                if (opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError('opening', '['));\n                }\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            decrement('brackets');\n            let prevValue = prev.value.slice(1);\n            if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n                value = '/' + value;\n            }\n            prev.value += value;\n            append({ value });\n            // when literal brackets are explicitly disabled\n            // assume we should match with a regex character class\n            if (opts.literalBrackets === false || utils$2.hasRegexChars(prevValue)) {\n                continue;\n            }\n            let escaped = utils$2.escapeRegex(prev.value);\n            state.output = state.output.slice(0, -prev.value.length);\n            // when literal brackets are explicitly enabled\n            // assume we should escape the brackets to match literal characters\n            if (opts.literalBrackets === true) {\n                state.output += escaped;\n                prev.value = escaped;\n                continue;\n            }\n            // when the user specifies nothing, try to match both\n            prev.value = `(${capture}${escaped}|${prev.value})`;\n            state.output += prev.value;\n            continue;\n        }\n        /**\n         * Braces\n         */\n        if (value === '{' && opts.nobrace !== true) {\n            push({ type: 'brace', value, output: '(' });\n            increment('braces');\n            continue;\n        }\n        if (value === '}') {\n            if (opts.nobrace === true || state.braces === 0) {\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            let output = ')';\n            if (state.dots === true) {\n                let arr = tokens.slice();\n                let range = [];\n                for (let i = arr.length - 1; i >= 0; i--) {\n                    tokens.pop();\n                    if (arr[i].type === 'brace') {\n                        break;\n                    }\n                    if (arr[i].type !== 'dots') {\n                        range.unshift(arr[i].value);\n                    }\n                }\n                output = expandRange(range, opts);\n                state.backtrack = true;\n            }\n            push({ type: 'brace', value, output });\n            decrement('braces');\n            continue;\n        }\n        /**\n         * Pipes\n         */\n        if (value === '|') {\n            if (extglobs.length > 0) {\n                extglobs[extglobs.length - 1].conditions++;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Commas\n         */\n        if (value === ',') {\n            let output = value;\n            if (state.braces > 0 && stack[stack.length - 1] === 'braces') {\n                output = '|';\n            }\n            push({ type: 'comma', value, output });\n            continue;\n        }\n        /**\n         * Slashes\n         */\n        if (value === '/') {\n            // if the beginning of the glob is \"./\", advance the start\n            // to the current index, and don't add the \"./\" characters\n            // to the state. This greatly simplifies lookbehinds when\n            // checking for BOS characters like \"!\" and \".\" (not \"./\")\n            if (prev.type === 'dot' && state.index === 1) {\n                state.start = state.index + 1;\n                state.consumed = '';\n                state.output = '';\n                tokens.pop();\n                prev = bos; // reset \"prev\" to the first token\n                continue;\n            }\n            push({ type: 'slash', value, output: SLASH_LITERAL });\n            continue;\n        }\n        /**\n         * Dots\n         */\n        if (value === '.') {\n            if (state.braces > 0 && prev.type === 'dot') {\n                if (prev.value === '.')\n                    prev.output = DOT_LITERAL;\n                prev.type = 'dots';\n                prev.output += value;\n                prev.value += value;\n                state.dots = true;\n                continue;\n            }\n            push({ type: 'dot', value, output: DOT_LITERAL });\n            continue;\n        }\n        /**\n         * Question marks\n         */\n        if (value === '?') {\n            if (prev && prev.type === 'paren') {\n                let next = peek();\n                let output = value;\n                if (next === '<' && !utils$2.supportsLookbehinds()) {\n                    throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n                }\n                if (prev.value === '(' && !/[!=<:]/.test(next) || (next === '<' && !/[!=]/.test(peek(2)))) {\n                    output = '\\\\' + value;\n                }\n                push({ type: 'text', value, output });\n                continue;\n            }\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                extglobOpen('qmark', value);\n                continue;\n            }\n            if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n                push({ type: 'qmark', value, output: QMARK_NO_DOT });\n                continue;\n            }\n            push({ type: 'qmark', value, output: QMARK });\n            continue;\n        }\n        /**\n         * Exclamation\n         */\n        if (value === '!') {\n            if (opts.noextglob !== true && peek() === '(') {\n                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n                    extglobOpen('negate', value);\n                    continue;\n                }\n            }\n            if (opts.nonegate !== true && state.index === 0) {\n                negate(state);\n                continue;\n            }\n        }\n        /**\n         * Plus\n         */\n        if (value === '+') {\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                extglobOpen('plus', value);\n                continue;\n            }\n            if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {\n                let output = prev.extglob === true ? '\\\\' + value : value;\n                push({ type: 'plus', value, output });\n                continue;\n            }\n            // use regex behavior inside parens\n            if (state.parens > 0 && opts.regex !== false) {\n                push({ type: 'plus', value });\n                continue;\n            }\n            push({ type: 'plus', value: PLUS_LITERAL });\n            continue;\n        }\n        /**\n         * Plain text\n         */\n        if (value === '@') {\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                push({ type: 'at', value, output: '' });\n                continue;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Plain text\n         */\n        if (value !== '*') {\n            if (value === '$' || value === '^') {\n                value = '\\\\' + value;\n            }\n            let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));\n            if (match) {\n                value += match[0];\n                state.index += match[0].length;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Stars\n         */\n        if (prev && (prev.type === 'globstar' || prev.star === true)) {\n            prev.type = 'star';\n            prev.star = true;\n            prev.value += value;\n            prev.output = star;\n            state.backtrack = true;\n            state.consumed += value;\n            continue;\n        }\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n            extglobOpen('star', value);\n            continue;\n        }\n        if (prev.type === 'star') {\n            if (opts.noglobstar === true) {\n                state.consumed += value;\n                continue;\n            }\n            let prior = prev.prev;\n            let before = prior.prev;\n            let isStart = prior.type === 'slash' || prior.type === 'bos';\n            let afterStar = before && (before.type === 'star' || before.type === 'globstar');\n            if (opts.bash === true && (!isStart || (!eos() && peek() !== '/'))) {\n                push({ type: 'star', value, output: '' });\n                continue;\n            }\n            let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n            let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n                push({ type: 'star', value, output: '' });\n                continue;\n            }\n            // strip consecutive `/**/`\n            while (input.slice(state.index + 1, state.index + 4) === '/**') {\n                let after = input[state.index + 4];\n                if (after && after !== '/') {\n                    break;\n                }\n                state.consumed += '/**';\n                state.index += 3;\n            }\n            if (prior.type === 'bos' && eos()) {\n                prev.type = 'globstar';\n                prev.value += value;\n                prev.output = globstar(opts);\n                state.output = prev.output;\n                state.consumed += value;\n                continue;\n            }\n            if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = '(?:' + prior.output;\n                prev.type = 'globstar';\n                prev.output = globstar(opts) + '|$)';\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.consumed += value;\n                continue;\n            }\n            let next = peek();\n            if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {\n                let end = peek(2) !== void 0 ? '|$' : '';\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = '(?:' + prior.output;\n                prev.type = 'globstar';\n                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.consumed += value + advance();\n                push({ type: 'slash', value, output: '' });\n                continue;\n            }\n            if (prior.type === 'bos' && next === '/') {\n                prev.type = 'globstar';\n                prev.value += value;\n                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n                state.output = prev.output;\n                state.consumed += value + advance();\n                push({ type: 'slash', value, output: '' });\n                continue;\n            }\n            // remove single star from output\n            state.output = state.output.slice(0, -prev.output.length);\n            // reset previous token to globstar\n            prev.type = 'globstar';\n            prev.output = globstar(opts);\n            prev.value += value;\n            // reset output with globstar\n            state.output += prev.output;\n            state.consumed += value;\n            continue;\n        }\n        let token = { type: 'star', value, output: star };\n        if (opts.bash === true) {\n            token.output = '.*?';\n            if (prev.type === 'bos' || prev.type === 'slash') {\n                token.output = nodot + token.output;\n            }\n            push(token);\n            continue;\n        }\n        if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n            token.output = value;\n            push(token);\n            continue;\n        }\n        if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n            if (prev.type === 'dot') {\n                state.output += NO_DOT_SLASH;\n                prev.output += NO_DOT_SLASH;\n            }\n            else if (opts.dot === true) {\n                state.output += NO_DOTS_SLASH;\n                prev.output += NO_DOTS_SLASH;\n            }\n            else {\n                state.output += nodot;\n                prev.output += nodot;\n            }\n            if (peek() !== '*') {\n                state.output += ONE_CHAR;\n                prev.output += ONE_CHAR;\n            }\n        }\n        push(token);\n    }\n    while (state.brackets > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', ']'));\n        state.output = utils$2.escapeLast(state.output, '[');\n        decrement('brackets');\n    }\n    while (state.parens > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', ')'));\n        state.output = utils$2.escapeLast(state.output, '(');\n        decrement('parens');\n    }\n    while (state.braces > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', '}'));\n        state.output = utils$2.escapeLast(state.output, '{');\n        decrement('braces');\n    }\n    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n        push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n    }\n    // rebuild the output if we had to backtrack at any point\n    if (state.backtrack === true) {\n        state.output = '';\n        for (let token of state.tokens) {\n            state.output += token.output != null ? token.output : token.value;\n            if (token.suffix) {\n                state.output += token.suffix;\n            }\n        }\n    }\n    return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\nparse$1.fastpaths = (input, options) => {\n    let opts = Object.assign({}, options);\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    input = REPLACEMENTS[input] || input;\n    let win32 = utils$2.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants$1.globChars(win32);\n    let capture = opts.capture ? '' : '?:';\n    let star = opts.bash === true ? '.*?' : STAR;\n    let nodot = opts.dot ? NO_DOTS : NO_DOT;\n    let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    const globstar = (opts) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const create = str => {\n        switch (str) {\n            case '*':\n                return `${nodot}${ONE_CHAR}${star}`;\n            case '.*':\n                return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '*.*':\n                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '*/*':\n                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n            case '**':\n                return nodot + globstar(opts);\n            case '**/*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n            case '**/*.*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '**/.*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n            default: {\n                let match = /^(.*?)\\.(\\w+)$/.exec(str);\n                if (!match)\n                    return;\n                let source = create(match[1]);\n                if (!source)\n                    return;\n                return source + DOT_LITERAL + match[2];\n            }\n        }\n    };\n    let output = create(input);\n    if (output && opts.strictSlashes !== true) {\n        output += `${SLASH_LITERAL}?`;\n    }\n    return output;\n};\nvar parse_1$1 = parse$1;\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\nconst picomatch = (glob, options, returnState = false) => {\n    if (Array.isArray(glob)) {\n        let fns = glob.map(input => picomatch(input, options, returnState));\n        return str => {\n            for (let isMatch of fns) {\n                let state = isMatch(str);\n                if (state)\n                    return state;\n            }\n            return false;\n        };\n    }\n    if (typeof glob !== 'string' || glob === '') {\n        throw new TypeError('Expected pattern to be a non-empty string');\n    }\n    let opts = options || {};\n    let posix = utils$2.isWindows(options);\n    let regex = picomatch.makeRe(glob, options, false, true);\n    let state = regex.state;\n    delete regex.state;\n    let isIgnored = () => false;\n    if (opts.ignore) {\n        let ignoreOpts = Object.assign(Object.assign({}, options), { ignore: null, onMatch: null, onResult: null });\n        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n    }\n    const matcher = (input, returnObject = false) => {\n        let { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n        let result = { glob, state, regex, posix, input, output, match, isMatch };\n        if (typeof opts.onResult === 'function') {\n            opts.onResult(result);\n        }\n        if (isMatch === false) {\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (isIgnored(input)) {\n            if (typeof opts.onIgnore === 'function') {\n                opts.onIgnore(result);\n            }\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (typeof opts.onMatch === 'function') {\n            opts.onMatch(result);\n        }\n        return returnObject ? result : true;\n    };\n    if (returnState) {\n        matcher.state = state;\n    }\n    return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected input to be a string');\n    }\n    if (input === '') {\n        return { isMatch: false, output: '' };\n    }\n    let opts = options || {};\n    let format = opts.format || (posix ? utils$2.toPosixSlashes : null);\n    let match = input === glob;\n    let output = (match && format) ? format(input) : input;\n    if (match === false) {\n        output = format ? format(input) : input;\n        match = output === glob;\n    }\n    if (match === false || opts.capture === true) {\n        if (opts.matchBase === true || opts.basename === true) {\n            match = picomatch.matchBase(input, regex, options, posix);\n        }\n        else {\n            match = regex.exec(output);\n        }\n    }\n    return { isMatch: !!match, match, output };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\npicomatch.matchBase = (input, glob, options, posix = utils$2.isWindows(options)) => {\n    let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n    return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\npicomatch.parse = (glob, options) => parse_1$1(glob, options);\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\npicomatch.scan = (input, options) => scan(input, options);\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n    if (!input || typeof input !== 'string') {\n        throw new TypeError('Expected a non-empty string');\n    }\n    let opts = options || {};\n    let prepend = opts.contains ? '' : '^';\n    let append = opts.contains ? '' : '$';\n    let state = { negated: false, fastpaths: true };\n    let prefix = '';\n    let output;\n    if (input.startsWith('./')) {\n        input = input.slice(2);\n        prefix = state.prefix = './';\n    }\n    if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n        output = parse_1$1.fastpaths(input, options);\n    }\n    if (output === void 0) {\n        state = picomatch.parse(input, options);\n        state.prefix = prefix + (state.prefix || '');\n        output = state.output;\n    }\n    if (returnOutput === true) {\n        return output;\n    }\n    let source = `${prepend}(?:${output})${append}`;\n    if (state && state.negated === true) {\n        source = `^(?!${source}).*$`;\n    }\n    let regex = picomatch.toRegex(source, options);\n    if (returnState === true) {\n        regex.state = state;\n    }\n    return regex;\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\npicomatch.toRegex = (source, options) => {\n    try {\n        let opts = options || {};\n        return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n    }\n    catch (err) {\n        if (options && options.debug === true)\n            throw err;\n        return /$^/;\n    }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\npicomatch.constants = constants$1;\n/**\n * Expose \"picomatch\"\n */\nvar picomatch_1 = picomatch;\n\nvar picomatch$1 = picomatch_1;\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\nconst micromatch = (list, patterns, options) => {\n    patterns = [].concat(patterns);\n    list = [].concat(list);\n    let omit = new Set();\n    let keep = new Set();\n    let items = new Set();\n    let negatives = 0;\n    let onResult = state => {\n        items.add(state.output);\n        if (options && options.onResult) {\n            options.onResult(state);\n        }\n    };\n    for (let i = 0; i < patterns.length; i++) {\n        let isMatch = picomatch$1(String(patterns[i]), Object.assign(Object.assign({}, options), { onResult }), true);\n        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n        if (negated)\n            negatives++;\n        for (let item of list) {\n            let matched = isMatch(item, true);\n            let match = negated ? !matched.isMatch : matched.isMatch;\n            if (!match)\n                continue;\n            if (negated) {\n                omit.add(matched.output);\n            }\n            else {\n                omit.delete(matched.output);\n                keep.add(matched.output);\n            }\n        }\n    }\n    let result = negatives === patterns.length ? [...items] : [...keep];\n    let matches = result.filter(item => !omit.has(item));\n    if (options && matches.length === 0) {\n        if (options.failglob === true) {\n            throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n        }\n        if (options.nonull === true || options.nullglob === true) {\n            return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n        }\n    }\n    return matches;\n};\n/**\n * Backwards compatibility\n */\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\nmicromatch.matcher = (pattern, options) => picomatch$1(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);\n/**\n * Backwards compatibility\n */\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\nmicromatch.not = (list, patterns, options = {}) => {\n    patterns = [].concat(patterns).map(String);\n    let result = new Set();\n    let items = [];\n    let onResult = state => {\n        if (options.onResult)\n            options.onResult(state);\n        items.push(state.output);\n    };\n    let matches = micromatch(list, patterns, Object.assign(Object.assign({}, options), { onResult }));\n    for (let item of items) {\n        if (!matches.includes(item)) {\n            result.add(item);\n        }\n    }\n    return [...result];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\nmicromatch.contains = (str, pattern, options) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    if (Array.isArray(pattern)) {\n        return pattern.some(p => micromatch.contains(str, p, options));\n    }\n    if (typeof pattern === 'string') {\n        if (isEmptyString(str) || isEmptyString(pattern)) {\n            return false;\n        }\n        if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n            return true;\n        }\n    }\n    return micromatch.isMatch(str, pattern, Object.assign(Object.assign({}, options), { contains: true }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\nmicromatch.matchKeys = (obj, patterns, options) => {\n    if (!utils$2.isObject(obj)) {\n        throw new TypeError('Expected the first argument to be an object');\n    }\n    let keys = micromatch(Object.keys(obj), patterns, options);\n    let res = {};\n    for (let key of keys)\n        res[key] = obj[key];\n    return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.some = (list, patterns, options) => {\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch$1(String(pattern), options);\n        if (items.some(item => isMatch(item))) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.every = (list, patterns, options) => {\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch$1(String(pattern), options);\n        if (!items.every(item => isMatch(item))) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.all = (str, patterns, options) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    return [].concat(patterns).every(p => picomatch$1(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\nmicromatch.capture = (glob, input, options) => {\n    let posix = utils$2.isWindows(options);\n    let regex = picomatch$1.makeRe(String(glob), Object.assign(Object.assign({}, options), { capture: true }));\n    let match = regex.exec(posix ? utils$2.toPosixSlashes(input) : input);\n    if (match) {\n        return match.slice(1).map(v => v === void 0 ? '' : v);\n    }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\nmicromatch.makeRe = (...args) => picomatch$1.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\nmicromatch.scan = (...args) => picomatch$1.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\nmicromatch.parse = (patterns, options) => {\n    let res = [];\n    for (let pattern of [].concat(patterns || [])) {\n        for (let str of braces_1(String(pattern), options)) {\n            res.push(picomatch$1.parse(str, options));\n        }\n    }\n    return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\nmicromatch.braces = (pattern, options) => {\n    if (typeof pattern !== 'string')\n        throw new TypeError('Expected a string');\n    if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n        return [pattern];\n    }\n    return braces_1(pattern, options);\n};\n/**\n * Expand braces\n */\nmicromatch.braceExpand = (pattern, options) => {\n    if (typeof pattern !== 'string')\n        throw new TypeError('Expected a string');\n    return micromatch.braces(pattern, Object.assign(Object.assign({}, options), { expand: true }));\n};\n/**\n * Expose micromatch\n */\nvar micromatch_1 = micromatch;\n\nfunction ensureArray$1(thing) {\n    if (Array.isArray(thing))\n        return thing;\n    if (thing == undefined)\n        return [];\n    return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false) {\n        return id;\n    }\n    return resolve(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => {\n        return id instanceof RegExp\n            ? id\n            : {\n                test: micromatch_1.matcher(getMatcherString(id, resolutionBase)\n                    .split(sep)\n                    .join('/'), { dot: true })\n            };\n    };\n    const includeMatchers = ensureArray$1(include).map(getMatcher);\n    const excludeMatchers = ensureArray$1(exclude).map(getMatcher);\n    return function (id) {\n        if (typeof id !== 'string')\n            return false;\n        if (/\\0/.test(id))\n            return false;\n        id = id.split(sep).join('/');\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(id))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(id))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nvar modules = {};\nvar getModule = function (dir) {\n    var rootPath = dir ? path.resolve(dir) : process.cwd();\n    var rootName = path.join(rootPath, '@root');\n    var root = modules[rootName];\n    if (!root) {\n        root = new module(rootName);\n        root.filename = rootName;\n        root.paths = module._nodeModulePaths(rootPath);\n        modules[rootName] = root;\n    }\n    return root;\n};\nvar requireRelative = function (requested, relativeTo) {\n    var root = getModule(relativeTo);\n    return root.require(requested);\n};\nrequireRelative.resolve = function (requested, relativeTo) {\n    var root = getModule(relativeTo);\n    return module._resolveFilename(requested, root);\n};\nvar requireRelative_1 = requireRelative;\n\nlet chokidar;\ntry {\n    chokidar = requireRelative_1('chokidar', process.cwd());\n}\ncatch (err) {\n    chokidar = null;\n}\nvar chokidar$1 = chokidar;\n\nconst opts = { encoding: 'utf-8', persistent: true };\nconst watchers = new Map();\nfunction addTask(id, task, chokidarOptions, chokidarOptionsHash, isTransformDependency) {\n    if (!watchers.has(chokidarOptionsHash))\n        watchers.set(chokidarOptionsHash, new Map());\n    const group = watchers.get(chokidarOptionsHash);\n    const watcher = group.get(id) || new FileWatcher(id, chokidarOptions, group);\n    if (!watcher.fsWatcher) {\n        if (isTransformDependency)\n            throw new Error(`Transform dependency ${id} does not exist.`);\n    }\n    else {\n        watcher.addTask(task, isTransformDependency);\n    }\n}\nfunction deleteTask(id, target, chokidarOptionsHash) {\n    const group = watchers.get(chokidarOptionsHash);\n    const watcher = group.get(id);\n    if (watcher)\n        watcher.deleteTask(target, group);\n}\nclass FileWatcher {\n    constructor(id, chokidarOptions, group) {\n        this.id = id;\n        this.tasks = new Set();\n        this.transformDependencyTasks = new Set();\n        let modifiedTime;\n        try {\n            const stats = statSync(id);\n            modifiedTime = +stats.mtime;\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                // can't watch files that don't exist (e.g. injected\n                // by plugins somehow)\n                return;\n            }\n            throw err;\n        }\n        const handleWatchEvent = (event) => {\n            if (event === 'rename' || event === 'unlink') {\n                this.close();\n                group.delete(id);\n                this.trigger(id);\n                return;\n            }\n            else {\n                let stats;\n                try {\n                    stats = statSync(id);\n                }\n                catch (err) {\n                    if (err.code === 'ENOENT') {\n                        modifiedTime = -1;\n                        this.trigger(id);\n                        return;\n                    }\n                    throw err;\n                }\n                // debounce\n                if (+stats.mtime - modifiedTime > 15)\n                    this.trigger(id);\n            }\n        };\n        this.fsWatcher = chokidarOptions\n            ? chokidar$1.watch(id, chokidarOptions).on('all', handleWatchEvent)\n            : watch$1(id, opts, handleWatchEvent);\n        group.set(id, this);\n    }\n    addTask(task, isTransformDependency) {\n        if (isTransformDependency)\n            this.transformDependencyTasks.add(task);\n        else\n            this.tasks.add(task);\n    }\n    close() {\n        if (this.fsWatcher)\n            this.fsWatcher.close();\n    }\n    deleteTask(task, group) {\n        let deleted = this.tasks.delete(task);\n        deleted = this.transformDependencyTasks.delete(task) || deleted;\n        if (deleted && this.tasks.size === 0 && this.transformDependencyTasks.size === 0) {\n            group.delete(this.id);\n            this.close();\n        }\n    }\n    trigger(id) {\n        for (const task of this.tasks) {\n            task.invalidate(id, false);\n        }\n        for (const task of this.transformDependencyTasks) {\n            task.invalidate(id, true);\n        }\n    }\n}\n\nconst DELAY = 200;\nclass Watcher {\n    constructor(configs) {\n        this.buildTimeout = null;\n        this.invalidatedIds = new Set();\n        this.rerun = false;\n        this.emitter = new (class extends EventEmitter {\n            constructor(close) {\n                super();\n                this.close = close;\n                // Allows more than 10 bundles to be watched without\n                // showing the `MaxListenersExceededWarning` to the user.\n                this.setMaxListeners(Infinity);\n            }\n        })(this.close.bind(this));\n        this.tasks = (Array.isArray(configs) ? configs : configs ? [configs] : []).map(config => new Task(this, config));\n        this.running = true;\n        process.nextTick(() => this.run());\n    }\n    close() {\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        this.emitter.removeAllListeners();\n    }\n    emit(event, value) {\n        this.emitter.emit(event, value);\n    }\n    invalidate(id) {\n        if (id) {\n            this.invalidatedIds.add(id);\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(() => {\n            this.buildTimeout = null;\n            for (const id of this.invalidatedIds) {\n                this.emit('change', id);\n            }\n            this.invalidatedIds.clear();\n            this.emit('restart');\n            this.run();\n        }, DELAY);\n    }\n    run() {\n        this.running = true;\n        this.emit('event', {\n            code: 'START'\n        });\n        let taskPromise = Promise.resolve();\n        for (const task of this.tasks)\n            taskPromise = taskPromise.then(() => task.run());\n        return taskPromise\n            .then(() => {\n            this.running = false;\n            this.emit('event', {\n                code: 'END'\n            });\n        })\n            .catch(error => {\n            this.running = false;\n            this.emit('event', {\n                code: 'ERROR',\n                error\n            });\n        })\n            .then(() => {\n            if (this.rerun) {\n                this.rerun = false;\n                this.invalidate();\n            }\n        });\n    }\n}\nclass Task {\n    constructor(watcher, config) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.invalidated = true;\n        this.watcher = watcher;\n        this.closed = false;\n        this.watched = new Set();\n        const { inputOptions, outputOptions } = mergeOptions({\n            config\n        });\n        this.inputOptions = inputOptions;\n        this.outputs = outputOptions;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return path.resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = inputOptions.watch || {};\n        if ('useChokidar' in watchOptions)\n            watchOptions.chokidar = watchOptions.useChokidar;\n        let chokidarOptions = 'chokidar' in watchOptions ? watchOptions.chokidar : !!chokidar$1;\n        if (chokidarOptions) {\n            chokidarOptions = Object.assign(Object.assign({}, (chokidarOptions === true ? {} : chokidarOptions)), { disableGlobbing: true, ignoreInitial: true });\n        }\n        if (chokidarOptions && !chokidar$1) {\n            throw new Error(`watch.chokidar was provided, but chokidar could not be found. Have you installed it?`);\n        }\n        this.chokidarOptions = chokidarOptions;\n        this.chokidarOptionsHash = JSON.stringify(chokidarOptions);\n        this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n    }\n    close() {\n        this.closed = true;\n        for (const id of this.watched) {\n            deleteTask(id, this, this.chokidarOptionsHash);\n        }\n    }\n    invalidate(id, isTransformDependency) {\n        this.invalidated = true;\n        if (isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (module.transformDependencies.indexOf(id) === -1)\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate(id);\n    }\n    run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = Object.assign(Object.assign({}, this.inputOptions), { cache: this.cache });\n        const start = Date.now();\n        this.watcher.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.inputOptions.input,\n            output: this.outputFiles\n        });\n        setWatcher(this.watcher.emitter);\n        return rollup(options)\n            .then(result => {\n            if (this.closed)\n                return undefined;\n            this.updateWatchedFiles(result);\n            return Promise.all(this.outputs.map(output => result.write(output))).then(() => result);\n        })\n            .then((result) => {\n            this.watcher.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.inputOptions.input,\n                output: this.outputFiles,\n                result\n            });\n        })\n            .catch((error) => {\n            if (this.closed)\n                return;\n            if (Array.isArray(error.watchFiles)) {\n                for (const id of error.watchFiles) {\n                    this.watchFile(id);\n                }\n            }\n            if (error.id) {\n                this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n            }\n            throw error;\n        });\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id))\n                deleteTask(id, this, this.chokidarOptionsHash);\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.some(file => file === id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        addTask(id, this, this.chokidarOptions, this.chokidarOptionsHash, isTransformDependency);\n    }\n}\nfunction watch(configs) {\n    return new Watcher(configs).emitter;\n}\n\nexport { version as VERSION, rollup, watch };\n"]},"metadata":{},"sourceType":"module"}