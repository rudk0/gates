{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar Assert = require('./assert');\n\nvar DeepEqual = require('./deepEqual');\n\nvar EscapeRegex = require('./escapeRegex');\n\nvar Utils = require('./utils');\n\nvar internals = {};\n\nmodule.exports = function (ref, values) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // options: { deep, once, only, part, symbols }\n\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  if (typeof values !== 'object') {\n    values = [values];\n  }\n\n  Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty'); // String\n\n  if (typeof ref === 'string') {\n    return internals.string(ref, values, options);\n  } // Array\n\n\n  if (Array.isArray(ref)) {\n    return internals.array(ref, values, options);\n  } // Object\n\n\n  Assert(typeof ref === 'object', 'Reference must be string or an object');\n  return internals.object(ref, values, options);\n};\n\ninternals.array = function (ref, values, options) {\n  if (!Array.isArray(values)) {\n    values = [values];\n  }\n\n  if (!ref.length) {\n    return false;\n  }\n\n  if (options.only && options.once && ref.length !== values.length) {\n    return false;\n  }\n\n  var compare; // Map values\n\n  var map = new Map();\n\n  var _iterator = _createForOfIteratorHelper(values),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n\n      if (!options.deep || !value || typeof value !== 'object') {\n        var existing = map.get(value);\n\n        if (existing) {\n          ++existing.allowed;\n        } else {\n          map.set(value, {\n            allowed: 1,\n            hits: 0\n          });\n        }\n      } else {\n        compare = compare || internals.compare(options);\n        var found = false;\n\n        var _iterator4 = _createForOfIteratorHelper(map.entries()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                key = _step4$value[0],\n                _existing = _step4$value[1];\n\n            if (compare(key, value)) {\n              ++_existing.allowed;\n              found = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        if (!found) {\n          map.set(value, {\n            allowed: 1,\n            hits: 0\n          });\n        }\n      }\n    } // Lookup values\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var hits = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(ref),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      var match = void 0;\n\n      if (!options.deep || !item || typeof item !== 'object') {\n        match = map.get(item);\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(map.entries()),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _step5$value = _slicedToArray(_step5.value, 2),\n                _key = _step5$value[0],\n                _existing2 = _step5$value[1];\n\n            if (compare(_key, item)) {\n              match = _existing2;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      if (match) {\n        ++match.hits;\n        ++hits;\n\n        if (options.once && match.hits > match.allowed) {\n          return false;\n        }\n      }\n    } // Validate results\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (options.only && hits !== ref.length) {\n    return false;\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(map.values()),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _match = _step3.value;\n\n      if (_match.hits === _match.allowed) {\n        continue;\n      }\n\n      if (_match.hits < _match.allowed && !options.part) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return !!hits;\n};\n\ninternals.object = function (ref, values, options) {\n  Assert(options.once === undefined, 'Cannot use option once with object');\n  var keys = Utils.keys(ref, options);\n\n  if (!keys.length) {\n    return false;\n  } // Keys list\n\n\n  if (Array.isArray(values)) {\n    return internals.array(keys, values, options);\n  } // Key value pairs\n\n\n  var symbols = Object.getOwnPropertySymbols(values).filter(function (sym) {\n    return values.propertyIsEnumerable(sym);\n  });\n  var targets = [].concat(_toConsumableArray(Object.keys(values)), _toConsumableArray(symbols));\n  var compare = internals.compare(options);\n  var set = new Set(targets);\n\n  var _iterator6 = _createForOfIteratorHelper(keys),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var key = _step6.value;\n\n      if (!set.has(key)) {\n        if (options.only) {\n          return false;\n        }\n\n        continue;\n      }\n\n      if (!compare(values[key], ref[key])) {\n        return false;\n      }\n\n      set.delete(key);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  if (set.size) {\n    return options.part ? set.size < targets.length : false;\n  }\n\n  return true;\n};\n\ninternals.string = function (ref, values, options) {\n  // Empty string\n  if (ref === '') {\n    return values.length === 1 && values[0] === '' || // '' contains ''\n    !options.once && !values.some(function (v) {\n      return v !== '';\n    }); // '' contains multiple '' if !once\n  } // Map values\n\n\n  var map = new Map();\n  var patterns = [];\n\n  var _iterator7 = _createForOfIteratorHelper(values),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var value = _step7.value;\n      Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n\n      if (value) {\n        var existing = map.get(value);\n\n        if (existing) {\n          ++existing.allowed;\n        } else {\n          map.set(value, {\n            allowed: 1,\n            hits: 0\n          });\n          patterns.push(EscapeRegex(value));\n        }\n      } else if (options.once || options.only) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  if (!patterns.length) {\n    // Non-empty string contains unlimited empty string\n    return true;\n  } // Match patterns\n\n\n  var regex = new RegExp(\"(\".concat(patterns.join('|'), \")\"), 'g');\n  var leftovers = ref.replace(regex, function ($0, $1) {\n    ++map.get($1).hits;\n    return ''; // Remove from string\n  }); // Validate results\n\n  if (options.only && leftovers) {\n    return false;\n  }\n\n  var any = false;\n\n  var _iterator8 = _createForOfIteratorHelper(map.values()),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var match = _step8.value;\n\n      if (match.hits) {\n        any = true;\n      }\n\n      if (match.hits === match.allowed) {\n        continue;\n      }\n\n      if (match.hits < match.allowed && !options.part) {\n        return false;\n      } // match.hits > match.allowed\n\n\n      if (options.once) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return !!any;\n};\n\ninternals.compare = function (options) {\n  if (!options.deep) {\n    return internals.shallow;\n  }\n\n  var hasOnly = options.only !== undefined;\n  var hasPart = options.part !== undefined;\n  var flags = {\n    prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n    part: hasOnly ? !options.only : hasPart ? options.part : false\n  };\n  return function (a, b) {\n    return DeepEqual(a, b, flags);\n  };\n};\n\ninternals.shallow = function (a, b) {\n  return a === b;\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/hoek/lib/contain.js"],"names":["Assert","require","DeepEqual","EscapeRegex","Utils","internals","module","exports","ref","values","options","Array","isArray","length","string","array","object","only","once","compare","map","Map","value","deep","existing","get","allowed","set","hits","found","entries","key","item","match","part","undefined","keys","symbols","Object","getOwnPropertySymbols","filter","sym","propertyIsEnumerable","targets","Set","has","delete","size","some","v","patterns","push","regex","RegExp","join","leftovers","replace","$0","$1","any","shallow","hasOnly","hasPart","flags","prototype","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('./assert');\nconst DeepEqual = require('./deepEqual');\nconst EscapeRegex = require('./escapeRegex');\nconst Utils = require('./utils');\n\n\nconst internals = {};\n\n\nmodule.exports = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    if (typeof values !== 'object') {\n        values = [values];\n    }\n\n    Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty');\n\n    // String\n\n    if (typeof ref === 'string') {\n        return internals.string(ref, values, options);\n    }\n\n    // Array\n\n    if (Array.isArray(ref)) {\n        return internals.array(ref, values, options);\n    }\n\n    // Object\n\n    Assert(typeof ref === 'object', 'Reference must be string or an object');\n    return internals.object(ref, values, options);\n};\n\n\ninternals.array = function (ref, values, options) {\n\n    if (!Array.isArray(values)) {\n        values = [values];\n    }\n\n    if (!ref.length) {\n        return false;\n    }\n\n    if (options.only &&\n        options.once &&\n        ref.length !== values.length) {\n\n        return false;\n    }\n\n    let compare;\n\n    // Map values\n\n    const map = new Map();\n    for (const value of values) {\n        if (!options.deep ||\n            !value ||\n            typeof value !== 'object') {\n\n            const existing = map.get(value);\n            if (existing) {\n                ++existing.allowed;\n            }\n            else {\n                map.set(value, { allowed: 1, hits: 0 });\n            }\n        }\n        else {\n            compare = compare || internals.compare(options);\n\n            let found = false;\n            for (const [key, existing] of map.entries()) {\n                if (compare(key, value)) {\n                    ++existing.allowed;\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                map.set(value, { allowed: 1, hits: 0 });\n            }\n        }\n    }\n\n    // Lookup values\n\n    let hits = 0;\n    for (const item of ref) {\n        let match;\n        if (!options.deep ||\n            !item ||\n            typeof item !== 'object') {\n\n            match = map.get(item);\n        }\n        else {\n            for (const [key, existing] of map.entries()) {\n                if (compare(key, item)) {\n                    match = existing;\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            ++match.hits;\n            ++hits;\n\n            if (options.once &&\n                match.hits > match.allowed) {\n\n                return false;\n            }\n        }\n    }\n\n    // Validate results\n\n    if (options.only &&\n        hits !== ref.length) {\n\n        return false;\n    }\n\n    for (const match of map.values()) {\n        if (match.hits === match.allowed) {\n            continue;\n        }\n\n        if (match.hits < match.allowed &&\n            !options.part) {\n\n            return false;\n        }\n    }\n\n    return !!hits;\n};\n\n\ninternals.object = function (ref, values, options) {\n\n    Assert(options.once === undefined, 'Cannot use option once with object');\n\n    const keys = Utils.keys(ref, options);\n    if (!keys.length) {\n        return false;\n    }\n\n    // Keys list\n\n    if (Array.isArray(values)) {\n        return internals.array(keys, values, options);\n    }\n\n    // Key value pairs\n\n    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));\n    const targets = [...Object.keys(values), ...symbols];\n\n    const compare = internals.compare(options);\n    const set = new Set(targets);\n\n    for (const key of keys) {\n        if (!set.has(key)) {\n            if (options.only) {\n                return false;\n            }\n\n            continue;\n        }\n\n        if (!compare(values[key], ref[key])) {\n            return false;\n        }\n\n        set.delete(key);\n    }\n\n    if (set.size) {\n        return options.part ? set.size < targets.length : false;\n    }\n\n    return true;\n};\n\n\ninternals.string = function (ref, values, options) {\n\n    // Empty string\n\n    if (ref === '') {\n        return values.length === 1 && values[0] === '' ||               // '' contains ''\n            !options.once && !values.some((v) => v !== '');             // '' contains multiple '' if !once\n    }\n\n    // Map values\n\n    const map = new Map();\n    const patterns = [];\n\n    for (const value of values) {\n        Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n\n        if (value) {\n            const existing = map.get(value);\n            if (existing) {\n                ++existing.allowed;\n            }\n            else {\n                map.set(value, { allowed: 1, hits: 0 });\n                patterns.push(EscapeRegex(value));\n            }\n        }\n        else if (options.once ||\n            options.only) {\n\n            return false;\n        }\n    }\n\n    if (!patterns.length) {                     // Non-empty string contains unlimited empty string\n        return true;\n    }\n\n    // Match patterns\n\n    const regex = new RegExp(`(${patterns.join('|')})`, 'g');\n    const leftovers = ref.replace(regex, ($0, $1) => {\n\n        ++map.get($1).hits;\n        return '';                              // Remove from string\n    });\n\n    // Validate results\n\n    if (options.only &&\n        leftovers) {\n\n        return false;\n    }\n\n    let any = false;\n    for (const match of map.values()) {\n        if (match.hits) {\n            any = true;\n        }\n\n        if (match.hits === match.allowed) {\n            continue;\n        }\n\n        if (match.hits < match.allowed &&\n            !options.part) {\n\n            return false;\n        }\n\n        // match.hits > match.allowed\n\n        if (options.once) {\n            return false;\n        }\n    }\n\n    return !!any;\n};\n\n\ninternals.compare = function (options) {\n\n    if (!options.deep) {\n        return internals.shallow;\n    }\n\n    const hasOnly = options.only !== undefined;\n    const hasPart = options.part !== undefined;\n\n    const flags = {\n        prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n        part: hasOnly ? !options.only : hasPart ? options.part : false\n    };\n\n    return (a, b) => DeepEqual(a, b, flags);\n};\n\n\ninternals.shallow = function (a, b) {\n\n    return a === b;\n};\n"]},"metadata":{},"sourceType":"script"}