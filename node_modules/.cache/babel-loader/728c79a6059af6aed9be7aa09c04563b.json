{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperHoistVariables = _interopRequireDefault(require(\"@babel/helper-hoist-variables\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst buildTemplate = (0, _core.template)(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n`);\nconst buildExportAll = (0, _core.template)(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\n\nfunction constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {\n  const statements = [];\n\n  if (exportNames.length === 1) {\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));\n  } else if (!exportStarTarget) {\n    const objectProperties = [];\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      objectProperties.push(_core.types.objectProperty(_core.types.identifier(exportName), exportValue));\n    }\n\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n    statements.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));\n    statements.push(buildExportAll({\n      KEY: path.scope.generateUidIdentifier(\"key\"),\n      EXPORT_OBJ: _core.types.identifier(exportObj),\n      TARGET: exportStarTarget\n    }));\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));\n    }\n\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));\n  }\n\n  return statements;\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    systemGlobal = \"System\",\n    allowTopLevelThis = false\n  } = options;\n  const IGNORE_REASSIGNMENT_SYMBOL = Symbol();\n  const reassignmentVisitor = {\n    \"AssignmentExpression|UpdateExpression\"(path) {\n      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;\n      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;\n      const arg = path.get(path.isAssignmentExpression() ? \"left\" : \"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs = [path.node];\n\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n\n          const exportedNames = this.exports[name];\n          if (!exportedNames) return;\n\n          for (const exportedName of exportedNames) {\n            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);\n          }\n        }\n\n        path.replaceWith(_core.types.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n      const name = arg.node.name;\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n      let node = path.node;\n      const isPostUpdateExpression = path.isUpdateExpression({\n        prefix: false\n      });\n\n      if (isPostUpdateExpression) {\n        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression(\"+\", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = _core.types.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    }\n\n  };\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (_core.types.isImport(path.node.callee)) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            console.warn(MISSING_PLUGIN_WARNING);\n          }\n\n          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"import\")), [(0, _utils.getImportSource)(_core.types, path.node)]));\n        }\n      },\n\n      MetaProperty(path, state) {\n        if (path.node.meta.name === \"import\" && path.node.property.name === \"meta\") {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"meta\")));\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (path.node.name === \"__moduleName\" && !path.scope.hasBinding(\"__moduleName\")) {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"id\")));\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n\n          if (!allowTopLevelThis) {\n            (0, _helperModuleTransforms.rewriteThis)(path);\n          }\n        },\n\n        exit(path, state) {\n          const undefinedIdent = path.scope.buildUndefinedNode();\n          const exportIdent = path.scope.generateUid(\"export\");\n          const contextIdent = state.contextIdent;\n          const exportMap = Object.create(null);\n          const modules = [];\n          let beforeBody = [];\n          const setters = [];\n          const sources = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key, val) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(source, key, specifiers) {\n            let module;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n\n            if (!module) {\n              modules.push(module = {\n                key: source,\n                imports: [],\n                exports: []\n              });\n            }\n\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name, val) {\n            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));\n          }\n\n          const exportNames = [];\n          const exportValues = [];\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(path.node.id);\n              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                path.scope.removeBinding(name);\n                variableIds.push(_core.types.identifier(name));\n              }\n\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.get(\"declaration\");\n              const id = declar.node.id;\n\n              if (declar.isClassDeclaration()) {\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(undefinedIdent);\n                  variableIds.push(id);\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar.node));\n                  removedPaths.push(path);\n                }\n              } else if (declar.isFunctionDeclaration()) {\n                if (id) {\n                  beforeBody.push(declar.node);\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar.node));\n                }\n\n                removedPaths.push(path);\n              } else {\n                path.replaceWith(buildExportCall(\"default\", declar.node));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.get(\"declaration\");\n\n              if (declar.node) {\n                path.replaceWith(declar);\n\n                if (path.isFunction()) {\n                  const node = declar.node;\n                  const name = node.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(node);\n                  exportNames.push(name);\n                  exportValues.push(_core.types.cloneNode(node.id));\n                  removedPaths.push(path);\n                } else if (path.isClass()) {\n                  const name = declar.node.id.name;\n                  exportNames.push(name);\n                  exportValues.push(undefinedIdent);\n                  variableIds.push(declar.node.id);\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node))));\n                  addExportName(name, name);\n                } else {\n                  for (const name of Object.keys(declar.getBindingIdentifiers())) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n\n                if (specifiers == null ? void 0 : specifiers.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      const binding = path.scope.getBinding(specifier.local.name);\n\n                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {\n                        exportNames.push(specifier.exported.name);\n                        exportValues.push(_core.types.cloneNode(specifier.local));\n                      } else if (!binding) {\n                        nodes.push(buildExportCall(specifier.exported.name, specifier.local));\n                      }\n\n                      addExportName(specifier.local.name, specifier.exported.name);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            let setterBody = [];\n            const target = path.scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (_core.types.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.identifier(target))));\n              } else if (_core.types.isImportDefaultSpecifier(specifier)) {\n                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier(\"default\"));\n              }\n\n              if (_core.types.isImportSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported))));\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (_core.types.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (_core.types.isExportSpecifier(node)) {\n                  exportNames.push(node.exported.name);\n                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local));\n                } else {}\n              }\n\n              setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null));\n            }\n\n            sources.push(_core.types.stringLiteral(specifiers.key));\n            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));\n          });\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {\n            variableIds.push(id);\n\n            if (!hasInit) {\n              exportNames.push(name);\n              exportValues.push(undefinedIdent);\n            }\n          }, null);\n\n          if (variableIds.length) {\n            beforeBody.unshift(_core.types.variableDeclaration(\"var\", variableIds.map(id => _core.types.variableDeclarator(id))));\n          }\n\n          if (exportNames.length) {\n            beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null));\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope: path.scope\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          path.node.body = [buildTemplate({\n            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier(\"register\")),\n            BEFORE_BODY: beforeBody,\n            MODULE_NAME: moduleName,\n            SETTERS: _core.types.arrayExpression(setters),\n            SOURCES: _core.types.arrayExpression(sources),\n            BODY: path.node.body,\n            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),\n            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)\n          })];\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-modules-systemjs/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_helperHoistVariables","_interopRequireDefault","_core","_utils","_helperModuleTransforms","obj","__esModule","buildTemplate","template","buildExportAll","MISSING_PLUGIN_WARNING","constructExportCall","path","exportIdent","exportNames","exportValues","exportStarTarget","statements","length","push","types","expressionStatement","callExpression","stringLiteral","objectProperties","i","exportName","exportValue","objectProperty","identifier","objectExpression","exportObj","scope","generateUid","variableDeclaration","variableDeclarator","KEY","generateUidIdentifier","EXPORT_OBJ","TARGET","assignmentExpression","memberExpression","_default","declare","api","options","assertVersion","systemGlobal","allowTopLevelThis","IGNORE_REASSIGNMENT_SYMBOL","Symbol","reassignmentVisitor","node","arg","get","isAssignmentExpression","isObjectPattern","isArrayPattern","exprs","name","keys","getBindingIdentifiers","getBinding","exportedNames","exportedName","buildCall","expression","replaceWith","sequenceExpression","isIdentifier","isPostUpdateExpression","isUpdateExpression","prefix","binaryExpression","operator","unaryExpression","cloneNode","argument","numericLiteral","pre","file","set","visitor","CallExpression","state","isImport","callee","has","console","warn","contextIdent","getImportSource","MetaProperty","meta","property","ReferencedIdentifier","hasBinding","Program","enter","rewriteThis","exit","undefinedIdent","buildUndefinedNode","exportMap","create","modules","beforeBody","setters","sources","variableIds","removedPaths","addExportName","key","val","pushModule","source","specifiers","module","forEach","m","imports","concat","buildExportCall","body","isFunctionDeclaration","isClassDeclaration","id","toExpression","isImportDeclaration","removeBinding","remove","isExportAllDeclaration","isExportDefaultDeclaration","declar","isExportNamedDeclaration","isFunction","isClass","nodes","specifier","binding","local","exported","replaceWithMultiple","setterBody","target","isImportNamespaceSpecifier","isImportDefaultSpecifier","importSpecifier","isImportSpecifier","imported","hasExportStar","isExportSpecifier","functionExpression","blockStatement","moduleName","getModuleName","opts","hasInit","unshift","map","traverse","SYSTEM_REGISTER","BEFORE_BODY","MODULE_NAME","SETTERS","arrayExpression","SOURCES","BODY","EXPORT_IDENTIFIER","CONTEXT_IDENTIFIER"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperHoistVariables = _interopRequireDefault(require(\"@babel/helper-hoist-variables\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst buildTemplate = (0, _core.template)(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n`);\nconst buildExportAll = (0, _core.template)(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\n\nfunction constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {\n  const statements = [];\n\n  if (exportNames.length === 1) {\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));\n  } else if (!exportStarTarget) {\n    const objectProperties = [];\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      objectProperties.push(_core.types.objectProperty(_core.types.identifier(exportName), exportValue));\n    }\n\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n    statements.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));\n    statements.push(buildExportAll({\n      KEY: path.scope.generateUidIdentifier(\"key\"),\n      EXPORT_OBJ: _core.types.identifier(exportObj),\n      TARGET: exportStarTarget\n    }));\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));\n    }\n\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));\n  }\n\n  return statements;\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    systemGlobal = \"System\",\n    allowTopLevelThis = false\n  } = options;\n  const IGNORE_REASSIGNMENT_SYMBOL = Symbol();\n  const reassignmentVisitor = {\n    \"AssignmentExpression|UpdateExpression\"(path) {\n      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;\n      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;\n      const arg = path.get(path.isAssignmentExpression() ? \"left\" : \"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs = [path.node];\n\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n\n          const exportedNames = this.exports[name];\n          if (!exportedNames) return;\n\n          for (const exportedName of exportedNames) {\n            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);\n          }\n        }\n\n        path.replaceWith(_core.types.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n      const name = arg.node.name;\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n      let node = path.node;\n      const isPostUpdateExpression = path.isUpdateExpression({\n        prefix: false\n      });\n\n      if (isPostUpdateExpression) {\n        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression(\"+\", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = _core.types.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    }\n\n  };\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (_core.types.isImport(path.node.callee)) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            console.warn(MISSING_PLUGIN_WARNING);\n          }\n\n          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"import\")), [(0, _utils.getImportSource)(_core.types, path.node)]));\n        }\n      },\n\n      MetaProperty(path, state) {\n        if (path.node.meta.name === \"import\" && path.node.property.name === \"meta\") {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"meta\")));\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (path.node.name === \"__moduleName\" && !path.scope.hasBinding(\"__moduleName\")) {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"id\")));\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n\n          if (!allowTopLevelThis) {\n            (0, _helperModuleTransforms.rewriteThis)(path);\n          }\n        },\n\n        exit(path, state) {\n          const undefinedIdent = path.scope.buildUndefinedNode();\n          const exportIdent = path.scope.generateUid(\"export\");\n          const contextIdent = state.contextIdent;\n          const exportMap = Object.create(null);\n          const modules = [];\n          let beforeBody = [];\n          const setters = [];\n          const sources = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key, val) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(source, key, specifiers) {\n            let module;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n\n            if (!module) {\n              modules.push(module = {\n                key: source,\n                imports: [],\n                exports: []\n              });\n            }\n\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name, val) {\n            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));\n          }\n\n          const exportNames = [];\n          const exportValues = [];\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(path.node.id);\n              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                path.scope.removeBinding(name);\n                variableIds.push(_core.types.identifier(name));\n              }\n\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.get(\"declaration\");\n              const id = declar.node.id;\n\n              if (declar.isClassDeclaration()) {\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(undefinedIdent);\n                  variableIds.push(id);\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar.node));\n                  removedPaths.push(path);\n                }\n              } else if (declar.isFunctionDeclaration()) {\n                if (id) {\n                  beforeBody.push(declar.node);\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar.node));\n                }\n\n                removedPaths.push(path);\n              } else {\n                path.replaceWith(buildExportCall(\"default\", declar.node));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.get(\"declaration\");\n\n              if (declar.node) {\n                path.replaceWith(declar);\n\n                if (path.isFunction()) {\n                  const node = declar.node;\n                  const name = node.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(node);\n                  exportNames.push(name);\n                  exportValues.push(_core.types.cloneNode(node.id));\n                  removedPaths.push(path);\n                } else if (path.isClass()) {\n                  const name = declar.node.id.name;\n                  exportNames.push(name);\n                  exportValues.push(undefinedIdent);\n                  variableIds.push(declar.node.id);\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node))));\n                  addExportName(name, name);\n                } else {\n                  for (const name of Object.keys(declar.getBindingIdentifiers())) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n\n                if (specifiers == null ? void 0 : specifiers.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      const binding = path.scope.getBinding(specifier.local.name);\n\n                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {\n                        exportNames.push(specifier.exported.name);\n                        exportValues.push(_core.types.cloneNode(specifier.local));\n                      } else if (!binding) {\n                          nodes.push(buildExportCall(specifier.exported.name, specifier.local));\n                        }\n\n                      addExportName(specifier.local.name, specifier.exported.name);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            let setterBody = [];\n            const target = path.scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (_core.types.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.identifier(target))));\n              } else if (_core.types.isImportDefaultSpecifier(specifier)) {\n                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier(\"default\"));\n              }\n\n              if (_core.types.isImportSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported))));\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (_core.types.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (_core.types.isExportSpecifier(node)) {\n                  exportNames.push(node.exported.name);\n                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local));\n                } else {}\n              }\n\n              setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null));\n            }\n\n            sources.push(_core.types.stringLiteral(specifiers.key));\n            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));\n          });\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {\n            variableIds.push(id);\n\n            if (!hasInit) {\n              exportNames.push(name);\n              exportValues.push(undefinedIdent);\n            }\n          }, null);\n\n          if (variableIds.length) {\n            beforeBody.unshift(_core.types.variableDeclaration(\"var\", variableIds.map(id => _core.types.variableDeclarator(id))));\n          }\n\n          if (exportNames.length) {\n            beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null));\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope: path.scope\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          path.node.body = [buildTemplate({\n            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier(\"register\")),\n            BEFORE_BODY: beforeBody,\n            MODULE_NAME: moduleName,\n            SETTERS: _core.types.arrayExpression(setters),\n            SOURCES: _core.types.arrayExpression(sources),\n            BODY: path.node.body,\n            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),\n            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)\n          })];\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}