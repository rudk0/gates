{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false,\n    useBuiltIns = false,\n    allowArrayLike = false\n  } = options;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(`.loose must be a boolean or undefined`);\n  }\n\n  const arrayOnlySpread = loose;\n\n  function getExtendsHelper(file) {\n    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n\n  function variableDeclarationHasPattern(node) {\n    for (const declar of node.declarations) {\n      if (_core.types.isPattern(declar.id)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function hasRest(pattern) {\n    for (const elem of pattern.elements) {\n      if (_core.types.isRestElement(elem)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function hasObjectRest(pattern) {\n    for (const elem of pattern.properties) {\n      if (_core.types.isRestElement(elem)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const STOP_TRAVERSAL = {};\n\n  const arrayUnpackVisitor = (node, ancestors, state) => {\n    if (!ancestors.length) {\n      return;\n    }\n\n    if (_core.types.isIdentifier(node) && _core.types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {\n      state.deopt = true;\n      throw STOP_TRAVERSAL;\n    }\n  };\n\n  class DestructuringTransformer {\n    constructor(opts) {\n      this.blockHoist = opts.blockHoist;\n      this.operator = opts.operator;\n      this.arrays = {};\n      this.nodes = opts.nodes || [];\n      this.scope = opts.scope;\n      this.kind = opts.kind;\n      this.arrayOnlySpread = opts.arrayOnlySpread;\n      this.allowArrayLike = opts.allowArrayLike;\n      this.addHelper = opts.addHelper;\n    }\n\n    buildVariableAssignment(id, init) {\n      let op = this.operator;\n      if (_core.types.isMemberExpression(id)) op = \"=\";\n      let node;\n\n      if (op) {\n        node = _core.types.expressionStatement(_core.types.assignmentExpression(op, id, _core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n      } else {\n        node = _core.types.variableDeclaration(this.kind, [_core.types.variableDeclarator(id, _core.types.cloneNode(init))]);\n      }\n\n      node._blockHoist = this.blockHoist;\n      return node;\n    }\n\n    buildVariableDeclaration(id, init) {\n      const declar = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.cloneNode(init))]);\n\n      declar._blockHoist = this.blockHoist;\n      return declar;\n    }\n\n    push(id, _init) {\n      const init = _core.types.cloneNode(_init);\n\n      if (_core.types.isObjectPattern(id)) {\n        this.pushObjectPattern(id, init);\n      } else if (_core.types.isArrayPattern(id)) {\n        this.pushArrayPattern(id, init);\n      } else if (_core.types.isAssignmentPattern(id)) {\n        this.pushAssignmentPattern(id, init);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(id, init));\n      }\n    }\n\n    toArray(node, count) {\n      if (this.arrayOnlySpread || _core.types.isIdentifier(node) && this.arrays[node.name]) {\n        return node;\n      } else {\n        return this.scope.toArray(node, count, this.allowArrayLike);\n      }\n    }\n\n    pushAssignmentPattern({\n      left,\n      right\n    }, valueRef) {\n      const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n      const tempConditional = _core.types.conditionalExpression(_core.types.binaryExpression(\"===\", _core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core.types.cloneNode(tempId));\n\n      if (_core.types.isPattern(left)) {\n        let patternId;\n        let node;\n\n        if (this.kind === \"const\" || this.kind === \"let\") {\n          patternId = this.scope.generateUidIdentifier(tempId.name);\n          node = this.buildVariableDeclaration(patternId, tempConditional);\n        } else {\n          patternId = tempId;\n          node = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(tempId), tempConditional));\n        }\n\n        this.nodes.push(node);\n        this.push(left, patternId);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n      }\n    }\n\n    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n      const keys = [];\n      let allLiteral = true;\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (i >= spreadPropIndex) break;\n        if (_core.types.isRestElement(prop)) continue;\n        const key = prop.key;\n\n        if (_core.types.isIdentifier(key) && !prop.computed) {\n          keys.push(_core.types.stringLiteral(key.name));\n        } else if (_core.types.isTemplateLiteral(prop.key)) {\n          keys.push(_core.types.cloneNode(prop.key));\n        } else if (_core.types.isLiteral(key)) {\n          keys.push(_core.types.stringLiteral(String(key.value)));\n        } else {\n          keys.push(_core.types.cloneNode(key));\n          allLiteral = false;\n        }\n      }\n\n      let value;\n\n      if (keys.length === 0) {\n        value = _core.types.callExpression(getExtendsHelper(this), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)]);\n      } else {\n        let keyExpression = _core.types.arrayExpression(keys);\n\n        if (!allLiteral) {\n          keyExpression = _core.types.callExpression(_core.types.memberExpression(keyExpression, _core.types.identifier(\"map\")), [this.addHelper(\"toPropertyKey\")]);\n        }\n\n        value = _core.types.callExpression(this.addHelper(`objectWithoutProperties${loose ? \"Loose\" : \"\"}`), [_core.types.cloneNode(objRef), keyExpression]);\n      }\n\n      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n    }\n\n    pushObjectProperty(prop, propRef) {\n      if (_core.types.isLiteral(prop.key)) prop.computed = true;\n      const pattern = prop.value;\n\n      const objRef = _core.types.memberExpression(_core.types.cloneNode(propRef), prop.key, prop.computed);\n\n      if (_core.types.isPattern(pattern)) {\n        this.push(pattern, objRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n      }\n    }\n\n    pushObjectPattern(pattern, objRef) {\n      if (!pattern.properties.length) {\n        this.nodes.push(_core.types.expressionStatement(_core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [objRef])));\n      }\n\n      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n        const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n        this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n        objRef = temp;\n      }\n\n      if (hasObjectRest(pattern)) {\n        let copiedPattern;\n\n        for (let i = 0; i < pattern.properties.length; i++) {\n          const prop = pattern.properties[i];\n\n          if (_core.types.isRestElement(prop)) {\n            break;\n          }\n\n          const key = prop.key;\n\n          if (prop.computed && !this.scope.isPure(key)) {\n            const name = this.scope.generateUidIdentifierBasedOnNode(key);\n            this.nodes.push(this.buildVariableDeclaration(name, key));\n\n            if (!copiedPattern) {\n              copiedPattern = pattern = Object.assign(Object.assign({}, pattern), {}, {\n                properties: pattern.properties.slice()\n              });\n            }\n\n            copiedPattern.properties[i] = Object.assign(Object.assign({}, copiedPattern.properties[i]), {}, {\n              key: name\n            });\n          }\n        }\n      }\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n\n        if (_core.types.isRestElement(prop)) {\n          this.pushObjectRest(pattern, objRef, prop, i);\n        } else {\n          this.pushObjectProperty(prop, objRef);\n        }\n      }\n    }\n\n    canUnpackArrayPattern(pattern, arr) {\n      if (!_core.types.isArrayExpression(arr)) return false;\n      if (pattern.elements.length > arr.elements.length) return;\n\n      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {\n        return false;\n      }\n\n      for (const elem of pattern.elements) {\n        if (!elem) return false;\n        if (_core.types.isMemberExpression(elem)) return false;\n      }\n\n      for (const elem of arr.elements) {\n        if (_core.types.isSpreadElement(elem)) return false;\n        if (_core.types.isCallExpression(elem)) return false;\n        if (_core.types.isMemberExpression(elem)) return false;\n      }\n\n      const bindings = _core.types.getBindingIdentifiers(pattern);\n\n      const state = {\n        deopt: false,\n        bindings\n      };\n\n      try {\n        _core.types.traverse(arr, arrayUnpackVisitor, state);\n      } catch (e) {\n        if (e !== STOP_TRAVERSAL) throw e;\n      }\n\n      return !state.deopt;\n    }\n\n    pushUnpackedArrayPattern(pattern, arr) {\n      for (let i = 0; i < pattern.elements.length; i++) {\n        const elem = pattern.elements[i];\n\n        if (_core.types.isRestElement(elem)) {\n          this.push(elem.argument, _core.types.arrayExpression(arr.elements.slice(i)));\n        } else {\n          this.push(elem, arr.elements[i]);\n        }\n      }\n    }\n\n    pushArrayPattern(pattern, arrayRef) {\n      if (!pattern.elements) return;\n\n      if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n        return this.pushUnpackedArrayPattern(pattern, arrayRef);\n      }\n\n      const count = !hasRest(pattern) && pattern.elements.length;\n      const toArray = this.toArray(arrayRef, count);\n\n      if (_core.types.isIdentifier(toArray)) {\n        arrayRef = toArray;\n      } else {\n        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n        this.arrays[arrayRef.name] = true;\n        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n      }\n\n      for (let i = 0; i < pattern.elements.length; i++) {\n        let elem = pattern.elements[i];\n        if (!elem) continue;\n        let elemRef;\n\n        if (_core.types.isRestElement(elem)) {\n          elemRef = this.toArray(arrayRef);\n          elemRef = _core.types.callExpression(_core.types.memberExpression(elemRef, _core.types.identifier(\"slice\")), [_core.types.numericLiteral(i)]);\n          elem = elem.argument;\n        } else {\n          elemRef = _core.types.memberExpression(arrayRef, _core.types.numericLiteral(i), true);\n        }\n\n        this.push(elem, elemRef);\n      }\n    }\n\n    init(pattern, ref) {\n      if (!_core.types.isArrayExpression(ref) && !_core.types.isMemberExpression(ref)) {\n        const memo = this.scope.maybeGenerateMemoised(ref, true);\n\n        if (memo) {\n          this.nodes.push(this.buildVariableDeclaration(memo, _core.types.cloneNode(ref)));\n          ref = memo;\n        }\n      }\n\n      this.push(pattern, ref);\n      return this.nodes;\n    }\n\n  }\n\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {\n          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n\n        if (_core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n\n          if (node.body.body.length === 0 && path.isCompletionRecord()) {\n            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, temp)));\n          return;\n        }\n\n        if (!_core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!_core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          allowArrayLike,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        path.ensureBlock();\n        const block = node.body;\n        block.body = nodes.concat(block.body);\n      },\n\n      CatchClause({\n        node,\n        scope\n      }) {\n        const pattern = node.param;\n        if (!_core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          allowArrayLike,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = nodes.concat(node.body.body);\n      },\n\n      AssignmentExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (!_core.types.isPattern(node.left)) return;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          operator: node.operator,\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          allowArrayLike,\n          addHelper: name => this.addHelper(name)\n        });\n        let ref;\n\n        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n          ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n          nodes.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(ref, node.right)]));\n\n          if (_core.types.isArrayExpression(node.right)) {\n            destructuring.arrays[ref.name] = true;\n          }\n        }\n\n        destructuring.init(node.left, ref || node.right);\n\n        if (ref) {\n          if (path.parentPath.isArrowFunctionExpression()) {\n            path.replaceWith(_core.types.blockStatement([]));\n            nodes.push(_core.types.returnStatement(_core.types.cloneNode(ref)));\n          } else {\n            nodes.push(_core.types.expressionStatement(_core.types.cloneNode(ref)));\n          }\n        }\n\n        path.replaceWithMultiple(nodes);\n        path.scope.crawl();\n      },\n\n      VariableDeclaration(path) {\n        const {\n          node,\n          scope,\n          parent\n        } = path;\n        if (_core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        const nodeKind = node.kind;\n        const nodes = [];\n        let declar;\n\n        for (let i = 0; i < node.declarations.length; i++) {\n          declar = node.declarations[i];\n          const patternId = declar.init;\n          const pattern = declar.id;\n          const destructuring = new DestructuringTransformer({\n            blockHoist: node._blockHoist,\n            nodes: nodes,\n            scope: scope,\n            kind: node.kind,\n            arrayOnlySpread,\n            allowArrayLike,\n            addHelper: name => this.addHelper(name)\n          });\n\n          if (_core.types.isPattern(pattern)) {\n            destructuring.init(pattern, patternId);\n\n            if (+i !== node.declarations.length - 1) {\n              _core.types.inherits(nodes[nodes.length - 1], declar);\n            }\n          } else {\n            nodes.push(_core.types.inherits(destructuring.buildVariableAssignment(declar.id, _core.types.cloneNode(declar.init)), declar));\n          }\n        }\n\n        let tail = null;\n        const nodesOut = [];\n\n        for (const node of nodes) {\n          if (tail !== null && _core.types.isVariableDeclaration(node)) {\n            tail.declarations.push(...node.declarations);\n          } else {\n            node.kind = nodeKind;\n            nodesOut.push(node);\n            tail = _core.types.isVariableDeclaration(node) ? node : null;\n          }\n        }\n\n        for (const nodeOut of nodesOut) {\n          if (!nodeOut.declarations) continue;\n\n          for (const declaration of nodeOut.declarations) {\n            const {\n              name\n            } = declaration.id;\n\n            if (scope.bindings[name]) {\n              scope.bindings[name].kind = nodeOut.kind;\n            }\n          }\n        }\n\n        if (nodesOut.length === 1) {\n          path.replaceWith(nodesOut[0]);\n        } else {\n          path.replaceWithMultiple(nodesOut);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-destructuring/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","options","assertVersion","loose","useBuiltIns","allowArrayLike","Error","arrayOnlySpread","getExtendsHelper","file","types","memberExpression","identifier","addHelper","variableDeclarationHasPattern","node","declar","declarations","isPattern","id","hasRest","pattern","elem","elements","isRestElement","hasObjectRest","properties","STOP_TRAVERSAL","arrayUnpackVisitor","ancestors","state","length","isIdentifier","isReferenced","bindings","name","deopt","DestructuringTransformer","constructor","opts","blockHoist","operator","arrays","nodes","scope","kind","buildVariableAssignment","init","op","isMemberExpression","expressionStatement","assignmentExpression","cloneNode","buildUndefinedNode","variableDeclaration","variableDeclarator","_blockHoist","buildVariableDeclaration","push","_init","isObjectPattern","pushObjectPattern","isArrayPattern","pushArrayPattern","isAssignmentPattern","pushAssignmentPattern","toArray","count","left","right","valueRef","tempId","generateUidIdentifierBasedOnNode","tempConditional","conditionalExpression","binaryExpression","patternId","generateUidIdentifier","pushObjectRest","objRef","spreadProp","spreadPropIndex","keys","allLiteral","i","prop","key","computed","stringLiteral","isTemplateLiteral","isLiteral","String","callExpression","objectExpression","keyExpression","arrayExpression","argument","pushObjectProperty","propRef","isStatic","temp","copiedPattern","isPure","assign","slice","canUnpackArrayPattern","arr","isArrayExpression","isSpreadElement","isCallExpression","getBindingIdentifiers","traverse","e","pushUnpackedArrayPattern","arrayRef","elemRef","numericLiteral","ref","memo","maybeGenerateMemoised","visitor","ExportNamedDeclaration","path","declaration","get","isVariableDeclaration","specifiers","getOuterBindingIdentifiers","exportSpecifier","replaceWith","insertAfter","exportNamedDeclaration","ForXStatement","ensureBlock","body","isCompletionRecord","unshift","destructuring","block","concat","CatchClause","param","AssignmentExpression","parentPath","isExpressionStatement","isArrowFunctionExpression","blockStatement","returnStatement","replaceWithMultiple","crawl","VariableDeclaration","parent","isForXStatement","container","nodeKind","inherits","tail","nodesOut","nodeOut"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false,\n    useBuiltIns = false,\n    allowArrayLike = false\n  } = options;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(`.loose must be a boolean or undefined`);\n  }\n\n  const arrayOnlySpread = loose;\n\n  function getExtendsHelper(file) {\n    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n\n  function variableDeclarationHasPattern(node) {\n    for (const declar of node.declarations) {\n      if (_core.types.isPattern(declar.id)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function hasRest(pattern) {\n    for (const elem of pattern.elements) {\n      if (_core.types.isRestElement(elem)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function hasObjectRest(pattern) {\n    for (const elem of pattern.properties) {\n      if (_core.types.isRestElement(elem)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const STOP_TRAVERSAL = {};\n\n  const arrayUnpackVisitor = (node, ancestors, state) => {\n    if (!ancestors.length) {\n      return;\n    }\n\n    if (_core.types.isIdentifier(node) && _core.types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {\n      state.deopt = true;\n      throw STOP_TRAVERSAL;\n    }\n  };\n\n  class DestructuringTransformer {\n    constructor(opts) {\n      this.blockHoist = opts.blockHoist;\n      this.operator = opts.operator;\n      this.arrays = {};\n      this.nodes = opts.nodes || [];\n      this.scope = opts.scope;\n      this.kind = opts.kind;\n      this.arrayOnlySpread = opts.arrayOnlySpread;\n      this.allowArrayLike = opts.allowArrayLike;\n      this.addHelper = opts.addHelper;\n    }\n\n    buildVariableAssignment(id, init) {\n      let op = this.operator;\n      if (_core.types.isMemberExpression(id)) op = \"=\";\n      let node;\n\n      if (op) {\n        node = _core.types.expressionStatement(_core.types.assignmentExpression(op, id, _core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n      } else {\n        node = _core.types.variableDeclaration(this.kind, [_core.types.variableDeclarator(id, _core.types.cloneNode(init))]);\n      }\n\n      node._blockHoist = this.blockHoist;\n      return node;\n    }\n\n    buildVariableDeclaration(id, init) {\n      const declar = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.cloneNode(init))]);\n\n      declar._blockHoist = this.blockHoist;\n      return declar;\n    }\n\n    push(id, _init) {\n      const init = _core.types.cloneNode(_init);\n\n      if (_core.types.isObjectPattern(id)) {\n        this.pushObjectPattern(id, init);\n      } else if (_core.types.isArrayPattern(id)) {\n        this.pushArrayPattern(id, init);\n      } else if (_core.types.isAssignmentPattern(id)) {\n        this.pushAssignmentPattern(id, init);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(id, init));\n      }\n    }\n\n    toArray(node, count) {\n      if (this.arrayOnlySpread || _core.types.isIdentifier(node) && this.arrays[node.name]) {\n        return node;\n      } else {\n        return this.scope.toArray(node, count, this.allowArrayLike);\n      }\n    }\n\n    pushAssignmentPattern({\n      left,\n      right\n    }, valueRef) {\n      const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n      const tempConditional = _core.types.conditionalExpression(_core.types.binaryExpression(\"===\", _core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core.types.cloneNode(tempId));\n\n      if (_core.types.isPattern(left)) {\n        let patternId;\n        let node;\n\n        if (this.kind === \"const\" || this.kind === \"let\") {\n          patternId = this.scope.generateUidIdentifier(tempId.name);\n          node = this.buildVariableDeclaration(patternId, tempConditional);\n        } else {\n          patternId = tempId;\n          node = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(tempId), tempConditional));\n        }\n\n        this.nodes.push(node);\n        this.push(left, patternId);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n      }\n    }\n\n    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n      const keys = [];\n      let allLiteral = true;\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (i >= spreadPropIndex) break;\n        if (_core.types.isRestElement(prop)) continue;\n        const key = prop.key;\n\n        if (_core.types.isIdentifier(key) && !prop.computed) {\n          keys.push(_core.types.stringLiteral(key.name));\n        } else if (_core.types.isTemplateLiteral(prop.key)) {\n          keys.push(_core.types.cloneNode(prop.key));\n        } else if (_core.types.isLiteral(key)) {\n          keys.push(_core.types.stringLiteral(String(key.value)));\n        } else {\n          keys.push(_core.types.cloneNode(key));\n          allLiteral = false;\n        }\n      }\n\n      let value;\n\n      if (keys.length === 0) {\n        value = _core.types.callExpression(getExtendsHelper(this), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)]);\n      } else {\n        let keyExpression = _core.types.arrayExpression(keys);\n\n        if (!allLiteral) {\n          keyExpression = _core.types.callExpression(_core.types.memberExpression(keyExpression, _core.types.identifier(\"map\")), [this.addHelper(\"toPropertyKey\")]);\n        }\n\n        value = _core.types.callExpression(this.addHelper(`objectWithoutProperties${loose ? \"Loose\" : \"\"}`), [_core.types.cloneNode(objRef), keyExpression]);\n      }\n\n      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n    }\n\n    pushObjectProperty(prop, propRef) {\n      if (_core.types.isLiteral(prop.key)) prop.computed = true;\n      const pattern = prop.value;\n\n      const objRef = _core.types.memberExpression(_core.types.cloneNode(propRef), prop.key, prop.computed);\n\n      if (_core.types.isPattern(pattern)) {\n        this.push(pattern, objRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n      }\n    }\n\n    pushObjectPattern(pattern, objRef) {\n      if (!pattern.properties.length) {\n        this.nodes.push(_core.types.expressionStatement(_core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [objRef])));\n      }\n\n      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n        const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n        this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n        objRef = temp;\n      }\n\n      if (hasObjectRest(pattern)) {\n        let copiedPattern;\n\n        for (let i = 0; i < pattern.properties.length; i++) {\n          const prop = pattern.properties[i];\n\n          if (_core.types.isRestElement(prop)) {\n            break;\n          }\n\n          const key = prop.key;\n\n          if (prop.computed && !this.scope.isPure(key)) {\n            const name = this.scope.generateUidIdentifierBasedOnNode(key);\n            this.nodes.push(this.buildVariableDeclaration(name, key));\n\n            if (!copiedPattern) {\n              copiedPattern = pattern = Object.assign(Object.assign({}, pattern), {}, {\n                properties: pattern.properties.slice()\n              });\n            }\n\n            copiedPattern.properties[i] = Object.assign(Object.assign({}, copiedPattern.properties[i]), {}, {\n              key: name\n            });\n          }\n        }\n      }\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n\n        if (_core.types.isRestElement(prop)) {\n          this.pushObjectRest(pattern, objRef, prop, i);\n        } else {\n          this.pushObjectProperty(prop, objRef);\n        }\n      }\n    }\n\n    canUnpackArrayPattern(pattern, arr) {\n      if (!_core.types.isArrayExpression(arr)) return false;\n      if (pattern.elements.length > arr.elements.length) return;\n\n      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {\n        return false;\n      }\n\n      for (const elem of pattern.elements) {\n        if (!elem) return false;\n        if (_core.types.isMemberExpression(elem)) return false;\n      }\n\n      for (const elem of arr.elements) {\n        if (_core.types.isSpreadElement(elem)) return false;\n        if (_core.types.isCallExpression(elem)) return false;\n        if (_core.types.isMemberExpression(elem)) return false;\n      }\n\n      const bindings = _core.types.getBindingIdentifiers(pattern);\n\n      const state = {\n        deopt: false,\n        bindings\n      };\n\n      try {\n        _core.types.traverse(arr, arrayUnpackVisitor, state);\n      } catch (e) {\n        if (e !== STOP_TRAVERSAL) throw e;\n      }\n\n      return !state.deopt;\n    }\n\n    pushUnpackedArrayPattern(pattern, arr) {\n      for (let i = 0; i < pattern.elements.length; i++) {\n        const elem = pattern.elements[i];\n\n        if (_core.types.isRestElement(elem)) {\n          this.push(elem.argument, _core.types.arrayExpression(arr.elements.slice(i)));\n        } else {\n          this.push(elem, arr.elements[i]);\n        }\n      }\n    }\n\n    pushArrayPattern(pattern, arrayRef) {\n      if (!pattern.elements) return;\n\n      if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n        return this.pushUnpackedArrayPattern(pattern, arrayRef);\n      }\n\n      const count = !hasRest(pattern) && pattern.elements.length;\n      const toArray = this.toArray(arrayRef, count);\n\n      if (_core.types.isIdentifier(toArray)) {\n        arrayRef = toArray;\n      } else {\n        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n        this.arrays[arrayRef.name] = true;\n        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n      }\n\n      for (let i = 0; i < pattern.elements.length; i++) {\n        let elem = pattern.elements[i];\n        if (!elem) continue;\n        let elemRef;\n\n        if (_core.types.isRestElement(elem)) {\n          elemRef = this.toArray(arrayRef);\n          elemRef = _core.types.callExpression(_core.types.memberExpression(elemRef, _core.types.identifier(\"slice\")), [_core.types.numericLiteral(i)]);\n          elem = elem.argument;\n        } else {\n          elemRef = _core.types.memberExpression(arrayRef, _core.types.numericLiteral(i), true);\n        }\n\n        this.push(elem, elemRef);\n      }\n    }\n\n    init(pattern, ref) {\n      if (!_core.types.isArrayExpression(ref) && !_core.types.isMemberExpression(ref)) {\n        const memo = this.scope.maybeGenerateMemoised(ref, true);\n\n        if (memo) {\n          this.nodes.push(this.buildVariableDeclaration(memo, _core.types.cloneNode(ref)));\n          ref = memo;\n        }\n      }\n\n      this.push(pattern, ref);\n      return this.nodes;\n    }\n\n  }\n\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {\n          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n\n        if (_core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n\n          if (node.body.body.length === 0 && path.isCompletionRecord()) {\n            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, temp)));\n          return;\n        }\n\n        if (!_core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!_core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          allowArrayLike,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        path.ensureBlock();\n        const block = node.body;\n        block.body = nodes.concat(block.body);\n      },\n\n      CatchClause({\n        node,\n        scope\n      }) {\n        const pattern = node.param;\n        if (!_core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          allowArrayLike,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = nodes.concat(node.body.body);\n      },\n\n      AssignmentExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (!_core.types.isPattern(node.left)) return;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          operator: node.operator,\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          allowArrayLike,\n          addHelper: name => this.addHelper(name)\n        });\n        let ref;\n\n        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n          ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n          nodes.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(ref, node.right)]));\n\n          if (_core.types.isArrayExpression(node.right)) {\n            destructuring.arrays[ref.name] = true;\n          }\n        }\n\n        destructuring.init(node.left, ref || node.right);\n\n        if (ref) {\n          if (path.parentPath.isArrowFunctionExpression()) {\n            path.replaceWith(_core.types.blockStatement([]));\n            nodes.push(_core.types.returnStatement(_core.types.cloneNode(ref)));\n          } else {\n            nodes.push(_core.types.expressionStatement(_core.types.cloneNode(ref)));\n          }\n        }\n\n        path.replaceWithMultiple(nodes);\n        path.scope.crawl();\n      },\n\n      VariableDeclaration(path) {\n        const {\n          node,\n          scope,\n          parent\n        } = path;\n        if (_core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        const nodeKind = node.kind;\n        const nodes = [];\n        let declar;\n\n        for (let i = 0; i < node.declarations.length; i++) {\n          declar = node.declarations[i];\n          const patternId = declar.init;\n          const pattern = declar.id;\n          const destructuring = new DestructuringTransformer({\n            blockHoist: node._blockHoist,\n            nodes: nodes,\n            scope: scope,\n            kind: node.kind,\n            arrayOnlySpread,\n            allowArrayLike,\n            addHelper: name => this.addHelper(name)\n          });\n\n          if (_core.types.isPattern(pattern)) {\n            destructuring.init(pattern, patternId);\n\n            if (+i !== node.declarations.length - 1) {\n              _core.types.inherits(nodes[nodes.length - 1], declar);\n            }\n          } else {\n            nodes.push(_core.types.inherits(destructuring.buildVariableAssignment(declar.id, _core.types.cloneNode(declar.init)), declar));\n          }\n        }\n\n        let tail = null;\n        const nodesOut = [];\n\n        for (const node of nodes) {\n          if (tail !== null && _core.types.isVariableDeclaration(node)) {\n            tail.declarations.push(...node.declarations);\n          } else {\n            node.kind = nodeKind;\n            nodesOut.push(node);\n            tail = _core.types.isVariableDeclaration(node) ? node : null;\n          }\n        }\n\n        for (const nodeOut of nodesOut) {\n          if (!nodeOut.declarations) continue;\n\n          for (const declaration of nodeOut.declarations) {\n            const {\n              name\n            } = declaration.id;\n\n            if (scope.bindings[name]) {\n              scope.bindings[name].kind = nodeOut.kind;\n            }\n          }\n        }\n\n        if (nodesOut.length === 1) {\n          path.replaceWith(nodesOut[0]);\n        } else {\n          path.replaceWithMultiple(nodesOut);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}