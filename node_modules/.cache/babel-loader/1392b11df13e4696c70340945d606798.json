{"ast":null,"code":"'use strict';\n\nvar _types = require('../types');\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nprocess.on('message', request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError('Unexpected request from parent process: ' + request[0]);\n  }\n});\n\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  process.send([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  process.send([type, error.constructor && error.constructor.name, error.message, error.stack, typeof error === 'object' ? _objectSpread({}, error) : error]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  process.exit(0);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (result && typeof result.then === 'function') {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/jest-worker/build/workers/processChild.js"],"names":["_types","require","_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","file","setupArgs","initialized","process","on","request","CHILD_MESSAGE_INITIALIZE","init","CHILD_MESSAGE_CALL","call","execMethod","CHILD_MESSAGE_END","end","TypeError","reportSuccess","result","send","Error","PARENT_MESSAGE_OK","reportClientError","error","reportError","PARENT_MESSAGE_CLIENT_ERROR","reportInitializeError","PARENT_MESSAGE_SETUP_ERROR","type","constructor","name","message","stack","main","teardown","exitProcess","execFunction","exit","method","args","fn","__esModule","execHelper","setup","ctx","onResult","onError","apply","err","then"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _types = require('../types');\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(\n        Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        })\n      );\n    }\n    ownKeys.forEach(function(key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nlet file = null;\nlet setupArgs = [];\nlet initialized = false;\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\n\nprocess.on('message', request => {\n  switch (request[0]) {\n    case _types.CHILD_MESSAGE_INITIALIZE:\n      const init = request;\n      file = init[2];\n      setupArgs = request[3];\n      break;\n\n    case _types.CHILD_MESSAGE_CALL:\n      const call = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case _types.CHILD_MESSAGE_END:\n      end();\n      break;\n\n    default:\n      throw new TypeError(\n        'Unexpected request from parent process: ' + request[0]\n      );\n  }\n});\n\nfunction reportSuccess(result) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  process.send([_types.PARENT_MESSAGE_OK, result]);\n}\n\nfunction reportClientError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error) {\n  return reportError(error, _types.PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error, type) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  process.send([\n    type,\n    error.constructor && error.constructor.name,\n    error.message,\n    error.stack,\n    typeof error === 'object' ? _objectSpread({}, error) : error\n  ]);\n}\n\nfunction end() {\n  const main = require(file);\n\n  if (!main.teardown) {\n    exitProcess();\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess() {\n  process.exit(0);\n}\n\nfunction execMethod(method, args) {\n  const main = require(file);\n\n  let fn;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main['default'] : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n    return;\n  }\n\n  initialized = true;\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(fn, ctx, args, onResult, onError) {\n  let result;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (err) {\n    onError(err);\n    return;\n  }\n\n  if (result && typeof result.then === 'function') {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}