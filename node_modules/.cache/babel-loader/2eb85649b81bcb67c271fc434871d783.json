{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Bourne = require('@hapi/bourne');\n\nvar Hoek = require('@hapi/hoek');\n\nvar Any = require('../any');\n\nvar Cast = require('../../cast');\n\nvar Ref = require('../../ref');\n\nvar State = require('../state');\n\nvar internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  var pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    _this = _super.call(this);\n    _this._type = 'array';\n    _this._inner.items = [];\n    _this._inner.ordereds = [];\n    _this._inner.inclusions = [];\n    _this._inner.exclusions = [];\n    _this._inner.requireds = [];\n    _this._flags.sparse = false;\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var result = {\n        value: value\n      };\n\n      if (typeof value === 'string' && options.convert) {\n        if (value.length > 1 && (value[0] === '[' || /^\\s*\\[/.test(value))) {\n          try {\n            result.value = Bourne.parse(value);\n          } catch (e) {}\n        }\n      }\n\n      var isArray = Array.isArray(result.value);\n      var wasArray = isArray;\n\n      if (options.convert && this._flags.single && !isArray) {\n        result.value = [result.value];\n        isArray = true;\n      }\n\n      if (!isArray) {\n        result.errors = this.createError('array.base', null, state, options);\n        return result;\n      }\n\n      if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {\n        // Clone the array so that we don't modify the original\n        if (wasArray) {\n          result.value = result.value.slice(0);\n        }\n\n        result.errors = this._checkItems(result.value, wasArray, state, options);\n\n        if (result.errors && wasArray && options.convert && this._flags.single) {\n          // Attempt a 2nd pass by putting the array inside one.\n          var previousErrors = result.errors;\n          result.value = [result.value];\n          result.errors = this._checkItems(result.value, wasArray, state, options);\n\n          if (result.errors) {\n            // Restore previous errors and value since this didn't validate either.\n            result.errors = previousErrors;\n            result.value = result.value[0];\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkItems\",\n    value: function _checkItems(items, wasArray, state, options) {\n      var errors = [];\n      var errored;\n\n      var requireds = this._inner.requireds.slice();\n\n      var ordereds = this._inner.ordereds.slice();\n\n      var inclusions = [].concat(_toConsumableArray(this._inner.inclusions), _toConsumableArray(requireds));\n      var il = items.length;\n\n      for (var i = 0; i < il; ++i) {\n        errored = false;\n        var item = items[i];\n        var isValid = false;\n        var key = wasArray ? i : state.key;\n        var path = wasArray ? [].concat(_toConsumableArray(state.path), [i]) : state.path;\n        var localState = new State(key, path, state.parent, state.reference);\n        var res = void 0; // Sparse\n\n        if (!this._flags.sparse && item === undefined) {\n          errors.push(this.createError('array.sparse', null, {\n            key: state.key,\n            path: localState.path,\n            pos: i\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          ordereds.shift();\n          continue;\n        } // Exclusions\n\n\n        for (var j = 0; j < this._inner.exclusions.length; ++j) {\n          res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\n          if (!res.errors) {\n            errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n              pos: i,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n            errored = true;\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            ordereds.shift();\n            break;\n          }\n        }\n\n        if (errored) {\n          continue;\n        } // Ordered\n\n\n        if (this._inner.ordereds.length) {\n          if (ordereds.length > 0) {\n            var ordered = ordereds.shift();\n            res = ordered._validate(item, localState, options);\n\n            if (!res.errors) {\n              if (ordered._flags.strip) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n              } else if (!this._flags.sparse && res.value === undefined) {\n                errors.push(this.createError('array.sparse', null, {\n                  key: state.key,\n                  path: localState.path,\n                  pos: i\n                }, options));\n\n                if (options.abortEarly) {\n                  return errors;\n                }\n\n                continue;\n              } else {\n                items[i] = res.value;\n              }\n            } else {\n              errors.push(this.createError('array.ordered', {\n                pos: i,\n                reason: res.errors,\n                value: item\n              }, {\n                key: state.key,\n                path: localState.path\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n            }\n\n            continue;\n          } else if (!this._inner.items.length) {\n            errors.push(this.createError('array.orderedLength', {\n              pos: i,\n              limit: this._inner.ordereds.length\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            continue;\n          }\n        } // Requireds\n\n\n        var requiredChecks = [];\n        var jl = requireds.length;\n\n        for (var _j = 0; _j < jl; ++_j) {\n          res = requiredChecks[_j] = requireds[_j]._validate(item, localState, options);\n\n          if (!res.errors) {\n            items[i] = res.value;\n            isValid = true;\n            internals.fastSplice(requireds, _j);\n            --_j;\n            --jl;\n\n            if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n            }\n\n            break;\n          }\n        }\n\n        if (isValid) {\n          continue;\n        } // Inclusions\n\n\n        var stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n        jl = inclusions.length;\n\n        for (var _j2 = 0; _j2 < jl; ++_j2) {\n          var inclusion = inclusions[_j2]; // Avoid re-running requireds that already didn't match in the previous loop\n\n          var previousCheck = requireds.indexOf(inclusion);\n\n          if (previousCheck !== -1) {\n            res = requiredChecks[previousCheck];\n          } else {\n            res = inclusion._validate(item, localState, options);\n\n            if (!res.errors) {\n              if (inclusion._flags.strip) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n              } else if (!this._flags.sparse && res.value === undefined) {\n                errors.push(this.createError('array.sparse', null, {\n                  key: state.key,\n                  path: localState.path,\n                  pos: i\n                }, options));\n                errored = true;\n              } else {\n                items[i] = res.value;\n              }\n\n              isValid = true;\n              break;\n            }\n          } // Return the actual error if only one inclusion defined\n\n\n          if (jl === 1) {\n            if (stripUnknown) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n              isValid = true;\n              break;\n            }\n\n            errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n              pos: i,\n              reason: res.errors,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n            errored = true;\n\n            if (options.abortEarly) {\n              return errors;\n            }\n\n            break;\n          }\n        }\n\n        if (errored) {\n          continue;\n        }\n\n        if (this._inner.inclusions.length && !isValid) {\n          if (stripUnknown) {\n            internals.fastSplice(items, i);\n            --i;\n            --il;\n            continue;\n          }\n\n          errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', {\n            pos: i,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n        }\n      }\n\n      if (requireds.length) {\n        this._fillMissedErrors(errors, requireds, state, options);\n      }\n\n      if (ordereds.length) {\n        this._fillOrderedErrors(errors, ordereds, state, options);\n      }\n\n      return errors.length ? errors : null;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n\n      if (this._inner.ordereds.length) {\n        description.orderedItems = [];\n\n        for (var i = 0; i < this._inner.ordereds.length; ++i) {\n          description.orderedItems.push(this._inner.ordereds[i].describe());\n        }\n      }\n\n      if (this._inner.items.length) {\n        description.items = [];\n\n        for (var _i = 0; _i < this._inner.items.length; ++_i) {\n          description.items.push(this._inner.items[_i].describe());\n        }\n      }\n\n      if (description.rules) {\n        for (var _i2 = 0; _i2 < description.rules.length; ++_i2) {\n          var rule = description.rules[_i2];\n\n          if (rule.name === 'has') {\n            rule.arg = rule.arg.describe();\n          }\n        }\n      }\n\n      return description;\n    }\n  }, {\n    key: \"items\",\n    value: function items() {\n      var _this2 = this;\n\n      var obj = this.clone();\n\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n\n      Hoek.flatten(schemas).forEach(function (type, index) {\n        try {\n          type = Cast.schema(_this2._currentJoi, type);\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = index + '.' + castErr.path;\n          } else {\n            castErr.path = index;\n          }\n\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n          throw castErr;\n        }\n\n        obj._inner.items.push(type);\n\n        if (type._flags.presence === 'required') {\n          obj._inner.requireds.push(type);\n        } else if (type._flags.presence === 'forbidden') {\n          obj._inner.exclusions.push(type.optional());\n        } else {\n          obj._inner.inclusions.push(type);\n        }\n      });\n      return obj;\n    }\n  }, {\n    key: \"ordered\",\n    value: function ordered() {\n      var _this3 = this;\n\n      var obj = this.clone();\n\n      for (var _len2 = arguments.length, schemas = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        schemas[_key2] = arguments[_key2];\n      }\n\n      Hoek.flatten(schemas).forEach(function (type, index) {\n        try {\n          type = Cast.schema(_this3._currentJoi, type);\n        } catch (castErr) {\n          if (castErr.hasOwnProperty('path')) {\n            castErr.path = index + '.' + castErr.path;\n          } else {\n            castErr.path = index;\n          }\n\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n          throw castErr;\n        }\n\n        obj._inner.ordereds.push(type);\n      });\n      return obj;\n    }\n  }, {\n    key: \"min\",\n    value: function min(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._testUnique('min', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit,\n              value: compareTo\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length >= compareTo) {\n          return value;\n        }\n\n        return this.createError('array.min', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"max\",\n    value: function max(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._testUnique('max', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length <= compareTo) {\n          return value;\n        }\n\n        return this.createError('array.max', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"length\",\n    value: function length(limit) {\n      var isRef = Ref.isRef(limit);\n      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n      return this._testUnique('length', limit, function (value, state, options) {\n        var compareTo;\n\n        if (isRef) {\n          compareTo = limit(state.reference || state.parent, options);\n\n          if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n            return this.createError('array.ref', {\n              ref: limit.key\n            }, state, options);\n          }\n        } else {\n          compareTo = limit;\n        }\n\n        if (value.length === compareTo) {\n          return value;\n        }\n\n        return this.createError('array.length', {\n          limit: limit,\n          value: value\n        }, state, options);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(schema) {\n      try {\n        schema = Cast.schema(this._currentJoi, schema);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.message = \"\".concat(castErr.message, \"(\").concat(castErr.path, \")\");\n        }\n\n        throw castErr;\n      }\n\n      return this._test('has', schema, function (value, state, options) {\n        var isValid = value.some(function (item, idx) {\n          var localState = new State(idx, [].concat(_toConsumableArray(state.path), [idx]), state.key, state.reference);\n          return !schema._validate(item, localState, options).errors;\n        });\n\n        if (isValid) {\n          return value;\n        }\n\n        var patternLabel = schema._getLabel();\n\n        if (patternLabel) {\n          return this.createError('array.hasKnown', {\n            patternLabel: patternLabel\n          }, state, options);\n        }\n\n        return this.createError('array.hasUnknown', null, state, options);\n      });\n    }\n  }, {\n    key: \"unique\",\n    value: function unique(comparator, configs) {\n      Hoek.assert(comparator === undefined || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n      Hoek.assert(configs === undefined || typeof configs === 'object', 'configs must be an object');\n      var settings = {\n        ignoreUndefined: configs && configs.ignoreUndefined || false\n      };\n\n      if (typeof comparator === 'string') {\n        settings.path = comparator;\n      } else if (typeof comparator === 'function') {\n        settings.comparator = comparator;\n      }\n\n      return this._test('unique', settings, function (value, state, options) {\n        var found = {\n          string: Object.create(null),\n          number: Object.create(null),\n          undefined: Object.create(null),\n          boolean: Object.create(null),\n          object: new Map(),\n          function: new Map(),\n          custom: new Map()\n        };\n        var compare = settings.comparator || Hoek.deepEqual;\n        var ignoreUndefined = settings.ignoreUndefined;\n\n        for (var i = 0; i < value.length; ++i) {\n          var item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n          var records = settings.comparator ? found.custom : found[typeof item]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n          // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n          if (\n          /* $lab:coverage:off$ */\n          records\n          /* $lab:coverage:on$ */\n          ) {\n              if (records instanceof Map) {\n                var entries = records.entries();\n                var current = void 0;\n\n                while (!(current = entries.next()).done) {\n                  if (compare(current.value[0], item)) {\n                    var localState = new State(state.key, [].concat(_toConsumableArray(state.path), [i]), state.parent, state.reference);\n                    var context = {\n                      pos: i,\n                      value: value[i],\n                      dupePos: current.value[1],\n                      dupeValue: value[current.value[1]]\n                    };\n\n                    if (settings.path) {\n                      context.path = settings.path;\n                    }\n\n                    return this.createError('array.unique', context, localState, options);\n                  }\n                }\n\n                records.set(item, i);\n              } else {\n                if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                  var _localState = new State(state.key, [].concat(_toConsumableArray(state.path), [i]), state.parent, state.reference);\n\n                  var _context = {\n                    pos: i,\n                    value: value[i],\n                    dupePos: records[item],\n                    dupeValue: value[records[item]]\n                  };\n\n                  if (settings.path) {\n                    _context.path = settings.path;\n                  }\n\n                  return this.createError('array.unique', _context, _localState, options);\n                }\n\n                records[item] = i;\n              }\n            }\n        }\n\n        return value;\n      });\n    }\n  }, {\n    key: \"sparse\",\n    value: function sparse(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.sparse === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.sparse = value;\n      return obj;\n    }\n  }, {\n    key: \"single\",\n    value: function single(enabled) {\n      var value = enabled === undefined ? true : !!enabled;\n\n      if (this._flags.single === value) {\n        return this;\n      }\n\n      var obj = this.clone();\n      obj._flags.single = value;\n      return obj;\n    }\n  }, {\n    key: \"_fillMissedErrors\",\n    value: function _fillMissedErrors(errors, requireds, state, options) {\n      var knownMisses = [];\n      var unknownMisses = 0;\n\n      for (var i = 0; i < requireds.length; ++i) {\n        var label = requireds[i]._getLabel();\n\n        if (label) {\n          knownMisses.push(label);\n        } else {\n          ++unknownMisses;\n        }\n      }\n\n      if (knownMisses.length) {\n        if (unknownMisses) {\n          errors.push(this.createError('array.includesRequiredBoth', {\n            knownMisses: knownMisses,\n            unknownMisses: unknownMisses\n          }, {\n            key: state.key,\n            path: state.path\n          }, options));\n        } else {\n          errors.push(this.createError('array.includesRequiredKnowns', {\n            knownMisses: knownMisses\n          }, {\n            key: state.key,\n            path: state.path\n          }, options));\n        }\n      } else {\n        errors.push(this.createError('array.includesRequiredUnknowns', {\n          unknownMisses: unknownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      }\n    }\n  }, {\n    key: \"_fillOrderedErrors\",\n    value: function _fillOrderedErrors(errors, ordereds, state, options) {\n      var requiredOrdereds = [];\n\n      for (var i = 0; i < ordereds.length; ++i) {\n        var presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n        if (presence === 'required') {\n          requiredOrdereds.push(ordereds[i]);\n        }\n      }\n\n      if (requiredOrdereds.length) {\n        this._fillMissedErrors(errors, requiredOrdereds, state, options);\n      }\n    }\n  }]);\n\n  return _class;\n}(Any);\n\nmodule.exports = new internals.Array();","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/joi/lib/types/array/index.js"],"names":["Bourne","require","Hoek","Any","Cast","Ref","State","internals","fastSplice","arr","i","pos","length","Array","_type","_inner","items","ordereds","inclusions","exclusions","requireds","_flags","sparse","value","state","options","result","convert","test","parse","e","isArray","wasArray","single","errors","createError","slice","_checkItems","previousErrors","errored","il","item","isValid","key","path","localState","parent","reference","res","undefined","push","abortEarly","shift","j","_validate","ordered","strip","reason","limit","requiredChecks","jl","stripUnknown","arrays","inclusion","previousCheck","indexOf","_fillMissedErrors","_fillOrderedErrors","description","orderedItems","describe","rules","rule","name","arg","obj","clone","schemas","flatten","forEach","type","index","schema","_currentJoi","castErr","hasOwnProperty","message","presence","optional","isRef","assert","Number","isSafeInteger","_testUnique","compareTo","ref","_test","some","idx","patternLabel","_getLabel","comparator","configs","settings","ignoreUndefined","found","string","Object","create","number","boolean","object","Map","function","custom","compare","deepEqual","reach","records","entries","current","next","done","context","dupePos","dupeValue","set","enabled","knownMisses","unknownMisses","label","requiredOrdereds","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Bourne = require('@hapi/bourne');\nconst Hoek = require('@hapi/hoek');\n\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\nconst State = require('../state');\n\n\nconst internals = {};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.Array = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'array';\n        this._inner.items = [];\n        this._inner.ordereds = [];\n        this._inner.inclusions = [];\n        this._inner.exclusions = [];\n        this._inner.requireds = [];\n        this._flags.sparse = false;\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (value.length > 1 &&\n                (value[0] === '[' || /^\\s*\\[/.test(value))) {\n\n                try {\n                    result.value = Bourne.parse(value);\n                }\n                catch (e) { }\n            }\n        }\n\n        let isArray = Array.isArray(result.value);\n        const wasArray = isArray;\n        if (options.convert && this._flags.single && !isArray) {\n            result.value = [result.value];\n            isArray = true;\n        }\n\n        if (!isArray) {\n            result.errors = this.createError('array.base', null, state, options);\n            return result;\n        }\n\n        if (this._inner.inclusions.length ||\n            this._inner.exclusions.length ||\n            this._inner.requireds.length ||\n            this._inner.ordereds.length ||\n            !this._flags.sparse) {\n\n            // Clone the array so that we don't modify the original\n            if (wasArray) {\n                result.value = result.value.slice(0);\n            }\n\n            result.errors = this._checkItems(result.value, wasArray, state, options);\n\n            if (result.errors && wasArray && options.convert && this._flags.single) {\n\n                // Attempt a 2nd pass by putting the array inside one.\n                const previousErrors = result.errors;\n\n                result.value = [result.value];\n                result.errors = this._checkItems(result.value, wasArray, state, options);\n\n                if (result.errors) {\n\n                    // Restore previous errors and value since this didn't validate either.\n                    result.errors = previousErrors;\n                    result.value = result.value[0];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    _checkItems(items, wasArray, state, options) {\n\n        const errors = [];\n        let errored;\n\n        const requireds = this._inner.requireds.slice();\n        const ordereds = this._inner.ordereds.slice();\n        const inclusions = [...this._inner.inclusions, ...requireds];\n\n        let il = items.length;\n        for (let i = 0; i < il; ++i) {\n            errored = false;\n            const item = items[i];\n            let isValid = false;\n            const key = wasArray ? i : state.key;\n            const path = wasArray ? [...state.path, i] : state.path;\n            const localState = new State(key, path, state.parent, state.reference);\n            let res;\n\n            // Sparse\n\n            if (!this._flags.sparse && item === undefined) {\n                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                ordereds.shift();\n\n                continue;\n            }\n\n            // Exclusions\n\n            for (let j = 0; j < this._inner.exclusions.length; ++j) {\n                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults\n\n                if (!res.errors) {\n                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    ordereds.shift();\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            // Ordered\n            if (this._inner.ordereds.length) {\n                if (ordereds.length > 0) {\n                    const ordered = ordereds.shift();\n                    res = ordered._validate(item, localState, options);\n                    if (!res.errors) {\n                        if (ordered._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                            if (options.abortEarly) {\n                                return errors;\n                            }\n\n                            continue;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                    }\n                    else {\n                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    continue;\n                }\n                else if (!this._inner.items.length) {\n                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    continue;\n                }\n            }\n\n            // Requireds\n\n            const requiredChecks = [];\n            let jl = requireds.length;\n            for (let j = 0; j < jl; ++j) {\n                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n                if (!res.errors) {\n                    items[i] = res.value;\n                    isValid = true;\n                    internals.fastSplice(requireds, j);\n                    --j;\n                    --jl;\n\n                    if (!this._flags.sparse && res.value === undefined) {\n                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            if (isValid) {\n                continue;\n            }\n\n            // Inclusions\n\n            const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n\n            jl = inclusions.length;\n            for (let j = 0; j < jl; ++j) {\n                const inclusion = inclusions[j];\n\n                // Avoid re-running requireds that already didn't match in the previous loop\n                const previousCheck = requireds.indexOf(inclusion);\n                if (previousCheck !== -1) {\n                    res = requiredChecks[previousCheck];\n                }\n                else {\n                    res = inclusion._validate(item, localState, options);\n\n                    if (!res.errors) {\n                        if (inclusion._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n                            errored = true;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n\n                        isValid = true;\n                        break;\n                    }\n                }\n\n                // Return the actual error if only one inclusion defined\n                if (jl === 1) {\n                    if (stripUnknown) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                        isValid = true;\n                        break;\n                    }\n\n                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            if (this._inner.inclusions.length && !isValid) {\n                if (stripUnknown) {\n                    internals.fastSplice(items, i);\n                    --i;\n                    --il;\n                    continue;\n                }\n\n                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n            }\n        }\n\n        if (requireds.length) {\n            this._fillMissedErrors(errors, requireds, state, options);\n        }\n\n        if (ordereds.length) {\n            this._fillOrderedErrors(errors, ordereds, state, options);\n        }\n\n        return errors.length ? errors : null;\n    }\n\n    describe() {\n\n        const description = super.describe();\n\n        if (this._inner.ordereds.length) {\n            description.orderedItems = [];\n\n            for (let i = 0; i < this._inner.ordereds.length; ++i) {\n                description.orderedItems.push(this._inner.ordereds[i].describe());\n            }\n        }\n\n        if (this._inner.items.length) {\n            description.items = [];\n\n            for (let i = 0; i < this._inner.items.length; ++i) {\n                description.items.push(this._inner.items[i].describe());\n            }\n        }\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                if (rule.name === 'has') {\n                    rule.arg = rule.arg.describe();\n                }\n            }\n        }\n\n        return description;\n    }\n\n    items(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n\n                castErr.message = `${castErr.message}(${castErr.path})`;\n                throw castErr;\n            }\n\n            obj._inner.items.push(type);\n\n            if (type._flags.presence === 'required') {\n                obj._inner.requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                obj._inner.exclusions.push(type.optional());\n            }\n            else {\n                obj._inner.inclusions.push(type);\n            }\n        });\n\n        return obj;\n    }\n\n    ordered(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n\n                castErr.message = `${castErr.message}(${castErr.path})`;\n                throw castErr;\n            }\n\n            obj._inner.ordereds.push(type);\n        });\n\n        return obj;\n    }\n\n    min(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('min', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit, value: compareTo }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length >= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('max', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length <= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('length', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length === compareTo) {\n                return value;\n            }\n\n            return this.createError('array.length', { limit, value }, state, options);\n        });\n    }\n\n    has(schema) {\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        return this._test('has', schema, function (value, state, options) {\n\n            const isValid = value.some((item, idx) => {\n\n                const localState = new State(idx, [...state.path, idx], state.key, state.reference);\n                return !schema._validate(item, localState, options).errors;\n            });\n\n            if (isValid) {\n                return value;\n            }\n\n            const patternLabel = schema._getLabel();\n            if (patternLabel) {\n                return this.createError('array.hasKnown', { patternLabel }, state, options);\n            }\n\n            return this.createError('array.hasUnknown', null, state, options);\n        });\n    }\n\n    unique(comparator, configs) {\n\n        Hoek.assert(comparator === undefined ||\n            typeof comparator === 'function' ||\n            typeof comparator === 'string', 'comparator must be a function or a string');\n\n        Hoek.assert(configs === undefined ||\n            typeof configs === 'object', 'configs must be an object');\n\n        const settings = {\n            ignoreUndefined: (configs && configs.ignoreUndefined) || false\n        };\n\n\n        if (typeof comparator === 'string') {\n            settings.path = comparator;\n        }\n        else if (typeof comparator === 'function') {\n            settings.comparator = comparator;\n        }\n\n        return this._test('unique', settings, function (value, state, options) {\n\n            const found = {\n                string: Object.create(null),\n                number: Object.create(null),\n                undefined: Object.create(null),\n                boolean: Object.create(null),\n                object: new Map(),\n                function: new Map(),\n                custom: new Map()\n            };\n\n            const compare = settings.comparator || Hoek.deepEqual;\n            const ignoreUndefined = settings.ignoreUndefined;\n\n            for (let i = 0; i < value.length; ++i) {\n                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n                const records = settings.comparator ? found.custom : found[typeof item];\n\n                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n                // I still want to keep the test for future js versions with new types (eg. Symbol).\n                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (settings.path) {\n                                    context.path = settings.path;\n                                }\n\n                                return this.createError('array.unique', context, localState, options);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                            const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (settings.path) {\n                                context.path = settings.path;\n                            }\n\n                            return this.createError('array.unique', context, localState, options);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n            }\n\n            return value;\n        });\n    }\n\n    sparse(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.sparse === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.sparse = value;\n        return obj;\n    }\n\n    single(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.single === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.single = value;\n        return obj;\n    }\n\n    _fillMissedErrors(errors, requireds, state, options) {\n\n        const knownMisses = [];\n        let unknownMisses = 0;\n        for (let i = 0; i < requireds.length; ++i) {\n            const label = requireds[i]._getLabel();\n            if (label) {\n                knownMisses.push(label);\n            }\n            else {\n                ++unknownMisses;\n            }\n        }\n\n        if (knownMisses.length) {\n            if (unknownMisses) {\n                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));\n            }\n            else {\n                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));\n            }\n        }\n        else {\n            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));\n        }\n    }\n\n\n    _fillOrderedErrors(errors, ordereds, state, options) {\n\n        const requiredOrdereds = [];\n\n        for (let i = 0; i < ordereds.length; ++i) {\n            const presence = Hoek.reach(ordereds[i], '_flags.presence');\n            if (presence === 'required') {\n                requiredOrdereds.push(ordereds[i]);\n            }\n        }\n\n        if (requiredOrdereds.length) {\n            this._fillMissedErrors(errors, requiredOrdereds, state, options);\n        }\n    }\n\n};\n\n\nmodule.exports = new internals.Array();\n"]},"metadata":{},"sourceType":"script"}