{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionRest;\n\nvar _core = require(\"@babel/core\");\n\nconst buildRest = (0, _core.template)(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\nconst restIndex = (0, _core.template)(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\nconst restIndexImpure = (0, _core.template)(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\nconst restLength = (0, _core.template)(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\n\nfunction referencesRest(path, state) {\n  if (path.node.name === state.name) {\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n\n  return false;\n}\n\nconst memberExpressionOptimisationVisitor = {\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n\n  Flow(path) {\n    if (path.isTypeCastExpression()) return;\n    path.skip();\n  },\n\n  Function(path, state) {\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, state) {\n    const {\n      node\n    } = path;\n\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    if (!referencesRest(path, state)) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const {\n        parentPath\n      } = path;\n\n      if (parentPath.listKey === \"params\" && parentPath.key < state.offset) {\n        return;\n      }\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        const grandparentPath = parentPath.parentPath;\n        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({\n          operator: \"delete\"\n        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({\n                cause: \"indexGetter\",\n                path\n              });\n              return;\n            }\n          } else if (parentPath.node.property.name === \"length\") {\n            state.candidates.push({\n              cause: \"lengthGetter\",\n              path\n            });\n            return;\n          }\n        }\n      }\n\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({\n            cause: \"argSpread\",\n            path\n          });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  }\n\n};\n\nfunction getParamsCount(node) {\n  let count = node.params.length;\n\n  if (count > 0 && _core.types.isIdentifier(node.params[0], {\n    name: \"this\"\n  })) {\n    count -= 1;\n  }\n\n  return count;\n}\n\nfunction hasRest(node) {\n  const length = node.params.length;\n  return length > 0 && _core.types.isRestElement(node.params[length - 1]);\n}\n\nfunction optimiseIndexGetter(path, argsId, offset) {\n  const offsetLiteral = _core.types.numericLiteral(offset);\n\n  let index;\n\n  if (_core.types.isNumericLiteral(path.parent.property)) {\n    index = _core.types.numericLiteral(path.parent.property.value + offset);\n  } else if (offset === 0) {\n    index = path.parent.property;\n  } else {\n    index = _core.types.binaryExpression(\"+\", path.parent.property, _core.types.cloneNode(offsetLiteral));\n  }\n\n  const {\n    scope\n  } = path;\n\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({\n      id: temp,\n      kind: \"var\"\n    });\n    path.parentPath.replaceWith(restIndexImpure({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index,\n      REF: _core.types.cloneNode(temp)\n    }));\n  } else {\n    const parentPath = path.parentPath;\n    parentPath.replaceWith(restIndex({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index\n    }));\n    const offsetTestPath = parentPath.get(\"test\").get(\"left\");\n    const valRes = offsetTestPath.evaluate();\n\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        parentPath.replaceWith(parentPath.scope.buildUndefinedNode());\n      } else {\n        parentPath.get(\"test\").replaceWith(parentPath.get(\"test\").get(\"right\"));\n      }\n    }\n  }\n}\n\nfunction optimiseLengthGetter(path, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(restLength({\n      ARGUMENTS: argsId,\n      OFFSET: _core.types.numericLiteral(offset)\n    }));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nfunction convertFunctionRest(path) {\n  const {\n    node,\n    scope\n  } = path;\n  if (!hasRest(node)) return false;\n  let rest = node.params.pop().argument;\n\n  const argsId = _core.types.identifier(\"arguments\");\n\n  if (_core.types.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n\n    const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(pattern, rest)]);\n\n    node.body.body.unshift(declar);\n  }\n\n  const paramsCount = getParamsCount(node);\n  const state = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false\n  };\n  path.traverse(memberExpressionOptimisationVisitor, state);\n\n  if (!state.deopted && !state.references.length) {\n    for (const {\n      path,\n      cause\n    } of state.candidates) {\n      const clonedArgsId = _core.types.cloneNode(argsId);\n\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n\n    return true;\n  }\n\n  state.references = state.references.concat(state.candidates.map(({\n    path\n  }) => path));\n\n  const start = _core.types.numericLiteral(paramsCount);\n\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n  let arrKey, arrLen;\n\n  if (paramsCount) {\n    arrKey = _core.types.binaryExpression(\"-\", _core.types.cloneNode(key), _core.types.cloneNode(start));\n    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(\">\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression(\"-\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));\n  } else {\n    arrKey = _core.types.identifier(key.name);\n    arrLen = _core.types.identifier(len.name);\n  }\n\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len\n  });\n\n  if (state.deopted) {\n    node.body.body.unshift(loop);\n  } else {\n    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        return path.isFunction();\n      }\n    });\n    target.insertBefore(loop);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-transform-parameters/lib/rest.js"],"names":["Object","defineProperty","exports","value","default","convertFunctionRest","_core","require","buildRest","template","restIndex","restIndexImpure","restLength","referencesRest","path","state","node","name","scope","bindingIdentifierEquals","outerBinding","memberExpressionOptimisationVisitor","Scope","skip","Flow","isTypeCastExpression","Function","oldNoOptimise","noOptimise","traverse","ReferencedIdentifier","deopted","parentPath","listKey","key","offset","isMemberExpression","object","grandparentPath","argsOptEligible","isAssignmentExpression","left","isLVal","isForXStatement","isUpdateExpression","isUnaryExpression","operator","isCallExpression","isNewExpression","callee","computed","get","isBaseType","candidates","push","cause","property","isSpreadElement","call","arguments","length","references","BindingIdentifier","getParamsCount","count","params","types","isIdentifier","hasRest","isRestElement","optimiseIndexGetter","argsId","offsetLiteral","numericLiteral","index","isNumericLiteral","parent","binaryExpression","cloneNode","isPure","temp","generateUidIdentifierBasedOnNode","id","kind","replaceWith","ARGUMENTS","OFFSET","INDEX","REF","offsetTestPath","valRes","evaluate","confident","buildUndefinedNode","optimiseLengthGetter","rest","pop","argument","identifier","isPattern","pattern","generateUidIdentifier","declar","variableDeclaration","variableDeclarator","body","unshift","paramsCount","argumentsNode","getBindingIdentifier","clonedArgsId","concat","map","start","len","arrKey","arrLen","conditionalExpression","loop","ARRAY_KEY","ARRAY_LEN","START","ARRAY","KEY","LEN","target","getEarliestCommonAncestorFrom","getStatementParent","findParent","isLoop","isFunction","insertBefore"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionRest;\n\nvar _core = require(\"@babel/core\");\n\nconst buildRest = (0, _core.template)(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\nconst restIndex = (0, _core.template)(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\nconst restIndexImpure = (0, _core.template)(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\nconst restLength = (0, _core.template)(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\n\nfunction referencesRest(path, state) {\n  if (path.node.name === state.name) {\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n\n  return false;\n}\n\nconst memberExpressionOptimisationVisitor = {\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n\n  Flow(path) {\n    if (path.isTypeCastExpression()) return;\n    path.skip();\n  },\n\n  Function(path, state) {\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, state) {\n    const {\n      node\n    } = path;\n\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    if (!referencesRest(path, state)) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const {\n        parentPath\n      } = path;\n\n      if (parentPath.listKey === \"params\" && parentPath.key < state.offset) {\n        return;\n      }\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        const grandparentPath = parentPath.parentPath;\n        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({\n          operator: \"delete\"\n        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({\n                cause: \"indexGetter\",\n                path\n              });\n              return;\n            }\n          } else if (parentPath.node.property.name === \"length\") {\n            state.candidates.push({\n              cause: \"lengthGetter\",\n              path\n            });\n            return;\n          }\n        }\n      }\n\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({\n            cause: \"argSpread\",\n            path\n          });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  }\n\n};\n\nfunction getParamsCount(node) {\n  let count = node.params.length;\n\n  if (count > 0 && _core.types.isIdentifier(node.params[0], {\n    name: \"this\"\n  })) {\n    count -= 1;\n  }\n\n  return count;\n}\n\nfunction hasRest(node) {\n  const length = node.params.length;\n  return length > 0 && _core.types.isRestElement(node.params[length - 1]);\n}\n\nfunction optimiseIndexGetter(path, argsId, offset) {\n  const offsetLiteral = _core.types.numericLiteral(offset);\n\n  let index;\n\n  if (_core.types.isNumericLiteral(path.parent.property)) {\n    index = _core.types.numericLiteral(path.parent.property.value + offset);\n  } else if (offset === 0) {\n    index = path.parent.property;\n  } else {\n    index = _core.types.binaryExpression(\"+\", path.parent.property, _core.types.cloneNode(offsetLiteral));\n  }\n\n  const {\n    scope\n  } = path;\n\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({\n      id: temp,\n      kind: \"var\"\n    });\n    path.parentPath.replaceWith(restIndexImpure({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index,\n      REF: _core.types.cloneNode(temp)\n    }));\n  } else {\n    const parentPath = path.parentPath;\n    parentPath.replaceWith(restIndex({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index\n    }));\n    const offsetTestPath = parentPath.get(\"test\").get(\"left\");\n    const valRes = offsetTestPath.evaluate();\n\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        parentPath.replaceWith(parentPath.scope.buildUndefinedNode());\n      } else {\n        parentPath.get(\"test\").replaceWith(parentPath.get(\"test\").get(\"right\"));\n      }\n    }\n  }\n}\n\nfunction optimiseLengthGetter(path, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(restLength({\n      ARGUMENTS: argsId,\n      OFFSET: _core.types.numericLiteral(offset)\n    }));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nfunction convertFunctionRest(path) {\n  const {\n    node,\n    scope\n  } = path;\n  if (!hasRest(node)) return false;\n  let rest = node.params.pop().argument;\n\n  const argsId = _core.types.identifier(\"arguments\");\n\n  if (_core.types.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n\n    const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(pattern, rest)]);\n\n    node.body.body.unshift(declar);\n  }\n\n  const paramsCount = getParamsCount(node);\n  const state = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false\n  };\n  path.traverse(memberExpressionOptimisationVisitor, state);\n\n  if (!state.deopted && !state.references.length) {\n    for (const {\n      path,\n      cause\n    } of state.candidates) {\n      const clonedArgsId = _core.types.cloneNode(argsId);\n\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n\n    return true;\n  }\n\n  state.references = state.references.concat(state.candidates.map(({\n    path\n  }) => path));\n\n  const start = _core.types.numericLiteral(paramsCount);\n\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n  let arrKey, arrLen;\n\n  if (paramsCount) {\n    arrKey = _core.types.binaryExpression(\"-\", _core.types.cloneNode(key), _core.types.cloneNode(start));\n    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(\">\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression(\"-\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));\n  } else {\n    arrKey = _core.types.identifier(key.name);\n    arrLen = _core.types.identifier(len.name);\n  }\n\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len\n  });\n\n  if (state.deopted) {\n    node.body.body.unshift(loop);\n  } else {\n    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        return path.isFunction();\n      }\n    });\n    target.insertBefore(loop);\n  }\n\n  return true;\n}"]},"metadata":{},"sourceType":"script"}