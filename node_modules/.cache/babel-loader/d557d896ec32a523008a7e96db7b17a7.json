{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxObjectRestSpread = _interopRequireDefault(require(\"@babel/plugin-syntax-object-rest-spread\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _pluginTransformParameters = require(\"@babel/plugin-transform-parameters\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst ZERO_REFS = (() => {\n  const node = _core.types.identifier(\"a\");\n\n  const property = _core.types.objectProperty(_core.types.identifier(\"key\"), node);\n\n  const pattern = _core.types.objectPattern([property]);\n\n  return _core.types.isReferenced(node, property, pattern) ? 1 : 0;\n})();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false,\n    loose = false\n  } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  function getExtendsHelper(file) {\n    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n\n  function hasRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n\n  function hasObjectPatternRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n\n  function visitRestElements(path, visitor) {\n    path.traverse({\n      Expression(path) {\n        const parentType = path.parent.type;\n\n        if (parentType === \"AssignmentPattern\" && path.key === \"right\" || parentType === \"ObjectProperty\" && path.parent.computed && path.key === \"key\") {\n          path.skip();\n        }\n      },\n\n      RestElement: visitor\n    });\n  }\n\n  function hasSpread(node) {\n    for (const prop of node.properties) {\n      if (_core.types.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function extractNormalizedKeys(path) {\n    const props = path.node.properties;\n    const keys = [];\n    let allLiteral = true;\n\n    for (const prop of props) {\n      if (_core.types.isIdentifier(prop.key) && !prop.computed) {\n        keys.push(_core.types.stringLiteral(prop.key.name));\n      } else if (_core.types.isTemplateLiteral(prop.key)) {\n        keys.push(_core.types.cloneNode(prop.key));\n      } else if (_core.types.isLiteral(prop.key)) {\n        keys.push(_core.types.stringLiteral(String(prop.key.value)));\n      } else {\n        keys.push(_core.types.cloneNode(prop.key));\n        allLiteral = false;\n      }\n    }\n\n    return {\n      keys,\n      allLiteral\n    };\n  }\n\n  function replaceImpureComputedKeys(properties, scope) {\n    const impureComputedPropertyDeclarators = [];\n\n    for (const propPath of properties) {\n      const key = propPath.get(\"key\");\n\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n\n        const declarator = _core.types.variableDeclarator(_core.types.identifier(name), key.node);\n\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(_core.types.identifier(name));\n      }\n    }\n\n    return impureComputedPropertyDeclarators;\n  }\n\n  function removeUnusedExcludedKeys(path) {\n    const bindings = path.getOuterBindingIdentifierPaths();\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n\n      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {\n        return;\n      }\n\n      bindingParentPath.remove();\n    });\n  }\n\n  function createObjectSpread(path, file, objRef) {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n\n    _core.types.assertRestElement(last.node);\n\n    const restElement = _core.types.cloneNode(last.node);\n\n    last.remove();\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get(\"properties\"), path.scope);\n    const {\n      keys,\n      allLiteral\n    } = extractNormalizedKeys(path);\n\n    if (keys.length === 0) {\n      return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(getExtendsHelper(file), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)])];\n    }\n\n    let keyExpression;\n\n    if (!allLiteral) {\n      keyExpression = _core.types.callExpression(_core.types.memberExpression(_core.types.arrayExpression(keys), _core.types.identifier(\"map\")), [file.addHelper(\"toPropertyKey\")]);\n    } else {\n      keyExpression = _core.types.arrayExpression(keys);\n    }\n\n    return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(file.addHelper(`objectWithoutProperties${loose ? \"Loose\" : \"\"}`), [_core.types.cloneNode(objRef), keyExpression])];\n  }\n\n  function replaceRestElement(parentPath, paramPath, container) {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(paramPath.node, uid)]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n\n      paramPath.replaceWith(_core.types.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"proposal-object-rest-spread\",\n    inherits: _pluginSyntaxObjectRestSpread.default,\n    visitor: {\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set();\n        const idsInRestParams = new Set();\n\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        let idInRest = false;\n\n        const IdentifierHandler = function (path, functionScope) {\n          const name = path.node.name;\n\n          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i;\n\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(path, path.scope);\n            } else {\n              param.traverse({\n                \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler\n              }, path.scope);\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(param.parentPath, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);\n\n          (0, _pluginTransformParameters.convertFunctionParams)(path, loose, shouldTransformParam, replaceRestElement);\n        }\n      },\n\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n\n          if (originalPath.node.id.properties.length > 1 && !_core.types.isIdentifier(originalPath.node.init)) {\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, \"ref\");\n            originalPath.insertBefore(_core.types.variableDeclarator(initRef, originalPath.node.init));\n            originalPath.replaceWith(_core.types.variableDeclarator(originalPath.node.id, _core.types.cloneNode(initRef)));\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath = [];\n          let kind;\n          path.findParent(path => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);\n          refPropertyPath.forEach(prop => {\n            const {\n              node\n            } = prop;\n            ref = _core.types.memberExpression(ref, _core.types.cloneNode(node.key), node.computed || _core.types.isLiteral(node.key));\n          });\n          const objectPatternPath = path.findParent(path => path.isObjectPattern());\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(objectPatternPath, file, ref);\n\n          if (loose) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          _core.types.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n          insertionPath.insertAfter(_core.types.variableDeclarator(argument, callExpression));\n          insertionPath = insertionPath.getSibling(insertionPath.key + 1);\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();\n          }\n        });\n      },\n\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        const hasRest = declaration.get(\"declarations\").some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {\n          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(paramPath.parentPath, paramPath);\n      },\n\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n          const refName = path.scope.generateUidBasedOnNode(path.node.right, \"ref\");\n          nodes.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(refName), path.node.right)]));\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(leftPath, file, _core.types.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(_core.types.variableDeclaration(\"var\", impureComputedPropertyDeclarators));\n          }\n\n          const nodeWithoutSpread = _core.types.cloneNode(path.node);\n\n          nodeWithoutSpread.right = _core.types.identifier(refName);\n          nodes.push(_core.types.expressionStatement(nodeWithoutSpread));\n          nodes.push(_core.types.toStatement(_core.types.assignmentExpression(\"=\", argument, callExpression)));\n          nodes.push(_core.types.expressionStatement(_core.types.identifier(refName)));\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n\n        if (!_core.types.isVariableDeclaration(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n\n          if (node.body.body.length === 0 && path.isCompletionRecord()) {\n            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, _core.types.cloneNode(temp))));\n        } else {\n          const pattern = left.declarations[0].id;\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);\n          path.ensureBlock();\n          node.body.body.unshift(_core.types.variableDeclaration(node.left.kind, [_core.types.variableDeclarator(pattern, _core.types.cloneNode(key))]));\n        }\n      },\n\n      ArrayPattern(path) {\n        const objectPatterns = [];\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n\n          const objectPattern = path.parentPath;\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(_core.types.variableDeclarator(objectPattern.node, uid));\n          objectPattern.replaceWith(_core.types.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          statementPath.insertAfter(_core.types.variableDeclaration(statementPath.node.kind || \"var\", objectPatterns));\n        }\n      },\n\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n        let helper;\n\n        if (loose) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch (_unused) {\n            this.file.declarations[\"objectSpread2\"] = null;\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n\n        let exp = null;\n        let props = [];\n\n        function make() {\n          const hadProps = props.length > 0;\n\n          const obj = _core.types.objectExpression(props);\n\n          props = [];\n\n          if (!exp) {\n            exp = _core.types.callExpression(helper, [obj]);\n            return;\n          }\n\n          if (loose) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n\n            return;\n          }\n\n          exp = _core.types.callExpression(_core.types.cloneNode(helper), [exp, ...(hadProps ? [_core.types.objectExpression([]), obj] : [])]);\n        }\n\n        for (const prop of path.node.properties) {\n          if (_core.types.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) make();\n        path.replaceWith(exp);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"sources":["/home/agatha/open/node_modules/@babel/plugin-proposal-object-rest-spread/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_pluginSyntaxObjectRestSpread","_interopRequireDefault","_core","_pluginTransformParameters","obj","__esModule","ZERO_REFS","node","types","identifier","property","objectProperty","pattern","objectPattern","isReferenced","_default","declare","api","opts","assertVersion","useBuiltIns","loose","Error","getExtendsHelper","file","memberExpression","addHelper","hasRestElement","path","foundRestElement","visitRestElements","restElement","stop","hasObjectPatternRestElement","parentPath","isObjectPattern","visitor","traverse","Expression","parentType","parent","type","key","computed","skip","RestElement","hasSpread","prop","properties","isSpreadElement","extractNormalizedKeys","props","keys","allLiteral","isIdentifier","push","stringLiteral","name","isTemplateLiteral","cloneNode","isLiteral","String","replaceImpureComputedKeys","scope","impureComputedPropertyDeclarators","propPath","get","isPure","generateUidBasedOnNode","declarator","variableDeclarator","replaceWith","removeUnusedExcludedKeys","bindings","getOuterBindingIdentifierPaths","forEach","bindingName","bindingParentPath","getBinding","references","isObjectProperty","remove","createObjectSpread","objRef","last","length","assertRestElement","argument","callExpression","objectExpression","keyExpression","arrayExpression","replaceRestElement","paramPath","container","isAssignmentPattern","isArrayPattern","elements","i","uid","generateUidIdentifier","declar","variableDeclaration","ensureBlock","unshiftContainer","inherits","Function","params","paramsWithRestElement","Set","idsInRestParams","param","add","getBindingIdentifiers","idInRest","IdentifierHandler","functionScope","has","isReferencedIdentifier","isBindingIdentifier","shouldTransformParam","idx","convertFunctionParams","VariableDeclarator","insertionPath","originalPath","id","init","initRef","generateUidIdentifierBasedOnNode","insertBefore","ref","refPropertyPath","kind","findParent","unshift","isVariableDeclarator","impureObjRefComputedDeclarators","objectPatternPath","assertIdentifier","insertAfter","getSibling","registerBinding","ExportNamedDeclaration","declaration","isVariableDeclaration","hasRest","some","specifiers","getOuterBindingIdentifiers","exportSpecifier","exportNamedDeclaration","CatchClause","AssignmentExpression","leftPath","nodes","refName","right","nodeWithoutSpread","expressionStatement","toStatement","assignmentExpression","replaceWithMultiple","ForXStatement","left","temp","body","isCompletionRecord","buildUndefinedNode","declarations","ArrayPattern","objectPatterns","statementPath","getStatementParent","ObjectExpression","helper","_unused","exp","make","hadProps","arguments"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxObjectRestSpread = _interopRequireDefault(require(\"@babel/plugin-syntax-object-rest-spread\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _pluginTransformParameters = require(\"@babel/plugin-transform-parameters\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst ZERO_REFS = (() => {\n  const node = _core.types.identifier(\"a\");\n\n  const property = _core.types.objectProperty(_core.types.identifier(\"key\"), node);\n\n  const pattern = _core.types.objectPattern([property]);\n\n  return _core.types.isReferenced(node, property, pattern) ? 1 : 0;\n})();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false,\n    loose = false\n  } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  function getExtendsHelper(file) {\n    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n\n  function hasRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n\n  function hasObjectPatternRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n\n  function visitRestElements(path, visitor) {\n    path.traverse({\n      Expression(path) {\n        const parentType = path.parent.type;\n\n        if (parentType === \"AssignmentPattern\" && path.key === \"right\" || parentType === \"ObjectProperty\" && path.parent.computed && path.key === \"key\") {\n          path.skip();\n        }\n      },\n\n      RestElement: visitor\n    });\n  }\n\n  function hasSpread(node) {\n    for (const prop of node.properties) {\n      if (_core.types.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function extractNormalizedKeys(path) {\n    const props = path.node.properties;\n    const keys = [];\n    let allLiteral = true;\n\n    for (const prop of props) {\n      if (_core.types.isIdentifier(prop.key) && !prop.computed) {\n        keys.push(_core.types.stringLiteral(prop.key.name));\n      } else if (_core.types.isTemplateLiteral(prop.key)) {\n        keys.push(_core.types.cloneNode(prop.key));\n      } else if (_core.types.isLiteral(prop.key)) {\n        keys.push(_core.types.stringLiteral(String(prop.key.value)));\n      } else {\n        keys.push(_core.types.cloneNode(prop.key));\n        allLiteral = false;\n      }\n    }\n\n    return {\n      keys,\n      allLiteral\n    };\n  }\n\n  function replaceImpureComputedKeys(properties, scope) {\n    const impureComputedPropertyDeclarators = [];\n\n    for (const propPath of properties) {\n      const key = propPath.get(\"key\");\n\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n\n        const declarator = _core.types.variableDeclarator(_core.types.identifier(name), key.node);\n\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(_core.types.identifier(name));\n      }\n    }\n\n    return impureComputedPropertyDeclarators;\n  }\n\n  function removeUnusedExcludedKeys(path) {\n    const bindings = path.getOuterBindingIdentifierPaths();\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n\n      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {\n        return;\n      }\n\n      bindingParentPath.remove();\n    });\n  }\n\n  function createObjectSpread(path, file, objRef) {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n\n    _core.types.assertRestElement(last.node);\n\n    const restElement = _core.types.cloneNode(last.node);\n\n    last.remove();\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get(\"properties\"), path.scope);\n    const {\n      keys,\n      allLiteral\n    } = extractNormalizedKeys(path);\n\n    if (keys.length === 0) {\n      return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(getExtendsHelper(file), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)])];\n    }\n\n    let keyExpression;\n\n    if (!allLiteral) {\n      keyExpression = _core.types.callExpression(_core.types.memberExpression(_core.types.arrayExpression(keys), _core.types.identifier(\"map\")), [file.addHelper(\"toPropertyKey\")]);\n    } else {\n      keyExpression = _core.types.arrayExpression(keys);\n    }\n\n    return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(file.addHelper(`objectWithoutProperties${loose ? \"Loose\" : \"\"}`), [_core.types.cloneNode(objRef), keyExpression])];\n  }\n\n  function replaceRestElement(parentPath, paramPath, container) {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(paramPath.node, uid)]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n\n      paramPath.replaceWith(_core.types.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"proposal-object-rest-spread\",\n    inherits: _pluginSyntaxObjectRestSpread.default,\n    visitor: {\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set();\n        const idsInRestParams = new Set();\n\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        let idInRest = false;\n\n        const IdentifierHandler = function (path, functionScope) {\n          const name = path.node.name;\n\n          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i;\n\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(path, path.scope);\n            } else {\n              param.traverse({\n                \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler\n              }, path.scope);\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(param.parentPath, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);\n\n          (0, _pluginTransformParameters.convertFunctionParams)(path, loose, shouldTransformParam, replaceRestElement);\n        }\n      },\n\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n\n          if (originalPath.node.id.properties.length > 1 && !_core.types.isIdentifier(originalPath.node.init)) {\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, \"ref\");\n            originalPath.insertBefore(_core.types.variableDeclarator(initRef, originalPath.node.init));\n            originalPath.replaceWith(_core.types.variableDeclarator(originalPath.node.id, _core.types.cloneNode(initRef)));\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath = [];\n          let kind;\n          path.findParent(path => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);\n          refPropertyPath.forEach(prop => {\n            const {\n              node\n            } = prop;\n            ref = _core.types.memberExpression(ref, _core.types.cloneNode(node.key), node.computed || _core.types.isLiteral(node.key));\n          });\n          const objectPatternPath = path.findParent(path => path.isObjectPattern());\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(objectPatternPath, file, ref);\n\n          if (loose) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          _core.types.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n          insertionPath.insertAfter(_core.types.variableDeclarator(argument, callExpression));\n          insertionPath = insertionPath.getSibling(insertionPath.key + 1);\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();\n          }\n        });\n      },\n\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        const hasRest = declaration.get(\"declarations\").some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {\n          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(paramPath.parentPath, paramPath);\n      },\n\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n          const refName = path.scope.generateUidBasedOnNode(path.node.right, \"ref\");\n          nodes.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(refName), path.node.right)]));\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(leftPath, file, _core.types.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(_core.types.variableDeclaration(\"var\", impureComputedPropertyDeclarators));\n          }\n\n          const nodeWithoutSpread = _core.types.cloneNode(path.node);\n\n          nodeWithoutSpread.right = _core.types.identifier(refName);\n          nodes.push(_core.types.expressionStatement(nodeWithoutSpread));\n          nodes.push(_core.types.toStatement(_core.types.assignmentExpression(\"=\", argument, callExpression)));\n          nodes.push(_core.types.expressionStatement(_core.types.identifier(refName)));\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n\n        if (!_core.types.isVariableDeclaration(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n\n          if (node.body.body.length === 0 && path.isCompletionRecord()) {\n            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, _core.types.cloneNode(temp))));\n        } else {\n          const pattern = left.declarations[0].id;\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);\n          path.ensureBlock();\n          node.body.body.unshift(_core.types.variableDeclaration(node.left.kind, [_core.types.variableDeclarator(pattern, _core.types.cloneNode(key))]));\n        }\n      },\n\n      ArrayPattern(path) {\n        const objectPatterns = [];\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n\n          const objectPattern = path.parentPath;\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(_core.types.variableDeclarator(objectPattern.node, uid));\n          objectPattern.replaceWith(_core.types.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          statementPath.insertAfter(_core.types.variableDeclaration(statementPath.node.kind || \"var\", objectPatterns));\n        }\n      },\n\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n        let helper;\n\n        if (loose) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch (_unused) {\n            this.file.declarations[\"objectSpread2\"] = null;\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n\n        let exp = null;\n        let props = [];\n\n        function make() {\n          const hadProps = props.length > 0;\n\n          const obj = _core.types.objectExpression(props);\n\n          props = [];\n\n          if (!exp) {\n            exp = _core.types.callExpression(helper, [obj]);\n            return;\n          }\n\n          if (loose) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n\n            return;\n          }\n\n          exp = _core.types.callExpression(_core.types.cloneNode(helper), [exp, ...(hadProps ? [_core.types.objectExpression([]), obj] : [])]);\n        }\n\n        for (const prop of path.node.properties) {\n          if (_core.types.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) make();\n        path.replaceWith(exp);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}