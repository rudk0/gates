{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar Reach = require('./reach');\n\nvar internals = {};\n\nexports.keys = function (obj) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj); // Defaults to true\n};\n\nexports.store = function (source, keys) {\n  var storage = new Map();\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    var value = Reach(source, key);\n\n    if (typeof value === 'object' || typeof value === 'function') {\n      storage.set(key, value);\n      internals.reachSet(source, key, undefined);\n    }\n  }\n\n  return storage;\n};\n\nexports.restore = function (copy, source, storage) {\n  var _iterator = _createForOfIteratorHelper(storage),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          value = _step$value[1];\n\n      internals.reachSet(copy, key, value);\n      internals.reachSet(source, key, value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\ninternals.reachSet = function (obj, key, value) {\n  var path = Array.isArray(key) ? key : key.split('.');\n  var ref = obj;\n\n  for (var i = 0; i < path.length; ++i) {\n    var segment = path[i];\n\n    if (i + 1 === path.length) {\n      ref[segment] = value;\n    }\n\n    ref = ref[segment];\n  }\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/hoek/lib/utils.js"],"names":["Reach","require","internals","exports","keys","obj","options","symbols","Reflect","ownKeys","Object","getOwnPropertyNames","store","source","storage","Map","i","length","key","value","set","reachSet","undefined","restore","copy","path","Array","isArray","split","ref","segment"],"mappings":"AAAA;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AAGA,IAAMC,SAAS,GAAG,EAAlB;;AAGAC,OAAO,CAACC,IAAR,GAAe,UAAUC,GAAV,EAA6B;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAExC,SAAOA,OAAO,CAACC,OAAR,KAAoB,KAApB,GAA4BC,OAAO,CAACC,OAAR,CAAgBJ,GAAhB,CAA5B,GAAmDK,MAAM,CAACC,mBAAP,CAA2BN,GAA3B,CAA1D,CAFwC,CAEoD;AAC/F,CAHD;;AAMAF,OAAO,CAACS,KAAR,GAAgB,UAAUC,MAAV,EAAkBT,IAAlB,EAAwB;AAEpC,MAAMU,OAAO,GAAG,IAAIC,GAAJ,EAAhB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,IAAI,CAACa,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAME,GAAG,GAAGd,IAAI,CAACY,CAAD,CAAhB;AACA,QAAMG,KAAK,GAAGnB,KAAK,CAACa,MAAD,EAASK,GAAT,CAAnB;;AACA,QAAI,OAAOC,KAAP,KAAiB,QAAjB,IACA,OAAOA,KAAP,KAAiB,UADrB,EACiC;AAE7BL,MAAAA,OAAO,CAACM,GAAR,CAAYF,GAAZ,EAAiBC,KAAjB;AACAjB,MAAAA,SAAS,CAACmB,QAAV,CAAmBR,MAAnB,EAA2BK,GAA3B,EAAgCI,SAAhC;AACH;AACJ;;AAED,SAAOR,OAAP;AACH,CAfD;;AAkBAX,OAAO,CAACoB,OAAR,GAAkB,UAAUC,IAAV,EAAgBX,MAAhB,EAAwBC,OAAxB,EAAiC;AAAA,6CAEpBA,OAFoB;AAAA;;AAAA;AAE/C,wDAAoC;AAAA;AAAA,UAAxBI,GAAwB;AAAA,UAAnBC,KAAmB;;AAChCjB,MAAAA,SAAS,CAACmB,QAAV,CAAmBG,IAAnB,EAAyBN,GAAzB,EAA8BC,KAA9B;AACAjB,MAAAA,SAAS,CAACmB,QAAV,CAAmBR,MAAnB,EAA2BK,GAA3B,EAAgCC,KAAhC;AACH;AAL8C;AAAA;AAAA;AAAA;AAAA;AAMlD,CAND;;AASAjB,SAAS,CAACmB,QAAV,GAAqB,UAAUhB,GAAV,EAAea,GAAf,EAAoBC,KAApB,EAA2B;AAE5C,MAAMM,IAAI,GAAGC,KAAK,CAACC,OAAN,CAAcT,GAAd,IAAqBA,GAArB,GAA2BA,GAAG,CAACU,KAAJ,CAAU,GAAV,CAAxC;AACA,MAAIC,GAAG,GAAGxB,GAAV;;AACA,OAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,IAAI,CAACR,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAMc,OAAO,GAAGL,IAAI,CAACT,CAAD,CAApB;;AACA,QAAIA,CAAC,GAAG,CAAJ,KAAUS,IAAI,CAACR,MAAnB,EAA2B;AACvBY,MAAAA,GAAG,CAACC,OAAD,CAAH,GAAeX,KAAf;AACH;;AAEDU,IAAAA,GAAG,GAAGA,GAAG,CAACC,OAAD,CAAT;AACH;AACJ,CAZD","sourcesContent":["'use strict';\n\nconst Reach = require('./reach');\n\n\nconst internals = {};\n\n\nexports.keys = function (obj, options = {}) {\n\n    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);  // Defaults to true\n};\n\n\nexports.store = function (source, keys) {\n\n    const storage = new Map();\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = Reach(source, key);\n        if (typeof value === 'object' ||\n            typeof value === 'function') {\n\n            storage.set(key, value);\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\nexports.restore = function (copy, source, storage) {\n\n    for (const [key, value] of storage) {\n        internals.reachSet(copy, key, value);\n        internals.reachSet(source, key, value);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = Array.isArray(key) ? key : key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n"]},"metadata":{},"sourceType":"script"}