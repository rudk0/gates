{"ast":null,"code":"import path, { extname, sep, resolve } from 'path';\nimport { walk } from 'estree-walker';\nimport util from 'util';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n  if (!extname(filename)) filename += ext;\n  return filename;\n};\n\nconst extractors = {\n  ArrayPattern(names, param) {\n    for (const element of param.elements) {\n      if (element) extractors[element.type](names, element);\n    }\n  },\n\n  AssignmentPattern(names, param) {\n    extractors[param.left.type](names, param.left);\n  },\n\n  Identifier(names, param) {\n    names.push(param.name);\n  },\n\n  MemberExpression() {},\n\n  ObjectPattern(names, param) {\n    for (const prop of param.properties) {\n      if (prop.type === 'RestElement') {\n        extractors.RestElement(names, prop);\n      } else {\n        extractors[prop.value.type](names, prop.value);\n      }\n    }\n  },\n\n  RestElement(names, param) {\n    extractors[param.argument.type](names, param.argument);\n  }\n\n};\n\nconst extractAssignedNames = function extractAssignedNames(param) {\n  const names = [];\n  extractors[param.type](names, param);\n  return names;\n};\n\nconst blockDeclarations = {\n  const: true,\n  let: true\n};\n\nclass Scope {\n  constructor(options = {}) {\n    this.parent = options.parent;\n    this.isBlockScope = !!options.block;\n    this.declarations = Object.create(null);\n\n    if (options.params) {\n      options.params.forEach(param => {\n        extractAssignedNames(param).forEach(name => {\n          this.declarations[name] = true;\n        });\n      });\n    }\n  }\n\n  addDeclaration(node, isBlockDeclaration, isVar) {\n    if (!isBlockDeclaration && this.isBlockScope) {\n      // it's a `var` or function node, and this\n      // is a block scope, so we need to go up\n      this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n    } else if (node.id) {\n      extractAssignedNames(node.id).forEach(name => {\n        this.declarations[name] = true;\n      });\n    }\n  }\n\n  contains(name) {\n    return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n  }\n\n}\n\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n  let scope = new Scope();\n  walk(ast, {\n    enter(node, parent) {\n      // function foo () {...}\n      // class Foo {...}\n      if (/(Function|Class)Declaration/.test(node.type)) {\n        scope.addDeclaration(node, false, false);\n      } // var foo = 1\n\n\n      if (node.type === 'VariableDeclaration') {\n        const kind = node.kind;\n        const isBlockDeclaration = blockDeclarations[kind];\n        node.declarations.forEach(declaration => {\n          scope.addDeclaration(declaration, isBlockDeclaration, true);\n        });\n      }\n\n      let newScope; // create new function scope\n\n      if (/Function/.test(node.type)) {\n        newScope = new Scope({\n          parent: scope,\n          block: false,\n          params: node.params\n        }); // named function expressions - the name is considered\n        // part of the function's scope\n\n        if (node.type === 'FunctionExpression' && node.id) {\n          newScope.addDeclaration(node, false, false);\n        }\n      } // create new block scope\n\n\n      if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n        newScope = new Scope({\n          parent: scope,\n          block: true\n        });\n      } // catch clause has its own block scope\n\n\n      if (node.type === 'CatchClause') {\n        newScope = new Scope({\n          parent: scope,\n          params: node.param ? [node.param] : [],\n          block: true\n        });\n      }\n\n      if (newScope) {\n        Object.defineProperty(node, propertyName, {\n          value: newScope,\n          configurable: true\n        });\n        scope = newScope;\n      }\n    },\n\n    leave(node) {\n      if (node[propertyName]) scope = scope.parent;\n    }\n\n  });\n  return scope;\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar utils = createCommonjsModule(function (module, exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n\n    return false;\n  };\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.exceedsLimit = (min, max, step = 1, limit) => {\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n\n  exports.escapeNode = (block, n = 0, type) => {\n    let node = block.nodes[n];\n    if (!node) return;\n\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n\n    return node.open === true || node.close === true;\n  };\n  /**\n   * Reduce an array of text nodes.\n   */\n\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n  /**\n   * Flatten an array\n   */\n\n\n  exports.flatten = (...args) => {\n    const result = [];\n\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n      }\n\n      return result;\n    };\n\n    flat(args);\n    return result;\n  };\n});\nvar utils_1 = utils.isInteger;\nvar utils_2 = utils.find;\nvar utils_3 = utils.exceedsLimit;\nvar utils_4 = utils.escapeNode;\nvar utils_5 = utils.encloseBrace;\nvar utils_6 = utils.isInvalidBrace;\nvar utils_7 = utils.isOpenOrClose;\nvar utils_8 = utils.reduce;\nvar utils_9 = utils.flatten;\n\nvar stringify = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n\n    return output;\n  };\n\n  return stringify(ast);\n};\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isNumber = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n\n  return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = Object.assign({\n    relaxZeros: true\n  }, options);\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange.cache = {};\n\ntoRegexRange.clearCache = () => toRegexRange.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber$1 = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify$1 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange_1(a, b, Object.assign({\n      wrap: false\n    }, options));\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange_1(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$1(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, Object.assign({\n      wrap: false\n    }, options));\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if (!isNumber$1(start) && start.length > 1 || !isNumber$1(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = Object.assign({}, options);\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber$1(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber$1(start) && isNumber$1(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fillRange(...args, Object.assign({}, options, {\n        wrap: false,\n        toRegex: true\n      }));\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fillRange(...args, options);\n\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand;\nvar constants = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n  CHAR_9: '9',\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n  CHAR_LOWERCASE_A: 'a',\n  CHAR_UPPERCASE_Z: 'Z',\n  CHAR_LOWERCASE_Z: 'z',\n  CHAR_LEFT_PARENTHESES: '(',\n  CHAR_RIGHT_PARENTHESES: ')',\n  CHAR_ASTERISK: '*',\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n  CHAR_AT: '@',\n  CHAR_BACKSLASH: '\\\\',\n  CHAR_BACKTICK: '`',\n  CHAR_CARRIAGE_RETURN: '\\r',\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n  CHAR_COLON: ':',\n  CHAR_COMMA: ',',\n  CHAR_DOLLAR: '$',\n  CHAR_DOT: '.',\n  CHAR_DOUBLE_QUOTE: '\"',\n  CHAR_EQUAL: '=',\n  CHAR_EXCLAMATION_MARK: '!',\n  CHAR_FORM_FEED: '\\f',\n  CHAR_FORWARD_SLASH: '/',\n  CHAR_HASH: '#',\n  CHAR_HYPHEN_MINUS: '-',\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n  CHAR_LEFT_CURLY_BRACE: '{',\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n  CHAR_LINE_FEED: '\\n',\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n  CHAR_PERCENT: '%',\n  CHAR_PLUS: '+',\n  CHAR_QUESTION_MARK: '?',\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n  CHAR_RIGHT_CURLY_BRACE: '}',\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n  CHAR_SEMICOLON: ';',\n  CHAR_SINGLE_QUOTE: '\\'',\n  CHAR_SPACE: ' ',\n  CHAR_TAB: '\\t',\n  CHAR_UNDERSCORE: '_',\n  CHAR_VERTICAL_LINE: '|',\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF'\n  /* \\uFEFF */\n\n};\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants;\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\n     * Escaped chars\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\n     * Left square bracket: '['\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Quotes: '|\"|`\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Left curly brace: '{'\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\n     * Right curly brace: '}'\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Comma: ','\n     */\n\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\n     * Dot: '.'\n     */\n\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\n     * Text\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nvar parse_1 = parse;\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n\n  return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nbraces.parse = (input, options = {}) => parse_1(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n\n  return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  return compile_1(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand_1(input, options); // filter out empty strings if specified\n\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  } // filter out duplicates if specified\n\n\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\n\n\nvar braces_1 = braces;\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = Object.assign({}, POSIX_CHARS, {\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n});\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHAR: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n  // Digits\n  CHAR_0: 48,\n  CHAR_9: 57,\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65,\n  CHAR_LOWERCASE_A: 97,\n  CHAR_UPPERCASE_Z: 90,\n  CHAR_LOWERCASE_Z: 122,\n  CHAR_LEFT_PARENTHESES: 40,\n  CHAR_RIGHT_PARENTHESES: 41,\n  CHAR_ASTERISK: 42,\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38,\n  CHAR_AT: 64,\n  CHAR_BACKWARD_SLASH: 92,\n  CHAR_CARRIAGE_RETURN: 13,\n  CHAR_CIRCUMFLEX_ACCENT: 94,\n  CHAR_COLON: 58,\n  CHAR_COMMA: 44,\n  CHAR_DOT: 46,\n  CHAR_DOUBLE_QUOTE: 34,\n  CHAR_EQUAL: 61,\n  CHAR_EXCLAMATION_MARK: 33,\n  CHAR_FORM_FEED: 12,\n  CHAR_FORWARD_SLASH: 47,\n  CHAR_GRAVE_ACCENT: 96,\n  CHAR_HASH: 35,\n  CHAR_HYPHEN_MINUS: 45,\n  CHAR_LEFT_ANGLE_BRACKET: 60,\n  CHAR_LEFT_CURLY_BRACE: 123,\n  CHAR_LEFT_SQUARE_BRACKET: 91,\n  CHAR_LINE_FEED: 10,\n  CHAR_NO_BREAK_SPACE: 160,\n  CHAR_PERCENT: 37,\n  CHAR_PLUS: 43,\n  CHAR_QUESTION_MARK: 63,\n  CHAR_RIGHT_ANGLE_BRACKET: 62,\n  CHAR_RIGHT_CURLY_BRACE: 125,\n  CHAR_RIGHT_SQUARE_BRACKET: 93,\n  CHAR_SEMICOLON: 59,\n  CHAR_SINGLE_QUOTE: 39,\n  CHAR_SPACE: 32,\n  CHAR_TAB: 9,\n  CHAR_UNDERSCORE: 95,\n  CHAR_VERTICAL_LINE: 124,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n  extglobChars(chars) {\n    return {\n      '!': {\n        type: 'negate',\n        open: '(?:(?!(?:',\n        close: `))${chars.STAR})`\n      },\n      '?': {\n        type: 'qmark',\n        open: '(?:',\n        close: ')?'\n      },\n      '+': {\n        type: 'plus',\n        open: '(?:',\n        close: ')+'\n      },\n      '*': {\n        type: 'star',\n        open: '(?:',\n        close: ')*'\n      },\n      '@': {\n        type: 'at',\n        open: '(?:',\n        close: ')'\n      }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n\n};\nvar utils$1 = createCommonjsModule(function (module, exports) {\n  const win32 = process.platform === 'win32';\n  const {\n    REGEX_SPECIAL_CHARS,\n    REGEX_SPECIAL_CHARS_GLOBAL,\n    REGEX_REMOVE_BACKSLASH\n  } = constants$1;\n\n  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\n  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n\n  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n\n  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n\n  exports.toPosixSlashes = str => str.replace(/\\\\/g, '/');\n\n  exports.removeBackslashes = str => {\n    return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n      return match === '\\\\' ? '' : match;\n    });\n  };\n\n  exports.supportsLookbehinds = () => {\n    let segs = process.version.slice(1).split('.');\n\n    if (segs.length === 3 && +segs[0] >= 9 || +segs[0] === 8 && +segs[1] >= 10) {\n      return true;\n    }\n\n    return false;\n  };\n\n  exports.isWindows = options => {\n    if (options && typeof options.windows === 'boolean') {\n      return options.windows;\n    }\n\n    return win32 === true || path.sep === '\\\\';\n  };\n\n  exports.escapeLast = (input, char, lastIdx) => {\n    let idx = input.lastIndexOf(char, lastIdx);\n    if (idx === -1) return input;\n    if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n    return input.slice(0, idx) + '\\\\' + input.slice(idx);\n  };\n});\nvar utils_1$1 = utils$1.isObject;\nvar utils_2$1 = utils$1.hasRegexChars;\nvar utils_3$1 = utils$1.isRegexChar;\nvar utils_4$1 = utils$1.escapeRegex;\nvar utils_5$1 = utils$1.toPosixSlashes;\nvar utils_6$1 = utils$1.removeBackslashes;\nvar utils_7$1 = utils$1.supportsLookbehinds;\nvar utils_8$1 = utils$1.isWindows;\nvar utils_9$1 = utils$1.escapeLast;\nconst {\n  CHAR_ASTERISK,\n\n  /* * */\n  CHAR_AT,\n\n  /* @ */\n  CHAR_BACKWARD_SLASH,\n\n  /* \\ */\n  CHAR_COMMA: CHAR_COMMA$1,\n\n  /* , */\n  CHAR_DOT: CHAR_DOT$1,\n\n  /* . */\n  CHAR_EXCLAMATION_MARK,\n\n  /* ! */\n  CHAR_FORWARD_SLASH,\n\n  /* / */\n  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,\n\n  /* { */\n  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,\n\n  /* ( */\n  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,\n\n  /* [ */\n  CHAR_PLUS,\n\n  /* + */\n  CHAR_QUESTION_MARK,\n\n  /* ? */\n  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,\n\n  /* } */\n  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,\n\n  /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1\n  /* ] */\n\n} = constants$1;\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\n\nvar scan = (input, options) => {\n  let opts = options || {};\n  let length = input.length - 1;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isGlob = false;\n  let backslashes = false;\n  let negated = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let braceEscaped = false;\n\n  let eos = () => index >= length;\n\n  let advance = () => {\n    prev = code;\n    return input.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = true;\n      next = advance();\n\n      if (next === CHAR_LEFT_CURLY_BRACE$1) {\n        braceEscaped = true;\n      }\n\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {\n      braces++;\n\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_LEFT_CURLY_BRACE$1) {\n          braces++;\n          continue;\n        }\n\n        if (!braceEscaped && next === CHAR_DOT$1 && (next = advance()) === CHAR_DOT$1) {\n          isGlob = true;\n          break;\n        }\n\n        if (!braceEscaped && next === CHAR_COMMA$1) {\n          isGlob = true;\n          break;\n        }\n\n        if (next === CHAR_RIGHT_CURLY_BRACE$1) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            break;\n          }\n        }\n      }\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      if (prev === CHAR_DOT$1 && index === start + 1) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (code === CHAR_ASTERISK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET$1) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    let isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_EXCLAMATION_MARK;\n\n    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES$1) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = true;\n      start++;\n      continue;\n    }\n\n    if (code === CHAR_LEFT_PARENTHESES$1) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_PARENTHESES$1) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    if (isGlob) {\n      break;\n    }\n  }\n\n  let prefix = '';\n  let orig = input;\n  let base = input;\n  let glob = '';\n\n  if (start > 0) {\n    prefix = input.slice(0, start);\n    input = input.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = input.slice(0, lastIndex);\n    glob = input.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = input;\n  } else {\n    base = input;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== input) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils$1.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils$1.removeBackslashes(base);\n    }\n  }\n\n  return {\n    prefix,\n    input: orig,\n    base,\n    glob,\n    negated,\n    isGlob\n  };\n};\n/**\n * Constants\n */\n\n\nconst {\n  MAX_LENGTH: MAX_LENGTH$1,\n  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,\n  REGEX_NON_SPECIAL_CHAR,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants$1;\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  let value = `[${args.join('-')}]`;\n\n  try {} catch (ex) {\n    return args.map(v => utils$1.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\nconst negate = state => {\n  let count = 1;\n\n  while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {\n    state.advance();\n    state.start++;\n    count++;\n  }\n\n  if (count % 2 === 0) {\n    return false;\n  }\n\n  state.negated = true;\n  state.start++;\n  return true;\n};\n/**\n * Create the message for a syntax error\n */\n\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\n\nconst parse$1 = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n  let opts = Object.assign({}, options);\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  let bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  let tokens = [bos];\n  let capture = opts.capture ? '' : '?:';\n  let win32 = utils$1.isWindows(options); // create constants based on platform, for windows or posix\n\n  const PLATFORM_CHARS = constants$1.globChars(win32);\n  const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  let nodot = opts.dot ? '' : NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n  let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  } // minimatch options support\n\n\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  let state = {\n    index: -1,\n    start: 0,\n    consumed: '',\n    output: '',\n    backtrack: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    tokens\n  };\n  let extglobs = [];\n  let stack = [];\n  let prev = bos;\n  let value;\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n\n  const peek = state.peek = (n = 1) => input[state.index + n];\n\n  const advance = state.advance = () => input[++state.index];\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    state.consumed += token.value || '';\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    let token = Object.assign({}, EXTGLOB_CHARS[value], {\n      conditions: 1,\n      inner: ''\n    });\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    let output = (opts.capture ? '(' : '') + token.open;\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    increment('parens');\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(input.slice(state.index + 1))) {\n        output = token.close = ')$))' + extglobStar;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/{[()\\]}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n\n        return star;\n      }\n\n      return esc ? m : '\\\\' + m;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n\n    state.output = output;\n    return state;\n  }\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n    /**\n     * Escaped characters\n     */\n\n\n    if (value === '\\\\') {\n      let next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      } // collapse slashes to reduce potential for exploits\n\n\n      let match = /^\\\\+/.exec(input.slice(state.index + 1));\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        let inner = prev.value.slice(1);\n\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            let idx = prev.value.lastIndexOf('[');\n            let pre = prev.value.slice(0, idx);\n            let rest = prev.value.slice(idx + 2);\n            let posix = POSIX_REGEX_SOURCE$1[rest];\n\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n\n              continue;\n            }\n          }\n        }\n      }\n\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = '\\\\' + value;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = '\\\\' + value;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils$1.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * Double quotes\n     */\n\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === '(') {\n      push({\n        type: 'paren',\n        value\n      });\n      increment('parens');\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      let extglob = extglobs[extglobs.length - 1];\n\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n    /**\n     * Brackets\n     */\n\n\n    if (value === '[') {\n      if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = '\\\\' + value;\n      } else {\n        increment('brackets');\n      }\n\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: '\\\\' + value\n        });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({\n          type: 'text',\n          value,\n          output: '\\\\' + value\n        });\n        continue;\n      }\n\n      decrement('brackets');\n      let prevValue = prev.value.slice(1);\n\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = '/' + value;\n      }\n\n      prev.value += value;\n      append({\n        value\n      }); // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n\n      if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      let escaped = utils$1.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      } // when the user specifies nothing, try to match both\n\n\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n    /**\n     * Braces\n     */\n\n\n    if (value === '{' && opts.nobrace !== true) {\n      push({\n        type: 'brace',\n        value,\n        output: '('\n      });\n      increment('braces');\n      continue;\n    }\n\n    if (value === '}') {\n      if (opts.nobrace === true || state.braces === 0) {\n        push({\n          type: 'text',\n          value,\n          output: '\\\\' + value\n        });\n        continue;\n      }\n\n      let output = ')';\n\n      if (state.dots === true) {\n        let arr = tokens.slice();\n        let range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n\n          if (arr[i].type === 'brace') {\n            break;\n          }\n\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      continue;\n    }\n    /**\n     * Pipes\n     */\n\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Commas\n     */\n\n\n    if (value === ',') {\n      let output = value;\n\n      if (state.braces > 0 && stack[stack.length - 1] === 'braces') {\n        output = '|';\n      }\n\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n    /**\n     * Slashes\n     */\n\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n\n        continue;\n      }\n\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Dots\n     */\n\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        state.dots = true;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Question marks\n     */\n\n\n    if (value === '?') {\n      if (prev && prev.type === 'paren') {\n        let next = peek();\n        let output = value;\n\n        if (next === '<' && !utils$1.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/[!=]/.test(peek(2))) {\n          output = '\\\\' + value;\n        }\n\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n    /**\n     * Exclamation\n     */\n\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate(state);\n        continue;\n      }\n    }\n    /**\n     * Plus\n     */\n\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {\n        let output = prev.extglob === true ? '\\\\' + value : value;\n        push({\n          type: 'plus',\n          value,\n          output\n        });\n        continue;\n      } // use regex behavior inside parens\n\n\n      if (state.parens > 0 && opts.regex !== false) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = '\\\\' + value;\n      }\n\n      let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));\n\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Stars\n     */\n\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.consumed += value;\n      continue;\n    }\n\n    if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        state.consumed += value;\n        continue;\n      }\n\n      let prior = prev.prev;\n      let before = prior.prev;\n      let isStart = prior.type === 'slash' || prior.type === 'bos';\n      let afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || !eos() && peek() !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      } // strip consecutive `/**/`\n\n\n      while (input.slice(state.index + 1, state.index + 4) === '/**') {\n        let after = input[state.index + 4];\n\n        if (after && after !== '/') {\n          break;\n        }\n\n        state.consumed += '/**';\n        state.index += 3;\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.consumed += value;\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = '(?:' + prior.output;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + '|$)';\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.consumed += value;\n        continue;\n      }\n\n      let next = peek();\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {\n        let end = peek(2) !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = '(?:' + prior.output;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.consumed += value + advance();\n        push({\n          type: 'slash',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      if (prior.type === 'bos' && next === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.consumed += value + advance();\n        push({\n          type: 'slash',\n          value,\n          output: ''\n        });\n        continue;\n      } // remove single star from output\n\n\n      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar\n\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value; // reset output with globstar\n\n      state.output += prev.output;\n      state.consumed += value;\n      continue;\n    }\n\n    let token = {\n      type: 'star',\n      value,\n      output: star\n    };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils$1.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils$1.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils$1.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  } // rebuild the output if we had to backtrack at any point\n\n\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (let token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\n\nparse$1.fastpaths = (input, options) => {\n  let opts = Object.assign({}, options);\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  let win32 = utils$1.isWindows(options); // create constants based on platform, for windows or posix\n\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants$1.globChars(win32);\n  let capture = opts.capture ? '' : '?:';\n  let star = opts.bash === true ? '.*?' : STAR;\n  let nodot = opts.dot ? NO_DOTS : NO_DOT;\n  let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default:\n        {\n          let match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          let source = create(match[1], options);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n\n  let output = create(input);\n\n  if (output && opts.strictSlashes !== true) {\n    output += `${SLASH_LITERAL}?`;\n  }\n\n  return output;\n};\n\nvar parse_1$1 = parse$1;\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    let fns = glob.map(input => picomatch(input, options, returnState));\n    return str => {\n      for (let isMatch of fns) {\n        let state = isMatch(str);\n        if (state) return state;\n      }\n\n      return false;\n    };\n  }\n\n  if (typeof glob !== 'string' || glob === '') {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  let opts = options || {};\n  let posix = utils$1.isWindows(options);\n  let regex = picomatch.makeRe(glob, options, false, true);\n  let state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n\n  if (opts.ignore) {\n    let ignoreOpts = Object.assign({}, options, {\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    });\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    let {\n      isMatch,\n      match,\n      output\n    } = picomatch.test(input, regex, options, {\n      glob,\n      posix\n    });\n    let result = {\n      glob,\n      state,\n      regex,\n      posix,\n      input,\n      output,\n      match,\n      isMatch\n    };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\n\npicomatch.test = (input, regex, options, {\n  glob,\n  posix\n} = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n\n  let opts = options || {};\n  let format = opts.format || (posix ? utils$1.toPosixSlashes : null);\n  let match = input === glob;\n  let output = match && format ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return {\n    isMatch: !!match,\n    match,\n    output\n  };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\n\npicomatch.matchBase = (input, glob, options, posix = utils$1.isWindows(options)) => {\n  let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\n\npicomatch.parse = (glob, options) => parse_1$1(glob, options);\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\npicomatch.scan = (input, options) => scan(input, options);\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let opts = options || {};\n  let prepend = opts.contains ? '' : '^';\n  let append = opts.contains ? '' : '$';\n  let state = {\n    negated: false,\n    fastpaths: true\n  };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = state.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse_1$1.fastpaths(input, options);\n  }\n\n  if (output === void 0) {\n    state = picomatch.parse(input, options);\n    state.prefix = prefix + (state.prefix || '');\n    output = state.output;\n  }\n\n  if (returnOutput === true) {\n    return output;\n  }\n\n  let source = `${prepend}(?:${output})${append}`;\n\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  let regex = picomatch.toRegex(source, options);\n\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\n\npicomatch.toRegex = (source, options) => {\n  try {\n    let opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\n\npicomatch.constants = constants$1;\n/**\n * Expose \"picomatch\"\n */\n\nvar picomatch_1 = picomatch;\nvar picomatch$1 = picomatch_1;\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch$1(String(patterns[i]), Object.assign({}, options, {\n      onResult\n    }), true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch$1(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, Object.assign({}, options, {\n    onResult\n  }));\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n\n  return [...result];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, Object.assign({}, options, {\n    contains: true\n  }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n\n  for (let key of keys) res[key] = obj[key];\n\n  return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch$1(String(pattern), options);\n\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch$1(String(pattern), options);\n\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch$1(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils$1.isWindows(options);\n  let regex = picomatch$1.makeRe(String(glob), Object.assign({}, options, {\n    capture: true\n  }));\n  let match = regex.exec(posix ? utils$1.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = (...args) => picomatch$1.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\nmicromatch.scan = (...args) => picomatch$1.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces_1(String(pattern), options)) {\n      res.push(picomatch$1.parse(str, options));\n    }\n  }\n\n  return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n\n  return braces_1(pattern, options);\n};\n/**\n * Expand braces\n */\n\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, Object.assign({}, options, {\n    expand: true\n  }));\n};\n/**\n * Expose micromatch\n */\n\n\nvar micromatch_1 = micromatch;\n\nfunction ensureArray(thing) {\n  if (Array.isArray(thing)) return thing;\n  if (thing == undefined) return [];\n  return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n  if (resolutionBase === false) {\n    return id;\n  }\n\n  return resolve(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));\n}\n\nconst createFilter = function createFilter(include, exclude, options) {\n  const resolutionBase = options && options.resolve;\n\n  const getMatcher = id => {\n    return id instanceof RegExp ? id : {\n      test: micromatch_1.matcher(getMatcherString(id, resolutionBase).split(sep).join('/'), {\n        dot: true\n      })\n    };\n  };\n\n  const includeMatchers = ensureArray(include).map(getMatcher);\n  const excludeMatchers = ensureArray(exclude).map(getMatcher);\n  return function (id) {\n    if (typeof id !== 'string') return false;\n    if (/\\0/.test(id)) return false;\n    id = id.split(sep).join('/');\n\n    for (let i = 0; i < excludeMatchers.length; ++i) {\n      const matcher = excludeMatchers[i];\n      if (matcher.test(id)) return false;\n    }\n\n    for (let i = 0; i < includeMatchers.length; ++i) {\n      const matcher = includeMatchers[i];\n      if (matcher.test(id)) return true;\n    }\n\n    return !includeMatchers.length;\n  };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\n\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n  str = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, '_');\n\n  if (/\\d/.test(str[0]) || forbiddenIdentifiers.has(str)) {\n    str = `_${str}`;\n  }\n\n  return str || '_';\n};\n\nfunction stringify$2(obj) {\n  return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, char => `\\\\u${('000' + char.charCodeAt(0).toString(16)).slice(-4)}`);\n}\n\nfunction serializeArray(arr, indent, baseIndent) {\n  let output = '[';\n  const separator = indent ? '\\n' + baseIndent + indent : '';\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = arr[i];\n    output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n  }\n\n  return output + `${indent ? '\\n' + baseIndent : ''}]`;\n}\n\nfunction serializeObject(obj, indent, baseIndent) {\n  let output = '{';\n  const separator = indent ? '\\n' + baseIndent + indent : '';\n  const keys = Object.keys(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const stringKey = makeLegalIdentifier(key) === key ? key : stringify$2(key);\n    output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(obj[key], indent, baseIndent + indent)}`;\n  }\n\n  return output + `${indent ? '\\n' + baseIndent : ''}}`;\n}\n\nfunction serialize(obj, indent, baseIndent) {\n  if (obj === Infinity) return 'Infinity';\n  if (obj === -Infinity) return '-Infinity';\n  if (obj === 0 && 1 / obj === -Infinity) return '-0';\n  if (obj instanceof Date) return 'new Date(' + obj.getTime() + ')';\n  if (obj instanceof RegExp) return obj.toString();\n  if (obj !== obj) return 'NaN';\n  if (Array.isArray(obj)) return serializeArray(obj, indent, baseIndent);\n  if (obj === null) return 'null';\n  if (typeof obj === 'object') return serializeObject(obj, indent, baseIndent);\n  return stringify$2(obj);\n}\n\nconst dataToEsm = function dataToEsm(data, options = {}) {\n  const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n\n  const _ = options.compact ? '' : ' ';\n\n  const n = options.compact ? '' : '\\n';\n  const declarationType = options.preferConst ? 'const' : 'var';\n\n  if (options.namedExports === false || typeof data !== 'object' || Array.isArray(data) || data instanceof Date || data instanceof RegExp || data === null) {\n    const code = serialize(data, options.compact ? null : t, '');\n\n    const __ = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' ');\n\n    return `export default${__}${code};`;\n  }\n\n  let namedExportCode = '';\n  const defaultExportRows = [];\n  const dataKeys = Object.keys(data);\n\n  for (let i = 0; i < dataKeys.length; i++) {\n    const key = dataKeys[i];\n\n    if (key === makeLegalIdentifier(key)) {\n      if (options.objectShorthand) defaultExportRows.push(key);else defaultExportRows.push(`${key}:${_}${key}`);\n      namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(data[key], options.compact ? null : t, '')};${n}`;\n    } else {\n      defaultExportRows.push(`${stringify$2(key)}:${_}${serialize(data[key], options.compact ? null : t, '')}`);\n    }\n  }\n\n  return namedExportCode + `export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;\n};\n\nexport { addExtension, attachScopes, createFilter, dataToEsm, extractAssignedNames, makeLegalIdentifier };","map":{"version":3,"sources":["/home/agatha/open/node_modules/rollup-pluginutils/dist/pluginutils.es.js"],"names":["path","extname","sep","resolve","walk","util","addExtension","filename","ext","extractors","ArrayPattern","names","param","element","elements","type","AssignmentPattern","left","Identifier","push","name","MemberExpression","ObjectPattern","prop","properties","RestElement","value","argument","extractAssignedNames","blockDeclarations","const","let","Scope","constructor","options","parent","isBlockScope","block","declarations","Object","create","params","forEach","addDeclaration","node","isBlockDeclaration","isVar","id","contains","attachScopes","ast","propertyName","scope","enter","test","kind","declaration","newScope","defineProperty","configurable","leave","createCommonjsModule","fn","module","exports","utils","isInteger","num","Number","trim","find","nodes","exceedsLimit","min","max","step","limit","escapeNode","n","escaped","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","open","close","isOpenOrClose","reduce","acc","flatten","args","result","flat","arr","i","length","ele","Array","isArray","utils_1","utils_2","utils_3","utils_4","utils_5","utils_6","utils_7","utils_8","utils_9","stringify","invalidBlock","escapeInvalid","invalidNode","output","child","isNumber","isFinite","toRegexRange","TypeError","String","opts","assign","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","concat","join","splitToRanges","nines","zeros","stop","countNines","stops","Set","add","countZeros","sort","compare","rangeToPattern","start","pattern","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","pop","string","toQuantifier","padZeros","comparison","prefix","intersection","key","val","some","len","slice","repeat","integer","pow","str","diff","clearCache","toRegexRange_1","isObject","transform","toNumber","isValidValue","isNumber$1","input","index","stringify$1","end","pad","maxLength","dash","padStart","toMaxLen","negative","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","format","range","fillLetters","charCodeAt","fill","fillRange","compile","isOpen","isClose","compile_1","append","queue","stash","enclose","map","item","expand","rangeLimit","p","q","expand_1","constants","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","parse","SyntaxError","stack","brackets","depth","advance","keepEscaping","next","keepQuotes","brace","shift","siblings","before","indexOf","splice","parse_1","braces","nodupes","noempty","filter","Boolean","braces_1","WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","PLUS_LITERAL","QMARK_LITERAL","SLASH_LITERAL","ONE_CHAR","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","POSIX_CHARS","WINDOWS_CHARS","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","constants$1","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHAR","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_BACKWARD_SLASH","CHAR_GRAVE_ACCENT","SEP","extglobChars","chars","globChars","win32","utils$1","process","platform","hasRegexChars","isRegexChar","escapeRegex","replace","toPosixSlashes","removeBackslashes","match","supportsLookbehinds","segs","version","split","isWindows","windows","escapeLast","char","lastIdx","idx","lastIndexOf","utils_1$1","utils_2$1","utils_3$1","utils_4$1","utils_5$1","utils_6$1","utils_7$1","utils_8$1","utils_9$1","CHAR_COMMA$1","CHAR_DOT$1","CHAR_LEFT_CURLY_BRACE$1","CHAR_LEFT_PARENTHESES$1","CHAR_LEFT_SQUARE_BRACKET$1","CHAR_RIGHT_CURLY_BRACE$1","CHAR_RIGHT_PARENTHESES$1","CHAR_RIGHT_SQUARE_BRACKET$1","isPathSeparator","code","scan","lastIndex","isGlob","backslashes","negated","braceEscaped","eos","isExtglobChar","orig","base","glob","unescape","MAX_LENGTH$1","POSIX_REGEX_SOURCE$1","expandRange","ex","v","negate","peek","syntaxError","parse$1","bos","prepend","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","star","bash","qmarkNoDot","noext","noextglob","consumed","backtrack","parens","quotes","extglobs","token","increment","decrement","isBrace","isExtglob","inner","extglobOpen","conditions","extglob","extglobClose","extglobStar","includes","negatedExtglob","fastpaths","m","esc","first","rest","exec","slashes","posix","pre","strictBrackets","nobracket","prevValue","literalBrackets","nobrace","dots","unshift","Error","nonegate","regex","noglobstar","prior","isStart","afterStar","after","strictSlashes","suffix","slashDot","source","parse_1$1","picomatch","returnState","fns","isMatch","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","onIgnore","matchBase","basename","RegExp","patterns","returnOutput","startsWith","flags","nocase","err","debug","picomatch_1","picomatch$1","isEmptyString","micromatch","list","omit","keep","items","matched","delete","matches","has","failglob","nonull","nullglob","any","not","matchKeys","keys","res","every","all","braceExpand","micromatch_1","ensureArray","thing","undefined","getMatcherString","resolutionBase","createFilter","include","exclude","getMatcher","includeMatchers","excludeMatchers","reservedWords","builtins","forbiddenIdentifiers","makeLegalIdentifier","_","letter","toUpperCase","stringify$2","JSON","toString","serializeArray","indent","baseIndent","separator","serialize","serializeObject","stringKey","Infinity","Date","getTime","dataToEsm","data","t","compact","declarationType","preferConst","namedExports","__","namedExportCode","defaultExportRows","dataKeys","objectShorthand"],"mappings":"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","sourcesContent":["import path, { extname, sep, resolve } from 'path';\nimport { walk } from 'estree-walker';\nimport util from 'util';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n    if (!extname(filename))\n        filename += ext;\n    return filename;\n};\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\nconst blockDeclarations = {\n    const: true,\n    let: true\n};\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent;\n        this.isBlockScope = !!options.block;\n        this.declarations = Object.create(null);\n        if (options.params) {\n            options.params.forEach(param => {\n                extractAssignedNames(param).forEach(name => {\n                    this.declarations[name] = true;\n                });\n            });\n        }\n    }\n    addDeclaration(node, isBlockDeclaration, isVar) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n            // it's a `var` or function node, and this\n            // is a block scope, so we need to go up\n            this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n        }\n        else if (node.id) {\n            extractAssignedNames(node.id).forEach(name => {\n                this.declarations[name] = true;\n            });\n        }\n    }\n    contains(name) {\n        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n    }\n}\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n    let scope = new Scope();\n    walk(ast, {\n        enter(node, parent) {\n            // function foo () {...}\n            // class Foo {...}\n            if (/(Function|Class)Declaration/.test(node.type)) {\n                scope.addDeclaration(node, false, false);\n            }\n            // var foo = 1\n            if (node.type === 'VariableDeclaration') {\n                const kind = node.kind;\n                const isBlockDeclaration = blockDeclarations[kind];\n                node.declarations.forEach((declaration) => {\n                    scope.addDeclaration(declaration, isBlockDeclaration, true);\n                });\n            }\n            let newScope;\n            // create new function scope\n            if (/Function/.test(node.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: false,\n                    params: node.params\n                });\n                // named function expressions - the name is considered\n                // part of the function's scope\n                if (node.type === 'FunctionExpression' && node.id) {\n                    newScope.addDeclaration(node, false, false);\n                }\n            }\n            // create new block scope\n            if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // catch clause has its own block scope\n            if (node.type === 'CatchClause') {\n                newScope = new Scope({\n                    parent: scope,\n                    params: node.param ? [node.param] : [],\n                    block: true\n                });\n            }\n            if (newScope) {\n                Object.defineProperty(node, propertyName, {\n                    value: newScope,\n                    configurable: true\n                });\n                scope = newScope;\n            }\n        },\n        leave(node) {\n            if (node[propertyName])\n                scope = scope.parent;\n        }\n    });\n    return scope;\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar utils = createCommonjsModule(function (module, exports) {\n    exports.isInteger = num => {\n        if (typeof num === 'number') {\n            return Number.isInteger(num);\n        }\n        if (typeof num === 'string' && num.trim() !== '') {\n            return Number.isInteger(Number(num));\n        }\n        return false;\n    };\n    /**\n     * Find a node of the given type\n     */\n    exports.find = (node, type) => node.nodes.find(node => node.type === type);\n    /**\n     * Find a node of the given type\n     */\n    exports.exceedsLimit = (min, max, step = 1, limit) => {\n        if (limit === false)\n            return false;\n        if (!exports.isInteger(min) || !exports.isInteger(max))\n            return false;\n        return ((Number(max) - Number(min)) / Number(step)) >= limit;\n    };\n    /**\n     * Escape the given node with '\\\\' before node.value\n     */\n    exports.escapeNode = (block, n = 0, type) => {\n        let node = block.nodes[n];\n        if (!node)\n            return;\n        if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n            if (node.escaped !== true) {\n                node.value = '\\\\' + node.value;\n                node.escaped = true;\n            }\n        }\n    };\n    /**\n     * Returns true if the given brace node should be enclosed in literal braces\n     */\n    exports.encloseBrace = node => {\n        if (node.type !== 'brace')\n            return false;\n        if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n            node.invalid = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns true if a brace node is invalid.\n     */\n    exports.isInvalidBrace = block => {\n        if (block.type !== 'brace')\n            return false;\n        if (block.invalid === true || block.dollar)\n            return true;\n        if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n            block.invalid = true;\n            return true;\n        }\n        if (block.open !== true || block.close !== true) {\n            block.invalid = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns true if a node is an open or close node\n     */\n    exports.isOpenOrClose = node => {\n        if (node.type === 'open' || node.type === 'close') {\n            return true;\n        }\n        return node.open === true || node.close === true;\n    };\n    /**\n     * Reduce an array of text nodes.\n     */\n    exports.reduce = nodes => nodes.reduce((acc, node) => {\n        if (node.type === 'text')\n            acc.push(node.value);\n        if (node.type === 'range')\n            node.type = 'text';\n        return acc;\n    }, []);\n    /**\n     * Flatten an array\n     */\n    exports.flatten = (...args) => {\n        const result = [];\n        const flat = arr => {\n            for (let i = 0; i < arr.length; i++) {\n                let ele = arr[i];\n                Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n            }\n            return result;\n        };\n        flat(args);\n        return result;\n    };\n});\nvar utils_1 = utils.isInteger;\nvar utils_2 = utils.find;\nvar utils_3 = utils.exceedsLimit;\nvar utils_4 = utils.escapeNode;\nvar utils_5 = utils.encloseBrace;\nvar utils_6 = utils.isInvalidBrace;\nvar utils_7 = utils.isOpenOrClose;\nvar utils_8 = utils.reduce;\nvar utils_9 = utils.flatten;\n\nvar stringify = (ast, options = {}) => {\n    let stringify = (node, parent = {}) => {\n        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let output = '';\n        if (node.value) {\n            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n                return '\\\\' + node.value;\n            }\n            return node.value;\n        }\n        if (node.value) {\n            return node.value;\n        }\n        if (node.nodes) {\n            for (let child of node.nodes) {\n                output += stringify(child);\n            }\n        }\n        return output;\n    };\n    return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\nvar isNumber = function (num) {\n    if (typeof num === 'number') {\n        return num - num === 0;\n    }\n    if (typeof num === 'string' && num.trim() !== '') {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    }\n    return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n    if (isNumber(min) === false) {\n        throw new TypeError('toRegexRange: expected the first argument to be a number');\n    }\n    if (max === void 0 || min === max) {\n        return String(min);\n    }\n    if (isNumber(max) === false) {\n        throw new TypeError('toRegexRange: expected the second argument to be a number.');\n    }\n    let opts = Object.assign({ relaxZeros: true }, options);\n    if (typeof opts.strictZeros === 'boolean') {\n        opts.relaxZeros = opts.strictZeros === false;\n    }\n    let relax = String(opts.relaxZeros);\n    let shorthand = String(opts.shorthand);\n    let capture = String(opts.capture);\n    let wrap = String(opts.wrap);\n    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n        return toRegexRange.cache[cacheKey].result;\n    }\n    let a = Math.min(min, max);\n    let b = Math.max(min, max);\n    if (Math.abs(a - b) === 1) {\n        let result = min + '|' + max;\n        if (opts.capture) {\n            return `(${result})`;\n        }\n        if (opts.wrap === false) {\n            return result;\n        }\n        return `(?:${result})`;\n    }\n    let isPadded = hasPadding(min) || hasPadding(max);\n    let state = { min, max, a, b };\n    let positives = [];\n    let negatives = [];\n    if (isPadded) {\n        state.isPadded = isPadded;\n        state.maxLen = String(state.max).length;\n    }\n    if (a < 0) {\n        let newMin = b < 0 ? Math.abs(b) : 1;\n        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n        a = state.a = 0;\n    }\n    if (b >= 0) {\n        positives = splitToPatterns(a, b, state, opts);\n    }\n    state.negatives = negatives;\n    state.positives = positives;\n    state.result = collatePatterns(negatives, positives, opts);\n    if (opts.capture === true) {\n        state.result = `(${state.result})`;\n    }\n    else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n        state.result = `(?:${state.result})`;\n    }\n    toRegexRange.cache[cacheKey] = state;\n    return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n    let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n    let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n    let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n    return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n    let nines = 1;\n    let zeros = 1;\n    let stop = countNines(min, nines);\n    let stops = new Set([max]);\n    while (min <= stop && stop <= max) {\n        stops.add(stop);\n        nines += 1;\n        stop = countNines(min, nines);\n    }\n    stop = countZeros(max + 1, zeros) - 1;\n    while (min < stop && stop <= max) {\n        stops.add(stop);\n        zeros += 1;\n        stop = countZeros(max + 1, zeros) - 1;\n    }\n    stops = [...stops];\n    stops.sort(compare);\n    return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\nfunction rangeToPattern(start, stop, options) {\n    if (start === stop) {\n        return { pattern: start, count: [], digits: 0 };\n    }\n    let zipped = zip(start, stop);\n    let digits = zipped.length;\n    let pattern = '';\n    let count = 0;\n    for (let i = 0; i < digits; i++) {\n        let [startDigit, stopDigit] = zipped[i];\n        if (startDigit === stopDigit) {\n            pattern += startDigit;\n        }\n        else if (startDigit !== '0' || stopDigit !== '9') {\n            pattern += toCharacterClass(startDigit, stopDigit, options);\n        }\n        else {\n            count++;\n        }\n    }\n    if (count) {\n        pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n    }\n    return { pattern, count: [count], digits };\n}\nfunction splitToPatterns(min, max, tok, options) {\n    let ranges = splitToRanges(min, max);\n    let tokens = [];\n    let start = min;\n    let prev;\n    for (let i = 0; i < ranges.length; i++) {\n        let max = ranges[i];\n        let obj = rangeToPattern(String(start), String(max), options);\n        let zeros = '';\n        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n            if (prev.count.length > 1) {\n                prev.count.pop();\n            }\n            prev.count.push(obj.count[0]);\n            prev.string = prev.pattern + toQuantifier(prev.count);\n            start = max + 1;\n            continue;\n        }\n        if (tok.isPadded) {\n            zeros = padZeros(max, tok, options);\n        }\n        obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n        tokens.push(obj);\n        start = max + 1;\n        prev = obj;\n    }\n    return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n    let result = [];\n    for (let ele of arr) {\n        let { string } = ele;\n        // only push if _both_ are negative...\n        if (!intersection && !contains(comparison, 'string', string)) {\n            result.push(prefix + string);\n        }\n        // or _both_ are positive\n        if (intersection && contains(comparison, 'string', string)) {\n            result.push(prefix + string);\n        }\n    }\n    return result;\n}\n/**\n * Zip strings\n */\nfunction zip(a, b) {\n    let arr = [];\n    for (let i = 0; i < a.length; i++)\n        arr.push([a[i], b[i]]);\n    return arr;\n}\nfunction compare(a, b) {\n    return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n    return arr.some(ele => ele[key] === val);\n}\nfunction countNines(min, len) {\n    return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n    return integer - (integer % Math.pow(10, zeros));\n}\nfunction toQuantifier(digits) {\n    let [start = 0, stop = ''] = digits;\n    if (stop || start > 1) {\n        return `{${start + (stop ? ',' + stop : '')}}`;\n    }\n    return '';\n}\nfunction toCharacterClass(a, b, options) {\n    return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\nfunction hasPadding(str) {\n    return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n    if (!tok.isPadded) {\n        return value;\n    }\n    let diff = Math.abs(tok.maxLen - String(value).length);\n    let relax = options.relaxZeros !== false;\n    switch (diff) {\n        case 0:\n            return '';\n        case 1:\n            return relax ? '0?' : '0';\n        case 2:\n            return relax ? '0{0,2}' : '00';\n        default: {\n            return relax ? `0{0,${diff}}` : `0{${diff}}`;\n        }\n    }\n}\n/**\n * Cache\n */\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n/**\n * Expose `toRegexRange`\n */\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nconst transform = toNumber => {\n    return value => toNumber === true ? Number(value) : String(value);\n};\nconst isValidValue = value => {\n    return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\nconst isNumber$1 = num => Number.isInteger(+num);\nconst zeros = input => {\n    let value = `${input}`;\n    let index = -1;\n    if (value[0] === '-')\n        value = value.slice(1);\n    if (value === '0')\n        return false;\n    while (value[++index] === '0')\n        ;\n    return index > 0;\n};\nconst stringify$1 = (start, end, options) => {\n    if (typeof start === 'string' || typeof end === 'string') {\n        return true;\n    }\n    return options.stringify === true;\n};\nconst pad = (input, maxLength, toNumber) => {\n    if (maxLength > 0) {\n        let dash = input[0] === '-' ? '-' : '';\n        if (dash)\n            input = input.slice(1);\n        input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n    }\n    if (toNumber === false) {\n        return String(input);\n    }\n    return input;\n};\nconst toMaxLen = (input, maxLength) => {\n    let negative = input[0] === '-' ? '-' : '';\n    if (negative) {\n        input = input.slice(1);\n        maxLength--;\n    }\n    while (input.length < maxLength)\n        input = '0' + input;\n    return negative ? ('-' + input) : input;\n};\nconst toSequence = (parts, options) => {\n    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    let prefix = options.capture ? '' : '?:';\n    let positives = '';\n    let negatives = '';\n    let result;\n    if (parts.positives.length) {\n        positives = parts.positives.join('|');\n    }\n    if (parts.negatives.length) {\n        negatives = `-(${prefix}${parts.negatives.join('|')})`;\n    }\n    if (positives && negatives) {\n        result = `${positives}|${negatives}`;\n    }\n    else {\n        result = positives || negatives;\n    }\n    if (options.wrap) {\n        return `(${prefix}${result})`;\n    }\n    return result;\n};\nconst toRange = (a, b, isNumbers, options) => {\n    if (isNumbers) {\n        return toRegexRange_1(a, b, Object.assign({ wrap: false }, options));\n    }\n    let start = String.fromCharCode(a);\n    if (a === b)\n        return start;\n    let stop = String.fromCharCode(b);\n    return `[${start}-${stop}]`;\n};\nconst toRegex = (start, end, options) => {\n    if (Array.isArray(start)) {\n        let wrap = options.wrap === true;\n        let prefix = options.capture ? '' : '?:';\n        return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n    }\n    return toRegexRange_1(start, end, options);\n};\nconst rangeError = (...args) => {\n    return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\nconst invalidRange = (start, end, options) => {\n    if (options.strictRanges === true)\n        throw rangeError([start, end]);\n    return [];\n};\nconst invalidStep = (step, options) => {\n    if (options.strictRanges === true) {\n        throw new TypeError(`Expected step \"${step}\" to be a number`);\n    }\n    return [];\n};\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n    let a = Number(start);\n    let b = Number(end);\n    if (!Number.isInteger(a) || !Number.isInteger(b)) {\n        if (options.strictRanges === true)\n            throw rangeError([start, end]);\n        return [];\n    }\n    // fix negative zero\n    if (a === 0)\n        a = 0;\n    if (b === 0)\n        b = 0;\n    let descending = a > b;\n    let startString = String(start);\n    let endString = String(end);\n    let stepString = String(step);\n    step = Math.max(Math.abs(step), 1);\n    let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n    let toNumber = padded === false && stringify$1(start, end, options) === false;\n    let format = options.transform || transform(toNumber);\n    if (options.toRegex && step === 1) {\n        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n    }\n    let parts = { negatives: [], positives: [] };\n    let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n        if (options.toRegex === true && step > 1) {\n            push(a);\n        }\n        else {\n            range.push(pad(format(a, index), maxLen, toNumber));\n        }\n        a = descending ? a - step : a + step;\n        index++;\n    }\n    if (options.toRegex === true) {\n        return step > 1\n            ? toSequence(parts, options)\n            : toRegex(range, null, Object.assign({ wrap: false }, options));\n    }\n    return range;\n};\nconst fillLetters = (start, end, step = 1, options = {}) => {\n    if ((!isNumber$1(start) && start.length > 1) || (!isNumber$1(end) && end.length > 1)) {\n        return invalidRange(start, end, options);\n    }\n    let format = options.transform || (val => String.fromCharCode(val));\n    let a = `${start}`.charCodeAt(0);\n    let b = `${end}`.charCodeAt(0);\n    let descending = a > b;\n    let min = Math.min(a, b);\n    let max = Math.max(a, b);\n    if (options.toRegex && step === 1) {\n        return toRange(min, max, false, options);\n    }\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n        range.push(format(a, index));\n        a = descending ? a - step : a + step;\n        index++;\n    }\n    if (options.toRegex === true) {\n        return toRegex(range, null, { wrap: false, options });\n    }\n    return range;\n};\nconst fill = (start, end, step, options = {}) => {\n    if (end == null && isValidValue(start)) {\n        return [start];\n    }\n    if (!isValidValue(start) || !isValidValue(end)) {\n        return invalidRange(start, end, options);\n    }\n    if (typeof step === 'function') {\n        return fill(start, end, 1, { transform: step });\n    }\n    if (isObject(step)) {\n        return fill(start, end, 0, step);\n    }\n    let opts = Object.assign({}, options);\n    if (opts.capture === true)\n        opts.wrap = true;\n    step = step || opts.step || 1;\n    if (!isNumber$1(step)) {\n        if (step != null && !isObject(step))\n            return invalidStep(step, opts);\n        return fill(start, end, 1, step);\n    }\n    if (isNumber$1(start) && isNumber$1(end)) {\n        return fillNumbers(start, end, step, opts);\n    }\n    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n    let walk = (node, parent = {}) => {\n        let invalidBlock = utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let invalid = invalidBlock === true || invalidNode === true;\n        let prefix = options.escapeInvalid === true ? '\\\\' : '';\n        let output = '';\n        if (node.isOpen === true) {\n            return prefix + node.value;\n        }\n        if (node.isClose === true) {\n            return prefix + node.value;\n        }\n        if (node.type === 'open') {\n            return invalid ? (prefix + node.value) : '(';\n        }\n        if (node.type === 'close') {\n            return invalid ? (prefix + node.value) : ')';\n        }\n        if (node.type === 'comma') {\n            return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n        }\n        if (node.value) {\n            return node.value;\n        }\n        if (node.nodes && node.ranges > 0) {\n            let args = utils.reduce(node.nodes);\n            let range = fillRange(...args, Object.assign({}, options, { wrap: false, toRegex: true }));\n            if (range.length !== 0) {\n                return args.length > 1 && range.length > 1 ? `(${range})` : range;\n            }\n        }\n        if (node.nodes) {\n            for (let child of node.nodes) {\n                output += walk(child, node);\n            }\n        }\n        return output;\n    };\n    return walk(ast);\n};\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n    let result = [];\n    queue = [].concat(queue);\n    stash = [].concat(stash);\n    if (!stash.length)\n        return queue;\n    if (!queue.length) {\n        return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n    }\n    for (let item of queue) {\n        if (Array.isArray(item)) {\n            for (let value of item) {\n                result.push(append(value, stash, enclose));\n            }\n        }\n        else {\n            for (let ele of stash) {\n                if (enclose === true && typeof ele === 'string')\n                    ele = `{${ele}}`;\n                result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n            }\n        }\n    }\n    return utils.flatten(result);\n};\nconst expand = (ast, options = {}) => {\n    let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n    let walk = (node, parent = {}) => {\n        node.queue = [];\n        let p = parent;\n        let q = parent.queue;\n        while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n            p = p.parent;\n            q = p.queue;\n        }\n        if (node.invalid || node.dollar) {\n            q.push(append(q.pop(), stringify(node, options)));\n            return;\n        }\n        if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n            q.push(append(q.pop(), ['{}']));\n            return;\n        }\n        if (node.nodes && node.ranges > 0) {\n            let args = utils.reduce(node.nodes);\n            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n                throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n            }\n            let range = fillRange(...args, options);\n            if (range.length === 0) {\n                range = stringify(node, options);\n            }\n            q.push(append(q.pop(), range));\n            node.nodes = [];\n            return;\n        }\n        let enclose = utils.encloseBrace(node);\n        let queue = node.queue;\n        let block = node;\n        while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n            block = block.parent;\n            queue = block.queue;\n        }\n        for (let i = 0; i < node.nodes.length; i++) {\n            let child = node.nodes[i];\n            if (child.type === 'comma' && node.type === 'brace') {\n                if (i === 1)\n                    queue.push('');\n                queue.push('');\n                continue;\n            }\n            if (child.type === 'close') {\n                q.push(append(q.pop(), queue, enclose));\n                continue;\n            }\n            if (child.value && child.type !== 'open') {\n                queue.push(append(queue.pop(), child.value));\n                continue;\n            }\n            if (child.nodes) {\n                walk(child, node);\n            }\n        }\n        return queue;\n    };\n    return utils.flatten(walk(ast));\n};\nvar expand_1 = expand;\n\nvar constants = {\n    MAX_LENGTH: 1024 * 64,\n    // Digits\n    CHAR_0: '0',\n    CHAR_9: '9',\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 'A',\n    CHAR_LOWERCASE_A: 'a',\n    CHAR_UPPERCASE_Z: 'Z',\n    CHAR_LOWERCASE_Z: 'z',\n    CHAR_LEFT_PARENTHESES: '(',\n    CHAR_RIGHT_PARENTHESES: ')',\n    CHAR_ASTERISK: '*',\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: '&',\n    CHAR_AT: '@',\n    CHAR_BACKSLASH: '\\\\',\n    CHAR_BACKTICK: '`',\n    CHAR_CARRIAGE_RETURN: '\\r',\n    CHAR_CIRCUMFLEX_ACCENT: '^',\n    CHAR_COLON: ':',\n    CHAR_COMMA: ',',\n    CHAR_DOLLAR: '$',\n    CHAR_DOT: '.',\n    CHAR_DOUBLE_QUOTE: '\"',\n    CHAR_EQUAL: '=',\n    CHAR_EXCLAMATION_MARK: '!',\n    CHAR_FORM_FEED: '\\f',\n    CHAR_FORWARD_SLASH: '/',\n    CHAR_HASH: '#',\n    CHAR_HYPHEN_MINUS: '-',\n    CHAR_LEFT_ANGLE_BRACKET: '<',\n    CHAR_LEFT_CURLY_BRACE: '{',\n    CHAR_LEFT_SQUARE_BRACKET: '[',\n    CHAR_LINE_FEED: '\\n',\n    CHAR_NO_BREAK_SPACE: '\\u00A0',\n    CHAR_PERCENT: '%',\n    CHAR_PLUS: '+',\n    CHAR_QUESTION_MARK: '?',\n    CHAR_RIGHT_ANGLE_BRACKET: '>',\n    CHAR_RIGHT_CURLY_BRACE: '}',\n    CHAR_RIGHT_SQUARE_BRACKET: ']',\n    CHAR_SEMICOLON: ';',\n    CHAR_SINGLE_QUOTE: '\\'',\n    CHAR_SPACE: ' ',\n    CHAR_TAB: '\\t',\n    CHAR_UNDERSCORE: '_',\n    CHAR_VERTICAL_LINE: '|',\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n/**\n * Constants\n */\nconst { MAX_LENGTH, CHAR_BACKSLASH, /* \\ */ CHAR_BACKTICK, /* ` */ CHAR_COMMA, /* , */ CHAR_DOT, /* . */ CHAR_LEFT_PARENTHESES, /* ( */ CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_RIGHT_SQUARE_BRACKET, /* ] */ CHAR_DOUBLE_QUOTE, /* \" */ CHAR_SINGLE_QUOTE, /* ' */ CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = constants;\n/**\n * parse\n */\nconst parse = (input, options = {}) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    let opts = options || {};\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    if (input.length > max) {\n        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n    }\n    let ast = { type: 'root', input, nodes: [] };\n    let stack = [ast];\n    let block = ast;\n    let prev = ast;\n    let brackets = 0;\n    let length = input.length;\n    let index = 0;\n    let depth = 0;\n    let value;\n    /**\n     * Helpers\n     */\n    const advance = () => input[index++];\n    const push = node => {\n        if (node.type === 'text' && prev.type === 'dot') {\n            prev.type = 'text';\n        }\n        if (prev && prev.type === 'text' && node.type === 'text') {\n            prev.value += node.value;\n            return;\n        }\n        block.nodes.push(node);\n        node.parent = block;\n        node.prev = prev;\n        prev = node;\n        return node;\n    };\n    push({ type: 'bos' });\n    while (index < length) {\n        block = stack[stack.length - 1];\n        value = advance();\n        /**\n         * Invalid chars\n         */\n        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n            continue;\n        }\n        /**\n         * Escaped chars\n         */\n        if (value === CHAR_BACKSLASH) {\n            push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n            continue;\n        }\n        /**\n         * Right square bracket (literal): ']'\n         */\n        if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n            push({ type: 'text', value: '\\\\' + value });\n            continue;\n        }\n        /**\n         * Left square bracket: '['\n         */\n        if (value === CHAR_LEFT_SQUARE_BRACKET) {\n            brackets++;\n            let next;\n            while (index < length && (next = advance())) {\n                value += next;\n                if (next === CHAR_LEFT_SQUARE_BRACKET) {\n                    brackets++;\n                    continue;\n                }\n                if (next === CHAR_BACKSLASH) {\n                    value += advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n                    brackets--;\n                    if (brackets === 0) {\n                        break;\n                    }\n                }\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Parentheses\n         */\n        if (value === CHAR_LEFT_PARENTHESES) {\n            block = push({ type: 'paren', nodes: [] });\n            stack.push(block);\n            push({ type: 'text', value });\n            continue;\n        }\n        if (value === CHAR_RIGHT_PARENTHESES) {\n            if (block.type !== 'paren') {\n                push({ type: 'text', value });\n                continue;\n            }\n            block = stack.pop();\n            push({ type: 'text', value });\n            block = stack[stack.length - 1];\n            continue;\n        }\n        /**\n         * Quotes: '|\"|`\n         */\n        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n            let open = value;\n            let next;\n            if (options.keepQuotes !== true) {\n                value = '';\n            }\n            while (index < length && (next = advance())) {\n                if (next === CHAR_BACKSLASH) {\n                    value += next + advance();\n                    continue;\n                }\n                if (next === open) {\n                    if (options.keepQuotes === true)\n                        value += next;\n                    break;\n                }\n                value += next;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Left curly brace: '{'\n         */\n        if (value === CHAR_LEFT_CURLY_BRACE) {\n            depth++;\n            let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n            let brace = {\n                type: 'brace',\n                open: true,\n                close: false,\n                dollar,\n                depth,\n                commas: 0,\n                ranges: 0,\n                nodes: []\n            };\n            block = push(brace);\n            stack.push(block);\n            push({ type: 'open', value });\n            continue;\n        }\n        /**\n         * Right curly brace: '}'\n         */\n        if (value === CHAR_RIGHT_CURLY_BRACE) {\n            if (block.type !== 'brace') {\n                push({ type: 'text', value });\n                continue;\n            }\n            let type = 'close';\n            block = stack.pop();\n            block.close = true;\n            push({ type, value });\n            depth--;\n            block = stack[stack.length - 1];\n            continue;\n        }\n        /**\n         * Comma: ','\n         */\n        if (value === CHAR_COMMA && depth > 0) {\n            if (block.ranges > 0) {\n                block.ranges = 0;\n                let open = block.nodes.shift();\n                block.nodes = [open, { type: 'text', value: stringify(block) }];\n            }\n            push({ type: 'comma', value });\n            block.commas++;\n            continue;\n        }\n        /**\n         * Dot: '.'\n         */\n        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n            let siblings = block.nodes;\n            if (depth === 0 || siblings.length === 0) {\n                push({ type: 'text', value });\n                continue;\n            }\n            if (prev.type === 'dot') {\n                block.range = [];\n                prev.value += value;\n                prev.type = 'range';\n                if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n                    block.invalid = true;\n                    block.ranges = 0;\n                    prev.type = 'text';\n                    continue;\n                }\n                block.ranges++;\n                block.args = [];\n                continue;\n            }\n            if (prev.type === 'range') {\n                siblings.pop();\n                let before = siblings[siblings.length - 1];\n                before.value += prev.value + value;\n                prev = before;\n                block.ranges--;\n                continue;\n            }\n            push({ type: 'dot', value });\n            continue;\n        }\n        /**\n         * Text\n         */\n        push({ type: 'text', value });\n    }\n    // Mark imbalanced braces and brackets as invalid\n    do {\n        block = stack.pop();\n        if (block.type !== 'root') {\n            block.nodes.forEach(node => {\n                if (!node.nodes) {\n                    if (node.type === 'open')\n                        node.isOpen = true;\n                    if (node.type === 'close')\n                        node.isClose = true;\n                    if (!node.nodes)\n                        node.type = 'text';\n                    node.invalid = true;\n                }\n            });\n            // get the location of the block on parent.nodes (block's siblings)\n            let parent = stack[stack.length - 1];\n            let index = parent.nodes.indexOf(block);\n            // replace the (invalid) block with it's nodes\n            parent.nodes.splice(index, 1, ...block.nodes);\n        }\n    } while (stack.length > 0);\n    push({ type: 'eos' });\n    return ast;\n};\nvar parse_1 = parse;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\nconst braces = (input, options = {}) => {\n    let output = [];\n    if (Array.isArray(input)) {\n        for (let pattern of input) {\n            let result = braces.create(pattern, options);\n            if (Array.isArray(result)) {\n                output.push(...result);\n            }\n            else {\n                output.push(result);\n            }\n        }\n    }\n    else {\n        output = [].concat(braces.create(input, options));\n    }\n    if (options && options.expand === true && options.nodupes === true) {\n        output = [...new Set(output)];\n    }\n    return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\nbraces.parse = (input, options = {}) => parse_1(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.stringify = (input, options = {}) => {\n    if (typeof input === 'string') {\n        return stringify(braces.parse(input, options), options);\n    }\n    return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.compile = (input, options = {}) => {\n    if (typeof input === 'string') {\n        input = braces.parse(input, options);\n    }\n    return compile_1(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.expand = (input, options = {}) => {\n    if (typeof input === 'string') {\n        input = braces.parse(input, options);\n    }\n    let result = expand_1(input, options);\n    // filter out empty strings if specified\n    if (options.noempty === true) {\n        result = result.filter(Boolean);\n    }\n    // filter out duplicates if specified\n    if (options.nodupes === true) {\n        result = [...new Set(result)];\n    }\n    return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\nbraces.create = (input, options = {}) => {\n    if (input === '' || input.length < 3) {\n        return [input];\n    }\n    return options.expand !== true\n        ? braces.compile(input, options)\n        : braces.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\nvar braces_1 = braces;\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    QMARK_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    QMARK,\n    END_ANCHOR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n};\n/**\n * Windows glob regex\n */\nconst WINDOWS_CHARS = Object.assign({}, POSIX_CHARS, { SLASH_LITERAL: `[${WIN_SLASH}]`, QMARK: WIN_NO_SLASH, STAR: `${WIN_NO_SLASH}*?`, DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`, NO_DOT: `(?!${DOT_LITERAL})`, NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`, NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, QMARK_NO_DOT: `[^.${WIN_SLASH}]`, START_ANCHOR: `(?:^|[${WIN_SLASH}])`, END_ANCHOR: `(?:[${WIN_SLASH}]|$)` });\n/**\n * POSIX Bracket Regex\n */\nconst POSIX_REGEX_SOURCE = {\n    alnum: 'a-zA-Z0-9',\n    alpha: 'a-zA-Z',\n    ascii: '\\\\x00-\\\\x7F',\n    blank: ' \\\\t',\n    cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n    digit: '0-9',\n    graph: '\\\\x21-\\\\x7E',\n    lower: 'a-z',\n    print: '\\\\x20-\\\\x7E ',\n    punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n    space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n    upper: 'A-Z',\n    word: 'A-Za-z0-9_',\n    xdigit: 'A-Fa-f0-9'\n};\nvar constants$1 = {\n    MAX_LENGTH: 1024 * 64,\n    POSIX_REGEX_SOURCE,\n    // regular expressions\n    REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n    REGEX_NON_SPECIAL_CHAR: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n    REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n    REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n    // Replace globs with equivalent patterns to reduce parsing time.\n    REPLACEMENTS: {\n        '***': '*',\n        '**/**': '**',\n        '**/**/**': '**'\n    },\n    // Digits\n    CHAR_0: 48,\n    CHAR_9: 57,\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 65,\n    CHAR_LOWERCASE_A: 97,\n    CHAR_UPPERCASE_Z: 90,\n    CHAR_LOWERCASE_Z: 122,\n    CHAR_LEFT_PARENTHESES: 40,\n    CHAR_RIGHT_PARENTHESES: 41,\n    CHAR_ASTERISK: 42,\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: 38,\n    CHAR_AT: 64,\n    CHAR_BACKWARD_SLASH: 92,\n    CHAR_CARRIAGE_RETURN: 13,\n    CHAR_CIRCUMFLEX_ACCENT: 94,\n    CHAR_COLON: 58,\n    CHAR_COMMA: 44,\n    CHAR_DOT: 46,\n    CHAR_DOUBLE_QUOTE: 34,\n    CHAR_EQUAL: 61,\n    CHAR_EXCLAMATION_MARK: 33,\n    CHAR_FORM_FEED: 12,\n    CHAR_FORWARD_SLASH: 47,\n    CHAR_GRAVE_ACCENT: 96,\n    CHAR_HASH: 35,\n    CHAR_HYPHEN_MINUS: 45,\n    CHAR_LEFT_ANGLE_BRACKET: 60,\n    CHAR_LEFT_CURLY_BRACE: 123,\n    CHAR_LEFT_SQUARE_BRACKET: 91,\n    CHAR_LINE_FEED: 10,\n    CHAR_NO_BREAK_SPACE: 160,\n    CHAR_PERCENT: 37,\n    CHAR_PLUS: 43,\n    CHAR_QUESTION_MARK: 63,\n    CHAR_RIGHT_ANGLE_BRACKET: 62,\n    CHAR_RIGHT_CURLY_BRACE: 125,\n    CHAR_RIGHT_SQUARE_BRACKET: 93,\n    CHAR_SEMICOLON: 59,\n    CHAR_SINGLE_QUOTE: 39,\n    CHAR_SPACE: 32,\n    CHAR_TAB: 9,\n    CHAR_UNDERSCORE: 95,\n    CHAR_VERTICAL_LINE: 124,\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n    SEP: path.sep,\n    /**\n     * Create EXTGLOB_CHARS\n     */\n    extglobChars(chars) {\n        return {\n            '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n            '?': { type: 'qmark', open: '(?:', close: ')?' },\n            '+': { type: 'plus', open: '(?:', close: ')+' },\n            '*': { type: 'star', open: '(?:', close: ')*' },\n            '@': { type: 'at', open: '(?:', close: ')' }\n        };\n    },\n    /**\n     * Create GLOB_CHARS\n     */\n    globChars(win32) {\n        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n    }\n};\n\nvar utils$1 = createCommonjsModule(function (module, exports) {\n    const win32 = process.platform === 'win32';\n    const { REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL, REGEX_REMOVE_BACKSLASH } = constants$1;\n    exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n    exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n    exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n    exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n    exports.toPosixSlashes = str => str.replace(/\\\\/g, '/');\n    exports.removeBackslashes = str => {\n        return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n            return match === '\\\\' ? '' : match;\n        });\n    };\n    exports.supportsLookbehinds = () => {\n        let segs = process.version.slice(1).split('.');\n        if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {\n            return true;\n        }\n        return false;\n    };\n    exports.isWindows = options => {\n        if (options && typeof options.windows === 'boolean') {\n            return options.windows;\n        }\n        return win32 === true || path.sep === '\\\\';\n    };\n    exports.escapeLast = (input, char, lastIdx) => {\n        let idx = input.lastIndexOf(char, lastIdx);\n        if (idx === -1)\n            return input;\n        if (input[idx - 1] === '\\\\')\n            return exports.escapeLast(input, char, idx - 1);\n        return input.slice(0, idx) + '\\\\' + input.slice(idx);\n    };\n});\nvar utils_1$1 = utils$1.isObject;\nvar utils_2$1 = utils$1.hasRegexChars;\nvar utils_3$1 = utils$1.isRegexChar;\nvar utils_4$1 = utils$1.escapeRegex;\nvar utils_5$1 = utils$1.toPosixSlashes;\nvar utils_6$1 = utils$1.removeBackslashes;\nvar utils_7$1 = utils$1.supportsLookbehinds;\nvar utils_8$1 = utils$1.isWindows;\nvar utils_9$1 = utils$1.escapeLast;\n\nconst { CHAR_ASTERISK, /* * */ CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH, /* \\ */ CHAR_COMMA: CHAR_COMMA$1, /* , */ CHAR_DOT: CHAR_DOT$1, /* . */ CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1, /* { */ CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1, /* ( */ CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1, /* [ */ CHAR_PLUS, /* + */ CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1, /* } */ CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1, /* ) */ CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1 /* ] */ } = constants$1;\nconst isPathSeparator = code => {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\nvar scan = (input, options) => {\n    let opts = options || {};\n    let length = input.length - 1;\n    let index = -1;\n    let start = 0;\n    let lastIndex = 0;\n    let isGlob = false;\n    let backslashes = false;\n    let negated = false;\n    let braces = 0;\n    let prev;\n    let code;\n    let braceEscaped = false;\n    let eos = () => index >= length;\n    let advance = () => {\n        prev = code;\n        return input.charCodeAt(++index);\n    };\n    while (index < length) {\n        code = advance();\n        let next;\n        if (code === CHAR_BACKWARD_SLASH) {\n            backslashes = true;\n            next = advance();\n            if (next === CHAR_LEFT_CURLY_BRACE$1) {\n                braceEscaped = true;\n            }\n            continue;\n        }\n        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {\n            braces++;\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_LEFT_CURLY_BRACE$1) {\n                    braces++;\n                    continue;\n                }\n                if (!braceEscaped && next === CHAR_DOT$1 && (next = advance()) === CHAR_DOT$1) {\n                    isGlob = true;\n                    break;\n                }\n                if (!braceEscaped && next === CHAR_COMMA$1) {\n                    isGlob = true;\n                    break;\n                }\n                if (next === CHAR_RIGHT_CURLY_BRACE$1) {\n                    braces--;\n                    if (braces === 0) {\n                        braceEscaped = false;\n                        break;\n                    }\n                }\n            }\n        }\n        if (code === CHAR_FORWARD_SLASH) {\n            if (prev === CHAR_DOT$1 && index === (start + 1)) {\n                start += 2;\n                continue;\n            }\n            lastIndex = index + 1;\n            continue;\n        }\n        if (code === CHAR_ASTERISK) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_LEFT_SQUARE_BRACKET$1) {\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n                    isGlob = true;\n                    break;\n                }\n            }\n        }\n        let isExtglobChar = code === CHAR_PLUS\n            || code === CHAR_AT\n            || code === CHAR_EXCLAMATION_MARK;\n        if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES$1) {\n            isGlob = true;\n            break;\n        }\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n            negated = true;\n            start++;\n            continue;\n        }\n        if (code === CHAR_LEFT_PARENTHESES$1) {\n            while (!eos() && (next = advance())) {\n                if (next === CHAR_BACKWARD_SLASH) {\n                    backslashes = true;\n                    next = advance();\n                    continue;\n                }\n                if (next === CHAR_RIGHT_PARENTHESES$1) {\n                    isGlob = true;\n                    break;\n                }\n            }\n        }\n        if (isGlob) {\n            break;\n        }\n    }\n    let prefix = '';\n    let orig = input;\n    let base = input;\n    let glob = '';\n    if (start > 0) {\n        prefix = input.slice(0, start);\n        input = input.slice(start);\n        lastIndex -= start;\n    }\n    if (base && isGlob === true && lastIndex > 0) {\n        base = input.slice(0, lastIndex);\n        glob = input.slice(lastIndex);\n    }\n    else if (isGlob === true) {\n        base = '';\n        glob = input;\n    }\n    else {\n        base = input;\n    }\n    if (base && base !== '' && base !== '/' && base !== input) {\n        if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n            base = base.slice(0, -1);\n        }\n    }\n    if (opts.unescape === true) {\n        if (glob)\n            glob = utils$1.removeBackslashes(glob);\n        if (base && backslashes === true) {\n            base = utils$1.removeBackslashes(base);\n        }\n    }\n    return { prefix, input: orig, base, glob, negated, isGlob };\n};\n\n/**\n * Constants\n */\nconst { MAX_LENGTH: MAX_LENGTH$1, POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1, REGEX_NON_SPECIAL_CHAR, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants$1;\n/**\n * Helpers\n */\nconst expandRange = (args, options) => {\n    if (typeof options.expandRange === 'function') {\n        return options.expandRange(...args, options);\n    }\n    args.sort();\n    let value = `[${args.join('-')}]`;\n    try {\n    }\n    catch (ex) {\n        return args.map(v => utils$1.escapeRegex(v)).join('..');\n    }\n    return value;\n};\nconst negate = state => {\n    let count = 1;\n    while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {\n        state.advance();\n        state.start++;\n        count++;\n    }\n    if (count % 2 === 0) {\n        return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n};\n/**\n * Create the message for a syntax error\n */\nconst syntaxError = (type, char) => {\n    return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\nconst parse$1 = (input, options) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    input = REPLACEMENTS[input] || input;\n    let opts = Object.assign({}, options);\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    let bos = { type: 'bos', value: '', output: opts.prepend || '' };\n    let tokens = [bos];\n    let capture = opts.capture ? '' : '?:';\n    let win32 = utils$1.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const PLATFORM_CHARS = constants$1.globChars(win32);\n    const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);\n    const { DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR } = PLATFORM_CHARS;\n    const globstar = (opts) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    let nodot = opts.dot ? '' : NO_DOT;\n    let star = opts.bash === true ? globstar(opts) : STAR;\n    let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    // minimatch options support\n    if (typeof opts.noext === 'boolean') {\n        opts.noextglob = opts.noext;\n    }\n    let state = {\n        index: -1,\n        start: 0,\n        consumed: '',\n        output: '',\n        backtrack: false,\n        brackets: 0,\n        braces: 0,\n        parens: 0,\n        quotes: 0,\n        tokens\n    };\n    let extglobs = [];\n    let stack = [];\n    let prev = bos;\n    let value;\n    /**\n     * Tokenizing helpers\n     */\n    const eos = () => state.index === len - 1;\n    const peek = state.peek = (n = 1) => input[state.index + n];\n    const advance = state.advance = () => input[++state.index];\n    const append = token => {\n        state.output += token.output != null ? token.output : token.value;\n        state.consumed += token.value || '';\n    };\n    const increment = type => {\n        state[type]++;\n        stack.push(type);\n    };\n    const decrement = type => {\n        state[type]--;\n        stack.pop();\n    };\n    /**\n     * Push tokens onto the tokens array. This helper speeds up\n     * tokenizing by 1) helping us avoid backtracking as much as possible,\n     * and 2) helping us avoid creating extra tokens when consecutive\n     * characters are plain text. This improves performance and simplifies\n     * lookbehinds.\n     */\n    const push = tok => {\n        if (prev.type === 'globstar') {\n            let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n            let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n            if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n                state.output = state.output.slice(0, -prev.output.length);\n                prev.type = 'star';\n                prev.value = '*';\n                prev.output = star;\n                state.output += prev.output;\n            }\n        }\n        if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n            extglobs[extglobs.length - 1].inner += tok.value;\n        }\n        if (tok.value || tok.output)\n            append(tok);\n        if (prev && prev.type === 'text' && tok.type === 'text') {\n            prev.value += tok.value;\n            return;\n        }\n        tok.prev = prev;\n        tokens.push(tok);\n        prev = tok;\n    };\n    const extglobOpen = (type, value) => {\n        let token = Object.assign({}, EXTGLOB_CHARS[value], { conditions: 1, inner: '' });\n        token.prev = prev;\n        token.parens = state.parens;\n        token.output = state.output;\n        let output = (opts.capture ? '(' : '') + token.open;\n        push({ type, value, output: state.output ? '' : ONE_CHAR });\n        push({ type: 'paren', extglob: true, value: advance(), output });\n        increment('parens');\n        extglobs.push(token);\n    };\n    const extglobClose = token => {\n        let output = token.close + (opts.capture ? ')' : '');\n        if (token.type === 'negate') {\n            let extglobStar = star;\n            if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n                extglobStar = globstar(opts);\n            }\n            if (extglobStar !== star || eos() || /^\\)+$/.test(input.slice(state.index + 1))) {\n                output = token.close = ')$))' + extglobStar;\n            }\n            if (token.prev.type === 'bos' && eos()) {\n                state.negatedExtglob = true;\n            }\n        }\n        push({ type: 'paren', extglob: true, value, output });\n        decrement('parens');\n    };\n    if (opts.fastpaths !== false && !/(^[*!]|[/{[()\\]}\"])/.test(input)) {\n        let backslashes = false;\n        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n            if (first === '\\\\') {\n                backslashes = true;\n                return m;\n            }\n            if (first === '?') {\n                if (esc) {\n                    return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n                }\n                if (index === 0) {\n                    return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n                }\n                return QMARK.repeat(chars.length);\n            }\n            if (first === '.') {\n                return DOT_LITERAL.repeat(chars.length);\n            }\n            if (first === '*') {\n                if (esc) {\n                    return esc + first + (rest ? star : '');\n                }\n                return star;\n            }\n            return esc ? m : '\\\\' + m;\n        });\n        if (backslashes === true) {\n            if (opts.unescape === true) {\n                output = output.replace(/\\\\/g, '');\n            }\n            else {\n                output = output.replace(/\\\\+/g, m => {\n                    return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n                });\n            }\n        }\n        state.output = output;\n        return state;\n    }\n    /**\n     * Tokenize input until we reach end-of-string\n     */\n    while (!eos()) {\n        value = advance();\n        if (value === '\\u0000') {\n            continue;\n        }\n        /**\n         * Escaped characters\n         */\n        if (value === '\\\\') {\n            let next = peek();\n            if (next === '/' && opts.bash !== true) {\n                continue;\n            }\n            if (next === '.' || next === ';') {\n                continue;\n            }\n            if (!next) {\n                value += '\\\\';\n                push({ type: 'text', value });\n                continue;\n            }\n            // collapse slashes to reduce potential for exploits\n            let match = /^\\\\+/.exec(input.slice(state.index + 1));\n            let slashes = 0;\n            if (match && match[0].length > 2) {\n                slashes = match[0].length;\n                state.index += slashes;\n                if (slashes % 2 !== 0) {\n                    value += '\\\\';\n                }\n            }\n            if (opts.unescape === true) {\n                value = advance() || '';\n            }\n            else {\n                value += advance() || '';\n            }\n            if (state.brackets === 0) {\n                push({ type: 'text', value });\n                continue;\n            }\n        }\n        /**\n         * If we're inside a regex character class, continue\n         * until we reach the closing bracket.\n         */\n        if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n            if (opts.posix !== false && value === ':') {\n                let inner = prev.value.slice(1);\n                if (inner.includes('[')) {\n                    prev.posix = true;\n                    if (inner.includes(':')) {\n                        let idx = prev.value.lastIndexOf('[');\n                        let pre = prev.value.slice(0, idx);\n                        let rest = prev.value.slice(idx + 2);\n                        let posix = POSIX_REGEX_SOURCE$1[rest];\n                        if (posix) {\n                            prev.value = pre + posix;\n                            state.backtrack = true;\n                            advance();\n                            if (!bos.output && tokens.indexOf(prev) === 1) {\n                                bos.output = ONE_CHAR;\n                            }\n                            continue;\n                        }\n                    }\n                }\n            }\n            if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n                value = '\\\\' + value;\n            }\n            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n                value = '\\\\' + value;\n            }\n            if (opts.posix === true && value === '!' && prev.value === '[') {\n                value = '^';\n            }\n            prev.value += value;\n            append({ value });\n            continue;\n        }\n        /**\n         * If we're inside a quoted string, continue\n         * until we reach the closing double quote.\n         */\n        if (state.quotes === 1 && value !== '\"') {\n            value = utils$1.escapeRegex(value);\n            prev.value += value;\n            append({ value });\n            continue;\n        }\n        /**\n         * Double quotes\n         */\n        if (value === '\"') {\n            state.quotes = state.quotes === 1 ? 0 : 1;\n            if (opts.keepQuotes === true) {\n                push({ type: 'text', value });\n            }\n            continue;\n        }\n        /**\n         * Parentheses\n         */\n        if (value === '(') {\n            push({ type: 'paren', value });\n            increment('parens');\n            continue;\n        }\n        if (value === ')') {\n            if (state.parens === 0 && opts.strictBrackets === true) {\n                throw new SyntaxError(syntaxError('opening', '('));\n            }\n            let extglob = extglobs[extglobs.length - 1];\n            if (extglob && state.parens === extglob.parens + 1) {\n                extglobClose(extglobs.pop());\n                continue;\n            }\n            push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n            decrement('parens');\n            continue;\n        }\n        /**\n         * Brackets\n         */\n        if (value === '[') {\n            if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {\n                if (opts.nobracket !== true && opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError('closing', ']'));\n                }\n                value = '\\\\' + value;\n            }\n            else {\n                increment('brackets');\n            }\n            push({ type: 'bracket', value });\n            continue;\n        }\n        if (value === ']') {\n            if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            if (state.brackets === 0) {\n                if (opts.strictBrackets === true) {\n                    throw new SyntaxError(syntaxError('opening', '['));\n                }\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            decrement('brackets');\n            let prevValue = prev.value.slice(1);\n            if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n                value = '/' + value;\n            }\n            prev.value += value;\n            append({ value });\n            // when literal brackets are explicitly disabled\n            // assume we should match with a regex character class\n            if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {\n                continue;\n            }\n            let escaped = utils$1.escapeRegex(prev.value);\n            state.output = state.output.slice(0, -prev.value.length);\n            // when literal brackets are explicitly enabled\n            // assume we should escape the brackets to match literal characters\n            if (opts.literalBrackets === true) {\n                state.output += escaped;\n                prev.value = escaped;\n                continue;\n            }\n            // when the user specifies nothing, try to match both\n            prev.value = `(${capture}${escaped}|${prev.value})`;\n            state.output += prev.value;\n            continue;\n        }\n        /**\n         * Braces\n         */\n        if (value === '{' && opts.nobrace !== true) {\n            push({ type: 'brace', value, output: '(' });\n            increment('braces');\n            continue;\n        }\n        if (value === '}') {\n            if (opts.nobrace === true || state.braces === 0) {\n                push({ type: 'text', value, output: '\\\\' + value });\n                continue;\n            }\n            let output = ')';\n            if (state.dots === true) {\n                let arr = tokens.slice();\n                let range = [];\n                for (let i = arr.length - 1; i >= 0; i--) {\n                    tokens.pop();\n                    if (arr[i].type === 'brace') {\n                        break;\n                    }\n                    if (arr[i].type !== 'dots') {\n                        range.unshift(arr[i].value);\n                    }\n                }\n                output = expandRange(range, opts);\n                state.backtrack = true;\n            }\n            push({ type: 'brace', value, output });\n            decrement('braces');\n            continue;\n        }\n        /**\n         * Pipes\n         */\n        if (value === '|') {\n            if (extglobs.length > 0) {\n                extglobs[extglobs.length - 1].conditions++;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Commas\n         */\n        if (value === ',') {\n            let output = value;\n            if (state.braces > 0 && stack[stack.length - 1] === 'braces') {\n                output = '|';\n            }\n            push({ type: 'comma', value, output });\n            continue;\n        }\n        /**\n         * Slashes\n         */\n        if (value === '/') {\n            // if the beginning of the glob is \"./\", advance the start\n            // to the current index, and don't add the \"./\" characters\n            // to the state. This greatly simplifies lookbehinds when\n            // checking for BOS characters like \"!\" and \".\" (not \"./\")\n            if (prev.type === 'dot' && state.index === 1) {\n                state.start = state.index + 1;\n                state.consumed = '';\n                state.output = '';\n                tokens.pop();\n                prev = bos; // reset \"prev\" to the first token\n                continue;\n            }\n            push({ type: 'slash', value, output: SLASH_LITERAL });\n            continue;\n        }\n        /**\n         * Dots\n         */\n        if (value === '.') {\n            if (state.braces > 0 && prev.type === 'dot') {\n                if (prev.value === '.')\n                    prev.output = DOT_LITERAL;\n                prev.type = 'dots';\n                prev.output += value;\n                prev.value += value;\n                state.dots = true;\n                continue;\n            }\n            push({ type: 'dot', value, output: DOT_LITERAL });\n            continue;\n        }\n        /**\n         * Question marks\n         */\n        if (value === '?') {\n            if (prev && prev.type === 'paren') {\n                let next = peek();\n                let output = value;\n                if (next === '<' && !utils$1.supportsLookbehinds()) {\n                    throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n                }\n                if (prev.value === '(' && !/[!=<:]/.test(next) || (next === '<' && !/[!=]/.test(peek(2)))) {\n                    output = '\\\\' + value;\n                }\n                push({ type: 'text', value, output });\n                continue;\n            }\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                extglobOpen('qmark', value);\n                continue;\n            }\n            if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n                push({ type: 'qmark', value, output: QMARK_NO_DOT });\n                continue;\n            }\n            push({ type: 'qmark', value, output: QMARK });\n            continue;\n        }\n        /**\n         * Exclamation\n         */\n        if (value === '!') {\n            if (opts.noextglob !== true && peek() === '(') {\n                if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n                    extglobOpen('negate', value);\n                    continue;\n                }\n            }\n            if (opts.nonegate !== true && state.index === 0) {\n                negate(state);\n                continue;\n            }\n        }\n        /**\n         * Plus\n         */\n        if (value === '+') {\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                extglobOpen('plus', value);\n                continue;\n            }\n            if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {\n                let output = prev.extglob === true ? '\\\\' + value : value;\n                push({ type: 'plus', value, output });\n                continue;\n            }\n            // use regex behavior inside parens\n            if (state.parens > 0 && opts.regex !== false) {\n                push({ type: 'plus', value });\n                continue;\n            }\n            push({ type: 'plus', value: PLUS_LITERAL });\n            continue;\n        }\n        /**\n         * Plain text\n         */\n        if (value === '@') {\n            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n                push({ type: 'at', value, output: '' });\n                continue;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Plain text\n         */\n        if (value !== '*') {\n            if (value === '$' || value === '^') {\n                value = '\\\\' + value;\n            }\n            let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));\n            if (match) {\n                value += match[0];\n                state.index += match[0].length;\n            }\n            push({ type: 'text', value });\n            continue;\n        }\n        /**\n         * Stars\n         */\n        if (prev && (prev.type === 'globstar' || prev.star === true)) {\n            prev.type = 'star';\n            prev.star = true;\n            prev.value += value;\n            prev.output = star;\n            state.backtrack = true;\n            state.consumed += value;\n            continue;\n        }\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n            extglobOpen('star', value);\n            continue;\n        }\n        if (prev.type === 'star') {\n            if (opts.noglobstar === true) {\n                state.consumed += value;\n                continue;\n            }\n            let prior = prev.prev;\n            let before = prior.prev;\n            let isStart = prior.type === 'slash' || prior.type === 'bos';\n            let afterStar = before && (before.type === 'star' || before.type === 'globstar');\n            if (opts.bash === true && (!isStart || (!eos() && peek() !== '/'))) {\n                push({ type: 'star', value, output: '' });\n                continue;\n            }\n            let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n            let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n                push({ type: 'star', value, output: '' });\n                continue;\n            }\n            // strip consecutive `/**/`\n            while (input.slice(state.index + 1, state.index + 4) === '/**') {\n                let after = input[state.index + 4];\n                if (after && after !== '/') {\n                    break;\n                }\n                state.consumed += '/**';\n                state.index += 3;\n            }\n            if (prior.type === 'bos' && eos()) {\n                prev.type = 'globstar';\n                prev.value += value;\n                prev.output = globstar(opts);\n                state.output = prev.output;\n                state.consumed += value;\n                continue;\n            }\n            if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = '(?:' + prior.output;\n                prev.type = 'globstar';\n                prev.output = globstar(opts) + '|$)';\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.consumed += value;\n                continue;\n            }\n            let next = peek();\n            if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {\n                let end = peek(2) !== void 0 ? '|$' : '';\n                state.output = state.output.slice(0, -(prior.output + prev.output).length);\n                prior.output = '(?:' + prior.output;\n                prev.type = 'globstar';\n                prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n                prev.value += value;\n                state.output += prior.output + prev.output;\n                state.consumed += value + advance();\n                push({ type: 'slash', value, output: '' });\n                continue;\n            }\n            if (prior.type === 'bos' && next === '/') {\n                prev.type = 'globstar';\n                prev.value += value;\n                prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n                state.output = prev.output;\n                state.consumed += value + advance();\n                push({ type: 'slash', value, output: '' });\n                continue;\n            }\n            // remove single star from output\n            state.output = state.output.slice(0, -prev.output.length);\n            // reset previous token to globstar\n            prev.type = 'globstar';\n            prev.output = globstar(opts);\n            prev.value += value;\n            // reset output with globstar\n            state.output += prev.output;\n            state.consumed += value;\n            continue;\n        }\n        let token = { type: 'star', value, output: star };\n        if (opts.bash === true) {\n            token.output = '.*?';\n            if (prev.type === 'bos' || prev.type === 'slash') {\n                token.output = nodot + token.output;\n            }\n            push(token);\n            continue;\n        }\n        if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n            token.output = value;\n            push(token);\n            continue;\n        }\n        if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n            if (prev.type === 'dot') {\n                state.output += NO_DOT_SLASH;\n                prev.output += NO_DOT_SLASH;\n            }\n            else if (opts.dot === true) {\n                state.output += NO_DOTS_SLASH;\n                prev.output += NO_DOTS_SLASH;\n            }\n            else {\n                state.output += nodot;\n                prev.output += nodot;\n            }\n            if (peek() !== '*') {\n                state.output += ONE_CHAR;\n                prev.output += ONE_CHAR;\n            }\n        }\n        push(token);\n    }\n    while (state.brackets > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', ']'));\n        state.output = utils$1.escapeLast(state.output, '[');\n        decrement('brackets');\n    }\n    while (state.parens > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', ')'));\n        state.output = utils$1.escapeLast(state.output, '(');\n        decrement('parens');\n    }\n    while (state.braces > 0) {\n        if (opts.strictBrackets === true)\n            throw new SyntaxError(syntaxError('closing', '}'));\n        state.output = utils$1.escapeLast(state.output, '{');\n        decrement('braces');\n    }\n    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n        push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n    }\n    // rebuild the output if we had to backtrack at any point\n    if (state.backtrack === true) {\n        state.output = '';\n        for (let token of state.tokens) {\n            state.output += token.output != null ? token.output : token.value;\n            if (token.suffix) {\n                state.output += token.suffix;\n            }\n        }\n    }\n    return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\nparse$1.fastpaths = (input, options) => {\n    let opts = Object.assign({}, options);\n    let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n    let len = input.length;\n    if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    input = REPLACEMENTS[input] || input;\n    let win32 = utils$1.isWindows(options);\n    // create constants based on platform, for windows or posix\n    const { DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR } = constants$1.globChars(win32);\n    let capture = opts.capture ? '' : '?:';\n    let star = opts.bash === true ? '.*?' : STAR;\n    let nodot = opts.dot ? NO_DOTS : NO_DOT;\n    let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n    if (opts.capture) {\n        star = `(${star})`;\n    }\n    const globstar = (opts) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const create = str => {\n        switch (str) {\n            case '*':\n                return `${nodot}${ONE_CHAR}${star}`;\n            case '.*':\n                return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '*.*':\n                return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '*/*':\n                return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n            case '**':\n                return nodot + globstar(opts);\n            case '**/*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n            case '**/*.*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n            case '**/.*':\n                return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n            default: {\n                let match = /^(.*?)\\.(\\w+)$/.exec(str);\n                if (!match)\n                    return;\n                let source = create(match[1], options);\n                if (!source)\n                    return;\n                return source + DOT_LITERAL + match[2];\n            }\n        }\n    };\n    let output = create(input);\n    if (output && opts.strictSlashes !== true) {\n        output += `${SLASH_LITERAL}?`;\n    }\n    return output;\n};\nvar parse_1$1 = parse$1;\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\nconst picomatch = (glob, options, returnState = false) => {\n    if (Array.isArray(glob)) {\n        let fns = glob.map(input => picomatch(input, options, returnState));\n        return str => {\n            for (let isMatch of fns) {\n                let state = isMatch(str);\n                if (state)\n                    return state;\n            }\n            return false;\n        };\n    }\n    if (typeof glob !== 'string' || glob === '') {\n        throw new TypeError('Expected pattern to be a non-empty string');\n    }\n    let opts = options || {};\n    let posix = utils$1.isWindows(options);\n    let regex = picomatch.makeRe(glob, options, false, true);\n    let state = regex.state;\n    delete regex.state;\n    let isIgnored = () => false;\n    if (opts.ignore) {\n        let ignoreOpts = Object.assign({}, options, { ignore: null, onMatch: null, onResult: null });\n        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n    }\n    const matcher = (input, returnObject = false) => {\n        let { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n        let result = { glob, state, regex, posix, input, output, match, isMatch };\n        if (typeof opts.onResult === 'function') {\n            opts.onResult(result);\n        }\n        if (isMatch === false) {\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (isIgnored(input)) {\n            if (typeof opts.onIgnore === 'function') {\n                opts.onIgnore(result);\n            }\n            result.isMatch = false;\n            return returnObject ? result : false;\n        }\n        if (typeof opts.onMatch === 'function') {\n            opts.onMatch(result);\n        }\n        return returnObject ? result : true;\n    };\n    if (returnState) {\n        matcher.state = state;\n    }\n    return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected input to be a string');\n    }\n    if (input === '') {\n        return { isMatch: false, output: '' };\n    }\n    let opts = options || {};\n    let format = opts.format || (posix ? utils$1.toPosixSlashes : null);\n    let match = input === glob;\n    let output = (match && format) ? format(input) : input;\n    if (match === false) {\n        output = format ? format(input) : input;\n        match = output === glob;\n    }\n    if (match === false || opts.capture === true) {\n        if (opts.matchBase === true || opts.basename === true) {\n            match = picomatch.matchBase(input, regex, options, posix);\n        }\n        else {\n            match = regex.exec(output);\n        }\n    }\n    return { isMatch: !!match, match, output };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\npicomatch.matchBase = (input, glob, options, posix = utils$1.isWindows(options)) => {\n    let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n    return regex.test(path.basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\npicomatch.parse = (glob, options) => parse_1$1(glob, options);\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\npicomatch.scan = (input, options) => scan(input, options);\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n    if (!input || typeof input !== 'string') {\n        throw new TypeError('Expected a non-empty string');\n    }\n    let opts = options || {};\n    let prepend = opts.contains ? '' : '^';\n    let append = opts.contains ? '' : '$';\n    let state = { negated: false, fastpaths: true };\n    let prefix = '';\n    let output;\n    if (input.startsWith('./')) {\n        input = input.slice(2);\n        prefix = state.prefix = './';\n    }\n    if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n        output = parse_1$1.fastpaths(input, options);\n    }\n    if (output === void 0) {\n        state = picomatch.parse(input, options);\n        state.prefix = prefix + (state.prefix || '');\n        output = state.output;\n    }\n    if (returnOutput === true) {\n        return output;\n    }\n    let source = `${prepend}(?:${output})${append}`;\n    if (state && state.negated === true) {\n        source = `^(?!${source}).*$`;\n    }\n    let regex = picomatch.toRegex(source, options);\n    if (returnState === true) {\n        regex.state = state;\n    }\n    return regex;\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\npicomatch.toRegex = (source, options) => {\n    try {\n        let opts = options || {};\n        return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n    }\n    catch (err) {\n        if (options && options.debug === true)\n            throw err;\n        return /$^/;\n    }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\npicomatch.constants = constants$1;\n/**\n * Expose \"picomatch\"\n */\nvar picomatch_1 = picomatch;\n\nvar picomatch$1 = picomatch_1;\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\nconst micromatch = (list, patterns, options) => {\n    patterns = [].concat(patterns);\n    list = [].concat(list);\n    let omit = new Set();\n    let keep = new Set();\n    let items = new Set();\n    let negatives = 0;\n    let onResult = state => {\n        items.add(state.output);\n        if (options && options.onResult) {\n            options.onResult(state);\n        }\n    };\n    for (let i = 0; i < patterns.length; i++) {\n        let isMatch = picomatch$1(String(patterns[i]), Object.assign({}, options, { onResult }), true);\n        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n        if (negated)\n            negatives++;\n        for (let item of list) {\n            let matched = isMatch(item, true);\n            let match = negated ? !matched.isMatch : matched.isMatch;\n            if (!match)\n                continue;\n            if (negated) {\n                omit.add(matched.output);\n            }\n            else {\n                omit.delete(matched.output);\n                keep.add(matched.output);\n            }\n        }\n    }\n    let result = negatives === patterns.length ? [...items] : [...keep];\n    let matches = result.filter(item => !omit.has(item));\n    if (options && matches.length === 0) {\n        if (options.failglob === true) {\n            throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n        }\n        if (options.nonull === true || options.nullglob === true) {\n            return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n        }\n    }\n    return matches;\n};\n/**\n * Backwards compatibility\n */\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\nmicromatch.matcher = (pattern, options) => picomatch$1(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);\n/**\n * Backwards compatibility\n */\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\nmicromatch.not = (list, patterns, options = {}) => {\n    patterns = [].concat(patterns).map(String);\n    let result = new Set();\n    let items = [];\n    let onResult = state => {\n        if (options.onResult)\n            options.onResult(state);\n        items.push(state.output);\n    };\n    let matches = micromatch(list, patterns, Object.assign({}, options, { onResult }));\n    for (let item of items) {\n        if (!matches.includes(item)) {\n            result.add(item);\n        }\n    }\n    return [...result];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\nmicromatch.contains = (str, pattern, options) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    if (Array.isArray(pattern)) {\n        return pattern.some(p => micromatch.contains(str, p, options));\n    }\n    if (typeof pattern === 'string') {\n        if (isEmptyString(str) || isEmptyString(pattern)) {\n            return false;\n        }\n        if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n            return true;\n        }\n    }\n    return micromatch.isMatch(str, pattern, Object.assign({}, options, { contains: true }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\nmicromatch.matchKeys = (obj, patterns, options) => {\n    if (!utils$1.isObject(obj)) {\n        throw new TypeError('Expected the first argument to be an object');\n    }\n    let keys = micromatch(Object.keys(obj), patterns, options);\n    let res = {};\n    for (let key of keys)\n        res[key] = obj[key];\n    return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.some = (list, patterns, options) => {\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch$1(String(pattern), options);\n        if (items.some(item => isMatch(item))) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.every = (list, patterns, options) => {\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch$1(String(pattern), options);\n        if (!items.every(item => isMatch(item))) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\nmicromatch.all = (str, patterns, options) => {\n    if (typeof str !== 'string') {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    return [].concat(patterns).every(p => picomatch$1(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\nmicromatch.capture = (glob, input, options) => {\n    let posix = utils$1.isWindows(options);\n    let regex = picomatch$1.makeRe(String(glob), Object.assign({}, options, { capture: true }));\n    let match = regex.exec(posix ? utils$1.toPosixSlashes(input) : input);\n    if (match) {\n        return match.slice(1).map(v => v === void 0 ? '' : v);\n    }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\nmicromatch.makeRe = (...args) => picomatch$1.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\nmicromatch.scan = (...args) => picomatch$1.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\nmicromatch.parse = (patterns, options) => {\n    let res = [];\n    for (let pattern of [].concat(patterns || [])) {\n        for (let str of braces_1(String(pattern), options)) {\n            res.push(picomatch$1.parse(str, options));\n        }\n    }\n    return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\nmicromatch.braces = (pattern, options) => {\n    if (typeof pattern !== 'string')\n        throw new TypeError('Expected a string');\n    if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n        return [pattern];\n    }\n    return braces_1(pattern, options);\n};\n/**\n * Expand braces\n */\nmicromatch.braceExpand = (pattern, options) => {\n    if (typeof pattern !== 'string')\n        throw new TypeError('Expected a string');\n    return micromatch.braces(pattern, Object.assign({}, options, { expand: true }));\n};\n/**\n * Expose micromatch\n */\nvar micromatch_1 = micromatch;\n\nfunction ensureArray(thing) {\n    if (Array.isArray(thing))\n        return thing;\n    if (thing == undefined)\n        return [];\n    return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false) {\n        return id;\n    }\n    return resolve(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => {\n        return id instanceof RegExp\n            ? id\n            : {\n                test: micromatch_1.matcher(getMatcherString(id, resolutionBase)\n                    .split(sep)\n                    .join('/'), { dot: true })\n            };\n    };\n    const includeMatchers = ensureArray(include).map(getMatcher);\n    const excludeMatchers = ensureArray(exclude).map(getMatcher);\n    return function (id) {\n        if (typeof id !== 'string')\n            return false;\n        if (/\\0/.test(id))\n            return false;\n        id = id.split(sep).join('/');\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(id))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(id))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n    str = str.replace(/-(\\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, '_');\n    if (/\\d/.test(str[0]) || forbiddenIdentifiers.has(str)) {\n        str = `_${str}`;\n    }\n    return str || '_';\n};\n\nfunction stringify$2(obj) {\n    return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, char => `\\\\u${('000' + char.charCodeAt(0).toString(16)).slice(-4)}`);\n}\nfunction serializeArray(arr, indent, baseIndent) {\n    let output = '[';\n    const separator = indent ? '\\n' + baseIndent + indent : '';\n    for (let i = 0; i < arr.length; i++) {\n        const key = arr[i];\n        output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n    }\n    return output + `${indent ? '\\n' + baseIndent : ''}]`;\n}\nfunction serializeObject(obj, indent, baseIndent) {\n    let output = '{';\n    const separator = indent ? '\\n' + baseIndent + indent : '';\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const stringKey = makeLegalIdentifier(key) === key ? key : stringify$2(key);\n        output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(obj[key], indent, baseIndent + indent)}`;\n    }\n    return output + `${indent ? '\\n' + baseIndent : ''}}`;\n}\nfunction serialize(obj, indent, baseIndent) {\n    if (obj === Infinity)\n        return 'Infinity';\n    if (obj === -Infinity)\n        return '-Infinity';\n    if (obj === 0 && 1 / obj === -Infinity)\n        return '-0';\n    if (obj instanceof Date)\n        return 'new Date(' + obj.getTime() + ')';\n    if (obj instanceof RegExp)\n        return obj.toString();\n    if (obj !== obj)\n        return 'NaN';\n    if (Array.isArray(obj))\n        return serializeArray(obj, indent, baseIndent);\n    if (obj === null)\n        return 'null';\n    if (typeof obj === 'object')\n        return serializeObject(obj, indent, baseIndent);\n    return stringify$2(obj);\n}\nconst dataToEsm = function dataToEsm(data, options = {}) {\n    const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const declarationType = options.preferConst ? 'const' : 'var';\n    if (options.namedExports === false ||\n        typeof data !== 'object' ||\n        Array.isArray(data) ||\n        data instanceof Date ||\n        data instanceof RegExp ||\n        data === null) {\n        const code = serialize(data, options.compact ? null : t, '');\n        const __ = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' ');\n        return `export default${__}${code};`;\n    }\n    let namedExportCode = '';\n    const defaultExportRows = [];\n    const dataKeys = Object.keys(data);\n    for (let i = 0; i < dataKeys.length; i++) {\n        const key = dataKeys[i];\n        if (key === makeLegalIdentifier(key)) {\n            if (options.objectShorthand)\n                defaultExportRows.push(key);\n            else\n                defaultExportRows.push(`${key}:${_}${key}`);\n            namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(data[key], options.compact ? null : t, '')};${n}`;\n        }\n        else {\n            defaultExportRows.push(`${stringify$2(key)}:${_}${serialize(data[key], options.compact ? null : t, '')}`);\n        }\n    }\n    return (namedExportCode + `export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`);\n};\n\nexport { addExtension, attachScopes, createFilter, dataToEsm, extractAssignedNames, makeLegalIdentifier };\n"]},"metadata":{},"sourceType":"module"}