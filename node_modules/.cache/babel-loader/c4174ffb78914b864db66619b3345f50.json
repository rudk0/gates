{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/agatha/open/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Ref = require('./ref');\n\nvar internals = {};\n\ninternals.extendedCheckForValue = function (value, insensitive) {\n  var valueType = typeof value;\n\n  if (valueType === 'object') {\n    if (value instanceof Date) {\n      return function (item) {\n        return item instanceof Date && value.getTime() === item.getTime();\n      };\n    }\n\n    if (Buffer.isBuffer(value)) {\n      return function (item) {\n        return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n      };\n    }\n  } else if (insensitive && valueType === 'string') {\n    var lowercaseValue = value.toLowerCase();\n    return function (item) {\n      return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n    };\n  }\n\n  return null;\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function InternalSet(from) {\n    _classCallCheck(this, InternalSet);\n\n    this._set = new Set(from);\n    this._hasRef = false;\n  }\n\n  _createClass(InternalSet, [{\n    key: \"add\",\n    value: function add(value, refs) {\n      var isRef = Ref.isRef(value);\n\n      if (!isRef && this.has(value, null, null, false)) {\n        return this;\n      }\n\n      if (refs !== undefined) {\n        // If it's a merge, we don't have any refs\n        Ref.push(refs, value);\n      }\n\n      this._set.add(value);\n\n      this._hasRef |= isRef;\n      return this;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(add, remove) {\n      var _iterator = _createForOfIteratorHelper(add._set),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          this.add(item);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(remove._set),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _item = _step2.value;\n          this.remove(_item);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(value) {\n      this._set.delete(value);\n\n      return this;\n    }\n  }, {\n    key: \"has\",\n    value: function has(value, state, options, insensitive) {\n      return !!this.get(value, state, options, insensitive);\n    }\n  }, {\n    key: \"get\",\n    value: function get(value, state, options, insensitive) {\n      if (!this._set.size) {\n        return false;\n      }\n\n      var hasValue = this._set.has(value);\n\n      if (hasValue) {\n        return {\n          value: value\n        };\n      }\n\n      var extendedCheck = internals.extendedCheckForValue(value, insensitive);\n\n      if (!extendedCheck) {\n        if (state && this._hasRef) {\n          var _iterator3 = _createForOfIteratorHelper(this._set),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var item = _step3.value;\n\n              if (Ref.isRef(item)) {\n                item = [].concat(item(state.reference || state.parent, options));\n                var found = item.indexOf(value);\n\n                if (found >= 0) {\n                  return {\n                    value: item[found]\n                  };\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        return false;\n      }\n\n      return this._has(value, state, options, extendedCheck);\n    }\n  }, {\n    key: \"_has\",\n    value: function _has(value, state, options, check) {\n      var checkRef = !!(state && this._hasRef);\n\n      var isReallyEqual = function isReallyEqual(item) {\n        if (value === item) {\n          return true;\n        }\n\n        return check(item);\n      };\n\n      var _iterator4 = _createForOfIteratorHelper(this._set),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var item = _step4.value;\n\n          if (checkRef && Ref.isRef(item)) {\n            // Only resolve references if there is a state, otherwise it's a merge\n            item = item(state.reference || state.parent, options);\n\n            if (Array.isArray(item)) {\n              var found = item.findIndex(isReallyEqual);\n\n              if (found >= 0) {\n                return {\n                  value: item[found]\n                };\n              }\n\n              continue;\n            }\n          }\n\n          if (isReallyEqual(item)) {\n            return {\n              value: item\n            };\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"values\",\n    value: function values(options) {\n      if (options && options.stripUndefined) {\n        var values = [];\n\n        var _iterator5 = _createForOfIteratorHelper(this._set),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var item = _step5.value;\n\n            if (item !== undefined) {\n              values.push(item);\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return values;\n      }\n\n      return Array.from(this._set);\n    }\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var set = new InternalSet(this._set);\n      set._hasRef = this._hasRef;\n      return set;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(source) {\n      var set = new InternalSet([].concat(_toConsumableArray(this._set), _toConsumableArray(source._set)));\n      set._hasRef = !!(this._hasRef | source._hasRef);\n      return set;\n    }\n  }]);\n\n  return InternalSet;\n}();","map":{"version":3,"sources":["/home/agatha/open/node_modules/@hapi/joi/lib/set.js"],"names":["Ref","require","internals","extendedCheckForValue","value","insensitive","valueType","Date","item","getTime","Buffer","isBuffer","length","toString","lowercaseValue","toLowerCase","module","exports","from","_set","Set","_hasRef","refs","isRef","has","undefined","push","add","remove","delete","state","options","get","size","hasValue","extendedCheck","concat","reference","parent","found","indexOf","_has","check","checkRef","isReallyEqual","Array","isArray","findIndex","stripUndefined","values","set","InternalSet","source"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\ninternals.extendedCheckForValue = function (value, insensitive) {\n\n    const valueType = typeof value;\n\n    if (valueType === 'object') {\n        if (value instanceof Date) {\n            return (item) => {\n\n                return item instanceof Date && value.getTime() === item.getTime();\n            };\n        }\n\n        if (Buffer.isBuffer(value)) {\n            return (item) => {\n\n                return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n            };\n        }\n    }\n    else if (insensitive && valueType === 'string') {\n        const lowercaseValue = value.toLowerCase();\n        return (item) => {\n\n            return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n        };\n    }\n\n    return null;\n};\n\n\nmodule.exports = class InternalSet {\n\n    constructor(from) {\n\n        this._set = new Set(from);\n        this._hasRef = false;\n    }\n\n    add(value, refs) {\n\n        const isRef = Ref.isRef(value);\n        if (!isRef && this.has(value, null, null, false)) {\n\n            return this;\n        }\n\n        if (refs !== undefined) { // If it's a merge, we don't have any refs\n            Ref.push(refs, value);\n        }\n\n        this._set.add(value);\n\n        this._hasRef |= isRef;\n\n        return this;\n    }\n\n    merge(add, remove) {\n\n        for (const item of add._set) {\n            this.add(item);\n        }\n\n        for (const item of remove._set) {\n            this.remove(item);\n        }\n\n        return this;\n    }\n\n    remove(value) {\n\n        this._set.delete(value);\n        return this;\n    }\n\n    has(value, state, options, insensitive) {\n\n        return !!this.get(value, state, options, insensitive);\n    }\n\n    get(value, state, options, insensitive) {\n\n        if (!this._set.size) {\n            return false;\n        }\n\n        const hasValue = this._set.has(value);\n        if (hasValue) {\n            return { value };\n        }\n\n        const extendedCheck = internals.extendedCheckForValue(value, insensitive);\n        if (!extendedCheck) {\n            if (state && this._hasRef) {\n                for (let item of this._set) {\n                    if (Ref.isRef(item)) {\n                        item = [].concat(item(state.reference || state.parent, options));\n                        const found = item.indexOf(value);\n                        if (found >= 0) {\n                            return { value: item[found] };\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        return this._has(value, state, options, extendedCheck);\n    }\n\n    _has(value, state, options, check) {\n\n        const checkRef = !!(state && this._hasRef);\n\n        const isReallyEqual = function (item) {\n\n            if (value === item) {\n                return true;\n            }\n\n            return check(item);\n        };\n\n        for (let item of this._set) {\n            if (checkRef && Ref.isRef(item)) { // Only resolve references if there is a state, otherwise it's a merge\n                item = item(state.reference || state.parent, options);\n\n                if (Array.isArray(item)) {\n                    const found = item.findIndex(isReallyEqual);\n                    if (found >= 0) {\n                        return {\n                            value: item[found]\n                        };\n                    }\n\n                    continue;\n                }\n            }\n\n            if (isReallyEqual(item)) {\n                return {\n                    value: item\n                };\n            }\n        }\n\n        return false;\n    }\n\n    values(options) {\n\n        if (options && options.stripUndefined) {\n            const values = [];\n\n            for (const item of this._set) {\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n\n            return values;\n        }\n\n        return Array.from(this._set);\n    }\n\n    slice() {\n\n        const set = new InternalSet(this._set);\n        set._hasRef = this._hasRef;\n        return set;\n    }\n\n    concat(source) {\n\n        const set = new InternalSet([...this._set, ...source._set]);\n        set._hasRef = !!(this._hasRef | source._hasRef);\n        return set;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}