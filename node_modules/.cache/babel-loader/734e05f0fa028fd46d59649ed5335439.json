{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst ol = require('common-tags').oneLine;\n\nconst errors = require('./errors');\n\nconst stringifyWithoutComments = require('./stringify-without-comments');\n/**\n * Given a set of options that configures `sw-toolbox`'s behavior, convert it\n * into a string that would configure equivalent `workbox-sw` behavior.\n *\n * @param {Object} options See\n *        https://googlechromelabs.github.io/sw-toolbox/api.html#options\n * @return {string} A JSON string representing the equivalent options.\n *\n * @private\n */\n\n\nfunction getOptionsString(options = {}) {\n  let plugins = [];\n\n  if (options.plugins) {\n    // Using libs because JSON.stringify won't handle functions.\n    plugins = options.plugins.map(stringifyWithoutComments);\n    delete options.plugins;\n  } // Pull handler-specific config from the options object, since they are\n  // not directly used to construct a Plugin instance. If set, need to be\n  // passed as options to the handler constructor instead.\n\n\n  const handlerOptionKeys = ['cacheName', 'networkTimeoutSeconds', 'fetchOptions', 'matchOptions'];\n  const handlerOptions = {};\n\n  for (var _i = 0; _i < handlerOptionKeys.length; _i++) {\n    const key = handlerOptionKeys[_i];\n\n    if (key in options) {\n      handlerOptions[key] = options[key];\n      delete options[key];\n    }\n  }\n\n  const pluginsMapping = {\n    backgroundSync: 'workbox.backgroundSync.Plugin',\n    broadcastUpdate: 'workbox.broadcastUpdate.Plugin',\n    expiration: 'workbox.expiration.Plugin',\n    cacheableResponse: 'workbox.cacheableResponse.Plugin'\n  };\n\n  var _arr = Object.entries(options);\n\n  for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n    const _arr$_i = (0, _slicedToArray2.default)(_arr[_i2], 2),\n          pluginName = _arr$_i[0],\n          pluginConfig = _arr$_i[1]; // Ensure that we have some valid configuration to pass to Plugin().\n\n\n    if (Object.keys(pluginConfig).length === 0) {\n      continue;\n    }\n\n    const pluginString = pluginsMapping[pluginName];\n\n    if (!pluginString) {\n      throw new Error(`${errors['bad-runtime-caching-config']} ${pluginName}`);\n    }\n\n    let pluginCode;\n\n    switch (pluginName) {\n      // Special case logic for plugins that have a required parameter, and then\n      // an additional optional config parameter.\n      case 'backgroundSync':\n        {\n          const name = pluginConfig.name;\n          pluginCode = `new ${pluginString}(${JSON.stringify(name)}`;\n\n          if ('options' in pluginConfig) {\n            pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;\n          }\n\n          pluginCode += `)`;\n          break;\n        }\n\n      case 'broadcastUpdate':\n        {\n          const channelName = pluginConfig.channelName;\n          const opts = Object.assign({\n            channelName\n          }, pluginConfig.options);\n          pluginCode = `new ${pluginString}(${stringifyWithoutComments(opts)})`;\n          break;\n        }\n      // For plugins that just pass in an Object to the constructor, like\n      // expiration and cacheableResponse\n\n      default:\n        {\n          pluginCode = `new ${pluginString}(${stringifyWithoutComments(pluginConfig)})`;\n        }\n    }\n\n    plugins.push(pluginCode);\n  }\n\n  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {\n    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);\n    return ol`{\n      ${optionsString ? optionsString + ',' : ''}\n      plugins: [${plugins.join(', ')}]\n    }`;\n  } else {\n    return '';\n  }\n}\n\nmodule.exports = (runtimeCaching = []) => {\n  return runtimeCaching.map(entry => {\n    const method = entry.method || 'GET';\n\n    if (!entry.urlPattern) {\n      throw new Error(errors['urlPattern-is-required']);\n    }\n\n    if (!entry.handler) {\n      throw new Error(errors['handler-is-required']);\n    } // This validation logic is a bit too gnarly for joi, so it's manually\n    // implemented here.\n\n\n    if (entry.options && entry.options.networkTimeoutSeconds && entry.handler !== 'NetworkFirst') {\n      throw new Error(errors['invalid-network-timeout-seconds']);\n    } // urlPattern might be a string, a RegExp object, or a function.\n    // If it's a string, it needs to be quoted.\n\n\n    const matcher = typeof entry.urlPattern === 'string' ? JSON.stringify(entry.urlPattern) : entry.urlPattern;\n\n    if (typeof entry.handler === 'string') {\n      const optionsString = getOptionsString(entry.options || {});\n      const strategyString = `new workbox.strategies.${entry.handler}(${optionsString})`;\n      return `workbox.routing.registerRoute(` + `${matcher}, ${strategyString}, '${method}');\\n`;\n    } else if (typeof entry.handler === 'function') {\n      return `workbox.routing.registerRoute(` + `${matcher}, ${entry.handler}, '${method}');\\n`;\n    }\n  }).filter(entry => Boolean(entry)); // Remove undefined map() return values.\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/lib/runtime-caching-converter.js"],"names":["_interopRequireDefault","require","_slicedToArray2","ol","oneLine","errors","stringifyWithoutComments","getOptionsString","options","plugins","map","handlerOptionKeys","handlerOptions","_i","length","key","pluginsMapping","backgroundSync","broadcastUpdate","expiration","cacheableResponse","_arr","Object","entries","_i2","_arr$_i","default","pluginName","pluginConfig","keys","pluginString","Error","pluginCode","name","JSON","stringify","channelName","opts","assign","push","optionsString","slice","join","module","exports","runtimeCaching","entry","method","urlPattern","handler","networkTimeoutSeconds","matcher","strategyString","filter","Boolean"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst ol = require('common-tags').oneLine;\n\nconst errors = require('./errors');\n\nconst stringifyWithoutComments = require('./stringify-without-comments');\n/**\n * Given a set of options that configures `sw-toolbox`'s behavior, convert it\n * into a string that would configure equivalent `workbox-sw` behavior.\n *\n * @param {Object} options See\n *        https://googlechromelabs.github.io/sw-toolbox/api.html#options\n * @return {string} A JSON string representing the equivalent options.\n *\n * @private\n */\n\n\nfunction getOptionsString(options = {}) {\n  let plugins = [];\n\n  if (options.plugins) {\n    // Using libs because JSON.stringify won't handle functions.\n    plugins = options.plugins.map(stringifyWithoutComments);\n    delete options.plugins;\n  } // Pull handler-specific config from the options object, since they are\n  // not directly used to construct a Plugin instance. If set, need to be\n  // passed as options to the handler constructor instead.\n\n\n  const handlerOptionKeys = ['cacheName', 'networkTimeoutSeconds', 'fetchOptions', 'matchOptions'];\n  const handlerOptions = {};\n\n  for (var _i = 0; _i < handlerOptionKeys.length; _i++) {\n    const key = handlerOptionKeys[_i];\n\n    if (key in options) {\n      handlerOptions[key] = options[key];\n      delete options[key];\n    }\n  }\n\n  const pluginsMapping = {\n    backgroundSync: 'workbox.backgroundSync.Plugin',\n    broadcastUpdate: 'workbox.broadcastUpdate.Plugin',\n    expiration: 'workbox.expiration.Plugin',\n    cacheableResponse: 'workbox.cacheableResponse.Plugin'\n  };\n\n  var _arr = Object.entries(options);\n\n  for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n    const _arr$_i = (0, _slicedToArray2.default)(_arr[_i2], 2),\n          pluginName = _arr$_i[0],\n          pluginConfig = _arr$_i[1];\n\n    // Ensure that we have some valid configuration to pass to Plugin().\n    if (Object.keys(pluginConfig).length === 0) {\n      continue;\n    }\n\n    const pluginString = pluginsMapping[pluginName];\n\n    if (!pluginString) {\n      throw new Error(`${errors['bad-runtime-caching-config']} ${pluginName}`);\n    }\n\n    let pluginCode;\n\n    switch (pluginName) {\n      // Special case logic for plugins that have a required parameter, and then\n      // an additional optional config parameter.\n      case 'backgroundSync':\n        {\n          const name = pluginConfig.name;\n          pluginCode = `new ${pluginString}(${JSON.stringify(name)}`;\n\n          if ('options' in pluginConfig) {\n            pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;\n          }\n\n          pluginCode += `)`;\n          break;\n        }\n\n      case 'broadcastUpdate':\n        {\n          const channelName = pluginConfig.channelName;\n          const opts = Object.assign({\n            channelName\n          }, pluginConfig.options);\n          pluginCode = `new ${pluginString}(${stringifyWithoutComments(opts)})`;\n          break;\n        }\n      // For plugins that just pass in an Object to the constructor, like\n      // expiration and cacheableResponse\n\n      default:\n        {\n          pluginCode = `new ${pluginString}(${stringifyWithoutComments(pluginConfig)})`;\n        }\n    }\n\n    plugins.push(pluginCode);\n  }\n\n  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {\n    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);\n    return ol`{\n      ${optionsString ? optionsString + ',' : ''}\n      plugins: [${plugins.join(', ')}]\n    }`;\n  } else {\n    return '';\n  }\n}\n\nmodule.exports = (runtimeCaching = []) => {\n  return runtimeCaching.map(entry => {\n    const method = entry.method || 'GET';\n\n    if (!entry.urlPattern) {\n      throw new Error(errors['urlPattern-is-required']);\n    }\n\n    if (!entry.handler) {\n      throw new Error(errors['handler-is-required']);\n    } // This validation logic is a bit too gnarly for joi, so it's manually\n    // implemented here.\n\n\n    if (entry.options && entry.options.networkTimeoutSeconds && entry.handler !== 'NetworkFirst') {\n      throw new Error(errors['invalid-network-timeout-seconds']);\n    } // urlPattern might be a string, a RegExp object, or a function.\n    // If it's a string, it needs to be quoted.\n\n\n    const matcher = typeof entry.urlPattern === 'string' ? JSON.stringify(entry.urlPattern) : entry.urlPattern;\n\n    if (typeof entry.handler === 'string') {\n      const optionsString = getOptionsString(entry.options || {});\n      const strategyString = `new workbox.strategies.${entry.handler}(${optionsString})`;\n      return `workbox.routing.registerRoute(` + `${matcher}, ${strategyString}, '${method}');\\n`;\n    } else if (typeof entry.handler === 'function') {\n      return `workbox.routing.registerRoute(` + `${matcher}, ${entry.handler}, '${method}');\\n`;\n    }\n  }).filter(entry => Boolean(entry)); // Remove undefined map() return values.\n};"]},"metadata":{},"sourceType":"script"}