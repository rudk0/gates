{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst fse = require('fs-extra');\n\nconst upath = require('upath');\n\nconst errors = require('./errors'); // Used to filter the libraries to copy based on our package.json dependencies.\n\n\nconst WORKBOX_PREFIX = 'workbox-'; // The directory within each package containing the final bundles.\n\nconst BUILD_DIR = 'build';\n/**\n * This copies over a set of runtime libraries used by Workbox into a\n * local directory, which should be deployed alongside your service worker file.\n *\n * As an alternative to deploying these local copies, you could instead use\n * Workbox from its official CDN URL.\n *\n * This method is exposed for the benefit of developers using\n * [injectManifest()]{@link module:workbox-build.injectManifest} who would\n * prefer not to use the CDN copies of Workbox. Developers using\n * [generateSW()]{@link module:workbox-build.generateSW} don't need to\n * explicitly call this method.\n *\n * @param {string} destDirectory The path to the parent directory under which\n * the new directory of libraries will be created.\n * @return {Promise<string>} The name of the newly created directory.\n *\n * @alias module:workbox-build.copyWorkboxLibraries\n */\n\nmodule.exports = async destDirectory => {\n  const thisPkg = require('../../package.json'); // Use the version string from workbox-build in the name of the parent\n  // directory. This should be safe, because lerna will bump workbox-build's\n  // pkg.version whenever one of the dependent libraries gets bumped, and we\n  // care about versioning the dependent libraries.\n\n\n  const workboxDirectoryName = `workbox-v${thisPkg.version}`;\n  const workboxDirectoryPath = upath.join(destDirectory, workboxDirectoryName);\n  await fse.ensureDir(workboxDirectoryPath);\n  const copyPromises = [];\n  const librariesToCopy = Object.keys(thisPkg.dependencies).filter(dependency => dependency.startsWith(WORKBOX_PREFIX));\n\n  for (const library of librariesToCopy) {\n    // Get the path to the package on the user's filesystem by require-ing\n    // the package's `package.json` file via the node resolution algorithm.\n    const libraryPath = upath.dirname(require.resolve(`${library}/package.json`));\n    const buildPath = upath.join(libraryPath, BUILD_DIR); // fse.copy() copies all the files in a directory, not the directory itself.\n    // See https://github.com/jprichardson/node-fs-extra/blob/master/docs/copy.md#copysrc-dest-options-callback\n\n    copyPromises.push(fse.copy(buildPath, workboxDirectoryPath));\n  }\n\n  try {\n    await Promise.all(copyPromises);\n    return workboxDirectoryName;\n  } catch (error) {\n    throw Error(`${errors['unable-to-copy-workbox-libraries']} ${error}`);\n  }\n};","map":{"version":3,"sources":["/home/agatha/open/node_modules/workbox-build/build/lib/copy-workbox-libraries.js"],"names":["fse","require","upath","errors","WORKBOX_PREFIX","BUILD_DIR","module","exports","destDirectory","thisPkg","workboxDirectoryName","version","workboxDirectoryPath","join","ensureDir","copyPromises","librariesToCopy","Object","keys","dependencies","filter","dependency","startsWith","library","libraryPath","dirname","resolve","buildPath","push","copy","Promise","all","error","Error"],"mappings":"AAAA;AAEA;;;;;;;;AAOA,MAAMA,GAAG,GAAGC,OAAO,CAAC,UAAD,CAAnB;;AAEA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAD,CAAtB,C,CAAoC;;;AAGpC,MAAMG,cAAc,GAAG,UAAvB,C,CAAmC;;AAEnC,MAAMC,SAAS,GAAG,OAAlB;AACA;;;;;;;;;;;;;;;;;;;;AAoBAC,MAAM,CAACC,OAAP,GAAiB,MAAMC,aAAN,IAAuB;AACtC,QAAMC,OAAO,GAAGR,OAAO,CAAC,oBAAD,CAAvB,CADsC,CACS;AAC/C;AACA;AACA;;;AAGA,QAAMS,oBAAoB,GAAI,YAAWD,OAAO,CAACE,OAAQ,EAAzD;AACA,QAAMC,oBAAoB,GAAGV,KAAK,CAACW,IAAN,CAAWL,aAAX,EAA0BE,oBAA1B,CAA7B;AACA,QAAMV,GAAG,CAACc,SAAJ,CAAcF,oBAAd,CAAN;AACA,QAAMG,YAAY,GAAG,EAArB;AACA,QAAMC,eAAe,GAAGC,MAAM,CAACC,IAAP,CAAYT,OAAO,CAACU,YAApB,EAAkCC,MAAlC,CAAyCC,UAAU,IAAIA,UAAU,CAACC,UAAX,CAAsBlB,cAAtB,CAAvD,CAAxB;;AAEA,OAAK,MAAMmB,OAAX,IAAsBP,eAAtB,EAAuC;AACrC;AACA;AACA,UAAMQ,WAAW,GAAGtB,KAAK,CAACuB,OAAN,CAAcxB,OAAO,CAACyB,OAAR,CAAiB,GAAEH,OAAQ,eAA3B,CAAd,CAApB;AACA,UAAMI,SAAS,GAAGzB,KAAK,CAACW,IAAN,CAAWW,WAAX,EAAwBnB,SAAxB,CAAlB,CAJqC,CAIiB;AACtD;;AAEAU,IAAAA,YAAY,CAACa,IAAb,CAAkB5B,GAAG,CAAC6B,IAAJ,CAASF,SAAT,EAAoBf,oBAApB,CAAlB;AACD;;AAED,MAAI;AACF,UAAMkB,OAAO,CAACC,GAAR,CAAYhB,YAAZ,CAAN;AACA,WAAOL,oBAAP;AACD,GAHD,CAGE,OAAOsB,KAAP,EAAc;AACd,UAAMC,KAAK,CAAE,GAAE9B,MAAM,CAAC,kCAAD,CAAqC,IAAG6B,KAAM,EAAxD,CAAX;AACD;AACF,CA7BD","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst fse = require('fs-extra');\n\nconst upath = require('upath');\n\nconst errors = require('./errors'); // Used to filter the libraries to copy based on our package.json dependencies.\n\n\nconst WORKBOX_PREFIX = 'workbox-'; // The directory within each package containing the final bundles.\n\nconst BUILD_DIR = 'build';\n/**\n * This copies over a set of runtime libraries used by Workbox into a\n * local directory, which should be deployed alongside your service worker file.\n *\n * As an alternative to deploying these local copies, you could instead use\n * Workbox from its official CDN URL.\n *\n * This method is exposed for the benefit of developers using\n * [injectManifest()]{@link module:workbox-build.injectManifest} who would\n * prefer not to use the CDN copies of Workbox. Developers using\n * [generateSW()]{@link module:workbox-build.generateSW} don't need to\n * explicitly call this method.\n *\n * @param {string} destDirectory The path to the parent directory under which\n * the new directory of libraries will be created.\n * @return {Promise<string>} The name of the newly created directory.\n *\n * @alias module:workbox-build.copyWorkboxLibraries\n */\n\nmodule.exports = async destDirectory => {\n  const thisPkg = require('../../package.json'); // Use the version string from workbox-build in the name of the parent\n  // directory. This should be safe, because lerna will bump workbox-build's\n  // pkg.version whenever one of the dependent libraries gets bumped, and we\n  // care about versioning the dependent libraries.\n\n\n  const workboxDirectoryName = `workbox-v${thisPkg.version}`;\n  const workboxDirectoryPath = upath.join(destDirectory, workboxDirectoryName);\n  await fse.ensureDir(workboxDirectoryPath);\n  const copyPromises = [];\n  const librariesToCopy = Object.keys(thisPkg.dependencies).filter(dependency => dependency.startsWith(WORKBOX_PREFIX));\n\n  for (const library of librariesToCopy) {\n    // Get the path to the package on the user's filesystem by require-ing\n    // the package's `package.json` file via the node resolution algorithm.\n    const libraryPath = upath.dirname(require.resolve(`${library}/package.json`));\n    const buildPath = upath.join(libraryPath, BUILD_DIR); // fse.copy() copies all the files in a directory, not the directory itself.\n    // See https://github.com/jprichardson/node-fs-extra/blob/master/docs/copy.md#copysrc-dest-options-callback\n\n    copyPromises.push(fse.copy(buildPath, workboxDirectoryPath));\n  }\n\n  try {\n    await Promise.all(copyPromises);\n    return workboxDirectoryName;\n  } catch (error) {\n    throw Error(`${errors['unable-to-copy-workbox-libraries']} ${error}`);\n  }\n};"]},"metadata":{},"sourceType":"script"}